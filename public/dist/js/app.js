/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/App.vue?vue&type=script&lang=js&":
/*!***********************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/App.vue?vue&type=script&lang=js& ***!
  \***********************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _components_Loading__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ~/components/Loading */ \"./resources/js/components/Loading.vue\");\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n // Load layout components dynamically.\n\nvar requireContext = __webpack_require__(\"./resources/js/layouts sync .*\\\\.vue$\");\n\nvar layouts = requireContext.keys().map(function (file) {\n  return [file.replace(/(^.\\/)|(\\.vue$)/g, ''), requireContext(file)];\n}).reduce(function (components, _ref) {\n  var _ref2 = _slicedToArray(_ref, 2),\n      name = _ref2[0],\n      component = _ref2[1];\n\n  components[name] = component[\"default\"] || component;\n  return components;\n}, {});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  el: '#app',\n  components: {\n    Loading: _components_Loading__WEBPACK_IMPORTED_MODULE_0__[\"default\"]\n  },\n  data: function data() {\n    return {\n      layout: null,\n      defaultLayout: 'default'\n    };\n  },\n  metaInfo: function metaInfo() {\n    var appName = window.config.appName;\n    return {\n      title: appName,\n      titleTemplate: \"%s \\xB7 \".concat(appName)\n    };\n  },\n  mounted: function mounted() {\n    this.$loading = this.$refs.loading;\n  },\n  methods: {\n    /**\n     * Set the application layout.\n     *\n     * @param {String} layout\n     */\n    setLayout: function setLayout(layout) {\n      if (!layout || !layouts[layout]) {\n        layout = this.defaultLayout;\n      }\n\n      this.layout = layouts[layout];\n    }\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC01LnVzZVswXSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vcmVzb3VyY2VzL2pzL0FwcC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBWUE7O0FBQ0E7O0FBQ0Esb0NBQ0FBLEdBREEsQ0FDQTtFQUFBLE9BQ0EsNERBREE7QUFBQSxDQURBLEVBSUFDLE1BSkEsQ0FJQTtFQUFBO0VBQUE7RUFBQTs7RUFDQUM7RUFDQTtBQUNBLENBUEEsRUFPQSxFQVBBO0FBUUEsaUVBQWU7RUFDZkMsVUFEQTtFQUVBRDtJQUNBRSxTQUFBQSwyREFBQUE7RUFEQSxDQUZBO0VBS0FDO0lBQUE7TUFDQUMsWUFEQTtNQUVBQztJQUZBO0VBQUEsQ0FMQTtFQVNBQyxRQVRBLHNCQVNBO0lBQ0E7SUFDQTtNQUNBQyxjQURBO01BRUFDO0lBRkE7RUFJQSxDQWZBO0VBZ0JBQyxPQWhCQSxxQkFnQkE7SUFDQTtFQUNBLENBbEJBO0VBbUJBQztJQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7SUFDQUMsU0FOQSxxQkFNQVAsTUFOQSxFQU1BO01BQ0E7UUFDQUE7TUFDQTs7TUFDQTtJQUNBO0VBWEE7QUFuQkEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vcmVzb3VyY2VzL2pzL0FwcC52dWU/OTRiMCJdLCJzb3VyY2VzQ29udGVudCI6WyI8dGVtcGxhdGU+XG4gIDxkaXYgaWQ9XCJhcHBcIj5cbiAgICA8bG9hZGluZyByZWY9XCJsb2FkaW5nXCIgLz5cblxuICAgIDx0cmFuc2l0aW9uIG5hbWU9XCJwYWdlXCIgbW9kZT1cIm91dC1pblwiPlxuICAgICAgPGNvbXBvbmVudCA6aXM9XCJsYXlvdXRcIiB2LWlmPVwibGF5b3V0XCIgLz5cbiAgICA8L3RyYW5zaXRpb24+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBMb2FkaW5nIGZyb20gJ34vY29tcG9uZW50cy9Mb2FkaW5nJ1xuLy8gTG9hZCBsYXlvdXQgY29tcG9uZW50cyBkeW5hbWljYWxseS5cbmNvbnN0IHJlcXVpcmVDb250ZXh0ID0gcmVxdWlyZS5jb250ZXh0KCd+L2xheW91dHMnLCBmYWxzZSwgLy4qXFwudnVlJC8pXG5jb25zdCBsYXlvdXRzID0gcmVxdWlyZUNvbnRleHQua2V5cygpXG4gIC5tYXAoZmlsZSA9PlxuICAgIFtmaWxlLnJlcGxhY2UoLyheLlxcLyl8KFxcLnZ1ZSQpL2csICcnKSwgcmVxdWlyZUNvbnRleHQoZmlsZSldXG4gIClcbiAgLnJlZHVjZSgoY29tcG9uZW50cywgW25hbWUsIGNvbXBvbmVudF0pID0+IHtcbiAgICBjb21wb25lbnRzW25hbWVdID0gY29tcG9uZW50LmRlZmF1bHQgfHwgY29tcG9uZW50XG4gICAgcmV0dXJuIGNvbXBvbmVudHNcbiAgfSwge30pXG5leHBvcnQgZGVmYXVsdCB7XG4gIGVsOiAnI2FwcCcsXG4gIGNvbXBvbmVudHM6IHtcbiAgICBMb2FkaW5nXG4gIH0sXG4gIGRhdGE6ICgpID0+ICh7XG4gICAgbGF5b3V0OiBudWxsLFxuICAgIGRlZmF1bHRMYXlvdXQ6ICdkZWZhdWx0J1xuICB9KSxcbiAgbWV0YUluZm8gKCkge1xuICAgIGNvbnN0IHsgYXBwTmFtZSB9ID0gd2luZG93LmNvbmZpZ1xuICAgIHJldHVybiB7XG4gICAgICB0aXRsZTogYXBwTmFtZSxcbiAgICAgIHRpdGxlVGVtcGxhdGU6IGAlcyDCtyAke2FwcE5hbWV9YFxuICAgIH1cbiAgfSxcbiAgbW91bnRlZCAoKSB7XG4gICAgdGhpcy4kbG9hZGluZyA9IHRoaXMuJHJlZnMubG9hZGluZ1xuICB9LFxuICBtZXRob2RzOiB7XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBhcHBsaWNhdGlvbiBsYXlvdXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbGF5b3V0XG4gICAgICovXG4gICAgc2V0TGF5b3V0IChsYXlvdXQpIHtcbiAgICAgIGlmICghbGF5b3V0IHx8ICFsYXlvdXRzW2xheW91dF0pIHtcbiAgICAgICAgbGF5b3V0ID0gdGhpcy5kZWZhdWx0TGF5b3V0XG4gICAgICB9XG4gICAgICB0aGlzLmxheW91dCA9IGxheW91dHNbbGF5b3V0XVxuICAgIH1cbiAgfVxufVxuPC9zY3JpcHQ+Il0sIm5hbWVzIjpbIm1hcCIsInJlZHVjZSIsImNvbXBvbmVudHMiLCJlbCIsIkxvYWRpbmciLCJkYXRhIiwibGF5b3V0IiwiZGVmYXVsdExheW91dCIsIm1ldGFJbmZvIiwidGl0bGUiLCJ0aXRsZVRlbXBsYXRlIiwibW91bnRlZCIsIm1ldGhvZHMiLCJzZXRMYXlvdXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/App.vue?vue&type=script&lang=js&\n");

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/components/Child.vue?vue&type=script&lang=js&":
/*!************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/components/Child.vue?vue&type=script&lang=js& ***!
  \************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  name: 'Child'\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC01LnVzZVswXSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vcmVzb3VyY2VzL2pzL2NvbXBvbmVudHMvQ2hpbGQudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBU0EsaUVBQWU7RUFDZkE7QUFEQSIsInNvdXJjZXMiOlsid2VicGFjazovLy9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9DaGlsZC52dWU/N2E2MyJdLCJzb3VyY2VzQ29udGVudCI6WyI8dGVtcGxhdGU+XG4gIDx0cmFuc2l0aW9uIG5hbWU9XCJwYWdlXCIgbW9kZT1cIm91dC1pblwiPlxuICAgIDxzbG90PlxuICAgICAgPHJvdXRlci12aWV3IC8+XG4gICAgPC9zbG90PlxuICA8L3RyYW5zaXRpb24+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnQ2hpbGQnXG59XG48L3NjcmlwdD4iXSwibmFtZXMiOlsibmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/components/Child.vue?vue&type=script&lang=js&\n");

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/components/Loading.vue?vue&type=script&lang=js&":
/*!**************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/components/Loading.vue?vue&type=script&lang=js& ***!
  \**************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n// https://github.com/nuxt/nuxt.js/blob/master/lib/app/components/nuxt-loading.vue\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  data: function data() {\n    return {\n      percent: 0,\n      show: false,\n      canSuccess: true,\n      duration: 3000,\n      height: '2px',\n      color: '#77b6ff',\n      failedColor: 'red'\n    };\n  },\n  methods: {\n    start: function start() {\n      var _this = this;\n\n      this.show = true;\n      this.canSuccess = true;\n\n      if (this._timer) {\n        clearInterval(this._timer);\n        this.percent = 0;\n      }\n\n      this._cut = 10000 / Math.floor(this.duration);\n      this._timer = setInterval(function () {\n        _this.increase(_this._cut * Math.random());\n\n        if (_this.percent > 95) {\n          _this.finish();\n        }\n      }, 100);\n      return this;\n    },\n    set: function set(num) {\n      this.show = true;\n      this.canSuccess = true;\n      this.percent = Math.floor(num);\n      return this;\n    },\n    get: function get() {\n      return Math.floor(this.percent);\n    },\n    increase: function increase(num) {\n      this.percent = this.percent + Math.floor(num);\n      return this;\n    },\n    decrease: function decrease(num) {\n      this.percent = this.percent - Math.floor(num);\n      return this;\n    },\n    finish: function finish() {\n      this.percent = 100;\n      this.hide();\n      return this;\n    },\n    pause: function pause() {\n      clearInterval(this._timer);\n      return this;\n    },\n    hide: function hide() {\n      var _this2 = this;\n\n      clearInterval(this._timer);\n      this._timer = null;\n      setTimeout(function () {\n        _this2.show = false;\n\n        _this2.$nextTick(function () {\n          setTimeout(function () {\n            _this2.percent = 0;\n          }, 200);\n        });\n      }, 500);\n      return this;\n    },\n    fail: function fail() {\n      this.canSuccess = false;\n      return this;\n    }\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC01LnVzZVswXSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vcmVzb3VyY2VzL2pzL2NvbXBvbmVudHMvTG9hZGluZy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFXQTtBQUNBLGlFQUFlO0VBQ2ZBO0lBQUE7TUFDQUMsVUFEQTtNQUVBQyxXQUZBO01BR0FDLGdCQUhBO01BSUFDLGNBSkE7TUFLQUMsYUFMQTtNQU1BQyxnQkFOQTtNQU9BQztJQVBBO0VBQUEsQ0FEQTtFQVdBQztJQUNBQyxLQURBLG1CQUNBO01BQUE7O01BQ0E7TUFDQTs7TUFDQTtRQUNBQztRQUNBO01BQ0E7O01BQ0E7TUFDQTtRQUNBOztRQUNBO1VBQ0E7UUFDQTtNQUNBLENBTEEsRUFLQSxHQUxBO01BTUE7SUFDQSxDQWhCQTtJQWlCQUMsR0FqQkEsZUFpQkFDLEdBakJBLEVBaUJBO01BQ0E7TUFDQTtNQUNBO01BQ0E7SUFDQSxDQXRCQTtJQXVCQUMsR0F2QkEsaUJBdUJBO01BQ0E7SUFDQSxDQXpCQTtJQTBCQUMsUUExQkEsb0JBMEJBRixHQTFCQSxFQTBCQTtNQUNBO01BQ0E7SUFDQSxDQTdCQTtJQThCQUcsUUE5QkEsb0JBOEJBSCxHQTlCQSxFQThCQTtNQUNBO01BQ0E7SUFDQSxDQWpDQTtJQWtDQUksTUFsQ0Esb0JBa0NBO01BQ0E7TUFDQTtNQUNBO0lBQ0EsQ0F0Q0E7SUF1Q0FDLEtBdkNBLG1CQXVDQTtNQUNBUDtNQUNBO0lBQ0EsQ0ExQ0E7SUEyQ0FRLElBM0NBLGtCQTJDQTtNQUFBOztNQUNBUjtNQUNBO01BQ0FTO1FBQ0E7O1FBQ0E7VUFDQUE7WUFDQTtVQUNBLENBRkEsRUFFQSxHQUZBO1FBR0EsQ0FKQTtNQUtBLENBUEEsRUFPQSxHQVBBO01BUUE7SUFDQSxDQXZEQTtJQXdEQUMsSUF4REEsa0JBd0RBO01BQ0E7TUFDQTtJQUNBO0VBM0RBO0FBWEEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vcmVzb3VyY2VzL2pzL2NvbXBvbmVudHMvTG9hZGluZy52dWU/NTg4YiJdLCJzb3VyY2VzQ29udGVudCI6WyI8dGVtcGxhdGU+XG4gIDxkaXYgOnN0eWxlPVwie1xuICAgIHdpZHRoOiBgJHtwZXJjZW50fSVgLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIG9wYWNpdHk6IHNob3cgPyAxIDogMCxcbiAgICAnYmFja2dyb3VuZC1jb2xvcic6IGNhblN1Y2Nlc3MgPyBjb2xvciA6IGZhaWxlZENvbG9yXG4gIH1cIiBjbGFzcz1cInByb2dyZXNzXCJcbiAgLz5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG4vLyBodHRwczovL2dpdGh1Yi5jb20vbnV4dC9udXh0LmpzL2Jsb2IvbWFzdGVyL2xpYi9hcHAvY29tcG9uZW50cy9udXh0LWxvYWRpbmcudnVlXG5leHBvcnQgZGVmYXVsdCB7XG4gIGRhdGE6ICgpID0+ICh7XG4gICAgcGVyY2VudDogMCxcbiAgICBzaG93OiBmYWxzZSxcbiAgICBjYW5TdWNjZXNzOiB0cnVlLFxuICAgIGR1cmF0aW9uOiAzMDAwLFxuICAgIGhlaWdodDogJzJweCcsXG4gICAgY29sb3I6ICcjNzdiNmZmJyxcbiAgICBmYWlsZWRDb2xvcjogJ3JlZCdcbiAgfSksXG5cbiAgbWV0aG9kczoge1xuICAgIHN0YXJ0ICgpIHtcbiAgICAgIHRoaXMuc2hvdyA9IHRydWVcbiAgICAgIHRoaXMuY2FuU3VjY2VzcyA9IHRydWVcbiAgICAgIGlmICh0aGlzLl90aW1lcikge1xuICAgICAgICBjbGVhckludGVydmFsKHRoaXMuX3RpbWVyKVxuICAgICAgICB0aGlzLnBlcmNlbnQgPSAwXG4gICAgICB9XG4gICAgICB0aGlzLl9jdXQgPSAxMDAwMCAvIE1hdGguZmxvb3IodGhpcy5kdXJhdGlvbilcbiAgICAgIHRoaXMuX3RpbWVyID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICB0aGlzLmluY3JlYXNlKHRoaXMuX2N1dCAqIE1hdGgucmFuZG9tKCkpXG4gICAgICAgIGlmICh0aGlzLnBlcmNlbnQgPiA5NSkge1xuICAgICAgICAgIHRoaXMuZmluaXNoKClcbiAgICAgICAgfVxuICAgICAgfSwgMTAwKVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9LFxuICAgIHNldCAobnVtKSB7XG4gICAgICB0aGlzLnNob3cgPSB0cnVlXG4gICAgICB0aGlzLmNhblN1Y2Nlc3MgPSB0cnVlXG4gICAgICB0aGlzLnBlcmNlbnQgPSBNYXRoLmZsb29yKG51bSlcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfSxcbiAgICBnZXQgKCkge1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IodGhpcy5wZXJjZW50KVxuICAgIH0sXG4gICAgaW5jcmVhc2UgKG51bSkge1xuICAgICAgdGhpcy5wZXJjZW50ID0gdGhpcy5wZXJjZW50ICsgTWF0aC5mbG9vcihudW0pXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH0sXG4gICAgZGVjcmVhc2UgKG51bSkge1xuICAgICAgdGhpcy5wZXJjZW50ID0gdGhpcy5wZXJjZW50IC0gTWF0aC5mbG9vcihudW0pXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH0sXG4gICAgZmluaXNoICgpIHtcbiAgICAgIHRoaXMucGVyY2VudCA9IDEwMFxuICAgICAgdGhpcy5oaWRlKClcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfSxcbiAgICBwYXVzZSAoKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMuX3RpbWVyKVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9LFxuICAgIGhpZGUgKCkge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl90aW1lcilcbiAgICAgIHRoaXMuX3RpbWVyID0gbnVsbFxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuc2hvdyA9IGZhbHNlXG4gICAgICAgIHRoaXMuJG5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGVyY2VudCA9IDBcbiAgICAgICAgICB9LCAyMDApXG4gICAgICAgIH0pXG4gICAgICB9LCA1MDApXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH0sXG4gICAgZmFpbCAoKSB7XG4gICAgICB0aGlzLmNhblN1Y2Nlc3MgPSBmYWxzZVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuXG48c3R5bGUgc2NvcGVkPlxuLnByb2dyZXNzIHtcbiAgcG9zaXRpb246IGZpeGVkO1xuICB0b3A6IDBweDtcbiAgbGVmdDogMHB4O1xuICByaWdodDogMHB4O1xuICBoZWlnaHQ6IDJweDtcbiAgd2lkdGg6IDAlO1xuICB0cmFuc2l0aW9uOiB3aWR0aCAwLjJzLCBvcGFjaXR5IDAuNHM7XG4gIG9wYWNpdHk6IDE7XG4gIGJhY2tncm91bmQtY29sb3I6ICNlZmMxNGU7XG4gIHotaW5kZXg6IDk5OTk5OTtcbn1cbjwvc3R5bGU+Il0sIm5hbWVzIjpbImRhdGEiLCJwZXJjZW50Iiwic2hvdyIsImNhblN1Y2Nlc3MiLCJkdXJhdGlvbiIsImhlaWdodCIsImNvbG9yIiwiZmFpbGVkQ29sb3IiLCJtZXRob2RzIiwic3RhcnQiLCJjbGVhckludGVydmFsIiwic2V0IiwibnVtIiwiZ2V0IiwiaW5jcmVhc2UiLCJkZWNyZWFzZSIsImZpbmlzaCIsInBhdXNlIiwiaGlkZSIsInNldFRpbWVvdXQiLCJmYWlsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/components/Loading.vue?vue&type=script&lang=js&\n");

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/layouts/default.vue?vue&type=script&lang=js&":
/*!***********************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/layouts/default.vue?vue&type=script&lang=js& ***!
  \***********************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  name: 'DefaultLayout'\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC01LnVzZVswXSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vcmVzb3VyY2VzL2pzL2xheW91dHMvZGVmYXVsdC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFPQSxpRUFBZTtFQUNmQTtBQURBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL3Jlc291cmNlcy9qcy9sYXlvdXRzL2RlZmF1bHQudnVlP2RjYzEiXSwic291cmNlc0NvbnRlbnQiOlsiPHRlbXBsYXRlPlxuICA8ZGl2PlxuICAgIDxjaGlsZCAvPlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdEZWZhdWx0TGF5b3V0J1xufVxuPC9zY3JpcHQ+XG4iXSwibmFtZXMiOlsibmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/layouts/default.vue?vue&type=script&lang=js&\n");

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/App.vue?vue&type=template&id=f348271a&":
/*!**********************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/App.vue?vue&type=template&id=f348271a& ***!
  \**********************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"render\": () => (/* binding */ render),\n/* harmony export */   \"staticRenderFns\": () => (/* binding */ staticRenderFns)\n/* harmony export */ });\nvar render = function render() {\n  var _vm = this,\n      _c = _vm._self._c;\n\n  return _c(\"div\", {\n    attrs: {\n      id: \"app\"\n    }\n  }, [_c(\"loading\", {\n    ref: \"loading\"\n  }), _vm._v(\" \"), _c(\"transition\", {\n    attrs: {\n      name: \"page\",\n      mode: \"out-in\"\n    }\n  }, [_vm.layout ? _c(_vm.layout, {\n    tag: \"component\"\n  }) : _vm._e()], 1)], 1);\n};\n\nvar staticRenderFns = [];\nrender._withStripped = true;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC01LnVzZVswXSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3RlbXBsYXRlTG9hZGVyLmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzJdIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9yZXNvdXJjZXMvanMvQXBwLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD1mMzQ4MjcxYSYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxJQUFJQSxNQUFNLEdBQUcsU0FBU0EsTUFBVCxHQUFrQjtFQUM3QixJQUFJQyxHQUFHLEdBQUcsSUFBVjtFQUFBLElBQ0VDLEVBQUUsR0FBR0QsR0FBRyxDQUFDRSxLQUFKLENBQVVELEVBRGpCOztFQUVBLE9BQU9BLEVBQUUsQ0FDUCxLQURPLEVBRVA7SUFBRUUsS0FBSyxFQUFFO01BQUVDLEVBQUUsRUFBRTtJQUFOO0VBQVQsQ0FGTyxFQUdQLENBQ0VILEVBQUUsQ0FBQyxTQUFELEVBQVk7SUFBRUksR0FBRyxFQUFFO0VBQVAsQ0FBWixDQURKLEVBRUVMLEdBQUcsQ0FBQ00sRUFBSixDQUFPLEdBQVAsQ0FGRixFQUdFTCxFQUFFLENBQ0EsWUFEQSxFQUVBO0lBQUVFLEtBQUssRUFBRTtNQUFFSSxJQUFJLEVBQUUsTUFBUjtNQUFnQkMsSUFBSSxFQUFFO0lBQXRCO0VBQVQsQ0FGQSxFQUdBLENBQUNSLEdBQUcsQ0FBQ1MsTUFBSixHQUFhUixFQUFFLENBQUNELEdBQUcsQ0FBQ1MsTUFBTCxFQUFhO0lBQUVDLEdBQUcsRUFBRTtFQUFQLENBQWIsQ0FBZixHQUFvRFYsR0FBRyxDQUFDVyxFQUFKLEVBQXJELENBSEEsRUFJQSxDQUpBLENBSEosQ0FITyxFQWFQLENBYk8sQ0FBVDtBQWVELENBbEJEOztBQW1CQSxJQUFJQyxlQUFlLEdBQUcsRUFBdEI7QUFDQWIsTUFBTSxDQUFDYyxhQUFQLEdBQXVCLElBQXZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2pzL0FwcC52dWU/NmJlNSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgcmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICB2YXIgX3ZtID0gdGhpcyxcbiAgICBfYyA9IF92bS5fc2VsZi5fY1xuICByZXR1cm4gX2MoXG4gICAgXCJkaXZcIixcbiAgICB7IGF0dHJzOiB7IGlkOiBcImFwcFwiIH0gfSxcbiAgICBbXG4gICAgICBfYyhcImxvYWRpbmdcIiwgeyByZWY6IFwibG9hZGluZ1wiIH0pLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF9jKFxuICAgICAgICBcInRyYW5zaXRpb25cIixcbiAgICAgICAgeyBhdHRyczogeyBuYW1lOiBcInBhZ2VcIiwgbW9kZTogXCJvdXQtaW5cIiB9IH0sXG4gICAgICAgIFtfdm0ubGF5b3V0ID8gX2MoX3ZtLmxheW91dCwgeyB0YWc6IFwiY29tcG9uZW50XCIgfSkgOiBfdm0uX2UoKV0sXG4gICAgICAgIDFcbiAgICAgICksXG4gICAgXSxcbiAgICAxXG4gIClcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5cbmV4cG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0iXSwibmFtZXMiOlsicmVuZGVyIiwiX3ZtIiwiX2MiLCJfc2VsZiIsImF0dHJzIiwiaWQiLCJyZWYiLCJfdiIsIm5hbWUiLCJtb2RlIiwibGF5b3V0IiwidGFnIiwiX2UiLCJzdGF0aWNSZW5kZXJGbnMiLCJfd2l0aFN0cmlwcGVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/App.vue?vue&type=template&id=f348271a&\n");

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/components/Child.vue?vue&type=template&id=66ab007e&":
/*!***********************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/components/Child.vue?vue&type=template&id=66ab007e& ***!
  \***********************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"render\": () => (/* binding */ render),\n/* harmony export */   \"staticRenderFns\": () => (/* binding */ staticRenderFns)\n/* harmony export */ });\nvar render = function render() {\n  var _vm = this,\n      _c = _vm._self._c;\n\n  return _c(\"transition\", {\n    attrs: {\n      name: \"page\",\n      mode: \"out-in\"\n    }\n  }, [_vm._t(\"default\", function () {\n    return [_c(\"router-view\")];\n  })], 2);\n};\n\nvar staticRenderFns = [];\nrender._withStripped = true;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC01LnVzZVswXSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3RlbXBsYXRlTG9hZGVyLmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzJdIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9DaGlsZC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NjZhYjAwN2UmLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsSUFBSUEsTUFBTSxHQUFHLFNBQVNBLE1BQVQsR0FBa0I7RUFDN0IsSUFBSUMsR0FBRyxHQUFHLElBQVY7RUFBQSxJQUNFQyxFQUFFLEdBQUdELEdBQUcsQ0FBQ0UsS0FBSixDQUFVRCxFQURqQjs7RUFFQSxPQUFPQSxFQUFFLENBQ1AsWUFETyxFQUVQO0lBQUVFLEtBQUssRUFBRTtNQUFFQyxJQUFJLEVBQUUsTUFBUjtNQUFnQkMsSUFBSSxFQUFFO0lBQXRCO0VBQVQsQ0FGTyxFQUdQLENBQ0VMLEdBQUcsQ0FBQ00sRUFBSixDQUFPLFNBQVAsRUFBa0IsWUFBWTtJQUM1QixPQUFPLENBQUNMLEVBQUUsQ0FBQyxhQUFELENBQUgsQ0FBUDtFQUNELENBRkQsQ0FERixDQUhPLEVBUVAsQ0FSTyxDQUFUO0FBVUQsQ0FiRDs7QUFjQSxJQUFJTSxlQUFlLEdBQUcsRUFBdEI7QUFDQVIsTUFBTSxDQUFDUyxhQUFQLEdBQXVCLElBQXZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2pzL2NvbXBvbmVudHMvQ2hpbGQudnVlPzY0ZDAiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgdmFyIF92bSA9IHRoaXMsXG4gICAgX2MgPSBfdm0uX3NlbGYuX2NcbiAgcmV0dXJuIF9jKFxuICAgIFwidHJhbnNpdGlvblwiLFxuICAgIHsgYXR0cnM6IHsgbmFtZTogXCJwYWdlXCIsIG1vZGU6IFwib3V0LWluXCIgfSB9LFxuICAgIFtcbiAgICAgIF92bS5fdChcImRlZmF1bHRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW19jKFwicm91dGVyLXZpZXdcIildXG4gICAgICB9KSxcbiAgICBdLFxuICAgIDJcbiAgKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcblxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSJdLCJuYW1lcyI6WyJyZW5kZXIiLCJfdm0iLCJfYyIsIl9zZWxmIiwiYXR0cnMiLCJuYW1lIiwibW9kZSIsIl90Iiwic3RhdGljUmVuZGVyRm5zIiwiX3dpdGhTdHJpcHBlZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/components/Child.vue?vue&type=template&id=66ab007e&\n");

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/components/Loading.vue?vue&type=template&id=6ca9e6be&scoped=true&":
/*!*************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/components/Loading.vue?vue&type=template&id=6ca9e6be&scoped=true& ***!
  \*************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"render\": () => (/* binding */ render),\n/* harmony export */   \"staticRenderFns\": () => (/* binding */ staticRenderFns)\n/* harmony export */ });\nvar render = function render() {\n  var _vm = this,\n      _c = _vm._self._c;\n\n  return _c(\"div\", {\n    staticClass: \"progress\",\n    style: {\n      width: \"\".concat(_vm.percent, \"%\"),\n      height: _vm.height,\n      opacity: _vm.show ? 1 : 0,\n      \"background-color\": _vm.canSuccess ? _vm.color : _vm.failedColor\n    }\n  });\n};\n\nvar staticRenderFns = [];\nrender._withStripped = true;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC01LnVzZVswXSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3RlbXBsYXRlTG9hZGVyLmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzJdIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9Mb2FkaW5nLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD02Y2E5ZTZiZSZzY29wZWQ9dHJ1ZSYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxJQUFJQSxNQUFNLEdBQUcsU0FBU0EsTUFBVCxHQUFrQjtFQUM3QixJQUFJQyxHQUFHLEdBQUcsSUFBVjtFQUFBLElBQ0VDLEVBQUUsR0FBR0QsR0FBRyxDQUFDRSxLQUFKLENBQVVELEVBRGpCOztFQUVBLE9BQU9BLEVBQUUsQ0FBQyxLQUFELEVBQVE7SUFDZkUsV0FBVyxFQUFFLFVBREU7SUFFZkMsS0FBSyxFQUFFO01BQ0xDLEtBQUssWUFBS0wsR0FBRyxDQUFDTSxPQUFULE1BREE7TUFFTEMsTUFBTSxFQUFFUCxHQUFHLENBQUNPLE1BRlA7TUFHTEMsT0FBTyxFQUFFUixHQUFHLENBQUNTLElBQUosR0FBVyxDQUFYLEdBQWUsQ0FIbkI7TUFJTCxvQkFBb0JULEdBQUcsQ0FBQ1UsVUFBSixHQUFpQlYsR0FBRyxDQUFDVyxLQUFyQixHQUE2QlgsR0FBRyxDQUFDWTtJQUpoRDtFQUZRLENBQVIsQ0FBVDtBQVNELENBWkQ7O0FBYUEsSUFBSUMsZUFBZSxHQUFHLEVBQXRCO0FBQ0FkLE1BQU0sQ0FBQ2UsYUFBUCxHQUF1QixJQUF2QiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9qcy9jb21wb25lbnRzL0xvYWRpbmcudnVlPzgyODMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgdmFyIF92bSA9IHRoaXMsXG4gICAgX2MgPSBfdm0uX3NlbGYuX2NcbiAgcmV0dXJuIF9jKFwiZGl2XCIsIHtcbiAgICBzdGF0aWNDbGFzczogXCJwcm9ncmVzc1wiLFxuICAgIHN0eWxlOiB7XG4gICAgICB3aWR0aDogYCR7X3ZtLnBlcmNlbnR9JWAsXG4gICAgICBoZWlnaHQ6IF92bS5oZWlnaHQsXG4gICAgICBvcGFjaXR5OiBfdm0uc2hvdyA/IDEgOiAwLFxuICAgICAgXCJiYWNrZ3JvdW5kLWNvbG9yXCI6IF92bS5jYW5TdWNjZXNzID8gX3ZtLmNvbG9yIDogX3ZtLmZhaWxlZENvbG9yLFxuICAgIH0sXG4gIH0pXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuXG5leHBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9Il0sIm5hbWVzIjpbInJlbmRlciIsIl92bSIsIl9jIiwiX3NlbGYiLCJzdGF0aWNDbGFzcyIsInN0eWxlIiwid2lkdGgiLCJwZXJjZW50IiwiaGVpZ2h0Iiwib3BhY2l0eSIsInNob3ciLCJjYW5TdWNjZXNzIiwiY29sb3IiLCJmYWlsZWRDb2xvciIsInN0YXRpY1JlbmRlckZucyIsIl93aXRoU3RyaXBwZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/components/Loading.vue?vue&type=template&id=6ca9e6be&scoped=true&\n");

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/layouts/default.vue?vue&type=template&id=06bc2b2d&":
/*!**********************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/layouts/default.vue?vue&type=template&id=06bc2b2d& ***!
  \**********************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"render\": () => (/* binding */ render),\n/* harmony export */   \"staticRenderFns\": () => (/* binding */ staticRenderFns)\n/* harmony export */ });\nvar render = function render() {\n  var _vm = this,\n      _c = _vm._self._c;\n\n  return _c(\"div\", [_c(\"child\")], 1);\n};\n\nvar staticRenderFns = [];\nrender._withStripped = true;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC01LnVzZVswXSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3RlbXBsYXRlTG9hZGVyLmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzJdIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9yZXNvdXJjZXMvanMvbGF5b3V0cy9kZWZhdWx0LnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0wNmJjMmIyZCYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxJQUFJQSxNQUFNLEdBQUcsU0FBU0EsTUFBVCxHQUFrQjtFQUM3QixJQUFJQyxHQUFHLEdBQUcsSUFBVjtFQUFBLElBQ0VDLEVBQUUsR0FBR0QsR0FBRyxDQUFDRSxLQUFKLENBQVVELEVBRGpCOztFQUVBLE9BQU9BLEVBQUUsQ0FBQyxLQUFELEVBQVEsQ0FBQ0EsRUFBRSxDQUFDLE9BQUQsQ0FBSCxDQUFSLEVBQXVCLENBQXZCLENBQVQ7QUFDRCxDQUpEOztBQUtBLElBQUlFLGVBQWUsR0FBRyxFQUF0QjtBQUNBSixNQUFNLENBQUNLLGFBQVAsR0FBdUIsSUFBdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvbGF5b3V0cy9kZWZhdWx0LnZ1ZT9mNGI2Il0sInNvdXJjZXNDb250ZW50IjpbInZhciByZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gIHZhciBfdm0gPSB0aGlzLFxuICAgIF9jID0gX3ZtLl9zZWxmLl9jXG4gIHJldHVybiBfYyhcImRpdlwiLCBbX2MoXCJjaGlsZFwiKV0sIDEpXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuXG5leHBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9Il0sIm5hbWVzIjpbInJlbmRlciIsIl92bSIsIl9jIiwiX3NlbGYiLCJzdGF0aWNSZW5kZXJGbnMiLCJfd2l0aFN0cmlwcGVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/layouts/default.vue?vue&type=template&id=06bc2b2d&\n");

/***/ }),

/***/ "./resources/js/app.js":
/*!*****************************!*\
  !*** ./resources/js/app.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vue */ \"./node_modules/vue/dist/vue.esm.js\");\n/* harmony import */ var _router__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ~/router */ \"./resources/js/router/index.js\");\n/* harmony import */ var _App__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ~/App */ \"./resources/js/App.vue\");\n/* harmony import */ var vue_js_modal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vue-js-modal */ \"./node_modules/vue-js-modal/dist/index.js\");\n/* harmony import */ var vue_js_modal__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(vue_js_modal__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _components__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ~/components */ \"./resources/js/components/index.js\");\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n\n\nvue__WEBPACK_IMPORTED_MODULE_4__[\"default\"].config.productionTip = false;\nvue__WEBPACK_IMPORTED_MODULE_4__[\"default\"].use((vue_js_modal__WEBPACK_IMPORTED_MODULE_2___default()));\n/* eslint-disable no-new */\n\nnew vue__WEBPACK_IMPORTED_MODULE_4__[\"default\"](_objectSpread({\n  router: _router__WEBPACK_IMPORTED_MODULE_0__[\"default\"]\n}, _App__WEBPACK_IMPORTED_MODULE_1__[\"default\"]));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvYXBwLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBRUFBLGdFQUFBLEdBQTJCLEtBQTNCO0FBQ0FBLCtDQUFBLENBQVFHLHFEQUFSO0FBRUE7O0FBQ0EsSUFBSUgsMkNBQUo7RUFDRUMsTUFBTSxFQUFOQSwrQ0FBTUE7QUFEUixHQUVLQyw0Q0FGTCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9qcy9hcHAuanM/Y2VkNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgVnVlIGZyb20gJ3Z1ZSdcbmltcG9ydCByb3V0ZXIgZnJvbSAnfi9yb3V0ZXInXG5pbXBvcnQgQXBwIGZyb20gJ34vQXBwJ1xuaW1wb3J0IFZNb2RhbCBmcm9tICd2dWUtanMtbW9kYWwnXG5cblxuaW1wb3J0ICd+L2NvbXBvbmVudHMnXG5cblZ1ZS5jb25maWcucHJvZHVjdGlvblRpcCA9IGZhbHNlXG5WdWUudXNlKFZNb2RhbCk7XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLW5ldyAqL1xubmV3IFZ1ZSh7XG4gIHJvdXRlcixcbiAgLi4uQXBwXG59KVxuIl0sIm5hbWVzIjpbIlZ1ZSIsInJvdXRlciIsIkFwcCIsIlZNb2RhbCIsImNvbmZpZyIsInByb2R1Y3Rpb25UaXAiLCJ1c2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/app.js\n");

/***/ }),

/***/ "./resources/js/components/index.js":
/*!******************************************!*\
  !*** ./resources/js/components/index.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vue */ \"./node_modules/vue/dist/vue.esm.js\");\n/* harmony import */ var _Child_vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Child.vue */ \"./resources/js/components/Child.vue\");\n\n // Components that are registered globaly.\n\n[_Child_vue__WEBPACK_IMPORTED_MODULE_0__[\"default\"]].forEach(function (Component) {\n  vue__WEBPACK_IMPORTED_MODULE_1__[\"default\"].component(Component.name, Component);\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBQTtDQUdBOztBQUNBLENBQ0lDLGtEQURKLEVBRUVDLE9BRkYsQ0FFVSxVQUFBQyxTQUFTLEVBQUk7RUFDckJILHFEQUFBLENBQWNHLFNBQVMsQ0FBQ0UsSUFBeEIsRUFBOEJGLFNBQTlCO0FBQ0QsQ0FKRCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9qcy9jb21wb25lbnRzL2luZGV4LmpzPzkzNTYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFZ1ZSBmcm9tICd2dWUnXG5pbXBvcnQgQ2hpbGQgZnJvbSAnLi9DaGlsZC52dWUnXG5cbi8vIENvbXBvbmVudHMgdGhhdCBhcmUgcmVnaXN0ZXJlZCBnbG9iYWx5LlxuW1xuICAgIENoaWxkXG5dLmZvckVhY2goQ29tcG9uZW50ID0+IHtcbiAgVnVlLmNvbXBvbmVudChDb21wb25lbnQubmFtZSwgQ29tcG9uZW50KVxufSkiXSwibmFtZXMiOlsiVnVlIiwiQ2hpbGQiLCJmb3JFYWNoIiwiQ29tcG9uZW50IiwiY29tcG9uZW50IiwibmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/js/components/index.js\n");

/***/ }),

/***/ "./resources/js/middleware/example.js":
/*!********************************************!*\
  !*** ./resources/js/middleware/example.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, \"throw\" === context.method) { if (delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel; context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, \"constructor\", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, \"catch\": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/*#__PURE__*/(function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(to, from, next) {\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            next();\n\n          case 1:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function (_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n})());//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvbWlkZGxld2FyZS9leGFtcGxlLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OzsrQ0FDQTs7Ozs7O0FBQUE7RUFBQSxzRUFBZSxpQkFBT0EsRUFBUCxFQUFXQyxJQUFYLEVBQWlCQyxJQUFqQjtJQUFBO01BQUE7UUFBQTtVQUFBO1lBQ2JBLElBQUk7O1VBRFM7VUFBQTtZQUFBO1FBQUE7TUFBQTtJQUFBO0VBQUEsQ0FBZjs7RUFBQTtJQUFBO0VBQUE7QUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9qcy9taWRkbGV3YXJlL2V4YW1wbGUuanM/Mjk4ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbmV4cG9ydCBkZWZhdWx0IGFzeW5jICh0bywgZnJvbSwgbmV4dCkgPT4ge1xuICBuZXh0KClcbn1cbiJdLCJuYW1lcyI6WyJ0byIsImZyb20iLCJuZXh0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/js/middleware/example.js\n");

/***/ }),

/***/ "./resources/js/router/index.js":
/*!**************************************!*\
  !*** ./resources/js/router/index.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vue */ \"./node_modules/vue/dist/vue.esm.js\");\n/* harmony import */ var vue_meta__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue-meta */ \"./node_modules/vue-meta/dist/vue-meta.esm.js\");\n/* harmony import */ var _routes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./routes */ \"./resources/js/router/routes.js\");\n/* harmony import */ var vue_router__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vue-router */ \"./node_modules/vue-router/dist/vue-router.esm.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, \"throw\" === context.method) { if (delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel; context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, \"constructor\", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, \"catch\": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\n\n\n\n\nvue__WEBPACK_IMPORTED_MODULE_2__[\"default\"].use(vue_meta__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\nvue__WEBPACK_IMPORTED_MODULE_2__[\"default\"].use(vue_router__WEBPACK_IMPORTED_MODULE_3__[\"default\"]); // The middleware for every page of the application.\n\nvar globalMiddleware = []; // Load middleware modules dynamically.\n\nvar routeMiddleware = resolveMiddleware(__webpack_require__(\"./resources/js/middleware sync .*\\\\.js$\"));\nvar router = createRouter();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (router);\n/**\n * Create a new router instance.\n *\n * @return {Router}\n */\n\nfunction createRouter() {\n  var router = new vue_router__WEBPACK_IMPORTED_MODULE_3__[\"default\"]({\n    scrollBehavior: scrollBehavior,\n    mode: 'history',\n    routes: _routes__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\n  });\n  router.beforeEach(beforeEach);\n  router.afterEach(afterEach);\n  return router;\n}\n/**\n * Global router guard.\n *\n * @param {Route} to\n * @param {Route} from\n * @param {Function} next\n */\n\n\nfunction beforeEach(_x, _x2, _x3) {\n  return _beforeEach.apply(this, arguments);\n}\n/**\n * @param  {Array} components\n * @return {Promise<void>\n */\n\n\nfunction _beforeEach() {\n  _beforeEach = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(to, from, next) {\n    var components, middleware;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            components = [];\n            _context.prev = 1;\n            _context.next = 4;\n            return resolveComponents(router.getMatchedComponents(_objectSpread({}, to)));\n\n          case 4:\n            components = _context.sent;\n            _context.next = 12;\n            break;\n\n          case 7:\n            _context.prev = 7;\n            _context.t0 = _context[\"catch\"](1);\n\n            if (!/^Loading( CSS)? chunk (\\d)+ failed\\./.test(_context.t0.message)) {\n              _context.next = 12;\n              break;\n            }\n\n            window.location.reload(true);\n            return _context.abrupt(\"return\");\n\n          case 12:\n            if (!(components.length === 0)) {\n              _context.next = 14;\n              break;\n            }\n\n            return _context.abrupt(\"return\", next());\n\n          case 14:\n            // Start the loading bar.\n            if (components[components.length - 1].loading !== false) {\n              router.app.$nextTick(function () {\n                return router.app.$loading.start();\n              });\n            } // Get the middleware for all the matched components.\n\n\n            middleware = getMiddleware(components); // Load async data for all the matched components.\n\n            _context.next = 18;\n            return asyncData(components);\n\n          case 18:\n            // Call each middleware.\n            callMiddleware(middleware, to, from, function () {\n              // Set the application layout only if \"next()\" was called with no args.\n              if (arguments.length === 0) {\n                router.app.setLayout(components[0].layout || '');\n              }\n\n              next.apply(void 0, arguments);\n            });\n\n          case 19:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[1, 7]]);\n  }));\n  return _beforeEach.apply(this, arguments);\n}\n\nfunction asyncData(_x4) {\n  return _asyncData.apply(this, arguments);\n}\n/**\n * Global after hook.\n *\n * @param {Route} to\n * @param {Route} from\n * @param {Function} next\n */\n\n\nfunction _asyncData() {\n  _asyncData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(components) {\n    var _loop, i, _ret;\n\n    return _regeneratorRuntime().wrap(function _callee2$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop(i) {\n              var component, dataFn, _asyncData2;\n\n              return _regeneratorRuntime().wrap(function _loop$(_context2) {\n                while (1) {\n                  switch (_context2.prev = _context2.next) {\n                    case 0:\n                      component = components[i];\n\n                      if (component.asyncData) {\n                        _context2.next = 3;\n                        break;\n                      }\n\n                      return _context2.abrupt(\"return\", \"continue\");\n\n                    case 3:\n                      dataFn = component.data;\n                      _context2.prev = 4;\n                      _context2.next = 7;\n                      return component.asyncData();\n\n                    case 7:\n                      _asyncData2 = _context2.sent;\n\n                      component.data = function () {\n                        return _objectSpread(_objectSpread({}, dataFn ? dataFn.apply(this) : {}), _asyncData2);\n                      };\n\n                      _context2.next = 15;\n                      break;\n\n                    case 11:\n                      _context2.prev = 11;\n                      _context2.t0 = _context2[\"catch\"](4);\n                      component.layout = 'error';\n                      console.error('Failed to load asyncData', _context2.t0);\n\n                    case 15:\n                    case \"end\":\n                      return _context2.stop();\n                  }\n                }\n              }, _loop, null, [[4, 11]]);\n            });\n            i = 0;\n\n          case 2:\n            if (!(i < components.length)) {\n              _context3.next = 10;\n              break;\n            }\n\n            return _context3.delegateYield(_loop(i), \"t0\", 4);\n\n          case 4:\n            _ret = _context3.t0;\n\n            if (!(_ret === \"continue\")) {\n              _context3.next = 7;\n              break;\n            }\n\n            return _context3.abrupt(\"continue\", 7);\n\n          case 7:\n            i++;\n            _context3.next = 2;\n            break;\n\n          case 10:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _asyncData.apply(this, arguments);\n}\n\nfunction afterEach(_x5, _x6, _x7) {\n  return _afterEach.apply(this, arguments);\n}\n/**\n * Call each middleware.\n *\n * @param {Array} middleware\n * @param {Route} to\n * @param {Route} from\n * @param {Function} next\n */\n\n\nfunction _afterEach() {\n  _afterEach = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(to, from, next) {\n    return _regeneratorRuntime().wrap(function _callee3$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _context4.next = 2;\n            return router.app.$nextTick();\n\n          case 2:\n            router.app.$loading.finish();\n\n          case 3:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _afterEach.apply(this, arguments);\n}\n\nfunction callMiddleware(middleware, to, from, next) {\n  var stack = middleware.reverse();\n\n  var _next = function _next() {\n    // Stop if \"_next\" was called with an argument or the stack is empty.\n    if (arguments.length > 0 || stack.length === 0) {\n      if (arguments.length > 0) {\n        router.app.$loading.finish();\n      }\n\n      return next.apply(void 0, arguments);\n    }\n\n    var _parseMiddleware = parseMiddleware(stack.pop()),\n        middleware = _parseMiddleware.middleware,\n        params = _parseMiddleware.params;\n\n    if (typeof middleware === 'function') {\n      middleware(to, from, _next, params);\n    } else if (routeMiddleware[middleware]) {\n      routeMiddleware[middleware](to, from, _next, params);\n    } else {\n      throw Error(\"Undefined middleware [\".concat(middleware, \"]\"));\n    }\n  };\n\n  _next();\n}\n/**\n * @param  {String|Function} middleware\n * @return {Object}\n */\n\n\nfunction parseMiddleware(middleware) {\n  if (typeof middleware === 'function') {\n    return {\n      middleware: middleware\n    };\n  }\n\n  var _middleware$split = middleware.split(':'),\n      _middleware$split2 = _slicedToArray(_middleware$split, 2),\n      name = _middleware$split2[0],\n      params = _middleware$split2[1];\n\n  return {\n    middleware: name,\n    params: params\n  };\n}\n/**\n * Resolve async components.\n *\n * @param  {Array} components\n * @return {Array}\n */\n\n\nfunction resolveComponents(components) {\n  return Promise.all(components.map(function (component) {\n    return typeof component === 'function' ? component() : component;\n  }));\n}\n/**\n * Merge the the global middleware with the components middleware.\n *\n * @param  {Array} components\n * @return {Array}\n */\n\n\nfunction getMiddleware(components) {\n  var middleware = [].concat(globalMiddleware);\n  components.filter(function (c) {\n    return c.middleware;\n  }).forEach(function (component) {\n    if (Array.isArray(component.middleware)) {\n      middleware.push.apply(middleware, _toConsumableArray(component.middleware));\n    } else {\n      middleware.push(component.middleware);\n    }\n  });\n  return middleware;\n}\n/**\n * Scroll Behavior\n *\n * @link https://router.vuejs.org/en/advanced/scroll-behavior.html\n *\n * @param  {Route} to\n * @param  {Route} from\n * @param  {Object|undefined} savedPosition\n * @return {Object}\n */\n\n\nfunction scrollBehavior(to, from, savedPosition) {\n  if (savedPosition) {\n    return savedPosition;\n  }\n\n  if (to.hash) {\n    return {\n      selector: to.hash\n    };\n  }\n\n  var _router$getMatchedCom = router.getMatchedComponents(_objectSpread({}, to)).slice(-1),\n      _router$getMatchedCom2 = _slicedToArray(_router$getMatchedCom, 1),\n      component = _router$getMatchedCom2[0];\n\n  if (component && component.scrollToTop === false) {\n    return {};\n  }\n\n  return new Promise(function (resolve, reject) {\n    setTimeout(function () {\n      resolve({\n        x: 0,\n        y: 0\n      });\n    }, 190);\n  });\n}\n/**\n * @param  {Object} requireContext\n * @return {Object}\n */\n\n\nfunction resolveMiddleware(requireContext) {\n  return requireContext.keys().map(function (file) {\n    return [file.replace(/(^.\\/)|(\\.js$)/g, ''), requireContext(file)];\n  }).reduce(function (guards, _ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        name = _ref2[0],\n        guard = _ref2[1];\n\n    return _objectSpread(_objectSpread({}, guards), {}, _defineProperty({}, name, guard[\"default\"]));\n  }, {});\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvcm91dGVyL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7K0NBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFFQUEsK0NBQUEsQ0FBUUMsZ0RBQVI7QUFDQUQsK0NBQUEsQ0FBUUcsa0RBQVIsR0FFQTs7QUFDQSxJQUFNRSxnQkFBZ0IsR0FBRyxFQUF6QixFQUVBOztBQUNBLElBQU1DLGVBQWUsR0FBR0MsaUJBQWlCLENBQ3ZDQyw4REFEdUMsQ0FBekM7QUFJQSxJQUFNRSxNQUFNLEdBQUdDLFlBQVksRUFBM0I7QUFHQSxpRUFBZUQsTUFBZjtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsU0FBU0MsWUFBVCxHQUF5QjtFQUN2QixJQUFNRCxNQUFNLEdBQUcsSUFBSVAsa0RBQUosQ0FBVztJQUN4QlMsY0FBYyxFQUFkQSxjQUR3QjtJQUV4QkMsSUFBSSxFQUFFLFNBRmtCO0lBR3hCWCxNQUFNLEVBQU5BLCtDQUFNQTtFQUhrQixDQUFYLENBQWY7RUFNQVEsTUFBTSxDQUFDSSxVQUFQLENBQWtCQSxVQUFsQjtFQUNBSixNQUFNLENBQUNLLFNBQVAsQ0FBaUJBLFNBQWpCO0VBRUEsT0FBT0wsTUFBUDtBQUNEO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztTQUNlSTs7O0FBeUNmO0FBQ0E7QUFDQTtBQUNBOzs7OzJFQTVDQSxpQkFBMkJFLEVBQTNCLEVBQStCQyxJQUEvQixFQUFxQ0MsSUFBckM7SUFBQTtJQUFBO01BQUE7UUFBQTtVQUFBO1lBQ01DLFVBRE4sR0FDbUIsRUFEbkI7WUFBQTtZQUFBO1lBQUEsT0FLdUJDLGlCQUFpQixDQUNsQ1YsTUFBTSxDQUFDVyxvQkFBUCxtQkFBaUNMLEVBQWpDLEVBRGtDLENBTHhDOztVQUFBO1lBS0lHLFVBTEo7WUFBQTtZQUFBOztVQUFBO1lBQUE7WUFBQTs7WUFBQSxLQVNRLHVDQUF1Q0csSUFBdkMsQ0FBNEMsWUFBTUMsT0FBbEQsQ0FUUjtjQUFBO2NBQUE7WUFBQTs7WUFVTUMsTUFBTSxDQUFDQyxRQUFQLENBQWdCQyxNQUFoQixDQUF1QixJQUF2QjtZQVZOOztVQUFBO1lBQUEsTUFlTVAsVUFBVSxDQUFDUSxNQUFYLEtBQXNCLENBZjVCO2NBQUE7Y0FBQTtZQUFBOztZQUFBLGlDQWdCV1QsSUFBSSxFQWhCZjs7VUFBQTtZQW1CRTtZQUNBLElBQUlDLFVBQVUsQ0FBQ0EsVUFBVSxDQUFDUSxNQUFYLEdBQW9CLENBQXJCLENBQVYsQ0FBa0NDLE9BQWxDLEtBQThDLEtBQWxELEVBQXlEO2NBQ3ZEbEIsTUFBTSxDQUFDbUIsR0FBUCxDQUFXQyxTQUFYLENBQXFCO2dCQUFBLE9BQU1wQixNQUFNLENBQUNtQixHQUFQLENBQVdFLFFBQVgsQ0FBb0JDLEtBQXBCLEVBQU47Y0FBQSxDQUFyQjtZQUNELENBdEJILENBd0JFOzs7WUFDTUMsVUF6QlIsR0F5QnFCQyxhQUFhLENBQUNmLFVBQUQsQ0F6QmxDLEVBMkJFOztZQTNCRjtZQUFBLE9BNEJRZ0IsU0FBUyxDQUFDaEIsVUFBRCxDQTVCakI7O1VBQUE7WUE4QkU7WUFDQWlCLGNBQWMsQ0FBQ0gsVUFBRCxFQUFhakIsRUFBYixFQUFpQkMsSUFBakIsRUFBdUIsWUFBYTtjQUNoRDtjQUNBLElBQUksVUFBS1UsTUFBTCxLQUFnQixDQUFwQixFQUF1QjtnQkFDckJqQixNQUFNLENBQUNtQixHQUFQLENBQVdRLFNBQVgsQ0FBcUJsQixVQUFVLENBQUMsQ0FBRCxDQUFWLENBQWNtQixNQUFkLElBQXdCLEVBQTdDO2NBQ0Q7O2NBRURwQixJQUFJLE1BQUo7WUFDRCxDQVBhLENBQWQ7O1VBL0JGO1VBQUE7WUFBQTtRQUFBO01BQUE7SUFBQTtFQUFBOzs7O1NBNkNlaUI7OztBQTJCZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OzswRUFqQ0Esa0JBQTBCaEIsVUFBMUI7SUFBQTs7SUFBQTtNQUFBO1FBQUE7VUFBQTtZQUFBLCtEQUNXb0IsQ0FEWDtjQUFBOztjQUFBO2dCQUFBO2tCQUFBO29CQUFBO3NCQUVVQyxTQUZWLEdBRXNCckIsVUFBVSxDQUFDb0IsQ0FBRCxDQUZoQzs7c0JBQUEsSUFJU0MsU0FBUyxDQUFDTCxTQUpuQjt3QkFBQTt3QkFBQTtzQkFBQTs7c0JBQUE7O29CQUFBO3NCQVFVTSxNQVJWLEdBUW1CRCxTQUFTLENBQUNFLElBUjdCO3NCQUFBO3NCQUFBO3NCQUFBLE9BVzhCRixTQUFTLENBQUNMLFNBQVYsRUFYOUI7O29CQUFBO3NCQVdZQSxXQVhaOztzQkFhTUssU0FBUyxDQUFDRSxJQUFWLEdBQWlCLFlBQVk7d0JBQzNCLHVDQUNNRCxNQUFNLEdBQUdBLE1BQU0sQ0FBQ0UsS0FBUCxDQUFhLElBQWIsQ0FBSCxHQUF3QixFQURwQyxHQUVLUixXQUZMO3NCQUlELENBTEQ7O3NCQWJOO3NCQUFBOztvQkFBQTtzQkFBQTtzQkFBQTtzQkFvQk1LLFNBQVMsQ0FBQ0YsTUFBVixHQUFtQixPQUFuQjtzQkFFQU0sT0FBTyxDQUFDQyxLQUFSLENBQWMsMEJBQWQ7O29CQXRCTjtvQkFBQTtzQkFBQTtrQkFBQTtnQkFBQTtjQUFBO1lBQUE7WUFDV04sQ0FEWCxHQUNlLENBRGY7O1VBQUE7WUFBQSxNQUNrQkEsQ0FBQyxHQUFHcEIsVUFBVSxDQUFDUSxNQURqQztjQUFBO2NBQUE7WUFBQTs7WUFBQSxxQ0FDV1ksQ0FEWDs7VUFBQTtZQUFBOztZQUFBO2NBQUE7Y0FBQTtZQUFBOztZQUFBOztVQUFBO1lBQ3lDQSxDQUFDLEVBRDFDO1lBQUE7WUFBQTs7VUFBQTtVQUFBO1lBQUE7UUFBQTtNQUFBO0lBQUE7RUFBQTs7OztTQWtDZXhCOzs7QUFNZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OzBFQWJBLGtCQUEwQkMsRUFBMUIsRUFBOEJDLElBQTlCLEVBQW9DQyxJQUFwQztJQUFBO01BQUE7UUFBQTtVQUFBO1lBQUE7WUFBQSxPQUNRUixNQUFNLENBQUNtQixHQUFQLENBQVdDLFNBQVgsRUFEUjs7VUFBQTtZQUdFcEIsTUFBTSxDQUFDbUIsR0FBUCxDQUFXRSxRQUFYLENBQW9CZSxNQUFwQjs7VUFIRjtVQUFBO1lBQUE7UUFBQTtNQUFBO0lBQUE7RUFBQTs7OztBQWNBLFNBQVNWLGNBQVQsQ0FBeUJILFVBQXpCLEVBQXFDakIsRUFBckMsRUFBeUNDLElBQXpDLEVBQStDQyxJQUEvQyxFQUFxRDtFQUNuRCxJQUFNNkIsS0FBSyxHQUFHZCxVQUFVLENBQUNlLE9BQVgsRUFBZDs7RUFFQSxJQUFNQyxLQUFLLEdBQUcsU0FBUkEsS0FBUSxHQUFhO0lBQ3pCO0lBQ0EsSUFBSSxVQUFLdEIsTUFBTCxHQUFjLENBQWQsSUFBbUJvQixLQUFLLENBQUNwQixNQUFOLEtBQWlCLENBQXhDLEVBQTJDO01BQ3pDLElBQUksVUFBS0EsTUFBTCxHQUFjLENBQWxCLEVBQXFCO1FBQ25CakIsTUFBTSxDQUFDbUIsR0FBUCxDQUFXRSxRQUFYLENBQW9CZSxNQUFwQjtNQUNEOztNQUVELE9BQU81QixJQUFJLE1BQUosbUJBQVA7SUFDRDs7SUFFRCx1QkFBK0JnQyxlQUFlLENBQUNILEtBQUssQ0FBQ0ksR0FBTixFQUFELENBQTlDO0lBQUEsSUFBUWxCLFVBQVIsb0JBQVFBLFVBQVI7SUFBQSxJQUFvQm1CLE1BQXBCLG9CQUFvQkEsTUFBcEI7O0lBRUEsSUFBSSxPQUFPbkIsVUFBUCxLQUFzQixVQUExQixFQUFzQztNQUNwQ0EsVUFBVSxDQUFDakIsRUFBRCxFQUFLQyxJQUFMLEVBQVdnQyxLQUFYLEVBQWtCRyxNQUFsQixDQUFWO0lBQ0QsQ0FGRCxNQUVPLElBQUk5QyxlQUFlLENBQUMyQixVQUFELENBQW5CLEVBQWlDO01BQ3RDM0IsZUFBZSxDQUFDMkIsVUFBRCxDQUFmLENBQTRCakIsRUFBNUIsRUFBZ0NDLElBQWhDLEVBQXNDZ0MsS0FBdEMsRUFBNkNHLE1BQTdDO0lBQ0QsQ0FGTSxNQUVBO01BQ0wsTUFBTUMsS0FBSyxpQ0FBMEJwQixVQUExQixPQUFYO0lBQ0Q7RUFDRixDQW5CRDs7RUFxQkFnQixLQUFLO0FBQ047QUFFRDtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsU0FBU0MsZUFBVCxDQUEwQmpCLFVBQTFCLEVBQXNDO0VBQ3BDLElBQUksT0FBT0EsVUFBUCxLQUFzQixVQUExQixFQUFzQztJQUNwQyxPQUFPO01BQUVBLFVBQVUsRUFBVkE7SUFBRixDQUFQO0VBQ0Q7O0VBRUQsd0JBQXVCQSxVQUFVLENBQUNxQixLQUFYLENBQWlCLEdBQWpCLENBQXZCO0VBQUE7RUFBQSxJQUFPQyxJQUFQO0VBQUEsSUFBYUgsTUFBYjs7RUFFQSxPQUFPO0lBQUVuQixVQUFVLEVBQUVzQixJQUFkO0lBQW9CSCxNQUFNLEVBQU5BO0VBQXBCLENBQVA7QUFDRDtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsU0FBU2hDLGlCQUFULENBQTRCRCxVQUE1QixFQUF3QztFQUN0QyxPQUFPcUMsT0FBTyxDQUFDQyxHQUFSLENBQVl0QyxVQUFVLENBQUN1QyxHQUFYLENBQWUsVUFBQWxCLFNBQVMsRUFBSTtJQUM3QyxPQUFPLE9BQU9BLFNBQVAsS0FBcUIsVUFBckIsR0FBa0NBLFNBQVMsRUFBM0MsR0FBZ0RBLFNBQXZEO0VBQ0QsQ0FGa0IsQ0FBWixDQUFQO0FBR0Q7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFNBQVNOLGFBQVQsQ0FBd0JmLFVBQXhCLEVBQW9DO0VBQ2xDLElBQU1jLFVBQVUsYUFBTzVCLGdCQUFQLENBQWhCO0VBRUFjLFVBQVUsQ0FBQ3dDLE1BQVgsQ0FBa0IsVUFBQUMsQ0FBQztJQUFBLE9BQUlBLENBQUMsQ0FBQzNCLFVBQU47RUFBQSxDQUFuQixFQUFxQzRCLE9BQXJDLENBQTZDLFVBQUFyQixTQUFTLEVBQUk7SUFDeEQsSUFBSXNCLEtBQUssQ0FBQ0MsT0FBTixDQUFjdkIsU0FBUyxDQUFDUCxVQUF4QixDQUFKLEVBQXlDO01BQ3ZDQSxVQUFVLENBQUMrQixJQUFYLE9BQUEvQixVQUFVLHFCQUFTTyxTQUFTLENBQUNQLFVBQW5CLEVBQVY7SUFDRCxDQUZELE1BRU87TUFDTEEsVUFBVSxDQUFDK0IsSUFBWCxDQUFnQnhCLFNBQVMsQ0FBQ1AsVUFBMUI7SUFDRDtFQUNGLENBTkQ7RUFRQSxPQUFPQSxVQUFQO0FBQ0Q7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsU0FBU3JCLGNBQVQsQ0FBeUJJLEVBQXpCLEVBQTZCQyxJQUE3QixFQUFtQ2dELGFBQW5DLEVBQWtEO0VBQ2hELElBQUlBLGFBQUosRUFBbUI7SUFDakIsT0FBT0EsYUFBUDtFQUNEOztFQUVELElBQUlqRCxFQUFFLENBQUNrRCxJQUFQLEVBQWE7SUFDWCxPQUFPO01BQUVDLFFBQVEsRUFBRW5ELEVBQUUsQ0FBQ2tEO0lBQWYsQ0FBUDtFQUNEOztFQUVELDRCQUFvQnhELE1BQU0sQ0FBQ1csb0JBQVAsbUJBQWlDTCxFQUFqQyxHQUF1Q29ELEtBQXZDLENBQTZDLENBQUMsQ0FBOUMsQ0FBcEI7RUFBQTtFQUFBLElBQU81QixTQUFQOztFQUVBLElBQUlBLFNBQVMsSUFBSUEsU0FBUyxDQUFDNkIsV0FBVixLQUEwQixLQUEzQyxFQUFrRDtJQUNoRCxPQUFPLEVBQVA7RUFDRDs7RUFFRCxPQUFPLElBQUliLE9BQUosQ0FBWSxVQUFDYyxPQUFELEVBQVVDLE1BQVYsRUFBcUI7SUFDdENDLFVBQVUsQ0FBQyxZQUFNO01BQ2ZGLE9BQU8sQ0FBQztRQUFFRyxDQUFDLEVBQUUsQ0FBTDtRQUFRQyxDQUFDLEVBQUU7TUFBWCxDQUFELENBQVA7SUFDRCxDQUZTLEVBRVAsR0FGTyxDQUFWO0VBR0QsQ0FKTSxDQUFQO0FBS0Q7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsU0FBU25FLGlCQUFULENBQTRCb0UsY0FBNUIsRUFBNEM7RUFDMUMsT0FBT0EsY0FBYyxDQUFDQyxJQUFmLEdBQ0psQixHQURJLENBQ0EsVUFBQW1CLElBQUk7SUFBQSxPQUNQLENBQUNBLElBQUksQ0FBQ0MsT0FBTCxDQUFhLGlCQUFiLEVBQWdDLEVBQWhDLENBQUQsRUFBc0NILGNBQWMsQ0FBQ0UsSUFBRCxDQUFwRCxDQURPO0VBQUEsQ0FESixFQUlKRSxNQUpJLENBSUcsVUFBQ0MsTUFBRDtJQUFBO0lBQUEsSUFBVXpCLElBQVY7SUFBQSxJQUFnQjBCLEtBQWhCOztJQUFBLHVDQUNERCxNQURDLDJCQUNRekIsSUFEUixFQUNlMEIsS0FBSyxXQURwQjtFQUFBLENBSkgsRUFNRixFQU5FLENBQVA7QUFPRCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9qcy9yb3V0ZXIvaW5kZXguanM/MjUxNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgVnVlIGZyb20gJ3Z1ZSdcbmltcG9ydCBNZXRhIGZyb20gJ3Z1ZS1tZXRhJ1xuaW1wb3J0IHJvdXRlcyBmcm9tICcuL3JvdXRlcydcbmltcG9ydCBSb3V0ZXIgZnJvbSAndnVlLXJvdXRlcidcblxuVnVlLnVzZShNZXRhKVxuVnVlLnVzZShSb3V0ZXIpXG5cbi8vIFRoZSBtaWRkbGV3YXJlIGZvciBldmVyeSBwYWdlIG9mIHRoZSBhcHBsaWNhdGlvbi5cbmNvbnN0IGdsb2JhbE1pZGRsZXdhcmUgPSBbXVxuXG4vLyBMb2FkIG1pZGRsZXdhcmUgbW9kdWxlcyBkeW5hbWljYWxseS5cbmNvbnN0IHJvdXRlTWlkZGxld2FyZSA9IHJlc29sdmVNaWRkbGV3YXJlKFxuICByZXF1aXJlLmNvbnRleHQoJ34vbWlkZGxld2FyZScsIGZhbHNlLCAvLipcXC5qcyQvKVxuKVxuXG5jb25zdCByb3V0ZXIgPSBjcmVhdGVSb3V0ZXIoKVxuXG5cbmV4cG9ydCBkZWZhdWx0IHJvdXRlclxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyByb3V0ZXIgaW5zdGFuY2UuXG4gKlxuICogQHJldHVybiB7Um91dGVyfVxuICovXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZXIgKCkge1xuICBjb25zdCByb3V0ZXIgPSBuZXcgUm91dGVyKHtcbiAgICBzY3JvbGxCZWhhdmlvcixcbiAgICBtb2RlOiAnaGlzdG9yeScsXG4gICAgcm91dGVzXG4gIH0pXG5cbiAgcm91dGVyLmJlZm9yZUVhY2goYmVmb3JlRWFjaClcbiAgcm91dGVyLmFmdGVyRWFjaChhZnRlckVhY2gpXG5cbiAgcmV0dXJuIHJvdXRlclxufVxuXG4vKipcbiAqIEdsb2JhbCByb3V0ZXIgZ3VhcmQuXG4gKlxuICogQHBhcmFtIHtSb3V0ZX0gdG9cbiAqIEBwYXJhbSB7Um91dGV9IGZyb21cbiAqIEBwYXJhbSB7RnVuY3Rpb259IG5leHRcbiAqL1xuYXN5bmMgZnVuY3Rpb24gYmVmb3JlRWFjaCAodG8sIGZyb20sIG5leHQpIHtcbiAgbGV0IGNvbXBvbmVudHMgPSBbXVxuXG4gIHRyeSB7XG4gICAgLy8gR2V0IHRoZSBtYXRjaGVkIGNvbXBvbmVudHMgYW5kIHJlc29sdmUgdGhlbS5cbiAgICBjb21wb25lbnRzID0gYXdhaXQgcmVzb2x2ZUNvbXBvbmVudHMoXG4gICAgICByb3V0ZXIuZ2V0TWF0Y2hlZENvbXBvbmVudHMoeyAuLi50byB9KVxuICAgIClcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoL15Mb2FkaW5nKCBDU1MpPyBjaHVuayAoXFxkKSsgZmFpbGVkXFwuLy50ZXN0KGVycm9yLm1lc3NhZ2UpKSB7XG4gICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKHRydWUpXG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cblxuICBpZiAoY29tcG9uZW50cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbmV4dCgpXG4gIH1cblxuICAvLyBTdGFydCB0aGUgbG9hZGluZyBiYXIuXG4gIGlmIChjb21wb25lbnRzW2NvbXBvbmVudHMubGVuZ3RoIC0gMV0ubG9hZGluZyAhPT0gZmFsc2UpIHtcbiAgICByb3V0ZXIuYXBwLiRuZXh0VGljaygoKSA9PiByb3V0ZXIuYXBwLiRsb2FkaW5nLnN0YXJ0KCkpXG4gIH1cblxuICAvLyBHZXQgdGhlIG1pZGRsZXdhcmUgZm9yIGFsbCB0aGUgbWF0Y2hlZCBjb21wb25lbnRzLlxuICBjb25zdCBtaWRkbGV3YXJlID0gZ2V0TWlkZGxld2FyZShjb21wb25lbnRzKVxuXG4gIC8vIExvYWQgYXN5bmMgZGF0YSBmb3IgYWxsIHRoZSBtYXRjaGVkIGNvbXBvbmVudHMuXG4gIGF3YWl0IGFzeW5jRGF0YShjb21wb25lbnRzKVxuXG4gIC8vIENhbGwgZWFjaCBtaWRkbGV3YXJlLlxuICBjYWxsTWlkZGxld2FyZShtaWRkbGV3YXJlLCB0bywgZnJvbSwgKC4uLmFyZ3MpID0+IHtcbiAgICAvLyBTZXQgdGhlIGFwcGxpY2F0aW9uIGxheW91dCBvbmx5IGlmIFwibmV4dCgpXCIgd2FzIGNhbGxlZCB3aXRoIG5vIGFyZ3MuXG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICByb3V0ZXIuYXBwLnNldExheW91dChjb21wb25lbnRzWzBdLmxheW91dCB8fCAnJylcbiAgICB9XG5cbiAgICBuZXh0KC4uLmFyZ3MpXG4gIH0pXG59XG5cbi8qKlxuICogQHBhcmFtICB7QXJyYXl9IGNvbXBvbmVudHNcbiAqIEByZXR1cm4ge1Byb21pc2U8dm9pZD5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gYXN5bmNEYXRhIChjb21wb25lbnRzKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY29tcG9uZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNvbXBvbmVudCA9IGNvbXBvbmVudHNbaV1cblxuICAgIGlmICghY29tcG9uZW50LmFzeW5jRGF0YSkge1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhRm4gPSBjb21wb25lbnQuZGF0YVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGFzeW5jRGF0YSA9IGF3YWl0IGNvbXBvbmVudC5hc3luY0RhdGEoKVxuXG4gICAgICBjb21wb25lbnQuZGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi4oZGF0YUZuID8gZGF0YUZuLmFwcGx5KHRoaXMpIDoge30pLFxuICAgICAgICAgIC4uLmFzeW5jRGF0YVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29tcG9uZW50LmxheW91dCA9ICdlcnJvcidcblxuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGxvYWQgYXN5bmNEYXRhJywgZSlcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBHbG9iYWwgYWZ0ZXIgaG9vay5cbiAqXG4gKiBAcGFyYW0ge1JvdXRlfSB0b1xuICogQHBhcmFtIHtSb3V0ZX0gZnJvbVxuICogQHBhcmFtIHtGdW5jdGlvbn0gbmV4dFxuICovXG5hc3luYyBmdW5jdGlvbiBhZnRlckVhY2ggKHRvLCBmcm9tLCBuZXh0KSB7XG4gIGF3YWl0IHJvdXRlci5hcHAuJG5leHRUaWNrKClcblxuICByb3V0ZXIuYXBwLiRsb2FkaW5nLmZpbmlzaCgpXG59XG5cbi8qKlxuICogQ2FsbCBlYWNoIG1pZGRsZXdhcmUuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gbWlkZGxld2FyZVxuICogQHBhcmFtIHtSb3V0ZX0gdG9cbiAqIEBwYXJhbSB7Um91dGV9IGZyb21cbiAqIEBwYXJhbSB7RnVuY3Rpb259IG5leHRcbiAqL1xuZnVuY3Rpb24gY2FsbE1pZGRsZXdhcmUgKG1pZGRsZXdhcmUsIHRvLCBmcm9tLCBuZXh0KSB7XG4gIGNvbnN0IHN0YWNrID0gbWlkZGxld2FyZS5yZXZlcnNlKClcblxuICBjb25zdCBfbmV4dCA9ICguLi5hcmdzKSA9PiB7XG4gICAgLy8gU3RvcCBpZiBcIl9uZXh0XCIgd2FzIGNhbGxlZCB3aXRoIGFuIGFyZ3VtZW50IG9yIHRoZSBzdGFjayBpcyBlbXB0eS5cbiAgICBpZiAoYXJncy5sZW5ndGggPiAwIHx8IHN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICByb3V0ZXIuYXBwLiRsb2FkaW5nLmZpbmlzaCgpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXh0KC4uLmFyZ3MpXG4gICAgfVxuXG4gICAgY29uc3QgeyBtaWRkbGV3YXJlLCBwYXJhbXMgfSA9IHBhcnNlTWlkZGxld2FyZShzdGFjay5wb3AoKSlcblxuICAgIGlmICh0eXBlb2YgbWlkZGxld2FyZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgbWlkZGxld2FyZSh0bywgZnJvbSwgX25leHQsIHBhcmFtcylcbiAgICB9IGVsc2UgaWYgKHJvdXRlTWlkZGxld2FyZVttaWRkbGV3YXJlXSkge1xuICAgICAgcm91dGVNaWRkbGV3YXJlW21pZGRsZXdhcmVdKHRvLCBmcm9tLCBfbmV4dCwgcGFyYW1zKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcihgVW5kZWZpbmVkIG1pZGRsZXdhcmUgWyR7bWlkZGxld2FyZX1dYClcbiAgICB9XG4gIH1cblxuICBfbmV4dCgpXG59XG5cbi8qKlxuICogQHBhcmFtICB7U3RyaW5nfEZ1bmN0aW9ufSBtaWRkbGV3YXJlXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIHBhcnNlTWlkZGxld2FyZSAobWlkZGxld2FyZSkge1xuICBpZiAodHlwZW9mIG1pZGRsZXdhcmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4geyBtaWRkbGV3YXJlIH1cbiAgfVxuXG4gIGNvbnN0IFtuYW1lLCBwYXJhbXNdID0gbWlkZGxld2FyZS5zcGxpdCgnOicpXG5cbiAgcmV0dXJuIHsgbWlkZGxld2FyZTogbmFtZSwgcGFyYW1zIH1cbn1cblxuLyoqXG4gKiBSZXNvbHZlIGFzeW5jIGNvbXBvbmVudHMuXG4gKlxuICogQHBhcmFtICB7QXJyYXl9IGNvbXBvbmVudHNcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5mdW5jdGlvbiByZXNvbHZlQ29tcG9uZW50cyAoY29tcG9uZW50cykge1xuICByZXR1cm4gUHJvbWlzZS5hbGwoY29tcG9uZW50cy5tYXAoY29tcG9uZW50ID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIGNvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJyA/IGNvbXBvbmVudCgpIDogY29tcG9uZW50XG4gIH0pKVxufVxuXG4vKipcbiAqIE1lcmdlIHRoZSB0aGUgZ2xvYmFsIG1pZGRsZXdhcmUgd2l0aCB0aGUgY29tcG9uZW50cyBtaWRkbGV3YXJlLlxuICpcbiAqIEBwYXJhbSAge0FycmF5fSBjb21wb25lbnRzXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuZnVuY3Rpb24gZ2V0TWlkZGxld2FyZSAoY29tcG9uZW50cykge1xuICBjb25zdCBtaWRkbGV3YXJlID0gWy4uLmdsb2JhbE1pZGRsZXdhcmVdXG5cbiAgY29tcG9uZW50cy5maWx0ZXIoYyA9PiBjLm1pZGRsZXdhcmUpLmZvckVhY2goY29tcG9uZW50ID0+IHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjb21wb25lbnQubWlkZGxld2FyZSkpIHtcbiAgICAgIG1pZGRsZXdhcmUucHVzaCguLi5jb21wb25lbnQubWlkZGxld2FyZSlcbiAgICB9IGVsc2Uge1xuICAgICAgbWlkZGxld2FyZS5wdXNoKGNvbXBvbmVudC5taWRkbGV3YXJlKVxuICAgIH1cbiAgfSlcblxuICByZXR1cm4gbWlkZGxld2FyZVxufVxuXG4vKipcbiAqIFNjcm9sbCBCZWhhdmlvclxuICpcbiAqIEBsaW5rIGh0dHBzOi8vcm91dGVyLnZ1ZWpzLm9yZy9lbi9hZHZhbmNlZC9zY3JvbGwtYmVoYXZpb3IuaHRtbFxuICpcbiAqIEBwYXJhbSAge1JvdXRlfSB0b1xuICogQHBhcmFtICB7Um91dGV9IGZyb21cbiAqIEBwYXJhbSAge09iamVjdHx1bmRlZmluZWR9IHNhdmVkUG9zaXRpb25cbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gc2Nyb2xsQmVoYXZpb3IgKHRvLCBmcm9tLCBzYXZlZFBvc2l0aW9uKSB7XG4gIGlmIChzYXZlZFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIHNhdmVkUG9zaXRpb25cbiAgfVxuXG4gIGlmICh0by5oYXNoKSB7XG4gICAgcmV0dXJuIHsgc2VsZWN0b3I6IHRvLmhhc2ggfVxuICB9XG5cbiAgY29uc3QgW2NvbXBvbmVudF0gPSByb3V0ZXIuZ2V0TWF0Y2hlZENvbXBvbmVudHMoeyAuLi50byB9KS5zbGljZSgtMSlcblxuICBpZiAoY29tcG9uZW50ICYmIGNvbXBvbmVudC5zY3JvbGxUb1RvcCA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4ge31cbiAgfVxuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICByZXNvbHZlKHsgeDogMCwgeTogMCB9KVxuICAgIH0sIDE5MClcbiAgfSlcbn1cblxuLyoqXG4gKiBAcGFyYW0gIHtPYmplY3R9IHJlcXVpcmVDb250ZXh0XG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVNaWRkbGV3YXJlIChyZXF1aXJlQ29udGV4dCkge1xuICByZXR1cm4gcmVxdWlyZUNvbnRleHQua2V5cygpXG4gICAgLm1hcChmaWxlID0+XG4gICAgICBbZmlsZS5yZXBsYWNlKC8oXi5cXC8pfChcXC5qcyQpL2csICcnKSwgcmVxdWlyZUNvbnRleHQoZmlsZSldXG4gICAgKVxuICAgIC5yZWR1Y2UoKGd1YXJkcywgW25hbWUsIGd1YXJkXSkgPT4gKFxuICAgICAgeyAuLi5ndWFyZHMsIFtuYW1lXTogZ3VhcmQuZGVmYXVsdCB9XG4gICAgKSwge30pXG59XG4iXSwibmFtZXMiOlsiVnVlIiwiTWV0YSIsInJvdXRlcyIsIlJvdXRlciIsInVzZSIsImdsb2JhbE1pZGRsZXdhcmUiLCJyb3V0ZU1pZGRsZXdhcmUiLCJyZXNvbHZlTWlkZGxld2FyZSIsInJlcXVpcmUiLCJjb250ZXh0Iiwicm91dGVyIiwiY3JlYXRlUm91dGVyIiwic2Nyb2xsQmVoYXZpb3IiLCJtb2RlIiwiYmVmb3JlRWFjaCIsImFmdGVyRWFjaCIsInRvIiwiZnJvbSIsIm5leHQiLCJjb21wb25lbnRzIiwicmVzb2x2ZUNvbXBvbmVudHMiLCJnZXRNYXRjaGVkQ29tcG9uZW50cyIsInRlc3QiLCJtZXNzYWdlIiwid2luZG93IiwibG9jYXRpb24iLCJyZWxvYWQiLCJsZW5ndGgiLCJsb2FkaW5nIiwiYXBwIiwiJG5leHRUaWNrIiwiJGxvYWRpbmciLCJzdGFydCIsIm1pZGRsZXdhcmUiLCJnZXRNaWRkbGV3YXJlIiwiYXN5bmNEYXRhIiwiY2FsbE1pZGRsZXdhcmUiLCJzZXRMYXlvdXQiLCJsYXlvdXQiLCJpIiwiY29tcG9uZW50IiwiZGF0YUZuIiwiZGF0YSIsImFwcGx5IiwiY29uc29sZSIsImVycm9yIiwiZmluaXNoIiwic3RhY2siLCJyZXZlcnNlIiwiX25leHQiLCJwYXJzZU1pZGRsZXdhcmUiLCJwb3AiLCJwYXJhbXMiLCJFcnJvciIsInNwbGl0IiwibmFtZSIsIlByb21pc2UiLCJhbGwiLCJtYXAiLCJmaWx0ZXIiLCJjIiwiZm9yRWFjaCIsIkFycmF5IiwiaXNBcnJheSIsInB1c2giLCJzYXZlZFBvc2l0aW9uIiwiaGFzaCIsInNlbGVjdG9yIiwic2xpY2UiLCJzY3JvbGxUb1RvcCIsInJlc29sdmUiLCJyZWplY3QiLCJzZXRUaW1lb3V0IiwieCIsInkiLCJyZXF1aXJlQ29udGV4dCIsImtleXMiLCJmaWxlIiwicmVwbGFjZSIsInJlZHVjZSIsImd1YXJkcyIsImd1YXJkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/js/router/index.js\n");

/***/ }),

/***/ "./resources/js/router/routes.js":
/*!***************************************!*\
  !*** ./resources/js/router/routes.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction page(path) {\n  return function () {\n    return __webpack_require__(\"./resources/js/pages lazy recursive ^\\\\.\\\\/.*$\")(\"./\".concat(path)).then(function (m) {\n      return m[\"default\"] || m;\n    });\n  };\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ([{\n  path: '/',\n  name: 'welcome',\n  component: page('welcome.vue')\n}, {\n  path: '*',\n  component: page('errors/404.vue')\n}]);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvcm91dGVyL3JvdXRlcy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsU0FBU0EsSUFBVCxDQUFlQyxJQUFmLEVBQXFCO0VBQ25CLE9BQU87SUFBQSxPQUFNLGtGQUE2Q0EsSUFBN0MsR0FBcURDLElBQXJELENBQTBELFVBQUFDLENBQUM7TUFBQSxPQUFJQSxDQUFDLFdBQUQsSUFBYUEsQ0FBakI7SUFBQSxDQUEzRCxDQUFOO0VBQUEsQ0FBUDtBQUNEOztBQUVELGlFQUFlLENBQ2I7RUFBRUYsSUFBSSxFQUFFLEdBQVI7RUFBYUcsSUFBSSxFQUFFLFNBQW5CO0VBQThCQyxTQUFTLEVBQUVMLElBQUksQ0FBQyxhQUFEO0FBQTdDLENBRGEsRUFHYjtFQUFFQyxJQUFJLEVBQUUsR0FBUjtFQUFhSSxTQUFTLEVBQUVMLElBQUksQ0FBQyxnQkFBRDtBQUE1QixDQUhhLENBQWYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvcm91dGVyL3JvdXRlcy5qcz80ODI2Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIHBhZ2UgKHBhdGgpIHtcbiAgcmV0dXJuICgpID0+IGltcG9ydCgvKiB3ZWJwYWNrQ2h1bmtOYW1lOiAnJyAqLyBgfi9wYWdlcy8ke3BhdGh9YCkudGhlbihtID0+IG0uZGVmYXVsdCB8fCBtKVxufVxuXG5leHBvcnQgZGVmYXVsdCBbXG4gIHsgcGF0aDogJy8nLCBuYW1lOiAnd2VsY29tZScsIGNvbXBvbmVudDogcGFnZSgnd2VsY29tZS52dWUnKSB9LFxuXG4gIHsgcGF0aDogJyonLCBjb21wb25lbnQ6IHBhZ2UoJ2Vycm9ycy80MDQudnVlJykgfVxuXVxuIl0sIm5hbWVzIjpbInBhZ2UiLCJwYXRoIiwidGhlbiIsIm0iLCJuYW1lIiwiY29tcG9uZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/js/router/routes.js\n");

/***/ }),

/***/ "./node_modules/deepmerge/dist/cjs.js":
/*!********************************************!*\
  !*** ./node_modules/deepmerge/dist/cjs.js ***!
  \********************************************/
/***/ ((module) => {

"use strict";
eval("\n\nvar isMergeableObject = function isMergeableObject(value) {\n\treturn isNonNullObject(value)\n\t\t&& !isSpecial(value)\n};\n\nfunction isNonNullObject(value) {\n\treturn !!value && typeof value === 'object'\n}\n\nfunction isSpecial(value) {\n\tvar stringValue = Object.prototype.toString.call(value);\n\n\treturn stringValue === '[object RegExp]'\n\t\t|| stringValue === '[object Date]'\n\t\t|| isReactElement(value)\n}\n\n// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\nvar canUseSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\n\nfunction isReactElement(value) {\n\treturn value.$$typeof === REACT_ELEMENT_TYPE\n}\n\nfunction emptyTarget(val) {\n\treturn Array.isArray(val) ? [] : {}\n}\n\nfunction cloneUnlessOtherwiseSpecified(value, options) {\n\treturn (options.clone !== false && options.isMergeableObject(value))\n\t\t? deepmerge(emptyTarget(value), value, options)\n\t\t: value\n}\n\nfunction defaultArrayMerge(target, source, options) {\n\treturn target.concat(source).map(function(element) {\n\t\treturn cloneUnlessOtherwiseSpecified(element, options)\n\t})\n}\n\nfunction getMergeFunction(key, options) {\n\tif (!options.customMerge) {\n\t\treturn deepmerge\n\t}\n\tvar customMerge = options.customMerge(key);\n\treturn typeof customMerge === 'function' ? customMerge : deepmerge\n}\n\nfunction getEnumerableOwnPropertySymbols(target) {\n\treturn Object.getOwnPropertySymbols\n\t\t? Object.getOwnPropertySymbols(target).filter(function(symbol) {\n\t\t\treturn target.propertyIsEnumerable(symbol)\n\t\t})\n\t\t: []\n}\n\nfunction getKeys(target) {\n\treturn Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))\n}\n\nfunction propertyIsOnObject(object, property) {\n\ttry {\n\t\treturn property in object\n\t} catch(_) {\n\t\treturn false\n\t}\n}\n\n// Protects from prototype poisoning and unexpected merging up the prototype chain.\nfunction propertyIsUnsafe(target, key) {\n\treturn propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,\n\t\t&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,\n\t\t\t&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.\n}\n\nfunction mergeObject(target, source, options) {\n\tvar destination = {};\n\tif (options.isMergeableObject(target)) {\n\t\tgetKeys(target).forEach(function(key) {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\n\t\t});\n\t}\n\tgetKeys(source).forEach(function(key) {\n\t\tif (propertyIsUnsafe(target, key)) {\n\t\t\treturn\n\t\t}\n\n\t\tif (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {\n\t\t\tdestination[key] = getMergeFunction(key, options)(target[key], source[key], options);\n\t\t} else {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\n\t\t}\n\t});\n\treturn destination\n}\n\nfunction deepmerge(target, source, options) {\n\toptions = options || {};\n\toptions.arrayMerge = options.arrayMerge || defaultArrayMerge;\n\toptions.isMergeableObject = options.isMergeableObject || isMergeableObject;\n\t// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()\n\t// implementations can use it. The caller may not replace it.\n\toptions.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;\n\n\tvar sourceIsArray = Array.isArray(source);\n\tvar targetIsArray = Array.isArray(target);\n\tvar sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n\n\tif (!sourceAndTargetTypesMatch) {\n\t\treturn cloneUnlessOtherwiseSpecified(source, options)\n\t} else if (sourceIsArray) {\n\t\treturn options.arrayMerge(target, source, options)\n\t} else {\n\t\treturn mergeObject(target, source, options)\n\t}\n}\n\ndeepmerge.all = function deepmergeAll(array, options) {\n\tif (!Array.isArray(array)) {\n\t\tthrow new Error('first argument should be an array')\n\t}\n\n\treturn array.reduce(function(prev, next) {\n\t\treturn deepmerge(prev, next, options)\n\t}, {})\n};\n\nvar deepmerge_1 = deepmerge;\n\nmodule.exports = deepmerge_1;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGVlcG1lcmdlL2Rpc3QvY2pzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUUsSUFBSTtBQUNOOztBQUVBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RlZXBtZXJnZS9kaXN0L2Nqcy5qcz82ODZmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGlzTWVyZ2VhYmxlT2JqZWN0ID0gZnVuY3Rpb24gaXNNZXJnZWFibGVPYmplY3QodmFsdWUpIHtcblx0cmV0dXJuIGlzTm9uTnVsbE9iamVjdCh2YWx1ZSlcblx0XHQmJiAhaXNTcGVjaWFsKHZhbHVlKVxufTtcblxuZnVuY3Rpb24gaXNOb25OdWxsT2JqZWN0KHZhbHVlKSB7XG5cdHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCdcbn1cblxuZnVuY3Rpb24gaXNTcGVjaWFsKHZhbHVlKSB7XG5cdHZhciBzdHJpbmdWYWx1ZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG5cblx0cmV0dXJuIHN0cmluZ1ZhbHVlID09PSAnW29iamVjdCBSZWdFeHBdJ1xuXHRcdHx8IHN0cmluZ1ZhbHVlID09PSAnW29iamVjdCBEYXRlXSdcblx0XHR8fCBpc1JlYWN0RWxlbWVudCh2YWx1ZSlcbn1cblxuLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9ibG9iL2I1YWM5NjNmYjc5MWQxMjk4ZTdmMzk2MjM2MzgzYmM5NTVmOTE2YzEvc3JjL2lzb21vcnBoaWMvY2xhc3NpYy9lbGVtZW50L1JlYWN0RWxlbWVudC5qcyNMMjEtTDI1XG52YXIgY2FuVXNlU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yO1xudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IGNhblVzZVN5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSA6IDB4ZWFjNztcblxuZnVuY3Rpb24gaXNSZWFjdEVsZW1lbnQodmFsdWUpIHtcblx0cmV0dXJuIHZhbHVlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEVcbn1cblxuZnVuY3Rpb24gZW1wdHlUYXJnZXQodmFsKSB7XG5cdHJldHVybiBBcnJheS5pc0FycmF5KHZhbCkgPyBbXSA6IHt9XG59XG5cbmZ1bmN0aW9uIGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKHZhbHVlLCBvcHRpb25zKSB7XG5cdHJldHVybiAob3B0aW9ucy5jbG9uZSAhPT0gZmFsc2UgJiYgb3B0aW9ucy5pc01lcmdlYWJsZU9iamVjdCh2YWx1ZSkpXG5cdFx0PyBkZWVwbWVyZ2UoZW1wdHlUYXJnZXQodmFsdWUpLCB2YWx1ZSwgb3B0aW9ucylcblx0XHQ6IHZhbHVlXG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRBcnJheU1lcmdlKHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG5cdHJldHVybiB0YXJnZXQuY29uY2F0KHNvdXJjZSkubWFwKGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHRyZXR1cm4gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQoZWxlbWVudCwgb3B0aW9ucylcblx0fSlcbn1cblxuZnVuY3Rpb24gZ2V0TWVyZ2VGdW5jdGlvbihrZXksIG9wdGlvbnMpIHtcblx0aWYgKCFvcHRpb25zLmN1c3RvbU1lcmdlKSB7XG5cdFx0cmV0dXJuIGRlZXBtZXJnZVxuXHR9XG5cdHZhciBjdXN0b21NZXJnZSA9IG9wdGlvbnMuY3VzdG9tTWVyZ2Uoa2V5KTtcblx0cmV0dXJuIHR5cGVvZiBjdXN0b21NZXJnZSA9PT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbU1lcmdlIDogZGVlcG1lcmdlXG59XG5cbmZ1bmN0aW9uIGdldEVudW1lcmFibGVPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSB7XG5cdHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzXG5cdFx0PyBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkuZmlsdGVyKGZ1bmN0aW9uKHN5bWJvbCkge1xuXHRcdFx0cmV0dXJuIHRhcmdldC5wcm9wZXJ0eUlzRW51bWVyYWJsZShzeW1ib2wpXG5cdFx0fSlcblx0XHQ6IFtdXG59XG5cbmZ1bmN0aW9uIGdldEtleXModGFyZ2V0KSB7XG5cdHJldHVybiBPYmplY3Qua2V5cyh0YXJnZXQpLmNvbmNhdChnZXRFbnVtZXJhYmxlT3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkpXG59XG5cbmZ1bmN0aW9uIHByb3BlcnR5SXNPbk9iamVjdChvYmplY3QsIHByb3BlcnR5KSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHByb3BlcnR5IGluIG9iamVjdFxuXHR9IGNhdGNoKF8pIHtcblx0XHRyZXR1cm4gZmFsc2Vcblx0fVxufVxuXG4vLyBQcm90ZWN0cyBmcm9tIHByb3RvdHlwZSBwb2lzb25pbmcgYW5kIHVuZXhwZWN0ZWQgbWVyZ2luZyB1cCB0aGUgcHJvdG90eXBlIGNoYWluLlxuZnVuY3Rpb24gcHJvcGVydHlJc1Vuc2FmZSh0YXJnZXQsIGtleSkge1xuXHRyZXR1cm4gcHJvcGVydHlJc09uT2JqZWN0KHRhcmdldCwga2V5KSAvLyBQcm9wZXJ0aWVzIGFyZSBzYWZlIHRvIG1lcmdlIGlmIHRoZXkgZG9uJ3QgZXhpc3QgaW4gdGhlIHRhcmdldCB5ZXQsXG5cdFx0JiYgIShPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbCh0YXJnZXQsIGtleSkgLy8gdW5zYWZlIGlmIHRoZXkgZXhpc3QgdXAgdGhlIHByb3RvdHlwZSBjaGFpbixcblx0XHRcdCYmIE9iamVjdC5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHRhcmdldCwga2V5KSkgLy8gYW5kIGFsc28gdW5zYWZlIGlmIHRoZXkncmUgbm9uZW51bWVyYWJsZS5cbn1cblxuZnVuY3Rpb24gbWVyZ2VPYmplY3QodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcblx0dmFyIGRlc3RpbmF0aW9uID0ge307XG5cdGlmIChvcHRpb25zLmlzTWVyZ2VhYmxlT2JqZWN0KHRhcmdldCkpIHtcblx0XHRnZXRLZXlzKHRhcmdldCkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcblx0XHRcdGRlc3RpbmF0aW9uW2tleV0gPSBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZCh0YXJnZXRba2V5XSwgb3B0aW9ucyk7XG5cdFx0fSk7XG5cdH1cblx0Z2V0S2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG5cdFx0aWYgKHByb3BlcnR5SXNVbnNhZmUodGFyZ2V0LCBrZXkpKSB7XG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cblx0XHRpZiAocHJvcGVydHlJc09uT2JqZWN0KHRhcmdldCwga2V5KSAmJiBvcHRpb25zLmlzTWVyZ2VhYmxlT2JqZWN0KHNvdXJjZVtrZXldKSkge1xuXHRcdFx0ZGVzdGluYXRpb25ba2V5XSA9IGdldE1lcmdlRnVuY3Rpb24oa2V5LCBvcHRpb25zKSh0YXJnZXRba2V5XSwgc291cmNlW2tleV0sIG9wdGlvbnMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkZXN0aW5hdGlvbltrZXldID0gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQoc291cmNlW2tleV0sIG9wdGlvbnMpO1xuXHRcdH1cblx0fSk7XG5cdHJldHVybiBkZXN0aW5hdGlvblxufVxuXG5mdW5jdGlvbiBkZWVwbWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdG9wdGlvbnMuYXJyYXlNZXJnZSA9IG9wdGlvbnMuYXJyYXlNZXJnZSB8fCBkZWZhdWx0QXJyYXlNZXJnZTtcblx0b3B0aW9ucy5pc01lcmdlYWJsZU9iamVjdCA9IG9wdGlvbnMuaXNNZXJnZWFibGVPYmplY3QgfHwgaXNNZXJnZWFibGVPYmplY3Q7XG5cdC8vIGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkIGlzIGFkZGVkIHRvIGBvcHRpb25zYCBzbyB0aGF0IGN1c3RvbSBhcnJheU1lcmdlKClcblx0Ly8gaW1wbGVtZW50YXRpb25zIGNhbiB1c2UgaXQuIFRoZSBjYWxsZXIgbWF5IG5vdCByZXBsYWNlIGl0LlxuXHRvcHRpb25zLmNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkID0gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQ7XG5cblx0dmFyIHNvdXJjZUlzQXJyYXkgPSBBcnJheS5pc0FycmF5KHNvdXJjZSk7XG5cdHZhciB0YXJnZXRJc0FycmF5ID0gQXJyYXkuaXNBcnJheSh0YXJnZXQpO1xuXHR2YXIgc291cmNlQW5kVGFyZ2V0VHlwZXNNYXRjaCA9IHNvdXJjZUlzQXJyYXkgPT09IHRhcmdldElzQXJyYXk7XG5cblx0aWYgKCFzb3VyY2VBbmRUYXJnZXRUeXBlc01hdGNoKSB7XG5cdFx0cmV0dXJuIGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKHNvdXJjZSwgb3B0aW9ucylcblx0fSBlbHNlIGlmIChzb3VyY2VJc0FycmF5KSB7XG5cdFx0cmV0dXJuIG9wdGlvbnMuYXJyYXlNZXJnZSh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucylcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gbWVyZ2VPYmplY3QodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpXG5cdH1cbn1cblxuZGVlcG1lcmdlLmFsbCA9IGZ1bmN0aW9uIGRlZXBtZXJnZUFsbChhcnJheSwgb3B0aW9ucykge1xuXHRpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXkpKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdmaXJzdCBhcmd1bWVudCBzaG91bGQgYmUgYW4gYXJyYXknKVxuXHR9XG5cblx0cmV0dXJuIGFycmF5LnJlZHVjZShmdW5jdGlvbihwcmV2LCBuZXh0KSB7XG5cdFx0cmV0dXJuIGRlZXBtZXJnZShwcmV2LCBuZXh0LCBvcHRpb25zKVxuXHR9LCB7fSlcbn07XG5cbnZhciBkZWVwbWVyZ2VfMSA9IGRlZXBtZXJnZTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWVwbWVyZ2VfMTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/deepmerge/dist/cjs.js\n");

/***/ }),

/***/ "./resources/sass/app.scss":
/*!*********************************!*\
  !*** ./resources/sass/app.scss ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvc2Fzcy9hcHAuc2Nzcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvc2Fzcy9hcHAuc2Nzcz82NWU2Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/sass/app.scss\n");

/***/ }),

/***/ "./node_modules/mini-css-extract-plugin/dist/loader.js??clonedRuleSet-9.use[0]!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/components/Loading.vue?vue&type=style&index=0&id=6ca9e6be&scoped=true&lang=css&":
/*!*****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/mini-css-extract-plugin/dist/loader.js??clonedRuleSet-9.use[0]!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/components/Loading.vue?vue&type=style&index=0&id=6ca9e6be&scoped=true&lang=css& ***!
  \*****************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vZGlzdC9sb2FkZXIuanM/P2Nsb25lZFJ1bGVTZXQtOS51c2VbMF0hLi9ub2RlX21vZHVsZXMvbGFyYXZlbC1taXgvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P2Nsb25lZFJ1bGVTZXQtOS51c2VbMV0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvZGlzdC9janMuanM/P2Nsb25lZFJ1bGVTZXQtOS51c2VbMl0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3Jlc291cmNlcy9qcy9jb21wb25lbnRzL0xvYWRpbmcudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9NmNhOWU2YmUmc2NvcGVkPXRydWUmbGFuZz1jc3MmLmpzIiwibWFwcGluZ3MiOiI7QUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9qcy9jb21wb25lbnRzL0xvYWRpbmcudnVlPzM2MDEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQge307Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/mini-css-extract-plugin/dist/loader.js??clonedRuleSet-9.use[0]!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/components/Loading.vue?vue&type=style&index=0&id=6ca9e6be&scoped=true&lang=css&\n");

/***/ }),

/***/ "./node_modules/vue-js-modal/dist/index.js":
/*!*************************************************!*\
  !*** ./node_modules/vue-js-modal/dist/index.js ***!
  \*************************************************/
/***/ ((module) => {

eval("!function(t,e){ true?module.exports=e():0}(window,function(){return i={},o.m=n=[function(t,e,n){var i=n(7);\"string\"==typeof i&&(i=[[t.i,i,\"\"]]),i.locals&&(t.exports=i.locals);(0,n(4).default)(\"d763679c\",i,!1,{})},function(t,e,n){var i=n(10);\"string\"==typeof i&&(i=[[t.i,i,\"\"]]),i.locals&&(t.exports=i.locals);(0,n(4).default)(\"6b9cc0e0\",i,!1,{})},function(t,e,n){var i=n(12);\"string\"==typeof i&&(i=[[t.i,i,\"\"]]),i.locals&&(t.exports=i.locals);(0,n(4).default)(\"663c004e\",i,!1,{})},function(t,e){t.exports=function(n){var s=[];return s.toString=function(){return this.map(function(t){var e=function(t,e){var n=t[1]||\"\",i=t[3];if(!i)return n;if(e&&\"function\"==typeof btoa){var o=function(t){return\"/*# sourceMappingURL=data:application/json;charset=utf-8;base64,\"+btoa(unescape(encodeURIComponent(JSON.stringify(t))))+\" */\"}(i),r=i.sources.map(function(t){return\"/*# sourceURL=\"+i.sourceRoot+t+\" */\"});return[n].concat(r).concat([o]).join(\"\\n\")}return[n].join(\"\\n\")}(t,n);return t[2]?\"@media \"+t[2]+\"{\"+e+\"}\":e}).join(\"\")},s.i=function(t,e){\"string\"==typeof t&&(t=[[null,t,\"\"]]);for(var n={},i=0;i<this.length;i++){var o=this[i][0];\"number\"==typeof o&&(n[o]=!0)}for(i=0;i<t.length;i++){var r=t[i];\"number\"==typeof r[0]&&n[r[0]]||(e&&!r[2]?r[2]=e:e&&(r[2]=\"(\"+r[2]+\") and (\"+e+\")\"),s.push(r))}},s}},function(t,e,n){\"use strict\";function l(t,e){for(var n=[],i={},o=0;o<e.length;o++){var r=e[o],s=r[0],a={id:t+\":\"+o,css:r[1],media:r[2],sourceMap:r[3]};i[s]?i[s].parts.push(a):n.push(i[s]={id:s,parts:[a]})}return n}n.r(e),n.d(e,\"default\",function(){return v});var i=\"undefined\"!=typeof document;if(\"undefined\"!=typeof DEBUG&&DEBUG&&!i)throw new Error(\"vue-style-loader cannot be used in a non-browser environment. Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.\");var u={},o=i&&(document.head||document.getElementsByTagName(\"head\")[0]),r=null,s=0,c=!1,a=function(){},d=null,h=\"data-vue-ssr-id\",f=\"undefined\"!=typeof navigator&&/msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());function v(s,t,e,n){c=e,d=n||{};var a=l(s,t);return p(a),function(t){for(var e=[],n=0;n<a.length;n++){var i=a[n];(o=u[i.id]).refs--,e.push(o)}t?p(a=l(s,t)):a=[];for(n=0;n<e.length;n++){var o;if(0===(o=e[n]).refs){for(var r=0;r<o.parts.length;r++)o.parts[r]();delete u[o.id]}}}}function p(t){for(var e=0;e<t.length;e++){var n=t[e],i=u[n.id];if(i){i.refs++;for(var o=0;o<i.parts.length;o++)i.parts[o](n.parts[o]);for(;o<n.parts.length;o++)i.parts.push(b(n.parts[o]));i.parts.length>n.parts.length&&(i.parts.length=n.parts.length)}else{var r=[];for(o=0;o<n.parts.length;o++)r.push(b(n.parts[o]));u[n.id]={id:n.id,refs:1,parts:r}}}}function m(){var t=document.createElement(\"style\");return t.type=\"text/css\",o.appendChild(t),t}function b(e){var n,i,t=document.querySelector(\"style[\"+h+'~=\"'+e.id+'\"]');if(t){if(c)return a;t.parentNode.removeChild(t)}if(f){var o=s++;t=r=r||m(),n=w.bind(null,t,o,!1),i=w.bind(null,t,o,!0)}else t=m(),n=function(t,e){var n=e.css,i=e.media,o=e.sourceMap;i&&t.setAttribute(\"media\",i);d.ssrId&&t.setAttribute(h,e.id);o&&(n+=\"\\n/*# sourceURL=\"+o.sources[0]+\" */\",n+=\"\\n/*# sourceMappingURL=data:application/json;base64,\"+btoa(unescape(encodeURIComponent(JSON.stringify(o))))+\" */\");if(t.styleSheet)t.styleSheet.cssText=n;else{for(;t.firstChild;)t.removeChild(t.firstChild);t.appendChild(document.createTextNode(n))}}.bind(null,t),i=function(){t.parentNode.removeChild(t)};return n(e),function(t){if(t){if(t.css===e.css&&t.media===e.media&&t.sourceMap===e.sourceMap)return;n(e=t)}else i()}}var g,y=(g=[],function(t,e){return g[t]=e,g.filter(Boolean).join(\"\\n\")});function w(t,e,n,i){var o=n?\"\":i.css;if(t.styleSheet)t.styleSheet.cssText=y(e,o);else{var r=document.createTextNode(o),s=t.childNodes;s[e]&&t.removeChild(s[e]),s.length?t.insertBefore(r,s[e]):t.appendChild(r)}}},function(t,z,e){\"use strict\";(function(t){var i=function(){if(\"undefined\"!=typeof Map)return Map;function i(t,n){var i=-1;return t.some(function(t,e){return t[0]===n&&(i=e,!0)}),i}return Object.defineProperty(t.prototype,\"size\",{get:function(){return this.__entries__.length},enumerable:!0,configurable:!0}),t.prototype.get=function(t){var e=i(this.__entries__,t),n=this.__entries__[e];return n&&n[1]},t.prototype.set=function(t,e){var n=i(this.__entries__,t);~n?this.__entries__[n][1]=e:this.__entries__.push([t,e])},t.prototype.delete=function(t){var e=this.__entries__,n=i(e,t);~n&&e.splice(n,1)},t.prototype.has=function(t){return!!~i(this.__entries__,t)},t.prototype.clear=function(){this.__entries__.splice(0)},t.prototype.forEach=function(t,e){void 0===e&&(e=null);for(var n=0,i=this.__entries__;n<i.length;n++){var o=i[n];t.call(e,o[1],o[0])}},t;function t(){this.__entries__=[]}}(),n=\"undefined\"!=typeof window&&\"undefined\"!=typeof document&&window.document===document,e=void 0!==t&&t.Math===Math?t:\"undefined\"!=typeof self&&self.Math===Math?self:\"undefined\"!=typeof window&&window.Math===Math?window:Function(\"return this\")(),l=\"function\"==typeof requestAnimationFrame?requestAnimationFrame.bind(e):function(t){return setTimeout(function(){return t(Date.now())},1e3/60)},u=2;var o=[\"top\",\"right\",\"bottom\",\"left\",\"width\",\"height\",\"size\",\"weight\"],r=\"undefined\"!=typeof MutationObserver,s=(a.prototype.addObserver=function(t){~this.observers_.indexOf(t)||this.observers_.push(t),this.connected_||this.connect_()},a.prototype.removeObserver=function(t){var e=this.observers_,n=e.indexOf(t);~n&&e.splice(n,1),!e.length&&this.connected_&&this.disconnect_()},a.prototype.refresh=function(){this.updateObservers_()&&this.refresh()},a.prototype.updateObservers_=function(){var t=this.observers_.filter(function(t){return t.gatherActive(),t.hasActive()});return t.forEach(function(t){return t.broadcastActive()}),0<t.length},a.prototype.connect_=function(){n&&!this.connected_&&(document.addEventListener(\"transitionend\",this.onTransitionEnd_),window.addEventListener(\"resize\",this.refresh),r?(this.mutationsObserver_=new MutationObserver(this.refresh),this.mutationsObserver_.observe(document,{attributes:!0,childList:!0,characterData:!0,subtree:!0})):(document.addEventListener(\"DOMSubtreeModified\",this.refresh),this.mutationEventsAdded_=!0),this.connected_=!0)},a.prototype.disconnect_=function(){n&&this.connected_&&(document.removeEventListener(\"transitionend\",this.onTransitionEnd_),window.removeEventListener(\"resize\",this.refresh),this.mutationsObserver_&&this.mutationsObserver_.disconnect(),this.mutationEventsAdded_&&document.removeEventListener(\"DOMSubtreeModified\",this.refresh),this.mutationsObserver_=null,this.mutationEventsAdded_=!1,this.connected_=!1)},a.prototype.onTransitionEnd_=function(t){var e=t.propertyName,n=void 0===e?\"\":e;o.some(function(t){return!!~n.indexOf(t)})&&this.refresh()},a.getInstance=function(){return this.instance_||(this.instance_=new a),this.instance_},a.instance_=null,a);function a(){function t(){r&&(r=!1,i()),s&&n()}function e(){l(t)}function n(){var t=Date.now();if(r){if(t-a<u)return;s=!0}else s=!(r=!0),setTimeout(e,o);a=t}var i,o,r,s,a;this.connected_=!1,this.mutationEventsAdded_=!1,this.mutationsObserver_=null,this.observers_=[],this.onTransitionEnd_=this.onTransitionEnd_.bind(this),this.refresh=(i=this.refresh.bind(this),s=r=!(o=20),a=0,n)}var c=function(t,e){for(var n=0,i=Object.keys(e);n<i.length;n++){var o=i[n];Object.defineProperty(t,o,{value:e[o],enumerable:!1,writable:!1,configurable:!0})}return t},h=function(t){return t&&t.ownerDocument&&t.ownerDocument.defaultView||e},f=g(0,0,0,0);function v(t){return parseFloat(t)||0}function p(n){for(var t=[],e=1;e<arguments.length;e++)t[e-1]=arguments[e];return t.reduce(function(t,e){return t+v(n[\"border-\"+e+\"-width\"])},0)}function d(t){var e=t.clientWidth,n=t.clientHeight;if(!e&&!n)return f;var i,o=h(t).getComputedStyle(t),r=function(t){for(var e={},n=0,i=[\"top\",\"right\",\"bottom\",\"left\"];n<i.length;n++){var o=i[n],r=t[\"padding-\"+o];e[o]=v(r)}return e}(o),s=r.left+r.right,a=r.top+r.bottom,l=v(o.width),u=v(o.height);if(\"border-box\"===o.boxSizing&&(Math.round(l+s)!==e&&(l-=p(o,\"left\",\"right\")+s),Math.round(u+a)!==n&&(u-=p(o,\"top\",\"bottom\")+a)),(i=t)!==h(i).document.documentElement){var c=Math.round(l+s)-e,d=Math.round(u+a)-n;1!==Math.abs(c)&&(l-=c),1!==Math.abs(d)&&(u-=d)}return g(r.left,r.top,l,u)}var m=\"undefined\"!=typeof SVGGraphicsElement?function(t){return t instanceof h(t).SVGGraphicsElement}:function(t){return t instanceof h(t).SVGElement&&\"function\"==typeof t.getBBox};function b(t){return n?m(t)?g(0,0,(e=t.getBBox()).width,e.height):d(t):f;var e}function g(t,e,n,i){return{x:t,y:e,width:n,height:i}}var y=(w.prototype.isActive=function(){var t=b(this.target);return(this.contentRect_=t).width!==this.broadcastWidth||t.height!==this.broadcastHeight},w.prototype.broadcastRect=function(){var t=this.contentRect_;return this.broadcastWidth=t.width,this.broadcastHeight=t.height,t},w);function w(t){this.broadcastWidth=0,this.broadcastHeight=0,this.contentRect_=g(0,0,0,0),this.target=t}var _=function(t,e){var n,i,o,r,s,a,l,u=(i=(n=e).x,o=n.y,r=n.width,s=n.height,a=\"undefined\"!=typeof DOMRectReadOnly?DOMRectReadOnly:Object,l=Object.create(a.prototype),c(l,{x:i,y:o,width:r,height:s,top:o,right:i+r,bottom:s+o,left:i}),l);c(this,{target:t,contentRect:u})},E=(x.prototype.observe=function(t){if(!arguments.length)throw new TypeError(\"1 argument required, but only 0 present.\");if(\"undefined\"!=typeof Element&&Element instanceof Object){if(!(t instanceof h(t).Element))throw new TypeError('parameter 1 is not of type \"Element\".');var e=this.observations_;e.has(t)||(e.set(t,new y(t)),this.controller_.addObserver(this),this.controller_.refresh())}},x.prototype.unobserve=function(t){if(!arguments.length)throw new TypeError(\"1 argument required, but only 0 present.\");if(\"undefined\"!=typeof Element&&Element instanceof Object){if(!(t instanceof h(t).Element))throw new TypeError('parameter 1 is not of type \"Element\".');var e=this.observations_;e.has(t)&&(e.delete(t),e.size||this.controller_.removeObserver(this))}},x.prototype.disconnect=function(){this.clearActive(),this.observations_.clear(),this.controller_.removeObserver(this)},x.prototype.gatherActive=function(){var e=this;this.clearActive(),this.observations_.forEach(function(t){t.isActive()&&e.activeObservations_.push(t)})},x.prototype.broadcastActive=function(){if(this.hasActive()){var t=this.callbackCtx_,e=this.activeObservations_.map(function(t){return new _(t.target,t.broadcastRect())});this.callback_.call(t,e,t),this.clearActive()}},x.prototype.clearActive=function(){this.activeObservations_.splice(0)},x.prototype.hasActive=function(){return 0<this.activeObservations_.length},x);function x(t,e,n){if(this.activeObservations_=[],this.observations_=new i,\"function\"!=typeof t)throw new TypeError(\"The callback provided as parameter 1 is not a function.\");this.callback_=t,this.controller_=e,this.callbackCtx_=n}var T=new(\"undefined\"!=typeof WeakMap?WeakMap:i),O=function t(e){if(!(this instanceof t))throw new TypeError(\"Cannot call a class as a function.\");if(!arguments.length)throw new TypeError(\"1 argument required, but only 0 present.\");var n=s.getInstance(),i=new E(e,n,this);T.set(this,i)};[\"observe\",\"unobserve\",\"disconnect\"].forEach(function(e){O.prototype[e]=function(){var t;return(t=T.get(this))[e].apply(t,arguments)}});var S=void 0!==e.ResizeObserver?e.ResizeObserver:O;z.a=S}).call(this,e(8))},function(t,e,n){\"use strict\";var i=n(0);n.n(i).a},function(t,e,n){(t.exports=n(3)(!1)).push([t.i,\"\\n.vue-modal-top,\\n.vue-modal-bottom,\\n.vue-modal-left,\\n.vue-modal-right,\\n.vue-modal-topRight,\\n.vue-modal-topLeft,\\n.vue-modal-bottomLeft,\\n.vue-modal-bottomRight {\\n  display: block;\\n  overflow: hidden;\\n  position: absolute;\\n  background: transparent;\\n  z-index: 9999999;\\n}\\n.vue-modal-topRight,\\n.vue-modal-topLeft,\\n.vue-modal-bottomLeft,\\n.vue-modal-bottomRight {\\n  width: 12px;\\n  height: 12px;\\n}\\n.vue-modal-top {\\n  right: 12;\\n  top: 0;\\n  width: 100%;\\n  height: 12px;\\n  cursor: n-resize;\\n}\\n.vue-modal-bottom {\\n  left: 0;\\n  bottom: 0;\\n  width: 100%;\\n  height: 12px;\\n  cursor: s-resize;\\n}\\n.vue-modal-left {\\n  left: 0;\\n  top: 0;\\n  width: 12px;\\n  height: 100%;\\n  cursor: w-resize;\\n}\\n.vue-modal-right {\\n  right: 0;\\n  top: 0;\\n  width: 12px;\\n  height: 100%;\\n  cursor: e-resize;\\n}\\n.vue-modal-topRight {\\n  right: 0;\\n  top: 0;\\n  background: transparent;\\n  cursor: ne-resize;\\n}\\n.vue-modal-topLeft {\\n  left: 0;\\n  top: 0;\\n  cursor: nw-resize;\\n}\\n.vue-modal-bottomLeft {\\n  left: 0;\\n  bottom: 0;\\n  cursor: sw-resize;\\n}\\n.vue-modal-bottomRight {\\n  right: 0;\\n  bottom: 0;\\n  cursor: se-resize;\\n}\\n#vue-modal-triangle::after {\\n  display: block;\\n  position: absolute;\\n  content: '';\\n  background: transparent;\\n  left: 0;\\n  top: 0;\\n  width: 0;\\n  height: 0;\\n  border-bottom: 10px solid #ddd;\\n  border-left: 10px solid transparent;\\n}\\n#vue-modal-triangle.clicked::after {\\n  border-bottom: 10px solid #369be9;\\n}\\n\",\"\"])},function(t,e){var n;n=function(){return this}();try{n=n||new Function(\"return this\")()}catch(t){\"object\"==typeof window&&(n=window)}t.exports=n},function(t,e,n){\"use strict\";var i=n(1);n.n(i).a},function(t,e,n){(t.exports=n(3)(!1)).push([t.i,\"\\n.vm--block-scroll {\\n  overflow: hidden;\\n  width: 100vw;\\n}\\n.vm--container {\\n  position: fixed;\\n  box-sizing: border-box;\\n  left: 0;\\n  top: 0;\\n  width: 100%;\\n  height: 100vh;\\n  z-index: 999;\\n}\\n.vm--overlay {\\n  position: fixed;\\n  box-sizing: border-box;\\n  left: 0;\\n  top: 0;\\n  width: 100%;\\n  height: 100vh;\\n  background: rgba(0, 0, 0, 0.2);\\n  /* z-index: 999; */\\n  opacity: 1;\\n}\\n.vm--container.scrollable {\\n  height: 100%;\\n  min-height: 100vh;\\n  overflow-y: auto;\\n  -webkit-overflow-scrolling: touch;\\n}\\n.vm--modal {\\n  position: relative;\\n  overflow: hidden;\\n  box-sizing: border-box;\\n\\n  background-color: white;\\n  border-radius: 3px;\\n  box-shadow: 0 20px 60px -2px rgba(27, 33, 58, 0.4);\\n}\\n.vm--container.scrollable .vm--modal {\\n  margin-bottom: 2px;\\n}\\n.vm--top-right-slot {\\n  display: block;\\n  position: absolute;\\n  right: 0;\\n  top: 0;\\n}\\n.vm-transition--overlay-enter-active,\\n.vm-transition--overlay-leave-active {\\n  transition: all 50ms;\\n}\\n.vm-transition--overlay-enter,\\n.vm-transition--overlay-leave-active {\\n  opacity: 0;\\n}\\n.vm-transition--modal-enter-active,\\n.vm-transition--modal-leave-active {\\n  transition: all 400ms;\\n}\\n.vm-transition--modal-enter,\\n.vm-transition--modal-leave-active {\\n  opacity: 0;\\n  transform: translateY(-20px);\\n}\\n.vm-transition--default-enter-active,\\n.vm-transition--default-leave-active {\\n  transition: all 2ms;\\n}\\n.vm-transition--default-enter,\\n.vm-transition--default-leave-active {\\n  opacity: 0;\\n}\\n\",\"\"])},function(t,e,n){\"use strict\";var i=n(2);n.n(i).a},function(t,e,n){(t.exports=n(3)(!1)).push([t.i,\"\\n.vue-dialog {\\n  font-size: 14px;\\n}\\n.vue-dialog div {\\n  box-sizing: border-box;\\n}\\n.vue-dialog-content {\\n  flex: 1 0 auto;\\n  width: 100%;\\n  padding: 14px;\\n}\\n.vue-dialog-content-title {\\n  font-weight: 600;\\n  padding-bottom: 14px;\\n}\\n.vue-dialog-buttons {\\n  display: flex;\\n  flex: 0 1 auto;\\n  width: 100%;\\n  border-top: 1px solid #eee;\\n}\\n.vue-dialog-buttons-none {\\n  width: 100%;\\n  padding-bottom: 14px;\\n}\\n.vue-dialog-button {\\n  font-size: inherit;\\n  background: transparent;\\n  padding: 0;\\n  margin: 0;\\n  border: 0;\\n  cursor: pointer;\\n  box-sizing: border-box;\\n  line-height: 40px;\\n  height: 40px;\\n  color: inherit;\\n  font: inherit;\\n  outline: none;\\n}\\n.vue-dialog-button:hover {\\n  background: #f9f9f9;\\n}\\n.vue-dialog-button:active {\\n  background: #f3f3f3;\\n}\\n.vue-dialog-button:not(:first-of-type) {\\n  border-left: 1px solid #eee;\\n}\\n\",\"\"])},function(t,e,n){\"use strict\";n.r(e),n.d(e,\"Modal\",function(){return W}),n.d(e,\"Dialog\",function(){return X}),n.d(e,\"version\",function(){return J});function i(){var e=this,t=e.$createElement,n=e._self._c||t;return e.visible?n(\"div\",{class:e.containerClass},[n(\"transition\",{attrs:{name:e.guaranteedOverlayTransition},on:{\"before-enter\":e.beforeOverlayTransitionEnter,\"after-enter\":e.afterOverlayTransitionEnter,\"before-leave\":e.beforeOverlayTransitionLeave,\"after-leave\":e.afterOverlayTransitionLeave}},[e.visibility.overlay?n(\"div\",{staticClass:\"vm--overlay\",attrs:{\"data-modal\":e.name,\"aria-expanded\":e.visibility.overlay.toString()},on:{click:function(t){return t.target!==t.currentTarget?null:(t.stopPropagation(),e.onOverlayClick(t))}}},[n(\"div\",{staticClass:\"vm--top-right-slot\"},[e._t(\"top-right\")],2)]):e._e()]),e._v(\" \"),n(\"transition\",{attrs:{name:e.guaranteedModalTransition},on:{\"before-enter\":e.beforeModalTransitionEnter,\"after-enter\":e.afterModalTransitionEnter,\"before-leave\":e.beforeModalTransitionLeave,\"after-leave\":e.afterModalTransitionLeave}},[e.visibility.modal?n(\"div\",{ref:\"modal\",class:e.modalClass,style:e.modalStyle,attrs:{\"aria-expanded\":e.visibility.modal.toString(),role:\"dialog\",\"aria-modal\":\"true\"}},[e._t(\"default\"),e._v(\" \"),e.resizable&&!e.isAutoHeight?n(\"resizer\",{attrs:{\"min-width\":e.minWidth,\"min-height\":e.minHeight,\"max-width\":e.maxWidth,\"max-height\":e.maxHeight,\"viewport-height\":e.viewportHeight,\"viewport-width\":e.viewportWidth,\"resize-indicator\":e.resizeIndicator,\"resize-edges\":e.resizeEdges},on:{resize:e.onModalResize}}):e._e()],2):e._e()])],1):e._e()}function o(){var t=this,e=t.$createElement,n=t._self._c||e;return n(\"div\",[this.resizeEdges.includes(\"t\")?n(\"div\",{staticClass:\"vue-modal-top\"}):t._e(),t._v(\" \"),this.resizeEdges.includes(\"b\")?n(\"div\",{staticClass:\"vue-modal-bottom\"}):t._e(),t._v(\" \"),this.resizeEdges.includes(\"l\")?n(\"div\",{staticClass:\"vue-modal-left\"}):t._e(),t._v(\" \"),this.resizeEdges.includes(\"r\")?n(\"div\",{staticClass:\"vue-modal-right\"}):t._e(),t._v(\" \"),this.resizeEdges.includes(\"tr\")?n(\"div\",{staticClass:\"vue-modal-topRight\"}):t._e(),t._v(\" \"),this.resizeEdges.includes(\"tl\")?n(\"div\",{staticClass:\"vue-modal-topLeft\"}):t._e(),t._v(\" \"),this.resizeEdges.includes(\"br\")?n(\"div\",{class:t.className,attrs:{id:t.getID}}):t._e(),t._v(\" \"),this.resizeEdges.includes(\"bl\")?n(\"div\",{staticClass:\"vue-modal-bottomLeft\"}):t._e()])}o._withStripped=i._withStripped=!0;function h(t,e,n){return n<t?t:e<n?e:n}function r(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function s(t,e){return function(t){if(Array.isArray(t))return t}(t)||function(t,e){var n=[],i=!0,o=!1,r=void 0;try{for(var s,a=t[Symbol.iterator]();!(i=(s=a.next()).done)&&(n.push(s.value),!e||n.length!==e);i=!0);}catch(t){o=!0,r=t}finally{try{i||null==a.return||a.return()}finally{if(o)throw r}}return n}(t,e)||function(){throw new TypeError(\"Invalid attempt to destructure non-iterable instance\")}()}function u(){var t=window.innerWidth,e=document.documentElement.clientWidth;return t&&e?Math.min(t,e):e||t}function a(t){return t.split(\";\").map(function(t){return t.trim()}).filter(Boolean).map(function(t){return t.split(\":\")}).reduce(function(t,e){var n=s(e,2);return function(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{},i=Object.keys(n);\"function\"==typeof Object.getOwnPropertySymbols&&(i=i.concat(Object.getOwnPropertySymbols(n).filter(function(t){return Object.getOwnPropertyDescriptor(n,t).enumerable}))),i.forEach(function(t){r(e,t,n[t])})}return e}({},t,r({},n[0],n[1]))},{})}function f(t){return t.touches&&0<t.touches.length?t.touches[0]:t}var v=[\"INPUT\",\"TEXTAREA\",\"SELECT\"],c=function(t){var e=0<arguments.length&&void 0!==t?t:0;return function(){return(e++).toString()}}(),l={name:\"VueJsModalResizer\",props:{minHeight:{type:Number,default:0},minWidth:{type:Number,default:0},maxWidth:{type:Number,default:Number.MAX_SAFE_INTEGER},maxHeight:{type:Number,default:Number.MAX_SAFE_INTEGER},viewportWidth:{type:Number,required:!0},viewportHeight:{type:Number,required:!0},resizeIndicator:{type:Boolean,default:!0},resizeEdges:{type:Array,required:!0}},data:function(){return{clicked:!1,targetClass:\"\",size:{},initialX:0,initialY:0}},mounted:function(){this.$el.addEventListener(\"mousedown\",this.start,!1)},computed:{className:function(){return[\"vue-modal-bottomRight\",{clicked:this.clicked}]},getID:function(){return this.resizeIndicator?\"vue-modal-triangle\":\"\"}},methods:{start:function(t){this.targetClass=t.target.className,this.clicked=!0,this.initialX=t.clientX,this.initialY=t.clientY,window.addEventListener(\"mousemove\",this.mousemove,!1),window.addEventListener(\"mouseup\",this.stop,!1),t.stopPropagation(),t.preventDefault()},stop:function(){this.clicked=!1,this.clicked=!1,this.targetClass=\"\",this.initialX=0,this.initialY=0,window.removeEventListener(\"mousemove\",this.mousemove,!1),window.removeEventListener(\"mouseup\",this.stop,!1),this.$emit(\"resize-stop\",{element:this.$el.parentElement,size:this.size})},mousemove:function(t){this.resize(t)},resize:function(t){var e=this.$el.parentElement,n=t.clientX,i=t.clientY,o=parseInt(e.style.width.replace(\"px\",\"\")),r=parseInt(e.style.height.replace(\"px\",\"\"));if(!(t.clientX>this.viewportWidth||t.clientX<0)&&!(t.clientY>this.viewportHeight||t.clientY<0)&&e){switch(this.targetClass){case\"vue-modal-right\":n-=e.offsetLeft,i=r;break;case\"vue-modal-left\":i=r,n=o+(this.initialX-t.clientX);break;case\"vue-modal-top\":n=o,i=r+(this.initialY-t.clientY);break;case\"vue-modal-bottom\":n=o,i-=e.offsetTop;break;case\"vue-modal-bottomRight\":n-=e.offsetLeft,i-=e.offsetTop;break;case\"vue-modal-topRight\":n-=e.offsetLeft,i=r+(this.initialY-t.clientY);break;case\"vue-modal-bottomLeft\":n=o+(this.initialX-t.clientX),i-=e.offsetTop;break;case\"vue-modal-topLeft\":n=o+(this.initialX-t.clientX),i=r+(this.initialY-t.clientY);break;default:console.error(\"Incorrrect/no resize direction.\")}var s=Math.min(u(),this.maxWidth),a=Math.min(window.innerHeight,this.maxHeight);n=h(this.minWidth,s,n),i=h(this.minHeight,a,i),this.initialX=t.clientX,this.initialY=t.clientY,this.size={width:n,height:i};var l={width:n-o,height:i-r};e.style.width=n+\"px\",e.style.height=i+\"px\",this.$emit(\"resize\",{element:e,size:this.size,direction:this.targetClass,dimGrowth:l})}}}};n(6);function d(t,e,n,i,o,r,s,a){var l,u=\"function\"==typeof t?t.options:t;if(e&&(u.render=e,u.staticRenderFns=n,u._compiled=!0),i&&(u.functional=!0),r&&(u._scopeId=\"data-v-\"+r),s?(l=function(t){(t=t||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||\"undefined\"==typeof __VUE_SSR_CONTEXT__||(t=__VUE_SSR_CONTEXT__),o&&o.call(this,t),t&&t._registeredComponents&&t._registeredComponents.add(s)},u._ssrRegister=l):o&&(l=a?function(){o.call(this,this.$root.$options.shadowRoot)}:o),l)if(u.functional){u._injectStyles=l;var c=u.render;u.render=function(t,e){return l.call(e),c(t,e)}}else{var d=u.beforeCreate;u.beforeCreate=d?[].concat(d,l):[l]}return{exports:t,options:u}}var p=d(l,o,[],!1,null,null,null);p.options.__file=\"src/components/Resizer.vue\";var m=p.exports;function b(t){return(b=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t})(t)}function g(t){switch(b(t)){case\"number\":return{type:\"px\",value:t};case\"string\":return function(e){if(\"auto\"===e)return{type:e,value:0};var t=_.find(function(t){return t.regexp.test(e)});return t?{type:t.name,value:parseFloat(e)}:{type:\"\",value:e}}(t);default:return{type:\"\",value:t}}}function y(t){if(\"string\"!=typeof t)return 0<=t;var e=g(t);return(\"%\"===e.type||\"px\"===e.type)&&0<e.value}var w=\"[-+]?[0-9]*.?[0-9]+\",_=[{name:\"px\",regexp:new RegExp(\"^\".concat(w,\"px$\"))},{name:\"%\",regexp:new RegExp(\"^\".concat(w,\"%$\"))},{name:\"px\",regexp:new RegExp(\"^\".concat(w,\"$\"))}],E=n(5),x=\"undefined\"!=typeof window&&window.ResizeObserver?ResizeObserver:E.a;function T(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,\"value\"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}function O(t){return function(t){if(Array.isArray(t)){for(var e=0,n=new Array(t.length);e<t.length;e++)n[e]=t[e];return n}}(t)||function(t){if(Symbol.iterator in Object(t)||\"[object Arguments]\"===Object.prototype.toString.call(t))return Array.from(t)}(t)||function(){throw new TypeError(\"Invalid attempt to spread non-iterable instance\")}()}function S(t){return e='button:not([disabled]), select:not([disabled]), a[href]:not([disabled]), area[href]:not([disabled]), [contentEditable=\"\"]:not([disabled]), [contentEditable=\"true\"]:not([disabled]), [contentEditable=\"TRUE\"]:not([disabled]), textarea:not([disabled]), iframe:not([disabled]), input:not([disabled]), summary:not([disabled]), [tabindex]:not([tabindex=\"-1\"])',O(t.querySelectorAll(e)||[]);var e}function z(t){return t==document.activeElement}var M=function(){function t(){!function(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}(this,t),this.root=null,this.elements=[],this.onKeyDown=this.onKeyDown.bind(this),this.enable=this.enable.bind(this),this.disable=this.disable.bind(this),this.firstElement=this.firstElement.bind(this),this.lastElement=this.lastElement.bind(this)}var e,n,i;return e=t,(n=[{key:\"lastElement\",value:function(){return this.elements[this.elements.length-1]||null}},{key:\"firstElement\",value:function(){return this.elements[0]||null}},{key:\"onKeyDown\",value:function(t){var e;if(\"Tab\"===(e=t).key||9===e.keyCode)return t.shiftKey&&z(this.firstElement())?(this.lastElement().focus(),void t.preventDefault()):!document.activeElement||z(this.lastElement())?(this.firstElement().focus(),void t.preventDefault()):void 0}},{key:\"enabled\",value:function(){return!!this.root}},{key:\"enable\",value:function(t){if(t){this.root=t,this.elements=S(this.root);var e=this.firstElement();e&&e.focus(),this.root.addEventListener(\"keydown\",this.onKeyDown)}}},{key:\"disable\",value:function(){this.root.removeEventListener(\"keydown\",this.onKeyDown),this.root=null}}])&&T(e.prototype,n),i&&T(e,i),t}();function L(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function k(t,e){return function(t){if(Array.isArray(t))return t}(t)||function(t,e){var n=[],i=!0,o=!1,r=void 0;try{for(var s,a=t[Symbol.iterator]();!(i=(s=a.next()).done)&&(n.push(s.value),!e||n.length!==e);i=!0);}catch(t){o=!0,r=t}finally{try{i||null==a.return||a.return()}finally{if(o)throw r}}return n}(t,e)||function(){throw new TypeError(\"Invalid attempt to destructure non-iterable instance\")}()}var R=\"vm-transition--default\",C=\"enter\",$=\"entering\",A=\"leave\",j=\"leavng\",H={name:\"VueJsModal\",props:{name:{required:!0,type:String},resizable:{type:Boolean,default:!1},resizeEdges:{default:function(){return[\"r\",\"br\",\"b\",\"bl\",\"l\",\"tl\",\"t\",\"tr\"]},validator:function(e){return[\"r\",\"br\",\"b\",\"bl\",\"l\",\"tl\",\"t\",\"tr\"].filter(function(t){return-1!==e.indexOf(t)}).length===e.length},type:Array},centerResize:{type:Boolean,default:!0},resizeIndicator:{type:Boolean,default:!0},adaptive:{type:Boolean,default:!1},draggable:{type:[Boolean,String],default:!1},scrollable:{type:Boolean,default:!1},focusTrap:{type:Boolean,default:!1},reset:{type:Boolean,default:!1},overlayTransition:{type:String,default:\"vm-transition--overlay\"},transition:{type:String,default:\"vm-transition--modal\"},clickToClose:{type:Boolean,default:!0},classes:{type:[String,Array],default:function(){return[]}},styles:{type:[String,Array,Object]},minWidth:{type:Number,default:0,validator:function(t){return 0<=t}},minHeight:{type:Number,default:0,validator:function(t){return 0<=t}},maxWidth:{type:Number,default:Number.MAX_SAFE_INTEGER},maxHeight:{type:Number,default:Number.MAX_SAFE_INTEGER},width:{type:[Number,String],default:600,validator:function(t){return\"auto\"===t||y(t)}},height:{type:[Number,String],default:300,validator:function(t){return\"auto\"===t||y(t)}},shiftX:{type:Number,default:.5,validator:function(t){return 0<=t&&t<=1}},shiftY:{type:Number,default:.5,validator:function(t){return 0<=t&&t<=1}}},components:{Resizer:m},data:function(){return{visible:!1,visibility:{modal:!1,overlay:!1},overlayTransitionState:null,modalTransitionState:null,shiftLeft:0,shiftTop:0,modal:{width:0,widthType:\"px\",height:0,heightType:\"px\",renderedHeight:0},viewportHeight:0,viewportWidth:0}},created:function(){this.setInitialSize()},beforeMount:function(){this.$modal.subscription.$on(\"toggle\",this.onToggle),window.addEventListener(\"resize\",this.onWindowResize),window.addEventListener(\"orientationchange\",this.onWindowResize),this.onWindowResize(),this.scrollable&&!this.isAutoHeight&&console.warn('Modal \"'.concat(this.name,'\" has scrollable flag set to true ')+'but height is not \"auto\" ('.concat(this.height,\")\")),this.clickToClose&&window.addEventListener(\"keyup\",this.onEscapeKeyUp)},mounted:function(){var n=this;this.resizeObserver=new x(function(t){if(0<t.length){var e=k(t,1)[0];n.modal.renderedHeight=e.contentRect.height}}),this.$focusTrap=new M},beforeDestroy:function(){this.$modal.subscription.$off(\"toggle\",this.onToggle),window.removeEventListener(\"resize\",this.onWindowResize),window.removeEventListener(\"orientationchange\",this.onWindowResize),this.clickToClose&&window.removeEventListener(\"keyup\",this.onEscapeKeyUp),document.body.classList.remove(\"vm--block-scroll\")},computed:{guaranteedOverlayTransition:function(){return this.overlayTransition||R},guaranteedModalTransition:function(){return this.transition||R},isAutoHeight:function(){return\"auto\"===this.modal.heightType},position:function(){var t=this.viewportHeight,e=this.viewportWidth,n=this.shiftLeft,i=this.shiftTop,o=this.shiftX,r=this.shiftY,s=this.trueModalWidth,a=this.trueModalHeight,l=e-s,u=Math.max(t-a,0),c=i+r*u;return{left:parseInt(h(0,l,n+o*l)),top:!a&&this.isAutoHeight?void 0:parseInt(h(0,u,c))}},trueModalWidth:function(){var t=this.viewportWidth,e=this.modal,n=this.adaptive,i=this.minWidth,o=this.maxWidth,r=\"%\"===e.widthType?t/100*e.width:e.width;if(n){var s=Math.max(i,Math.min(t,o));return h(i,s,r)}return r},trueModalHeight:function(){var t=this.viewportHeight,e=this.modal,n=this.isAutoHeight,i=this.adaptive,o=this.minHeight,r=this.maxHeight,s=\"%\"===e.heightType?t/100*e.height:e.height;if(n)return this.modal.renderedHeight;if(i){var a=Math.max(o,Math.min(t,r));return h(o,a,s)}return s},autoHeight:function(){return this.adaptive&&this.modal.renderedHeight>=this.viewportHeight?Math.max(this.minHeight,this.viewportHeight)+\"px\":\"auto\"},containerClass:function(){return[\"vm--container\",this.scrollable&&this.isAutoHeight&&\"scrollable\"]},modalClass:function(){return[\"vm--modal\",this.classes]},stylesProp:function(){return\"string\"==typeof this.styles?a(this.styles):this.styles},modalStyle:function(){return[this.stylesProp,{top:this.position.top+\"px\",left:this.position.left+\"px\",width:this.trueModalWidth+\"px\",height:this.isAutoHeight?this.autoHeight:this.trueModalHeight+\"px\"}]},isComponentReadyToBeDestroyed:function(){return this.overlayTransitionState===A&&this.modalTransitionState===A}},watch:{isComponentReadyToBeDestroyed:function(t){t&&(this.visible=!1)}},methods:{startTransitionEnter:function(){this.visibility.overlay=!0,this.visibility.modal=!0},startTransitionLeave:function(){this.visibility.overlay=!1,this.visibility.modal=!1},beforeOverlayTransitionEnter:function(){this.overlayTransitionState=$},afterOverlayTransitionEnter:function(){this.overlayTransitionState=C},beforeOverlayTransitionLeave:function(){this.overlayTransitionState=j},afterOverlayTransitionLeave:function(){this.overlayTransitionState=A},beforeModalTransitionEnter:function(){var t=this;this.modalTransitionState=$,this.$nextTick(function(){t.resizeObserver.observe(t.$refs.modal)})},afterModalTransitionEnter:function(){this.modalTransitionState=C,this.draggable&&this.addDraggableListeners(),this.focusTrap&&this.$focusTrap.enable(this.$refs.modal);var t=this.createModalEvent({state:\"opened\"});this.$emit(\"opened\",t)},beforeModalTransitionLeave:function(){this.modalTransitionState=j,this.resizeObserver.unobserve(this.$refs.modal),this.$focusTrap.enabled()&&this.$focusTrap.disable()},afterModalTransitionLeave:function(){this.modalTransitionState=A;var t=this.createModalEvent({state:\"closed\"});this.$emit(\"closed\",t)},onToggle:function(t,e,n){if(this.name===t){var i=void 0===e?!this.visible:e;this.toggle(i,n)}},setInitialSize:function(){var t=g(this.width),e=g(this.height);this.modal.width=t.value,this.modal.widthType=t.type,this.modal.height=e.value,this.modal.heightType=e.type},onEscapeKeyUp:function(t){27===t.which&&this.visible&&this.$modal.hide(this.name)},onWindowResize:function(){this.viewportWidth=u(),this.viewportHeight=window.innerHeight,this.ensureShiftInWindowBounds()},createModalEvent:function(t){var e=0<arguments.length&&void 0!==t?t:{};return function(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{},i=Object.keys(n);\"function\"==typeof Object.getOwnPropertySymbols&&(i=i.concat(Object.getOwnPropertySymbols(n).filter(function(t){return Object.getOwnPropertyDescriptor(n,t).enumerable}))),i.forEach(function(t){L(e,t,n[t])})}return e}({name:this.name,ref:this.$refs.modal||null},e)},onModalResize:function(t){this.modal.widthType=\"px\",this.modal.width=t.size.width,this.modal.heightType=\"px\",this.modal.height=t.size.height,this.centerResize||(this.shiftLeft=this.getResizedShiftLeft(t),this.shiftTop=this.getResizedShiftTop(t));var e=this.modal.size;this.$emit(\"resize\",this.createModalEvent({size:e}))},getResizedShiftLeft:function(t){this.viewportHeight,this.viewportWidth,this.trueModalWidth,this.trueModalHeight;var e=this.shiftLeft;switch(t.direction){case\"vue-modal-topRight\":case\"vue-modal-bottomRight\":case\"vue-modal-right\":e+=.5*t.dimGrowth.width;break;case\"vue-modal-bottomLeft\":case\"vue-modal-topLeft\":case\"vue-modal-left\":e-=.5*t.dimGrowth.width;break;case\"vue-modal-top\":case\"vue-modal-bottom\":break;default:console.error(\"Could not Find Resize Direction In ShiftLeft\")}return e},getResizedShiftTop:function(t){this.viewportHeight,this.viewportWidth,this.trueModalWidth,this.trueModalHeight;var e=this.shiftTop;switch(t.direction){case\"vue-modal-bottom\":case\"vue-modal-bottomRight\":case\"vue-modal-bottomLeft\":e+=.5*t.dimGrowth.height;break;case\"vue-modal-top\":case\"vue-modal-topRight\":case\"vue-modal-topLeft\":e-=.5*t.dimGrowth.height;break;case\"vue-modal-left\":case\"vue-modal-right\":break;default:console.error(\"Could not Find Resize Direction In ShiftTop\")}return e},open:function(t){var e=this;this.reset&&(this.setInitialSize(),this.shiftLeft=0,this.shiftTop=0),this.scrollable&&document.body.classList.add(\"vm--block-scroll\");var n=!1,i=this.createModalEvent({cancel:function(){n=!0},state:\"before-open\",params:t});this.$emit(\"before-open\",i),n?this.scrollable&&document.body.classList.remove(\"vm--block-scroll\"):(\"undefined\"!=typeof document&&document.activeElement&&\"BODY\"!==document.activeElement.tagName&&document.activeElement.blur&&document.activeElement.blur(),this.visible=!0,this.$nextTick(function(){e.startTransitionEnter()}))},close:function(t){this.scrollable&&document.body.classList.remove(\"vm--block-scroll\");var e=!1,n=this.createModalEvent({cancel:function(){e=!0},state:\"before-close\",params:t});this.$emit(\"before-close\",n),e||this.startTransitionLeave()},toggle:function(t,e){this.visible!==t&&(t?this.open(e):this.close(e))},getDraggableElement:function(){return!0===this.draggable?this.$refs.modal:\"string\"==typeof this.draggable?this.$refs.modal.querySelector(this.draggable):null},onOverlayClick:function(){this.clickToClose&&this.toggle(!1)},addDraggableListeners:function(){var s=this,t=this.getDraggableElement();if(t){var a=0,l=0,u=0,c=0,e=function(t){var e=t.target;if(!(n=e)||-1===v.indexOf(n.nodeName)){var n,i=f(t),o=i.clientX,r=i.clientY;document.addEventListener(\"mousemove\",d),document.addEventListener(\"touchmove\",d),document.addEventListener(\"mouseup\",h),document.addEventListener(\"touchend\",h),a=o,l=r,u=s.shiftLeft,c=s.shiftTop}},d=function(t){var e=f(t),n=e.clientX,i=e.clientY;s.shiftLeft=u+n-a,s.shiftTop=c+i-l,t.preventDefault()},h=function t(e){s.ensureShiftInWindowBounds(),document.removeEventListener(\"mousemove\",d),document.removeEventListener(\"touchmove\",d),document.removeEventListener(\"mouseup\",t),document.removeEventListener(\"touchend\",t),e.preventDefault()};t.addEventListener(\"mousedown\",e),t.addEventListener(\"touchstart\",e)}},ensureShiftInWindowBounds:function(){var t=this.viewportHeight,e=this.viewportWidth,n=this.shiftLeft,i=this.shiftTop,o=this.shiftX,r=this.shiftY,s=this.trueModalWidth,a=this.trueModalHeight,l=e-s,u=Math.max(t-a,0),c=n+o*l,d=i+r*u;this.shiftLeft-=c-h(0,l,c),this.shiftTop-=d-h(0,u,d)}}},N=(n(9),d(H,i,[],!1,null,null,null));N.options.__file=\"src/components/Modal.vue\";function D(){var n=this,t=n.$createElement,i=n._self._c||t;return i(n.$modal.context.componentName,{tag:\"component\",attrs:{name:\"dialog\",height:\"auto\",classes:[\"vue-dialog\",this.params.class],width:n.width,\"shift-y\":.3,adaptive:!0,\"focus-trap\":!0,clickToClose:n.clickToClose,transition:n.transition},on:{\"before-open\":n.beforeOpened,\"before-close\":n.beforeClosed,opened:function(t){return n.$emit(\"opened\",t)},closed:function(t){return n.$emit(\"closed\",t)}}},[i(\"div\",{staticClass:\"vue-dialog-content\"},[n.params.title?i(\"div\",{staticClass:\"vue-dialog-content-title\",domProps:{innerHTML:n._s(n.params.title||\"\")}}):n._e(),n._v(\" \"),n.params.component?i(n.params.component,n._b({tag:\"component\"},\"component\",n.params.props,!1)):i(\"div\",{domProps:{innerHTML:n._s(n.params.text||\"\")}})],1),n._v(\" \"),n.buttons?i(\"div\",{staticClass:\"vue-dialog-buttons\"},n._l(n.buttons,function(t,e){return i(\"button\",{key:e,class:t.class||\"vue-dialog-button\",style:n.buttonStyle,attrs:{type:\"button\",tabindex:\"0\"},domProps:{innerHTML:n._s(t.title)},on:{click:function(t){return t.stopPropagation(),n.click(e,t)}}},[n._v(n._s(t.title))])}),0):i(\"div\",{staticClass:\"vue-dialog-buttons-none\"})])}var W=N.exports;D._withStripped=!0;var I={name:\"VueJsDialog\",props:{width:{type:[Number,String],default:400},clickToClose:{type:Boolean,default:!0},transition:{type:String}},data:function(){return{params:{}}},computed:{buttons:function(){return this.params.buttons||[]},buttonStyle:function(){return{flex:\"1 1 \".concat(100/this.buttons.length,\"%\")}}},methods:{beforeOpened:function(t){this.params=t.params||{},this.$emit(\"before-opened\",t)},beforeClosed:function(t){this.params={},this.$emit(\"before-closed\",t)},click:function(t,e,n){var i=2<arguments.length&&void 0!==n?n:\"click\",o=this.buttons[t],r=null==o?void 0:o.handler;\"function\"==typeof r&&r(t,e,{source:i})}}},P=(n(11),d(I,D,[],!1,null,null,null));P.options.__file=\"src/components/Dialog.vue\";function B(){var n=this,t=n.$createElement,i=n._self._c||t;return i(\"div\",{attrs:{id:\"modals-container\"}},n._l(n.modals,function(e){return i(\"modal\",n._g(n._b({key:e.id,on:{closed:function(t){return n.remove(e.id)}}},\"modal\",e.modalAttrs,!1),e.modalListeners),[i(e.component,n._g(n._b({tag:\"component\",on:{close:function(t){return n.$modal.hide(e.modalAttrs.name,t)}}},\"component\",e.componentAttrs,!1),n.$listeners))],1)}),1)}var X=P.exports;function Y(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}B._withStripped=!0;var G=d({data:function(){return{modals:[]}},created:function(){this.$root.__modalContainer=this},mounted:function(){var t=this;this.$modal.subscription.$on(\"hide-all\",function(){t.modals=[]})},methods:{add:function(t,e,n,i){var o=this,r=1<arguments.length&&void 0!==e?e:{},s=2<arguments.length&&void 0!==n?n:{},a=3<arguments.length&&void 0!==i?i:{},l=c(),u=s.name||\"dynamic_modal_\"+l;this.modals.push({id:l,modalAttrs:function(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{},i=Object.keys(n);\"function\"==typeof Object.getOwnPropertySymbols&&(i=i.concat(Object.getOwnPropertySymbols(n).filter(function(t){return Object.getOwnPropertyDescriptor(n,t).enumerable}))),i.forEach(function(t){Y(e,t,n[t])})}return e}({},s,{name:u}),modalListeners:a,component:t,componentAttrs:r}),this.$nextTick(function(){o.$modal.show(u)})},remove:function(e){var t=this.modals.findIndex(function(t){return t.id===e});-1!==t&&this.modals.splice(t,1)}}},B,[],!1,null,null,null);G.options.__file=\"src/components/ModalsContainer.vue\";var U=G.exports;function F(t){return(F=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t})(t)}function q(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}var V=function(i,t){function o(t,e,n,i){var o,r=2<arguments.length&&void 0!==n?n:{},s=3<arguments.length?i:void 0,a=null===(o=c.root)||void 0===o?void 0:o.__modalContainer,l=u.dynamicDefaults||{};null!=a&&a.add(t,e,function(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{},i=Object.keys(n);\"function\"==typeof Object.getOwnPropertySymbols&&(i=i.concat(Object.getOwnPropertySymbols(n).filter(function(t){return Object.getOwnPropertyDescriptor(n,t).enumerable}))),i.forEach(function(t){q(e,t,n[t])})}return e}({},l,r),s)}var u=1<arguments.length&&void 0!==t?t:{},r=new i,c={root:null,componentName:u.componentName||\"Modal\"};return{context:c,subscription:r,show:function(){for(var t=arguments.length,e=new Array(t),n=0;n<t;n++)e[n]=arguments[n];var i=e[0];switch(F(i)){case\"string\":(function(t,e){r.$emit(\"toggle\",t,!0,e)}).apply(void 0,e);break;case\"object\":case\"function\":o.apply(void 0,e);break;default:console.warn(\"[vue-js-modal] $modal() received an unsupported argument as a first argument.\",i)}},hide:function(t,e){r.$emit(\"toggle\",t,!1,e)},hideAll:function(){r.$emit(\"hide-all\")},toggle:function(t,e){r.$emit(\"toggle\",t,void 0,e)},setDynamicModalContainer:function(t){c.root=t;var e,n=(e=document.createElement(\"div\"),document.body.appendChild(e),e);new i({parent:t,render:function(t){return t(U)}}).$mount(n)}}},K={install:function(e,t){var n=1<arguments.length&&void 0!==t?t:{};if(!e.prototype.$modal){var i=new V(e,n);if(Object.defineProperty(e.prototype,\"$modal\",{get:function(){if(this instanceof e){var t=this.$root;i.context.root||i.setDynamicModalContainer(t)}return i}}),e.component(i.context.componentName,W),n.dialog){var o=n.dialogComponentName||\"VDialog\";e.component(o,X)}}}},J=\"__VERSION__\";e.default=K}],o.c=i,o.d=function(t,e,n){o.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:n})},o.r=function(t){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(t,\"__esModule\",{value:!0})},o.t=function(e,t){if(1&t&&(e=o(e)),8&t)return e;if(4&t&&\"object\"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(o.r(n),Object.defineProperty(n,\"default\",{enumerable:!0,value:e}),2&t&&\"string\"!=typeof e)for(var i in e)o.d(n,i,function(t){return e[t]}.bind(null,i));return n},o.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return o.d(e,\"a\",e),e},o.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},o.p=\"/dist/\",o(o.s=13);function o(t){if(i[t])return i[t].exports;var e=i[t]={i:t,l:!1,exports:{}};return n[t].call(e.exports,e,e.exports,o),e.l=!0,e.exports}var n,i});\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnVlLWpzLW1vZGFsL2Rpc3QvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQUEsZUFBZSxLQUFpRCxvQkFBb0IsQ0FBNkgsQ0FBQyxtQkFBbUIsV0FBVyx3QkFBd0IsV0FBVyxvRUFBb0UsbUNBQW1DLEVBQUUsaUJBQWlCLFlBQVksb0VBQW9FLG1DQUFtQyxFQUFFLGlCQUFpQixZQUFZLG9FQUFvRSxtQ0FBbUMsRUFBRSxlQUFlLHNCQUFzQixTQUFTLDZCQUE2Qiw0QkFBNEIsb0JBQW9CLHNCQUFzQixlQUFlLCtCQUErQixrQkFBa0Isa0RBQWtELGNBQWMscUVBQXFFLGdDQUFnQyw0Q0FBNEMsRUFBRSwyQ0FBMkMscUJBQXFCLE1BQU0sNkJBQTZCLE1BQU0sSUFBSSxXQUFXLG1CQUFtQixzQ0FBc0MsWUFBWSxLQUFLLGNBQWMsS0FBSyxpQkFBaUIsOEJBQThCLFFBQVEsV0FBVyxLQUFLLFdBQVcsZ0dBQWdHLElBQUksaUJBQWlCLGFBQWEsZ0JBQWdCLGlCQUFpQixLQUFLLFdBQVcsS0FBSyxxQkFBcUIsK0NBQStDLHFDQUFxQyxlQUFlLEVBQUUsU0FBUyxrQ0FBa0MsU0FBUyxFQUFFLG1DQUFtQyw2SEFBNkgsaUJBQWlCLHFFQUFxRSxRQUFRLDhGQUE4RixvSEFBb0gsb0JBQW9CLFlBQVksYUFBYSx3QkFBd0IsaUJBQWlCLFdBQVcsS0FBSyxXQUFXLDZCQUE2QixtQkFBbUIsUUFBUSxXQUFXLEtBQUssTUFBTSxzQkFBc0IsWUFBWSxpQkFBaUIsaUJBQWlCLGtCQUFrQixjQUFjLFlBQVksV0FBVyxLQUFLLHFCQUFxQixNQUFNLFNBQVMsWUFBWSxpQkFBaUIsMkJBQTJCLEtBQUssaUJBQWlCLGdDQUFnQywrREFBK0QsS0FBSyxTQUFTLFFBQVEsaUJBQWlCLDBCQUEwQixTQUFTLDBCQUEwQixhQUFhLHNDQUFzQyw0Q0FBNEMsY0FBYyw2REFBNkQsTUFBTSxjQUFjLDRCQUE0QixNQUFNLFVBQVUsdURBQXVELDJCQUEyQixvQ0FBb0MsNkJB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QUE0QixpQkFBaUIsRUFBRSxvQkFBb0Isd0NBQXdDLGdCQUFnQixFQUFFLGtDQUFrQyx5QkFBeUIsc0RBQXNELGdCQUFnQixjQUFjLGlGQUFpRixnQkFBZ0IsYUFBYSxvR0FBb0csS0FBSyxrQkFBa0IseUNBQXlDLGtEQUFrRCxXQUFXLG9CQUFvQixvQkFBb0IsMkNBQTJDLGlIQUFpSCwrQkFBK0IsWUFBWSxtQkFBbUIsS0FBSyx3Q0FBd0Msa0JBQWtCLGdIQUFnSCx1REFBdUQsMEJBQTBCLFlBQVksRUFBRSxTQUFTLEdBQUcsU0FBUyx5Q0FBeUMsWUFBWSxrREFBa0QsT0FBTyx5Q0FBeUMsOENBQThDLElBQUksc0JBQXNCLFdBQVcsYUFBYSw0QkFBNEIseUJBQXlCLGtCQUFrQixNQUFNLDhDQUE4QyxNQUFNLHlHQUF5RyxvQkFBb0IseUJBQXlCLG9CQUFvQixvQkFBb0Isc0JBQXNCLDZCQUE2QixzQ0FBc0MsU0FBUyx5RUFBeUUsT0FBTyw0QkFBNEIsYUFBYSxjQUFjLElBQUksc0JBQXNCLDBDQUEwQyx3QkFBd0IsaUJBQWlCLCtDQUErQyxlQUFlLHNCQUFzQixpQkFBaUIsOENBQThDLFVBQVUsbURBQW1ELHVDQUF1QyxvQkFBb0IsaUJBQWlCLFlBQVksNEJBQTRCLHFDQUFxQyxvQkFBb0IsRUFBRSxpQkFBaUIsNEZBQTRGLGVBQWUsd0NBQXdDLFNBQVMsRUFBRSxtQkFBbUIsOEJBQThCLHFEQUFxRCwwQkFBMEIsNkNBQTZDLHNCQUFzQiw2REFBNkQsWUFBWSxlQUFlLFNBQVMsaUJBQWlCLGlDQUFpQyxpQkFBaUIsWUFBWSxVQUFVLHNCQUFzQixtQkFBbUIsaURBQWlELHdCQUF3QixjQUFjLDRCQUE0QixZQUFZLHFCQUFxQiwyREFBMkQsUUFBUTtBQUNsdzBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Z1ZS1qcy1tb2RhbC9kaXN0L2luZGV4LmpzP2Y1ZDciXSwic291cmNlc0NvbnRlbnQiOlsiIWZ1bmN0aW9uKHQsZSl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9ZSgpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW10sZSk6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/ZXhwb3J0c1tcInZ1ZS1qcy1tb2RhbFwiXT1lKCk6dFtcInZ1ZS1qcy1tb2RhbFwiXT1lKCl9KHdpbmRvdyxmdW5jdGlvbigpe3JldHVybiBpPXt9LG8ubT1uPVtmdW5jdGlvbih0LGUsbil7dmFyIGk9big3KTtcInN0cmluZ1wiPT10eXBlb2YgaSYmKGk9W1t0LmksaSxcIlwiXV0pLGkubG9jYWxzJiYodC5leHBvcnRzPWkubG9jYWxzKTsoMCxuKDQpLmRlZmF1bHQpKFwiZDc2MzY3OWNcIixpLCExLHt9KX0sZnVuY3Rpb24odCxlLG4pe3ZhciBpPW4oMTApO1wic3RyaW5nXCI9PXR5cGVvZiBpJiYoaT1bW3QuaSxpLFwiXCJdXSksaS5sb2NhbHMmJih0LmV4cG9ydHM9aS5sb2NhbHMpOygwLG4oNCkuZGVmYXVsdCkoXCI2YjljYzBlMFwiLGksITEse30pfSxmdW5jdGlvbih0LGUsbil7dmFyIGk9bigxMik7XCJzdHJpbmdcIj09dHlwZW9mIGkmJihpPVtbdC5pLGksXCJcIl1dKSxpLmxvY2FscyYmKHQuZXhwb3J0cz1pLmxvY2Fscyk7KDAsbig0KS5kZWZhdWx0KShcIjY2M2MwMDRlXCIsaSwhMSx7fSl9LGZ1bmN0aW9uKHQsZSl7dC5leHBvcnRzPWZ1bmN0aW9uKG4pe3ZhciBzPVtdO3JldHVybiBzLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKHQpe3ZhciBlPWZ1bmN0aW9uKHQsZSl7dmFyIG49dFsxXXx8XCJcIixpPXRbM107aWYoIWkpcmV0dXJuIG47aWYoZSYmXCJmdW5jdGlvblwiPT10eXBlb2YgYnRvYSl7dmFyIG89ZnVuY3Rpb24odCl7cmV0dXJuXCIvKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsXCIrYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkodCkpKSkrXCIgKi9cIn0oaSkscj1pLnNvdXJjZXMubWFwKGZ1bmN0aW9uKHQpe3JldHVyblwiLyojIHNvdXJjZVVSTD1cIitpLnNvdXJjZVJvb3QrdCtcIiAqL1wifSk7cmV0dXJuW25dLmNvbmNhdChyKS5jb25jYXQoW29dKS5qb2luKFwiXFxuXCIpfXJldHVybltuXS5qb2luKFwiXFxuXCIpfSh0LG4pO3JldHVybiB0WzJdP1wiQG1lZGlhIFwiK3RbMl0rXCJ7XCIrZStcIn1cIjplfSkuam9pbihcIlwiKX0scy5pPWZ1bmN0aW9uKHQsZSl7XCJzdHJpbmdcIj09dHlwZW9mIHQmJih0PVtbbnVsbCx0LFwiXCJdXSk7Zm9yKHZhciBuPXt9LGk9MDtpPHRoaXMubGVuZ3RoO2krKyl7dmFyIG89dGhpc1tpXVswXTtcIm51bWJlclwiPT10eXBlb2YgbyYmKG5bb109ITApfWZvcihpPTA7aTx0Lmxlbmd0aDtpKyspe3ZhciByPXRbaV07XCJudW1iZXJcIj09dHlwZW9mIHJbMF0mJm5bclswXV18fChlJiYhclsyXT9yWzJdPWU6ZSYmKHJbMl09XCIoXCIrclsyXStcIikgYW5kIChcIitlK1wiKVwiKSxzLnB1c2gocikpfX0sc319LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBsKHQsZSl7Zm9yKHZhciBuPVtdLGk9e30sbz0wO288ZS5sZW5ndGg7bysrKXt2YXIgcj1lW29dLHM9clswXSxhPXtpZDp0K1wiOlwiK28sY3NzOnJbMV0sbWVkaWE6clsyXSxzb3VyY2VNYXA6clszXX07aVtzXT9pW3NdLnBhcnRzLnB1c2goYSk6bi5wdXNoKGlbc109e2lkOnMscGFydHM6W2FdfSl9cmV0dXJuIG59bi5yKGUpLG4uZChlLFwiZGVmYXVsdFwiLGZ1bmN0aW9uKCl7cmV0dXJuIHZ9KTt2YXIgaT1cInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQ7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIERFQlVHJiZERUJVRyYmIWkpdGhyb3cgbmV3IEVycm9yKFwidnVlLXN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50LiBVc2UgeyB0YXJnZXQ6ICdub2RlJyB9IGluIHlvdXIgV2VicGFjayBjb25maWcgdG8gaW5kaWNhdGUgYSBzZXJ2ZXItcmVuZGVyaW5nIGVudmlyb25tZW50LlwiKTt2YXIgdT17fSxvPWkmJihkb2N1bWVudC5oZWFkfHxkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF0pLHI9bnVsbCxzPTAsYz0hMSxhPWZ1bmN0aW9uKCl7fSxkPW51bGwsaD1cImRhdGEtdnVlLXNzci1pZFwiLGY9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIG5hdmlnYXRvciYmL21zaWUgWzYtOV1cXGIvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKTtmdW5jdGlvbiB2KHMsdCxlLG4pe2M9ZSxkPW58fHt9O3ZhciBhPWwocyx0KTtyZXR1cm4gcChhKSxmdW5jdGlvbih0KXtmb3IodmFyIGU9W10sbj0wO248YS5sZW5ndGg7bisrKXt2YXIgaT1hW25dOyhvPXVbaS5pZF0pLnJlZnMtLSxlLnB1c2gobyl9dD9wKGE9bChzLHQpKTphPVtdO2ZvcihuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciBvO2lmKDA9PT0obz1lW25dKS5yZWZzKXtmb3IodmFyIHI9MDtyPG8ucGFydHMubGVuZ3RoO3IrKylvLnBhcnRzW3JdKCk7ZGVsZXRlIHVbby5pZF19fX19ZnVuY3Rpb24gcCh0KXtmb3IodmFyIGU9MDtlPHQubGVuZ3RoO2UrKyl7dmFyIG49dFtlXSxpPXVbbi5pZF07aWYoaSl7aS5yZWZzKys7Zm9yKHZhciBvPTA7bzxpLnBhcnRzLmxlbmd0aDtvKyspaS5wYXJ0c1tvXShuLnBhcnRzW29dKTtmb3IoO288bi5wYXJ0cy5sZW5ndGg7bysrKWkucGFydHMucHVzaChiKG4ucGFydHNbb10pKTtpLnBhcnRzLmxlbmd0aD5uLnBhcnRzLmxlbmd0aCYmKGkucGFydHMubGVuZ3RoPW4ucGFydHMubGVuZ3RoKX1lbHNle3ZhciByPVtdO2ZvcihvPTA7bzxuLnBhcnRzLmxlbmd0aDtvKyspci5wdXNoKGIobi5wYXJ0c1tvXSkpO3Vbbi5pZF09e2lkOm4uaWQscmVmczoxLHBhcnRzOnJ9fX19ZnVuY3Rpb24gbSgpe3ZhciB0PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtyZXR1cm4gdC50eXBlPVwidGV4dC9jc3NcIixvLmFwcGVuZENoaWxkKHQpLHR9ZnVuY3Rpb24gYihlKXt2YXIgbixpLHQ9ZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcInN0eWxlW1wiK2grJ349XCInK2UuaWQrJ1wiXScpO2lmKHQpe2lmKGMpcmV0dXJuIGE7dC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHQpfWlmKGYpe3ZhciBvPXMrKzt0PXI9cnx8bSgpLG49dy5iaW5kKG51bGwsdCxvLCExKSxpPXcuYmluZChudWxsLHQsbywhMCl9ZWxzZSB0PW0oKSxuPWZ1bmN0aW9uKHQsZSl7dmFyIG49ZS5jc3MsaT1lLm1lZGlhLG89ZS5zb3VyY2VNYXA7aSYmdC5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLGkpO2Quc3NySWQmJnQuc2V0QXR0cmlidXRlKGgsZS5pZCk7byYmKG4rPVwiXFxuLyojIHNvdXJjZVVSTD1cIitvLnNvdXJjZXNbMF0rXCIgKi9cIixuKz1cIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIrYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkobykpKSkrXCIgKi9cIik7aWYodC5zdHlsZVNoZWV0KXQuc3R5bGVTaGVldC5jc3NUZXh0PW47ZWxzZXtmb3IoO3QuZmlyc3RDaGlsZDspdC5yZW1vdmVDaGlsZCh0LmZpcnN0Q2hpbGQpO3QuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobikpfX0uYmluZChudWxsLHQpLGk9ZnVuY3Rpb24oKXt0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodCl9O3JldHVybiBuKGUpLGZ1bmN0aW9uKHQpe2lmKHQpe2lmKHQuY3NzPT09ZS5jc3MmJnQubWVkaWE9PT1lLm1lZGlhJiZ0LnNvdXJjZU1hcD09PWUuc291cmNlTWFwKXJldHVybjtuKGU9dCl9ZWxzZSBpKCl9fXZhciBnLHk9KGc9W10sZnVuY3Rpb24odCxlKXtyZXR1cm4gZ1t0XT1lLGcuZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCJcXG5cIil9KTtmdW5jdGlvbiB3KHQsZSxuLGkpe3ZhciBvPW4/XCJcIjppLmNzcztpZih0LnN0eWxlU2hlZXQpdC5zdHlsZVNoZWV0LmNzc1RleHQ9eShlLG8pO2Vsc2V7dmFyIHI9ZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobykscz10LmNoaWxkTm9kZXM7c1tlXSYmdC5yZW1vdmVDaGlsZChzW2VdKSxzLmxlbmd0aD90Lmluc2VydEJlZm9yZShyLHNbZV0pOnQuYXBwZW5kQ2hpbGQocil9fX0sZnVuY3Rpb24odCx6LGUpe1widXNlIHN0cmljdFwiOyhmdW5jdGlvbih0KXt2YXIgaT1mdW5jdGlvbigpe2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBNYXApcmV0dXJuIE1hcDtmdW5jdGlvbiBpKHQsbil7dmFyIGk9LTE7cmV0dXJuIHQuc29tZShmdW5jdGlvbih0LGUpe3JldHVybiB0WzBdPT09biYmKGk9ZSwhMCl9KSxpfXJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCJzaXplXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9fZW50cmllc19fLmxlbmd0aH0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSx0LnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24odCl7dmFyIGU9aSh0aGlzLl9fZW50cmllc19fLHQpLG49dGhpcy5fX2VudHJpZXNfX1tlXTtyZXR1cm4gbiYmblsxXX0sdC5wcm90b3R5cGUuc2V0PWZ1bmN0aW9uKHQsZSl7dmFyIG49aSh0aGlzLl9fZW50cmllc19fLHQpO35uP3RoaXMuX19lbnRyaWVzX19bbl1bMV09ZTp0aGlzLl9fZW50cmllc19fLnB1c2goW3QsZV0pfSx0LnByb3RvdHlwZS5kZWxldGU9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5fX2VudHJpZXNfXyxuPWkoZSx0KTt+biYmZS5zcGxpY2UobiwxKX0sdC5wcm90b3R5cGUuaGFzPWZ1bmN0aW9uKHQpe3JldHVybiEhfmkodGhpcy5fX2VudHJpZXNfXyx0KX0sdC5wcm90b3R5cGUuY2xlYXI9ZnVuY3Rpb24oKXt0aGlzLl9fZW50cmllc19fLnNwbGljZSgwKX0sdC5wcm90b3R5cGUuZm9yRWFjaD1mdW5jdGlvbih0LGUpe3ZvaWQgMD09PWUmJihlPW51bGwpO2Zvcih2YXIgbj0wLGk9dGhpcy5fX2VudHJpZXNfXztuPGkubGVuZ3RoO24rKyl7dmFyIG89aVtuXTt0LmNhbGwoZSxvWzFdLG9bMF0pfX0sdDtmdW5jdGlvbiB0KCl7dGhpcy5fX2VudHJpZXNfXz1bXX19KCksbj1cInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93JiZcInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQmJndpbmRvdy5kb2N1bWVudD09PWRvY3VtZW50LGU9dm9pZCAwIT09dCYmdC5NYXRoPT09TWF0aD90OlwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmJiZzZWxmLk1hdGg9PT1NYXRoP3NlbGY6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdyYmd2luZG93Lk1hdGg9PT1NYXRoP3dpbmRvdzpGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCksbD1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWU/cmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQoZSk6ZnVuY3Rpb24odCl7cmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtyZXR1cm4gdChEYXRlLm5vdygpKX0sMWUzLzYwKX0sdT0yO3ZhciBvPVtcInRvcFwiLFwicmlnaHRcIixcImJvdHRvbVwiLFwibGVmdFwiLFwid2lkdGhcIixcImhlaWdodFwiLFwic2l6ZVwiLFwid2VpZ2h0XCJdLHI9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIscz0oYS5wcm90b3R5cGUuYWRkT2JzZXJ2ZXI9ZnVuY3Rpb24odCl7fnRoaXMub2JzZXJ2ZXJzXy5pbmRleE9mKHQpfHx0aGlzLm9ic2VydmVyc18ucHVzaCh0KSx0aGlzLmNvbm5lY3RlZF98fHRoaXMuY29ubmVjdF8oKX0sYS5wcm90b3R5cGUucmVtb3ZlT2JzZXJ2ZXI9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5vYnNlcnZlcnNfLG49ZS5pbmRleE9mKHQpO35uJiZlLnNwbGljZShuLDEpLCFlLmxlbmd0aCYmdGhpcy5jb25uZWN0ZWRfJiZ0aGlzLmRpc2Nvbm5lY3RfKCl9LGEucHJvdG90eXBlLnJlZnJlc2g9ZnVuY3Rpb24oKXt0aGlzLnVwZGF0ZU9ic2VydmVyc18oKSYmdGhpcy5yZWZyZXNoKCl9LGEucHJvdG90eXBlLnVwZGF0ZU9ic2VydmVyc189ZnVuY3Rpb24oKXt2YXIgdD10aGlzLm9ic2VydmVyc18uZmlsdGVyKGZ1bmN0aW9uKHQpe3JldHVybiB0LmdhdGhlckFjdGl2ZSgpLHQuaGFzQWN0aXZlKCl9KTtyZXR1cm4gdC5mb3JFYWNoKGZ1bmN0aW9uKHQpe3JldHVybiB0LmJyb2FkY2FzdEFjdGl2ZSgpfSksMDx0Lmxlbmd0aH0sYS5wcm90b3R5cGUuY29ubmVjdF89ZnVuY3Rpb24oKXtuJiYhdGhpcy5jb25uZWN0ZWRfJiYoZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRyYW5zaXRpb25lbmRcIix0aGlzLm9uVHJhbnNpdGlvbkVuZF8pLHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsdGhpcy5yZWZyZXNoKSxyPyh0aGlzLm11dGF0aW9uc09ic2VydmVyXz1uZXcgTXV0YXRpb25PYnNlcnZlcih0aGlzLnJlZnJlc2gpLHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfLm9ic2VydmUoZG9jdW1lbnQse2F0dHJpYnV0ZXM6ITAsY2hpbGRMaXN0OiEwLGNoYXJhY3RlckRhdGE6ITAsc3VidHJlZTohMH0pKTooZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTVN1YnRyZWVNb2RpZmllZFwiLHRoaXMucmVmcmVzaCksdGhpcy5tdXRhdGlvbkV2ZW50c0FkZGVkXz0hMCksdGhpcy5jb25uZWN0ZWRfPSEwKX0sYS5wcm90b3R5cGUuZGlzY29ubmVjdF89ZnVuY3Rpb24oKXtuJiZ0aGlzLmNvbm5lY3RlZF8mJihkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidHJhbnNpdGlvbmVuZFwiLHRoaXMub25UcmFuc2l0aW9uRW5kXyksd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIix0aGlzLnJlZnJlc2gpLHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfJiZ0aGlzLm11dGF0aW9uc09ic2VydmVyXy5kaXNjb25uZWN0KCksdGhpcy5tdXRhdGlvbkV2ZW50c0FkZGVkXyYmZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTVN1YnRyZWVNb2RpZmllZFwiLHRoaXMucmVmcmVzaCksdGhpcy5tdXRhdGlvbnNPYnNlcnZlcl89bnVsbCx0aGlzLm11dGF0aW9uRXZlbnRzQWRkZWRfPSExLHRoaXMuY29ubmVjdGVkXz0hMSl9LGEucHJvdG90eXBlLm9uVHJhbnNpdGlvbkVuZF89ZnVuY3Rpb24odCl7dmFyIGU9dC5wcm9wZXJ0eU5hbWUsbj12b2lkIDA9PT1lP1wiXCI6ZTtvLnNvbWUoZnVuY3Rpb24odCl7cmV0dXJuISF+bi5pbmRleE9mKHQpfSkmJnRoaXMucmVmcmVzaCgpfSxhLmdldEluc3RhbmNlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaW5zdGFuY2VffHwodGhpcy5pbnN0YW5jZV89bmV3IGEpLHRoaXMuaW5zdGFuY2VffSxhLmluc3RhbmNlXz1udWxsLGEpO2Z1bmN0aW9uIGEoKXtmdW5jdGlvbiB0KCl7ciYmKHI9ITEsaSgpKSxzJiZuKCl9ZnVuY3Rpb24gZSgpe2wodCl9ZnVuY3Rpb24gbigpe3ZhciB0PURhdGUubm93KCk7aWYocil7aWYodC1hPHUpcmV0dXJuO3M9ITB9ZWxzZSBzPSEocj0hMCksc2V0VGltZW91dChlLG8pO2E9dH12YXIgaSxvLHIscyxhO3RoaXMuY29ubmVjdGVkXz0hMSx0aGlzLm11dGF0aW9uRXZlbnRzQWRkZWRfPSExLHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfPW51bGwsdGhpcy5vYnNlcnZlcnNfPVtdLHRoaXMub25UcmFuc2l0aW9uRW5kXz10aGlzLm9uVHJhbnNpdGlvbkVuZF8uYmluZCh0aGlzKSx0aGlzLnJlZnJlc2g9KGk9dGhpcy5yZWZyZXNoLmJpbmQodGhpcykscz1yPSEobz0yMCksYT0wLG4pfXZhciBjPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPTAsaT1PYmplY3Qua2V5cyhlKTtuPGkubGVuZ3RoO24rKyl7dmFyIG89aVtuXTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxvLHt2YWx1ZTplW29dLGVudW1lcmFibGU6ITEsd3JpdGFibGU6ITEsY29uZmlndXJhYmxlOiEwfSl9cmV0dXJuIHR9LGg9ZnVuY3Rpb24odCl7cmV0dXJuIHQmJnQub3duZXJEb2N1bWVudCYmdC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3fHxlfSxmPWcoMCwwLDAsMCk7ZnVuY3Rpb24gdih0KXtyZXR1cm4gcGFyc2VGbG9hdCh0KXx8MH1mdW5jdGlvbiBwKG4pe2Zvcih2YXIgdD1bXSxlPTE7ZTxhcmd1bWVudHMubGVuZ3RoO2UrKyl0W2UtMV09YXJndW1lbnRzW2VdO3JldHVybiB0LnJlZHVjZShmdW5jdGlvbih0LGUpe3JldHVybiB0K3YobltcImJvcmRlci1cIitlK1wiLXdpZHRoXCJdKX0sMCl9ZnVuY3Rpb24gZCh0KXt2YXIgZT10LmNsaWVudFdpZHRoLG49dC5jbGllbnRIZWlnaHQ7aWYoIWUmJiFuKXJldHVybiBmO3ZhciBpLG89aCh0KS5nZXRDb21wdXRlZFN0eWxlKHQpLHI9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXt9LG49MCxpPVtcInRvcFwiLFwicmlnaHRcIixcImJvdHRvbVwiLFwibGVmdFwiXTtuPGkubGVuZ3RoO24rKyl7dmFyIG89aVtuXSxyPXRbXCJwYWRkaW5nLVwiK29dO2Vbb109dihyKX1yZXR1cm4gZX0obykscz1yLmxlZnQrci5yaWdodCxhPXIudG9wK3IuYm90dG9tLGw9dihvLndpZHRoKSx1PXYoby5oZWlnaHQpO2lmKFwiYm9yZGVyLWJveFwiPT09by5ib3hTaXppbmcmJihNYXRoLnJvdW5kKGwrcykhPT1lJiYobC09cChvLFwibGVmdFwiLFwicmlnaHRcIikrcyksTWF0aC5yb3VuZCh1K2EpIT09biYmKHUtPXAobyxcInRvcFwiLFwiYm90dG9tXCIpK2EpKSwoaT10KSE9PWgoaSkuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KXt2YXIgYz1NYXRoLnJvdW5kKGwrcyktZSxkPU1hdGgucm91bmQodSthKS1uOzEhPT1NYXRoLmFicyhjKSYmKGwtPWMpLDEhPT1NYXRoLmFicyhkKSYmKHUtPWQpfXJldHVybiBnKHIubGVmdCxyLnRvcCxsLHUpfXZhciBtPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBTVkdHcmFwaGljc0VsZW1lbnQ/ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBoKHQpLlNWR0dyYXBoaWNzRWxlbWVudH06ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBoKHQpLlNWR0VsZW1lbnQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIHQuZ2V0QkJveH07ZnVuY3Rpb24gYih0KXtyZXR1cm4gbj9tKHQpP2coMCwwLChlPXQuZ2V0QkJveCgpKS53aWR0aCxlLmhlaWdodCk6ZCh0KTpmO3ZhciBlfWZ1bmN0aW9uIGcodCxlLG4saSl7cmV0dXJue3g6dCx5OmUsd2lkdGg6bixoZWlnaHQ6aX19dmFyIHk9KHcucHJvdG90eXBlLmlzQWN0aXZlPWZ1bmN0aW9uKCl7dmFyIHQ9Yih0aGlzLnRhcmdldCk7cmV0dXJuKHRoaXMuY29udGVudFJlY3RfPXQpLndpZHRoIT09dGhpcy5icm9hZGNhc3RXaWR0aHx8dC5oZWlnaHQhPT10aGlzLmJyb2FkY2FzdEhlaWdodH0sdy5wcm90b3R5cGUuYnJvYWRjYXN0UmVjdD1mdW5jdGlvbigpe3ZhciB0PXRoaXMuY29udGVudFJlY3RfO3JldHVybiB0aGlzLmJyb2FkY2FzdFdpZHRoPXQud2lkdGgsdGhpcy5icm9hZGNhc3RIZWlnaHQ9dC5oZWlnaHQsdH0sdyk7ZnVuY3Rpb24gdyh0KXt0aGlzLmJyb2FkY2FzdFdpZHRoPTAsdGhpcy5icm9hZGNhc3RIZWlnaHQ9MCx0aGlzLmNvbnRlbnRSZWN0Xz1nKDAsMCwwLDApLHRoaXMudGFyZ2V0PXR9dmFyIF89ZnVuY3Rpb24odCxlKXt2YXIgbixpLG8scixzLGEsbCx1PShpPShuPWUpLngsbz1uLnkscj1uLndpZHRoLHM9bi5oZWlnaHQsYT1cInVuZGVmaW5lZFwiIT10eXBlb2YgRE9NUmVjdFJlYWRPbmx5P0RPTVJlY3RSZWFkT25seTpPYmplY3QsbD1PYmplY3QuY3JlYXRlKGEucHJvdG90eXBlKSxjKGwse3g6aSx5Om8sd2lkdGg6cixoZWlnaHQ6cyx0b3A6byxyaWdodDppK3IsYm90dG9tOnMrbyxsZWZ0Oml9KSxsKTtjKHRoaXMse3RhcmdldDp0LGNvbnRlbnRSZWN0OnV9KX0sRT0oeC5wcm90b3R5cGUub2JzZXJ2ZT1mdW5jdGlvbih0KXtpZighYXJndW1lbnRzLmxlbmd0aCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgMCBwcmVzZW50LlwiKTtpZihcInVuZGVmaW5lZFwiIT10eXBlb2YgRWxlbWVudCYmRWxlbWVudCBpbnN0YW5jZW9mIE9iamVjdCl7aWYoISh0IGluc3RhbmNlb2YgaCh0KS5FbGVtZW50KSl0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXJhbWV0ZXIgMSBpcyBub3Qgb2YgdHlwZSBcIkVsZW1lbnRcIi4nKTt2YXIgZT10aGlzLm9ic2VydmF0aW9uc187ZS5oYXModCl8fChlLnNldCh0LG5ldyB5KHQpKSx0aGlzLmNvbnRyb2xsZXJfLmFkZE9ic2VydmVyKHRoaXMpLHRoaXMuY29udHJvbGxlcl8ucmVmcmVzaCgpKX19LHgucHJvdG90eXBlLnVub2JzZXJ2ZT1mdW5jdGlvbih0KXtpZighYXJndW1lbnRzLmxlbmd0aCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgMCBwcmVzZW50LlwiKTtpZihcInVuZGVmaW5lZFwiIT10eXBlb2YgRWxlbWVudCYmRWxlbWVudCBpbnN0YW5jZW9mIE9iamVjdCl7aWYoISh0IGluc3RhbmNlb2YgaCh0KS5FbGVtZW50KSl0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXJhbWV0ZXIgMSBpcyBub3Qgb2YgdHlwZSBcIkVsZW1lbnRcIi4nKTt2YXIgZT10aGlzLm9ic2VydmF0aW9uc187ZS5oYXModCkmJihlLmRlbGV0ZSh0KSxlLnNpemV8fHRoaXMuY29udHJvbGxlcl8ucmVtb3ZlT2JzZXJ2ZXIodGhpcykpfX0seC5wcm90b3R5cGUuZGlzY29ubmVjdD1mdW5jdGlvbigpe3RoaXMuY2xlYXJBY3RpdmUoKSx0aGlzLm9ic2VydmF0aW9uc18uY2xlYXIoKSx0aGlzLmNvbnRyb2xsZXJfLnJlbW92ZU9ic2VydmVyKHRoaXMpfSx4LnByb3RvdHlwZS5nYXRoZXJBY3RpdmU9ZnVuY3Rpb24oKXt2YXIgZT10aGlzO3RoaXMuY2xlYXJBY3RpdmUoKSx0aGlzLm9ic2VydmF0aW9uc18uZm9yRWFjaChmdW5jdGlvbih0KXt0LmlzQWN0aXZlKCkmJmUuYWN0aXZlT2JzZXJ2YXRpb25zXy5wdXNoKHQpfSl9LHgucHJvdG90eXBlLmJyb2FkY2FzdEFjdGl2ZT1mdW5jdGlvbigpe2lmKHRoaXMuaGFzQWN0aXZlKCkpe3ZhciB0PXRoaXMuY2FsbGJhY2tDdHhfLGU9dGhpcy5hY3RpdmVPYnNlcnZhdGlvbnNfLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gbmV3IF8odC50YXJnZXQsdC5icm9hZGNhc3RSZWN0KCkpfSk7dGhpcy5jYWxsYmFja18uY2FsbCh0LGUsdCksdGhpcy5jbGVhckFjdGl2ZSgpfX0seC5wcm90b3R5cGUuY2xlYXJBY3RpdmU9ZnVuY3Rpb24oKXt0aGlzLmFjdGl2ZU9ic2VydmF0aW9uc18uc3BsaWNlKDApfSx4LnByb3RvdHlwZS5oYXNBY3RpdmU9ZnVuY3Rpb24oKXtyZXR1cm4gMDx0aGlzLmFjdGl2ZU9ic2VydmF0aW9uc18ubGVuZ3RofSx4KTtmdW5jdGlvbiB4KHQsZSxuKXtpZih0aGlzLmFjdGl2ZU9ic2VydmF0aW9uc189W10sdGhpcy5vYnNlcnZhdGlvbnNfPW5ldyBpLFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBjYWxsYmFjayBwcm92aWRlZCBhcyBwYXJhbWV0ZXIgMSBpcyBub3QgYSBmdW5jdGlvbi5cIik7dGhpcy5jYWxsYmFja189dCx0aGlzLmNvbnRyb2xsZXJfPWUsdGhpcy5jYWxsYmFja0N0eF89bn12YXIgVD1uZXcoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFdlYWtNYXA/V2Vha01hcDppKSxPPWZ1bmN0aW9uIHQoZSl7aWYoISh0aGlzIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbi5cIik7aWYoIWFyZ3VtZW50cy5sZW5ndGgpdGhyb3cgbmV3IFR5cGVFcnJvcihcIjEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5IDAgcHJlc2VudC5cIik7dmFyIG49cy5nZXRJbnN0YW5jZSgpLGk9bmV3IEUoZSxuLHRoaXMpO1Quc2V0KHRoaXMsaSl9O1tcIm9ic2VydmVcIixcInVub2JzZXJ2ZVwiLFwiZGlzY29ubmVjdFwiXS5mb3JFYWNoKGZ1bmN0aW9uKGUpe08ucHJvdG90eXBlW2VdPWZ1bmN0aW9uKCl7dmFyIHQ7cmV0dXJuKHQ9VC5nZXQodGhpcykpW2VdLmFwcGx5KHQsYXJndW1lbnRzKX19KTt2YXIgUz12b2lkIDAhPT1lLlJlc2l6ZU9ic2VydmVyP2UuUmVzaXplT2JzZXJ2ZXI6Tzt6LmE9U30pLmNhbGwodGhpcyxlKDgpKX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO3ZhciBpPW4oMCk7bi5uKGkpLmF9LGZ1bmN0aW9uKHQsZSxuKXsodC5leHBvcnRzPW4oMykoITEpKS5wdXNoKFt0LmksXCJcXG4udnVlLW1vZGFsLXRvcCxcXG4udnVlLW1vZGFsLWJvdHRvbSxcXG4udnVlLW1vZGFsLWxlZnQsXFxuLnZ1ZS1tb2RhbC1yaWdodCxcXG4udnVlLW1vZGFsLXRvcFJpZ2h0LFxcbi52dWUtbW9kYWwtdG9wTGVmdCxcXG4udnVlLW1vZGFsLWJvdHRvbUxlZnQsXFxuLnZ1ZS1tb2RhbC1ib3R0b21SaWdodCB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcXG4gIHotaW5kZXg6IDk5OTk5OTk7XFxufVxcbi52dWUtbW9kYWwtdG9wUmlnaHQsXFxuLnZ1ZS1tb2RhbC10b3BMZWZ0LFxcbi52dWUtbW9kYWwtYm90dG9tTGVmdCxcXG4udnVlLW1vZGFsLWJvdHRvbVJpZ2h0IHtcXG4gIHdpZHRoOiAxMnB4O1xcbiAgaGVpZ2h0OiAxMnB4O1xcbn1cXG4udnVlLW1vZGFsLXRvcCB7XFxuICByaWdodDogMTI7XFxuICB0b3A6IDA7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogMTJweDtcXG4gIGN1cnNvcjogbi1yZXNpemU7XFxufVxcbi52dWUtbW9kYWwtYm90dG9tIHtcXG4gIGxlZnQ6IDA7XFxuICBib3R0b206IDA7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogMTJweDtcXG4gIGN1cnNvcjogcy1yZXNpemU7XFxufVxcbi52dWUtbW9kYWwtbGVmdCB7XFxuICBsZWZ0OiAwO1xcbiAgdG9wOiAwO1xcbiAgd2lkdGg6IDEycHg7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICBjdXJzb3I6IHctcmVzaXplO1xcbn1cXG4udnVlLW1vZGFsLXJpZ2h0IHtcXG4gIHJpZ2h0OiAwO1xcbiAgdG9wOiAwO1xcbiAgd2lkdGg6IDEycHg7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICBjdXJzb3I6IGUtcmVzaXplO1xcbn1cXG4udnVlLW1vZGFsLXRvcFJpZ2h0IHtcXG4gIHJpZ2h0OiAwO1xcbiAgdG9wOiAwO1xcbiAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XFxuICBjdXJzb3I6IG5lLXJlc2l6ZTtcXG59XFxuLnZ1ZS1tb2RhbC10b3BMZWZ0IHtcXG4gIGxlZnQ6IDA7XFxuICB0b3A6IDA7XFxuICBjdXJzb3I6IG53LXJlc2l6ZTtcXG59XFxuLnZ1ZS1tb2RhbC1ib3R0b21MZWZ0IHtcXG4gIGxlZnQ6IDA7XFxuICBib3R0b206IDA7XFxuICBjdXJzb3I6IHN3LXJlc2l6ZTtcXG59XFxuLnZ1ZS1tb2RhbC1ib3R0b21SaWdodCB7XFxuICByaWdodDogMDtcXG4gIGJvdHRvbTogMDtcXG4gIGN1cnNvcjogc2UtcmVzaXplO1xcbn1cXG4jdnVlLW1vZGFsLXRyaWFuZ2xlOjphZnRlciB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGNvbnRlbnQ6ICcnO1xcbiAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XFxuICBsZWZ0OiAwO1xcbiAgdG9wOiAwO1xcbiAgd2lkdGg6IDA7XFxuICBoZWlnaHQ6IDA7XFxuICBib3JkZXItYm90dG9tOiAxMHB4IHNvbGlkICNkZGQ7XFxuICBib3JkZXItbGVmdDogMTBweCBzb2xpZCB0cmFuc3BhcmVudDtcXG59XFxuI3Z1ZS1tb2RhbC10cmlhbmdsZS5jbGlja2VkOjphZnRlciB7XFxuICBib3JkZXItYm90dG9tOiAxMHB4IHNvbGlkICMzNjliZTk7XFxufVxcblwiLFwiXCJdKX0sZnVuY3Rpb24odCxlKXt2YXIgbjtuPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9KCk7dHJ5e249bnx8bmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKX1jYXRjaCh0KXtcIm9iamVjdFwiPT10eXBlb2Ygd2luZG93JiYobj13aW5kb3cpfXQuZXhwb3J0cz1ufSxmdW5jdGlvbih0LGUsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGk9bigxKTtuLm4oaSkuYX0sZnVuY3Rpb24odCxlLG4peyh0LmV4cG9ydHM9bigzKSghMSkpLnB1c2goW3QuaSxcIlxcbi52bS0tYmxvY2stc2Nyb2xsIHtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxuICB3aWR0aDogMTAwdnc7XFxufVxcbi52bS0tY29udGFpbmVyIHtcXG4gIHBvc2l0aW9uOiBmaXhlZDtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICBsZWZ0OiAwO1xcbiAgdG9wOiAwO1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDEwMHZoO1xcbiAgei1pbmRleDogOTk5O1xcbn1cXG4udm0tLW92ZXJsYXkge1xcbiAgcG9zaXRpb246IGZpeGVkO1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIGxlZnQ6IDA7XFxuICB0b3A6IDA7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogMTAwdmg7XFxuICBiYWNrZ3JvdW5kOiByZ2JhKDAsIDAsIDAsIDAuMik7XFxuICAvKiB6LWluZGV4OiA5OTk7ICovXFxuICBvcGFjaXR5OiAxO1xcbn1cXG4udm0tLWNvbnRhaW5lci5zY3JvbGxhYmxlIHtcXG4gIGhlaWdodDogMTAwJTtcXG4gIG1pbi1oZWlnaHQ6IDEwMHZoO1xcbiAgb3ZlcmZsb3cteTogYXV0bztcXG4gIC13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nOiB0b3VjaDtcXG59XFxuLnZtLS1tb2RhbCB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG5cXG4gIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xcbiAgYm9yZGVyLXJhZGl1czogM3B4O1xcbiAgYm94LXNoYWRvdzogMCAyMHB4IDYwcHggLTJweCByZ2JhKDI3LCAzMywgNTgsIDAuNCk7XFxufVxcbi52bS0tY29udGFpbmVyLnNjcm9sbGFibGUgLnZtLS1tb2RhbCB7XFxuICBtYXJnaW4tYm90dG9tOiAycHg7XFxufVxcbi52bS0tdG9wLXJpZ2h0LXNsb3Qge1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICByaWdodDogMDtcXG4gIHRvcDogMDtcXG59XFxuLnZtLXRyYW5zaXRpb24tLW92ZXJsYXktZW50ZXItYWN0aXZlLFxcbi52bS10cmFuc2l0aW9uLS1vdmVybGF5LWxlYXZlLWFjdGl2ZSB7XFxuICB0cmFuc2l0aW9uOiBhbGwgNTBtcztcXG59XFxuLnZtLXRyYW5zaXRpb24tLW92ZXJsYXktZW50ZXIsXFxuLnZtLXRyYW5zaXRpb24tLW92ZXJsYXktbGVhdmUtYWN0aXZlIHtcXG4gIG9wYWNpdHk6IDA7XFxufVxcbi52bS10cmFuc2l0aW9uLS1tb2RhbC1lbnRlci1hY3RpdmUsXFxuLnZtLXRyYW5zaXRpb24tLW1vZGFsLWxlYXZlLWFjdGl2ZSB7XFxuICB0cmFuc2l0aW9uOiBhbGwgNDAwbXM7XFxufVxcbi52bS10cmFuc2l0aW9uLS1tb2RhbC1lbnRlcixcXG4udm0tdHJhbnNpdGlvbi0tbW9kYWwtbGVhdmUtYWN0aXZlIHtcXG4gIG9wYWNpdHk6IDA7XFxuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTIwcHgpO1xcbn1cXG4udm0tdHJhbnNpdGlvbi0tZGVmYXVsdC1lbnRlci1hY3RpdmUsXFxuLnZtLXRyYW5zaXRpb24tLWRlZmF1bHQtbGVhdmUtYWN0aXZlIHtcXG4gIHRyYW5zaXRpb246IGFsbCAybXM7XFxufVxcbi52bS10cmFuc2l0aW9uLS1kZWZhdWx0LWVudGVyLFxcbi52bS10cmFuc2l0aW9uLS1kZWZhdWx0LWxlYXZlLWFjdGl2ZSB7XFxuICBvcGFjaXR5OiAwO1xcbn1cXG5cIixcIlwiXSl9LGZ1bmN0aW9uKHQsZSxuKXtcInVzZSBzdHJpY3RcIjt2YXIgaT1uKDIpO24ubihpKS5hfSxmdW5jdGlvbih0LGUsbil7KHQuZXhwb3J0cz1uKDMpKCExKSkucHVzaChbdC5pLFwiXFxuLnZ1ZS1kaWFsb2cge1xcbiAgZm9udC1zaXplOiAxNHB4O1xcbn1cXG4udnVlLWRpYWxvZyBkaXYge1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG59XFxuLnZ1ZS1kaWFsb2ctY29udGVudCB7XFxuICBmbGV4OiAxIDAgYXV0bztcXG4gIHdpZHRoOiAxMDAlO1xcbiAgcGFkZGluZzogMTRweDtcXG59XFxuLnZ1ZS1kaWFsb2ctY29udGVudC10aXRsZSB7XFxuICBmb250LXdlaWdodDogNjAwO1xcbiAgcGFkZGluZy1ib3R0b206IDE0cHg7XFxufVxcbi52dWUtZGlhbG9nLWJ1dHRvbnMge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXg6IDAgMSBhdXRvO1xcbiAgd2lkdGg6IDEwMCU7XFxuICBib3JkZXItdG9wOiAxcHggc29saWQgI2VlZTtcXG59XFxuLnZ1ZS1kaWFsb2ctYnV0dG9ucy1ub25lIHtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgcGFkZGluZy1ib3R0b206IDE0cHg7XFxufVxcbi52dWUtZGlhbG9nLWJ1dHRvbiB7XFxuICBmb250LXNpemU6IGluaGVyaXQ7XFxuICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcXG4gIHBhZGRpbmc6IDA7XFxuICBtYXJnaW46IDA7XFxuICBib3JkZXI6IDA7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgbGluZS1oZWlnaHQ6IDQwcHg7XFxuICBoZWlnaHQ6IDQwcHg7XFxuICBjb2xvcjogaW5oZXJpdDtcXG4gIGZvbnQ6IGluaGVyaXQ7XFxuICBvdXRsaW5lOiBub25lO1xcbn1cXG4udnVlLWRpYWxvZy1idXR0b246aG92ZXIge1xcbiAgYmFja2dyb3VuZDogI2Y5ZjlmOTtcXG59XFxuLnZ1ZS1kaWFsb2ctYnV0dG9uOmFjdGl2ZSB7XFxuICBiYWNrZ3JvdW5kOiAjZjNmM2YzO1xcbn1cXG4udnVlLWRpYWxvZy1idXR0b246bm90KDpmaXJzdC1vZi10eXBlKSB7XFxuICBib3JkZXItbGVmdDogMXB4IHNvbGlkICNlZWU7XFxufVxcblwiLFwiXCJdKX0sZnVuY3Rpb24odCxlLG4pe1widXNlIHN0cmljdFwiO24ucihlKSxuLmQoZSxcIk1vZGFsXCIsZnVuY3Rpb24oKXtyZXR1cm4gV30pLG4uZChlLFwiRGlhbG9nXCIsZnVuY3Rpb24oKXtyZXR1cm4gWH0pLG4uZChlLFwidmVyc2lvblwiLGZ1bmN0aW9uKCl7cmV0dXJuIEp9KTtmdW5jdGlvbiBpKCl7dmFyIGU9dGhpcyx0PWUuJGNyZWF0ZUVsZW1lbnQsbj1lLl9zZWxmLl9jfHx0O3JldHVybiBlLnZpc2libGU/bihcImRpdlwiLHtjbGFzczplLmNvbnRhaW5lckNsYXNzfSxbbihcInRyYW5zaXRpb25cIix7YXR0cnM6e25hbWU6ZS5ndWFyYW50ZWVkT3ZlcmxheVRyYW5zaXRpb259LG9uOntcImJlZm9yZS1lbnRlclwiOmUuYmVmb3JlT3ZlcmxheVRyYW5zaXRpb25FbnRlcixcImFmdGVyLWVudGVyXCI6ZS5hZnRlck92ZXJsYXlUcmFuc2l0aW9uRW50ZXIsXCJiZWZvcmUtbGVhdmVcIjplLmJlZm9yZU92ZXJsYXlUcmFuc2l0aW9uTGVhdmUsXCJhZnRlci1sZWF2ZVwiOmUuYWZ0ZXJPdmVybGF5VHJhbnNpdGlvbkxlYXZlfX0sW2UudmlzaWJpbGl0eS5vdmVybGF5P24oXCJkaXZcIix7c3RhdGljQ2xhc3M6XCJ2bS0tb3ZlcmxheVwiLGF0dHJzOntcImRhdGEtbW9kYWxcIjplLm5hbWUsXCJhcmlhLWV4cGFuZGVkXCI6ZS52aXNpYmlsaXR5Lm92ZXJsYXkudG9TdHJpbmcoKX0sb246e2NsaWNrOmZ1bmN0aW9uKHQpe3JldHVybiB0LnRhcmdldCE9PXQuY3VycmVudFRhcmdldD9udWxsOih0LnN0b3BQcm9wYWdhdGlvbigpLGUub25PdmVybGF5Q2xpY2sodCkpfX19LFtuKFwiZGl2XCIse3N0YXRpY0NsYXNzOlwidm0tLXRvcC1yaWdodC1zbG90XCJ9LFtlLl90KFwidG9wLXJpZ2h0XCIpXSwyKV0pOmUuX2UoKV0pLGUuX3YoXCIgXCIpLG4oXCJ0cmFuc2l0aW9uXCIse2F0dHJzOntuYW1lOmUuZ3VhcmFudGVlZE1vZGFsVHJhbnNpdGlvbn0sb246e1wiYmVmb3JlLWVudGVyXCI6ZS5iZWZvcmVNb2RhbFRyYW5zaXRpb25FbnRlcixcImFmdGVyLWVudGVyXCI6ZS5hZnRlck1vZGFsVHJhbnNpdGlvbkVudGVyLFwiYmVmb3JlLWxlYXZlXCI6ZS5iZWZvcmVNb2RhbFRyYW5zaXRpb25MZWF2ZSxcImFmdGVyLWxlYXZlXCI6ZS5hZnRlck1vZGFsVHJhbnNpdGlvbkxlYXZlfX0sW2UudmlzaWJpbGl0eS5tb2RhbD9uKFwiZGl2XCIse3JlZjpcIm1vZGFsXCIsY2xhc3M6ZS5tb2RhbENsYXNzLHN0eWxlOmUubW9kYWxTdHlsZSxhdHRyczp7XCJhcmlhLWV4cGFuZGVkXCI6ZS52aXNpYmlsaXR5Lm1vZGFsLnRvU3RyaW5nKCkscm9sZTpcImRpYWxvZ1wiLFwiYXJpYS1tb2RhbFwiOlwidHJ1ZVwifX0sW2UuX3QoXCJkZWZhdWx0XCIpLGUuX3YoXCIgXCIpLGUucmVzaXphYmxlJiYhZS5pc0F1dG9IZWlnaHQ/bihcInJlc2l6ZXJcIix7YXR0cnM6e1wibWluLXdpZHRoXCI6ZS5taW5XaWR0aCxcIm1pbi1oZWlnaHRcIjplLm1pbkhlaWdodCxcIm1heC13aWR0aFwiOmUubWF4V2lkdGgsXCJtYXgtaGVpZ2h0XCI6ZS5tYXhIZWlnaHQsXCJ2aWV3cG9ydC1oZWlnaHRcIjplLnZpZXdwb3J0SGVpZ2h0LFwidmlld3BvcnQtd2lkdGhcIjplLnZpZXdwb3J0V2lkdGgsXCJyZXNpemUtaW5kaWNhdG9yXCI6ZS5yZXNpemVJbmRpY2F0b3IsXCJyZXNpemUtZWRnZXNcIjplLnJlc2l6ZUVkZ2VzfSxvbjp7cmVzaXplOmUub25Nb2RhbFJlc2l6ZX19KTplLl9lKCldLDIpOmUuX2UoKV0pXSwxKTplLl9lKCl9ZnVuY3Rpb24gbygpe3ZhciB0PXRoaXMsZT10LiRjcmVhdGVFbGVtZW50LG49dC5fc2VsZi5fY3x8ZTtyZXR1cm4gbihcImRpdlwiLFt0aGlzLnJlc2l6ZUVkZ2VzLmluY2x1ZGVzKFwidFwiKT9uKFwiZGl2XCIse3N0YXRpY0NsYXNzOlwidnVlLW1vZGFsLXRvcFwifSk6dC5fZSgpLHQuX3YoXCIgXCIpLHRoaXMucmVzaXplRWRnZXMuaW5jbHVkZXMoXCJiXCIpP24oXCJkaXZcIix7c3RhdGljQ2xhc3M6XCJ2dWUtbW9kYWwtYm90dG9tXCJ9KTp0Ll9lKCksdC5fdihcIiBcIiksdGhpcy5yZXNpemVFZGdlcy5pbmNsdWRlcyhcImxcIik/bihcImRpdlwiLHtzdGF0aWNDbGFzczpcInZ1ZS1tb2RhbC1sZWZ0XCJ9KTp0Ll9lKCksdC5fdihcIiBcIiksdGhpcy5yZXNpemVFZGdlcy5pbmNsdWRlcyhcInJcIik/bihcImRpdlwiLHtzdGF0aWNDbGFzczpcInZ1ZS1tb2RhbC1yaWdodFwifSk6dC5fZSgpLHQuX3YoXCIgXCIpLHRoaXMucmVzaXplRWRnZXMuaW5jbHVkZXMoXCJ0clwiKT9uKFwiZGl2XCIse3N0YXRpY0NsYXNzOlwidnVlLW1vZGFsLXRvcFJpZ2h0XCJ9KTp0Ll9lKCksdC5fdihcIiBcIiksdGhpcy5yZXNpemVFZGdlcy5pbmNsdWRlcyhcInRsXCIpP24oXCJkaXZcIix7c3RhdGljQ2xhc3M6XCJ2dWUtbW9kYWwtdG9wTGVmdFwifSk6dC5fZSgpLHQuX3YoXCIgXCIpLHRoaXMucmVzaXplRWRnZXMuaW5jbHVkZXMoXCJiclwiKT9uKFwiZGl2XCIse2NsYXNzOnQuY2xhc3NOYW1lLGF0dHJzOntpZDp0LmdldElEfX0pOnQuX2UoKSx0Ll92KFwiIFwiKSx0aGlzLnJlc2l6ZUVkZ2VzLmluY2x1ZGVzKFwiYmxcIik/bihcImRpdlwiLHtzdGF0aWNDbGFzczpcInZ1ZS1tb2RhbC1ib3R0b21MZWZ0XCJ9KTp0Ll9lKCldKX1vLl93aXRoU3RyaXBwZWQ9aS5fd2l0aFN0cmlwcGVkPSEwO2Z1bmN0aW9uIGgodCxlLG4pe3JldHVybiBuPHQ/dDplPG4/ZTpufWZ1bmN0aW9uIHIodCxlLG4pe3JldHVybiBlIGluIHQ/T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsZSx7dmFsdWU6bixlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOnRbZV09bix0fWZ1bmN0aW9uIHModCxlKXtyZXR1cm4gZnVuY3Rpb24odCl7aWYoQXJyYXkuaXNBcnJheSh0KSlyZXR1cm4gdH0odCl8fGZ1bmN0aW9uKHQsZSl7dmFyIG49W10saT0hMCxvPSExLHI9dm9pZCAwO3RyeXtmb3IodmFyIHMsYT10W1N5bWJvbC5pdGVyYXRvcl0oKTshKGk9KHM9YS5uZXh0KCkpLmRvbmUpJiYobi5wdXNoKHMudmFsdWUpLCFlfHxuLmxlbmd0aCE9PWUpO2k9ITApO31jYXRjaCh0KXtvPSEwLHI9dH1maW5hbGx5e3RyeXtpfHxudWxsPT1hLnJldHVybnx8YS5yZXR1cm4oKX1maW5hbGx5e2lmKG8pdGhyb3cgcn19cmV0dXJuIG59KHQsZSl8fGZ1bmN0aW9uKCl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIil9KCl9ZnVuY3Rpb24gdSgpe3ZhciB0PXdpbmRvdy5pbm5lcldpZHRoLGU9ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO3JldHVybiB0JiZlP01hdGgubWluKHQsZSk6ZXx8dH1mdW5jdGlvbiBhKHQpe3JldHVybiB0LnNwbGl0KFwiO1wiKS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQudHJpbSgpfSkuZmlsdGVyKEJvb2xlYW4pLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC5zcGxpdChcIjpcIil9KS5yZWR1Y2UoZnVuY3Rpb24odCxlKXt2YXIgbj1zKGUsMik7cmV0dXJuIGZ1bmN0aW9uKGUpe2Zvcih2YXIgdD0xO3Q8YXJndW1lbnRzLmxlbmd0aDt0Kyspe3ZhciBuPW51bGwhPWFyZ3VtZW50c1t0XT9hcmd1bWVudHNbdF06e30saT1PYmplY3Qua2V5cyhuKTtcImZ1bmN0aW9uXCI9PXR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzJiYoaT1pLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG4pLmZpbHRlcihmdW5jdGlvbih0KXtyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuLHQpLmVudW1lcmFibGV9KSkpLGkuZm9yRWFjaChmdW5jdGlvbih0KXtyKGUsdCxuW3RdKX0pfXJldHVybiBlfSh7fSx0LHIoe30sblswXSxuWzFdKSl9LHt9KX1mdW5jdGlvbiBmKHQpe3JldHVybiB0LnRvdWNoZXMmJjA8dC50b3VjaGVzLmxlbmd0aD90LnRvdWNoZXNbMF06dH12YXIgdj1bXCJJTlBVVFwiLFwiVEVYVEFSRUFcIixcIlNFTEVDVFwiXSxjPWZ1bmN0aW9uKHQpe3ZhciBlPTA8YXJndW1lbnRzLmxlbmd0aCYmdm9pZCAwIT09dD90OjA7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuKGUrKykudG9TdHJpbmcoKX19KCksbD17bmFtZTpcIlZ1ZUpzTW9kYWxSZXNpemVyXCIscHJvcHM6e21pbkhlaWdodDp7dHlwZTpOdW1iZXIsZGVmYXVsdDowfSxtaW5XaWR0aDp7dHlwZTpOdW1iZXIsZGVmYXVsdDowfSxtYXhXaWR0aDp7dHlwZTpOdW1iZXIsZGVmYXVsdDpOdW1iZXIuTUFYX1NBRkVfSU5URUdFUn0sbWF4SGVpZ2h0Ont0eXBlOk51bWJlcixkZWZhdWx0Ok51bWJlci5NQVhfU0FGRV9JTlRFR0VSfSx2aWV3cG9ydFdpZHRoOnt0eXBlOk51bWJlcixyZXF1aXJlZDohMH0sdmlld3BvcnRIZWlnaHQ6e3R5cGU6TnVtYmVyLHJlcXVpcmVkOiEwfSxyZXNpemVJbmRpY2F0b3I6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiEwfSxyZXNpemVFZGdlczp7dHlwZTpBcnJheSxyZXF1aXJlZDohMH19LGRhdGE6ZnVuY3Rpb24oKXtyZXR1cm57Y2xpY2tlZDohMSx0YXJnZXRDbGFzczpcIlwiLHNpemU6e30saW5pdGlhbFg6MCxpbml0aWFsWTowfX0sbW91bnRlZDpmdW5jdGlvbigpe3RoaXMuJGVsLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIix0aGlzLnN0YXJ0LCExKX0sY29tcHV0ZWQ6e2NsYXNzTmFtZTpmdW5jdGlvbigpe3JldHVybltcInZ1ZS1tb2RhbC1ib3R0b21SaWdodFwiLHtjbGlja2VkOnRoaXMuY2xpY2tlZH1dfSxnZXRJRDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnJlc2l6ZUluZGljYXRvcj9cInZ1ZS1tb2RhbC10cmlhbmdsZVwiOlwiXCJ9fSxtZXRob2RzOntzdGFydDpmdW5jdGlvbih0KXt0aGlzLnRhcmdldENsYXNzPXQudGFyZ2V0LmNsYXNzTmFtZSx0aGlzLmNsaWNrZWQ9ITAsdGhpcy5pbml0aWFsWD10LmNsaWVudFgsdGhpcy5pbml0aWFsWT10LmNsaWVudFksd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIix0aGlzLm1vdXNlbW92ZSwhMSksd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsdGhpcy5zdG9wLCExKSx0LnN0b3BQcm9wYWdhdGlvbigpLHQucHJldmVudERlZmF1bHQoKX0sc3RvcDpmdW5jdGlvbigpe3RoaXMuY2xpY2tlZD0hMSx0aGlzLmNsaWNrZWQ9ITEsdGhpcy50YXJnZXRDbGFzcz1cIlwiLHRoaXMuaW5pdGlhbFg9MCx0aGlzLmluaXRpYWxZPTAsd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIix0aGlzLm1vdXNlbW92ZSwhMSksd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsdGhpcy5zdG9wLCExKSx0aGlzLiRlbWl0KFwicmVzaXplLXN0b3BcIix7ZWxlbWVudDp0aGlzLiRlbC5wYXJlbnRFbGVtZW50LHNpemU6dGhpcy5zaXplfSl9LG1vdXNlbW92ZTpmdW5jdGlvbih0KXt0aGlzLnJlc2l6ZSh0KX0scmVzaXplOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuJGVsLnBhcmVudEVsZW1lbnQsbj10LmNsaWVudFgsaT10LmNsaWVudFksbz1wYXJzZUludChlLnN0eWxlLndpZHRoLnJlcGxhY2UoXCJweFwiLFwiXCIpKSxyPXBhcnNlSW50KGUuc3R5bGUuaGVpZ2h0LnJlcGxhY2UoXCJweFwiLFwiXCIpKTtpZighKHQuY2xpZW50WD50aGlzLnZpZXdwb3J0V2lkdGh8fHQuY2xpZW50WDwwKSYmISh0LmNsaWVudFk+dGhpcy52aWV3cG9ydEhlaWdodHx8dC5jbGllbnRZPDApJiZlKXtzd2l0Y2godGhpcy50YXJnZXRDbGFzcyl7Y2FzZVwidnVlLW1vZGFsLXJpZ2h0XCI6bi09ZS5vZmZzZXRMZWZ0LGk9cjticmVhaztjYXNlXCJ2dWUtbW9kYWwtbGVmdFwiOmk9cixuPW8rKHRoaXMuaW5pdGlhbFgtdC5jbGllbnRYKTticmVhaztjYXNlXCJ2dWUtbW9kYWwtdG9wXCI6bj1vLGk9cisodGhpcy5pbml0aWFsWS10LmNsaWVudFkpO2JyZWFrO2Nhc2VcInZ1ZS1tb2RhbC1ib3R0b21cIjpuPW8saS09ZS5vZmZzZXRUb3A7YnJlYWs7Y2FzZVwidnVlLW1vZGFsLWJvdHRvbVJpZ2h0XCI6bi09ZS5vZmZzZXRMZWZ0LGktPWUub2Zmc2V0VG9wO2JyZWFrO2Nhc2VcInZ1ZS1tb2RhbC10b3BSaWdodFwiOm4tPWUub2Zmc2V0TGVmdCxpPXIrKHRoaXMuaW5pdGlhbFktdC5jbGllbnRZKTticmVhaztjYXNlXCJ2dWUtbW9kYWwtYm90dG9tTGVmdFwiOm49bysodGhpcy5pbml0aWFsWC10LmNsaWVudFgpLGktPWUub2Zmc2V0VG9wO2JyZWFrO2Nhc2VcInZ1ZS1tb2RhbC10b3BMZWZ0XCI6bj1vKyh0aGlzLmluaXRpYWxYLXQuY2xpZW50WCksaT1yKyh0aGlzLmluaXRpYWxZLXQuY2xpZW50WSk7YnJlYWs7ZGVmYXVsdDpjb25zb2xlLmVycm9yKFwiSW5jb3JycmVjdC9ubyByZXNpemUgZGlyZWN0aW9uLlwiKX12YXIgcz1NYXRoLm1pbih1KCksdGhpcy5tYXhXaWR0aCksYT1NYXRoLm1pbih3aW5kb3cuaW5uZXJIZWlnaHQsdGhpcy5tYXhIZWlnaHQpO249aCh0aGlzLm1pbldpZHRoLHMsbiksaT1oKHRoaXMubWluSGVpZ2h0LGEsaSksdGhpcy5pbml0aWFsWD10LmNsaWVudFgsdGhpcy5pbml0aWFsWT10LmNsaWVudFksdGhpcy5zaXplPXt3aWR0aDpuLGhlaWdodDppfTt2YXIgbD17d2lkdGg6bi1vLGhlaWdodDppLXJ9O2Uuc3R5bGUud2lkdGg9bitcInB4XCIsZS5zdHlsZS5oZWlnaHQ9aStcInB4XCIsdGhpcy4kZW1pdChcInJlc2l6ZVwiLHtlbGVtZW50OmUsc2l6ZTp0aGlzLnNpemUsZGlyZWN0aW9uOnRoaXMudGFyZ2V0Q2xhc3MsZGltR3Jvd3RoOmx9KX19fX07big2KTtmdW5jdGlvbiBkKHQsZSxuLGksbyxyLHMsYSl7dmFyIGwsdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiB0P3Qub3B0aW9uczp0O2lmKGUmJih1LnJlbmRlcj1lLHUuc3RhdGljUmVuZGVyRm5zPW4sdS5fY29tcGlsZWQ9ITApLGkmJih1LmZ1bmN0aW9uYWw9ITApLHImJih1Ll9zY29wZUlkPVwiZGF0YS12LVwiK3IpLHM/KGw9ZnVuY3Rpb24odCl7KHQ9dHx8dGhpcy4kdm5vZGUmJnRoaXMuJHZub2RlLnNzckNvbnRleHR8fHRoaXMucGFyZW50JiZ0aGlzLnBhcmVudC4kdm5vZGUmJnRoaXMucGFyZW50LiR2bm9kZS5zc3JDb250ZXh0KXx8XCJ1bmRlZmluZWRcIj09dHlwZW9mIF9fVlVFX1NTUl9DT05URVhUX198fCh0PV9fVlVFX1NTUl9DT05URVhUX18pLG8mJm8uY2FsbCh0aGlzLHQpLHQmJnQuX3JlZ2lzdGVyZWRDb21wb25lbnRzJiZ0Ll9yZWdpc3RlcmVkQ29tcG9uZW50cy5hZGQocyl9LHUuX3NzclJlZ2lzdGVyPWwpOm8mJihsPWE/ZnVuY3Rpb24oKXtvLmNhbGwodGhpcyx0aGlzLiRyb290LiRvcHRpb25zLnNoYWRvd1Jvb3QpfTpvKSxsKWlmKHUuZnVuY3Rpb25hbCl7dS5faW5qZWN0U3R5bGVzPWw7dmFyIGM9dS5yZW5kZXI7dS5yZW5kZXI9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbC5jYWxsKGUpLGModCxlKX19ZWxzZXt2YXIgZD11LmJlZm9yZUNyZWF0ZTt1LmJlZm9yZUNyZWF0ZT1kP1tdLmNvbmNhdChkLGwpOltsXX1yZXR1cm57ZXhwb3J0czp0LG9wdGlvbnM6dX19dmFyIHA9ZChsLG8sW10sITEsbnVsbCxudWxsLG51bGwpO3Aub3B0aW9ucy5fX2ZpbGU9XCJzcmMvY29tcG9uZW50cy9SZXNpemVyLnZ1ZVwiO3ZhciBtPXAuZXhwb3J0cztmdW5jdGlvbiBiKHQpe3JldHVybihiPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHR9OmZ1bmN0aW9uKHQpe3JldHVybiB0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJnQuY29uc3RydWN0b3I9PT1TeW1ib2wmJnQhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIHR9KSh0KX1mdW5jdGlvbiBnKHQpe3N3aXRjaChiKHQpKXtjYXNlXCJudW1iZXJcIjpyZXR1cm57dHlwZTpcInB4XCIsdmFsdWU6dH07Y2FzZVwic3RyaW5nXCI6cmV0dXJuIGZ1bmN0aW9uKGUpe2lmKFwiYXV0b1wiPT09ZSlyZXR1cm57dHlwZTplLHZhbHVlOjB9O3ZhciB0PV8uZmluZChmdW5jdGlvbih0KXtyZXR1cm4gdC5yZWdleHAudGVzdChlKX0pO3JldHVybiB0P3t0eXBlOnQubmFtZSx2YWx1ZTpwYXJzZUZsb2F0KGUpfTp7dHlwZTpcIlwiLHZhbHVlOmV9fSh0KTtkZWZhdWx0OnJldHVybnt0eXBlOlwiXCIsdmFsdWU6dH19fWZ1bmN0aW9uIHkodCl7aWYoXCJzdHJpbmdcIiE9dHlwZW9mIHQpcmV0dXJuIDA8PXQ7dmFyIGU9Zyh0KTtyZXR1cm4oXCIlXCI9PT1lLnR5cGV8fFwicHhcIj09PWUudHlwZSkmJjA8ZS52YWx1ZX12YXIgdz1cIlstK10/WzAtOV0qLj9bMC05XStcIixfPVt7bmFtZTpcInB4XCIscmVnZXhwOm5ldyBSZWdFeHAoXCJeXCIuY29uY2F0KHcsXCJweCRcIikpfSx7bmFtZTpcIiVcIixyZWdleHA6bmV3IFJlZ0V4cChcIl5cIi5jb25jYXQodyxcIiUkXCIpKX0se25hbWU6XCJweFwiLHJlZ2V4cDpuZXcgUmVnRXhwKFwiXlwiLmNvbmNhdCh3LFwiJFwiKSl9XSxFPW4oNSkseD1cInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93JiZ3aW5kb3cuUmVzaXplT2JzZXJ2ZXI/UmVzaXplT2JzZXJ2ZXI6RS5hO2Z1bmN0aW9uIFQodCxlKXtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIGk9ZVtuXTtpLmVudW1lcmFibGU9aS5lbnVtZXJhYmxlfHwhMSxpLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBpJiYoaS53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsaS5rZXksaSl9fWZ1bmN0aW9uIE8odCl7cmV0dXJuIGZ1bmN0aW9uKHQpe2lmKEFycmF5LmlzQXJyYXkodCkpe2Zvcih2YXIgZT0wLG49bmV3IEFycmF5KHQubGVuZ3RoKTtlPHQubGVuZ3RoO2UrKyluW2VdPXRbZV07cmV0dXJuIG59fSh0KXx8ZnVuY3Rpb24odCl7aWYoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdCh0KXx8XCJbb2JqZWN0IEFyZ3VtZW50c11cIj09PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KSlyZXR1cm4gQXJyYXkuZnJvbSh0KX0odCl8fGZ1bmN0aW9uKCl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpfSgpfWZ1bmN0aW9uIFModCl7cmV0dXJuIGU9J2J1dHRvbjpub3QoW2Rpc2FibGVkXSksIHNlbGVjdDpub3QoW2Rpc2FibGVkXSksIGFbaHJlZl06bm90KFtkaXNhYmxlZF0pLCBhcmVhW2hyZWZdOm5vdChbZGlzYWJsZWRdKSwgW2NvbnRlbnRFZGl0YWJsZT1cIlwiXTpub3QoW2Rpc2FibGVkXSksIFtjb250ZW50RWRpdGFibGU9XCJ0cnVlXCJdOm5vdChbZGlzYWJsZWRdKSwgW2NvbnRlbnRFZGl0YWJsZT1cIlRSVUVcIl06bm90KFtkaXNhYmxlZF0pLCB0ZXh0YXJlYTpub3QoW2Rpc2FibGVkXSksIGlmcmFtZTpub3QoW2Rpc2FibGVkXSksIGlucHV0Om5vdChbZGlzYWJsZWRdKSwgc3VtbWFyeTpub3QoW2Rpc2FibGVkXSksIFt0YWJpbmRleF06bm90KFt0YWJpbmRleD1cIi0xXCJdKScsTyh0LnF1ZXJ5U2VsZWN0b3JBbGwoZSl8fFtdKTt2YXIgZX1mdW5jdGlvbiB6KHQpe3JldHVybiB0PT1kb2N1bWVudC5hY3RpdmVFbGVtZW50fXZhciBNPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCgpeyFmdW5jdGlvbih0LGUpe2lmKCEodCBpbnN0YW5jZW9mIGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9KHRoaXMsdCksdGhpcy5yb290PW51bGwsdGhpcy5lbGVtZW50cz1bXSx0aGlzLm9uS2V5RG93bj10aGlzLm9uS2V5RG93bi5iaW5kKHRoaXMpLHRoaXMuZW5hYmxlPXRoaXMuZW5hYmxlLmJpbmQodGhpcyksdGhpcy5kaXNhYmxlPXRoaXMuZGlzYWJsZS5iaW5kKHRoaXMpLHRoaXMuZmlyc3RFbGVtZW50PXRoaXMuZmlyc3RFbGVtZW50LmJpbmQodGhpcyksdGhpcy5sYXN0RWxlbWVudD10aGlzLmxhc3RFbGVtZW50LmJpbmQodGhpcyl9dmFyIGUsbixpO3JldHVybiBlPXQsKG49W3trZXk6XCJsYXN0RWxlbWVudFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWxlbWVudHNbdGhpcy5lbGVtZW50cy5sZW5ndGgtMV18fG51bGx9fSx7a2V5OlwiZmlyc3RFbGVtZW50XCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lbGVtZW50c1swXXx8bnVsbH19LHtrZXk6XCJvbktleURvd25cIix2YWx1ZTpmdW5jdGlvbih0KXt2YXIgZTtpZihcIlRhYlwiPT09KGU9dCkua2V5fHw5PT09ZS5rZXlDb2RlKXJldHVybiB0LnNoaWZ0S2V5JiZ6KHRoaXMuZmlyc3RFbGVtZW50KCkpPyh0aGlzLmxhc3RFbGVtZW50KCkuZm9jdXMoKSx2b2lkIHQucHJldmVudERlZmF1bHQoKSk6IWRvY3VtZW50LmFjdGl2ZUVsZW1lbnR8fHoodGhpcy5sYXN0RWxlbWVudCgpKT8odGhpcy5maXJzdEVsZW1lbnQoKS5mb2N1cygpLHZvaWQgdC5wcmV2ZW50RGVmYXVsdCgpKTp2b2lkIDB9fSx7a2V5OlwiZW5hYmxlZFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuISF0aGlzLnJvb3R9fSx7a2V5OlwiZW5hYmxlXCIsdmFsdWU6ZnVuY3Rpb24odCl7aWYodCl7dGhpcy5yb290PXQsdGhpcy5lbGVtZW50cz1TKHRoaXMucm9vdCk7dmFyIGU9dGhpcy5maXJzdEVsZW1lbnQoKTtlJiZlLmZvY3VzKCksdGhpcy5yb290LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsdGhpcy5vbktleURvd24pfX19LHtrZXk6XCJkaXNhYmxlXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLnJvb3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIix0aGlzLm9uS2V5RG93biksdGhpcy5yb290PW51bGx9fV0pJiZUKGUucHJvdG90eXBlLG4pLGkmJlQoZSxpKSx0fSgpO2Z1bmN0aW9uIEwodCxlLG4pe3JldHVybiBlIGluIHQ/T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsZSx7dmFsdWU6bixlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOnRbZV09bix0fWZ1bmN0aW9uIGsodCxlKXtyZXR1cm4gZnVuY3Rpb24odCl7aWYoQXJyYXkuaXNBcnJheSh0KSlyZXR1cm4gdH0odCl8fGZ1bmN0aW9uKHQsZSl7dmFyIG49W10saT0hMCxvPSExLHI9dm9pZCAwO3RyeXtmb3IodmFyIHMsYT10W1N5bWJvbC5pdGVyYXRvcl0oKTshKGk9KHM9YS5uZXh0KCkpLmRvbmUpJiYobi5wdXNoKHMudmFsdWUpLCFlfHxuLmxlbmd0aCE9PWUpO2k9ITApO31jYXRjaCh0KXtvPSEwLHI9dH1maW5hbGx5e3RyeXtpfHxudWxsPT1hLnJldHVybnx8YS5yZXR1cm4oKX1maW5hbGx5e2lmKG8pdGhyb3cgcn19cmV0dXJuIG59KHQsZSl8fGZ1bmN0aW9uKCl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIil9KCl9dmFyIFI9XCJ2bS10cmFuc2l0aW9uLS1kZWZhdWx0XCIsQz1cImVudGVyXCIsJD1cImVudGVyaW5nXCIsQT1cImxlYXZlXCIsaj1cImxlYXZuZ1wiLEg9e25hbWU6XCJWdWVKc01vZGFsXCIscHJvcHM6e25hbWU6e3JlcXVpcmVkOiEwLHR5cGU6U3RyaW5nfSxyZXNpemFibGU6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiExfSxyZXNpemVFZGdlczp7ZGVmYXVsdDpmdW5jdGlvbigpe3JldHVybltcInJcIixcImJyXCIsXCJiXCIsXCJibFwiLFwibFwiLFwidGxcIixcInRcIixcInRyXCJdfSx2YWxpZGF0b3I6ZnVuY3Rpb24oZSl7cmV0dXJuW1wiclwiLFwiYnJcIixcImJcIixcImJsXCIsXCJsXCIsXCJ0bFwiLFwidFwiLFwidHJcIl0uZmlsdGVyKGZ1bmN0aW9uKHQpe3JldHVybi0xIT09ZS5pbmRleE9mKHQpfSkubGVuZ3RoPT09ZS5sZW5ndGh9LHR5cGU6QXJyYXl9LGNlbnRlclJlc2l6ZTp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITB9LHJlc2l6ZUluZGljYXRvcjp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITB9LGFkYXB0aXZlOnt0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX0sZHJhZ2dhYmxlOnt0eXBlOltCb29sZWFuLFN0cmluZ10sZGVmYXVsdDohMX0sc2Nyb2xsYWJsZTp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9LGZvY3VzVHJhcDp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITF9LHJlc2V0Ont0eXBlOkJvb2xlYW4sZGVmYXVsdDohMX0sb3ZlcmxheVRyYW5zaXRpb246e3R5cGU6U3RyaW5nLGRlZmF1bHQ6XCJ2bS10cmFuc2l0aW9uLS1vdmVybGF5XCJ9LHRyYW5zaXRpb246e3R5cGU6U3RyaW5nLGRlZmF1bHQ6XCJ2bS10cmFuc2l0aW9uLS1tb2RhbFwifSxjbGlja1RvQ2xvc2U6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiEwfSxjbGFzc2VzOnt0eXBlOltTdHJpbmcsQXJyYXldLGRlZmF1bHQ6ZnVuY3Rpb24oKXtyZXR1cm5bXX19LHN0eWxlczp7dHlwZTpbU3RyaW5nLEFycmF5LE9iamVjdF19LG1pbldpZHRoOnt0eXBlOk51bWJlcixkZWZhdWx0OjAsdmFsaWRhdG9yOmZ1bmN0aW9uKHQpe3JldHVybiAwPD10fX0sbWluSGVpZ2h0Ont0eXBlOk51bWJlcixkZWZhdWx0OjAsdmFsaWRhdG9yOmZ1bmN0aW9uKHQpe3JldHVybiAwPD10fX0sbWF4V2lkdGg6e3R5cGU6TnVtYmVyLGRlZmF1bHQ6TnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJ9LG1heEhlaWdodDp7dHlwZTpOdW1iZXIsZGVmYXVsdDpOdW1iZXIuTUFYX1NBRkVfSU5URUdFUn0sd2lkdGg6e3R5cGU6W051bWJlcixTdHJpbmddLGRlZmF1bHQ6NjAwLHZhbGlkYXRvcjpmdW5jdGlvbih0KXtyZXR1cm5cImF1dG9cIj09PXR8fHkodCl9fSxoZWlnaHQ6e3R5cGU6W051bWJlcixTdHJpbmddLGRlZmF1bHQ6MzAwLHZhbGlkYXRvcjpmdW5jdGlvbih0KXtyZXR1cm5cImF1dG9cIj09PXR8fHkodCl9fSxzaGlmdFg6e3R5cGU6TnVtYmVyLGRlZmF1bHQ6LjUsdmFsaWRhdG9yOmZ1bmN0aW9uKHQpe3JldHVybiAwPD10JiZ0PD0xfX0sc2hpZnRZOnt0eXBlOk51bWJlcixkZWZhdWx0Oi41LHZhbGlkYXRvcjpmdW5jdGlvbih0KXtyZXR1cm4gMDw9dCYmdDw9MX19fSxjb21wb25lbnRzOntSZXNpemVyOm19LGRhdGE6ZnVuY3Rpb24oKXtyZXR1cm57dmlzaWJsZTohMSx2aXNpYmlsaXR5Onttb2RhbDohMSxvdmVybGF5OiExfSxvdmVybGF5VHJhbnNpdGlvblN0YXRlOm51bGwsbW9kYWxUcmFuc2l0aW9uU3RhdGU6bnVsbCxzaGlmdExlZnQ6MCxzaGlmdFRvcDowLG1vZGFsOnt3aWR0aDowLHdpZHRoVHlwZTpcInB4XCIsaGVpZ2h0OjAsaGVpZ2h0VHlwZTpcInB4XCIscmVuZGVyZWRIZWlnaHQ6MH0sdmlld3BvcnRIZWlnaHQ6MCx2aWV3cG9ydFdpZHRoOjB9fSxjcmVhdGVkOmZ1bmN0aW9uKCl7dGhpcy5zZXRJbml0aWFsU2l6ZSgpfSxiZWZvcmVNb3VudDpmdW5jdGlvbigpe3RoaXMuJG1vZGFsLnN1YnNjcmlwdGlvbi4kb24oXCJ0b2dnbGVcIix0aGlzLm9uVG9nZ2xlKSx3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLHRoaXMub25XaW5kb3dSZXNpemUpLHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwib3JpZW50YXRpb25jaGFuZ2VcIix0aGlzLm9uV2luZG93UmVzaXplKSx0aGlzLm9uV2luZG93UmVzaXplKCksdGhpcy5zY3JvbGxhYmxlJiYhdGhpcy5pc0F1dG9IZWlnaHQmJmNvbnNvbGUud2FybignTW9kYWwgXCInLmNvbmNhdCh0aGlzLm5hbWUsJ1wiIGhhcyBzY3JvbGxhYmxlIGZsYWcgc2V0IHRvIHRydWUgJykrJ2J1dCBoZWlnaHQgaXMgbm90IFwiYXV0b1wiICgnLmNvbmNhdCh0aGlzLmhlaWdodCxcIilcIikpLHRoaXMuY2xpY2tUb0Nsb3NlJiZ3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsdGhpcy5vbkVzY2FwZUtleVVwKX0sbW91bnRlZDpmdW5jdGlvbigpe3ZhciBuPXRoaXM7dGhpcy5yZXNpemVPYnNlcnZlcj1uZXcgeChmdW5jdGlvbih0KXtpZigwPHQubGVuZ3RoKXt2YXIgZT1rKHQsMSlbMF07bi5tb2RhbC5yZW5kZXJlZEhlaWdodD1lLmNvbnRlbnRSZWN0LmhlaWdodH19KSx0aGlzLiRmb2N1c1RyYXA9bmV3IE19LGJlZm9yZURlc3Ryb3k6ZnVuY3Rpb24oKXt0aGlzLiRtb2RhbC5zdWJzY3JpcHRpb24uJG9mZihcInRvZ2dsZVwiLHRoaXMub25Ub2dnbGUpLHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsdGhpcy5vbldpbmRvd1Jlc2l6ZSksd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJvcmllbnRhdGlvbmNoYW5nZVwiLHRoaXMub25XaW5kb3dSZXNpemUpLHRoaXMuY2xpY2tUb0Nsb3NlJiZ3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsdGhpcy5vbkVzY2FwZUtleVVwKSxkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoXCJ2bS0tYmxvY2stc2Nyb2xsXCIpfSxjb21wdXRlZDp7Z3VhcmFudGVlZE92ZXJsYXlUcmFuc2l0aW9uOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMub3ZlcmxheVRyYW5zaXRpb258fFJ9LGd1YXJhbnRlZWRNb2RhbFRyYW5zaXRpb246ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50cmFuc2l0aW9ufHxSfSxpc0F1dG9IZWlnaHQ6ZnVuY3Rpb24oKXtyZXR1cm5cImF1dG9cIj09PXRoaXMubW9kYWwuaGVpZ2h0VHlwZX0scG9zaXRpb246ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnZpZXdwb3J0SGVpZ2h0LGU9dGhpcy52aWV3cG9ydFdpZHRoLG49dGhpcy5zaGlmdExlZnQsaT10aGlzLnNoaWZ0VG9wLG89dGhpcy5zaGlmdFgscj10aGlzLnNoaWZ0WSxzPXRoaXMudHJ1ZU1vZGFsV2lkdGgsYT10aGlzLnRydWVNb2RhbEhlaWdodCxsPWUtcyx1PU1hdGgubWF4KHQtYSwwKSxjPWkrcip1O3JldHVybntsZWZ0OnBhcnNlSW50KGgoMCxsLG4rbypsKSksdG9wOiFhJiZ0aGlzLmlzQXV0b0hlaWdodD92b2lkIDA6cGFyc2VJbnQoaCgwLHUsYykpfX0sdHJ1ZU1vZGFsV2lkdGg6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnZpZXdwb3J0V2lkdGgsZT10aGlzLm1vZGFsLG49dGhpcy5hZGFwdGl2ZSxpPXRoaXMubWluV2lkdGgsbz10aGlzLm1heFdpZHRoLHI9XCIlXCI9PT1lLndpZHRoVHlwZT90LzEwMCplLndpZHRoOmUud2lkdGg7aWYobil7dmFyIHM9TWF0aC5tYXgoaSxNYXRoLm1pbih0LG8pKTtyZXR1cm4gaChpLHMscil9cmV0dXJuIHJ9LHRydWVNb2RhbEhlaWdodDpmdW5jdGlvbigpe3ZhciB0PXRoaXMudmlld3BvcnRIZWlnaHQsZT10aGlzLm1vZGFsLG49dGhpcy5pc0F1dG9IZWlnaHQsaT10aGlzLmFkYXB0aXZlLG89dGhpcy5taW5IZWlnaHQscj10aGlzLm1heEhlaWdodCxzPVwiJVwiPT09ZS5oZWlnaHRUeXBlP3QvMTAwKmUuaGVpZ2h0OmUuaGVpZ2h0O2lmKG4pcmV0dXJuIHRoaXMubW9kYWwucmVuZGVyZWRIZWlnaHQ7aWYoaSl7dmFyIGE9TWF0aC5tYXgobyxNYXRoLm1pbih0LHIpKTtyZXR1cm4gaChvLGEscyl9cmV0dXJuIHN9LGF1dG9IZWlnaHQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hZGFwdGl2ZSYmdGhpcy5tb2RhbC5yZW5kZXJlZEhlaWdodD49dGhpcy52aWV3cG9ydEhlaWdodD9NYXRoLm1heCh0aGlzLm1pbkhlaWdodCx0aGlzLnZpZXdwb3J0SGVpZ2h0KStcInB4XCI6XCJhdXRvXCJ9LGNvbnRhaW5lckNsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuW1widm0tLWNvbnRhaW5lclwiLHRoaXMuc2Nyb2xsYWJsZSYmdGhpcy5pc0F1dG9IZWlnaHQmJlwic2Nyb2xsYWJsZVwiXX0sbW9kYWxDbGFzczpmdW5jdGlvbigpe3JldHVybltcInZtLS1tb2RhbFwiLHRoaXMuY2xhc3Nlc119LHN0eWxlc1Byb3A6ZnVuY3Rpb24oKXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgdGhpcy5zdHlsZXM/YSh0aGlzLnN0eWxlcyk6dGhpcy5zdHlsZXN9LG1vZGFsU3R5bGU6ZnVuY3Rpb24oKXtyZXR1cm5bdGhpcy5zdHlsZXNQcm9wLHt0b3A6dGhpcy5wb3NpdGlvbi50b3ArXCJweFwiLGxlZnQ6dGhpcy5wb3NpdGlvbi5sZWZ0K1wicHhcIix3aWR0aDp0aGlzLnRydWVNb2RhbFdpZHRoK1wicHhcIixoZWlnaHQ6dGhpcy5pc0F1dG9IZWlnaHQ/dGhpcy5hdXRvSGVpZ2h0OnRoaXMudHJ1ZU1vZGFsSGVpZ2h0K1wicHhcIn1dfSxpc0NvbXBvbmVudFJlYWR5VG9CZURlc3Ryb3llZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLm92ZXJsYXlUcmFuc2l0aW9uU3RhdGU9PT1BJiZ0aGlzLm1vZGFsVHJhbnNpdGlvblN0YXRlPT09QX19LHdhdGNoOntpc0NvbXBvbmVudFJlYWR5VG9CZURlc3Ryb3llZDpmdW5jdGlvbih0KXt0JiYodGhpcy52aXNpYmxlPSExKX19LG1ldGhvZHM6e3N0YXJ0VHJhbnNpdGlvbkVudGVyOmZ1bmN0aW9uKCl7dGhpcy52aXNpYmlsaXR5Lm92ZXJsYXk9ITAsdGhpcy52aXNpYmlsaXR5Lm1vZGFsPSEwfSxzdGFydFRyYW5zaXRpb25MZWF2ZTpmdW5jdGlvbigpe3RoaXMudmlzaWJpbGl0eS5vdmVybGF5PSExLHRoaXMudmlzaWJpbGl0eS5tb2RhbD0hMX0sYmVmb3JlT3ZlcmxheVRyYW5zaXRpb25FbnRlcjpmdW5jdGlvbigpe3RoaXMub3ZlcmxheVRyYW5zaXRpb25TdGF0ZT0kfSxhZnRlck92ZXJsYXlUcmFuc2l0aW9uRW50ZXI6ZnVuY3Rpb24oKXt0aGlzLm92ZXJsYXlUcmFuc2l0aW9uU3RhdGU9Q30sYmVmb3JlT3ZlcmxheVRyYW5zaXRpb25MZWF2ZTpmdW5jdGlvbigpe3RoaXMub3ZlcmxheVRyYW5zaXRpb25TdGF0ZT1qfSxhZnRlck92ZXJsYXlUcmFuc2l0aW9uTGVhdmU6ZnVuY3Rpb24oKXt0aGlzLm92ZXJsYXlUcmFuc2l0aW9uU3RhdGU9QX0sYmVmb3JlTW9kYWxUcmFuc2l0aW9uRW50ZXI6ZnVuY3Rpb24oKXt2YXIgdD10aGlzO3RoaXMubW9kYWxUcmFuc2l0aW9uU3RhdGU9JCx0aGlzLiRuZXh0VGljayhmdW5jdGlvbigpe3QucmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZSh0LiRyZWZzLm1vZGFsKX0pfSxhZnRlck1vZGFsVHJhbnNpdGlvbkVudGVyOmZ1bmN0aW9uKCl7dGhpcy5tb2RhbFRyYW5zaXRpb25TdGF0ZT1DLHRoaXMuZHJhZ2dhYmxlJiZ0aGlzLmFkZERyYWdnYWJsZUxpc3RlbmVycygpLHRoaXMuZm9jdXNUcmFwJiZ0aGlzLiRmb2N1c1RyYXAuZW5hYmxlKHRoaXMuJHJlZnMubW9kYWwpO3ZhciB0PXRoaXMuY3JlYXRlTW9kYWxFdmVudCh7c3RhdGU6XCJvcGVuZWRcIn0pO3RoaXMuJGVtaXQoXCJvcGVuZWRcIix0KX0sYmVmb3JlTW9kYWxUcmFuc2l0aW9uTGVhdmU6ZnVuY3Rpb24oKXt0aGlzLm1vZGFsVHJhbnNpdGlvblN0YXRlPWosdGhpcy5yZXNpemVPYnNlcnZlci51bm9ic2VydmUodGhpcy4kcmVmcy5tb2RhbCksdGhpcy4kZm9jdXNUcmFwLmVuYWJsZWQoKSYmdGhpcy4kZm9jdXNUcmFwLmRpc2FibGUoKX0sYWZ0ZXJNb2RhbFRyYW5zaXRpb25MZWF2ZTpmdW5jdGlvbigpe3RoaXMubW9kYWxUcmFuc2l0aW9uU3RhdGU9QTt2YXIgdD10aGlzLmNyZWF0ZU1vZGFsRXZlbnQoe3N0YXRlOlwiY2xvc2VkXCJ9KTt0aGlzLiRlbWl0KFwiY2xvc2VkXCIsdCl9LG9uVG9nZ2xlOmZ1bmN0aW9uKHQsZSxuKXtpZih0aGlzLm5hbWU9PT10KXt2YXIgaT12b2lkIDA9PT1lPyF0aGlzLnZpc2libGU6ZTt0aGlzLnRvZ2dsZShpLG4pfX0sc2V0SW5pdGlhbFNpemU6ZnVuY3Rpb24oKXt2YXIgdD1nKHRoaXMud2lkdGgpLGU9Zyh0aGlzLmhlaWdodCk7dGhpcy5tb2RhbC53aWR0aD10LnZhbHVlLHRoaXMubW9kYWwud2lkdGhUeXBlPXQudHlwZSx0aGlzLm1vZGFsLmhlaWdodD1lLnZhbHVlLHRoaXMubW9kYWwuaGVpZ2h0VHlwZT1lLnR5cGV9LG9uRXNjYXBlS2V5VXA6ZnVuY3Rpb24odCl7Mjc9PT10LndoaWNoJiZ0aGlzLnZpc2libGUmJnRoaXMuJG1vZGFsLmhpZGUodGhpcy5uYW1lKX0sb25XaW5kb3dSZXNpemU6ZnVuY3Rpb24oKXt0aGlzLnZpZXdwb3J0V2lkdGg9dSgpLHRoaXMudmlld3BvcnRIZWlnaHQ9d2luZG93LmlubmVySGVpZ2h0LHRoaXMuZW5zdXJlU2hpZnRJbldpbmRvd0JvdW5kcygpfSxjcmVhdGVNb2RhbEV2ZW50OmZ1bmN0aW9uKHQpe3ZhciBlPTA8YXJndW1lbnRzLmxlbmd0aCYmdm9pZCAwIT09dD90Ont9O3JldHVybiBmdW5jdGlvbihlKXtmb3IodmFyIHQ9MTt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKXt2YXIgbj1udWxsIT1hcmd1bWVudHNbdF0/YXJndW1lbnRzW3RdOnt9LGk9T2JqZWN0LmtleXMobik7XCJmdW5jdGlvblwiPT10eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyYmKGk9aS5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhuKS5maWx0ZXIoZnVuY3Rpb24odCl7cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iobix0KS5lbnVtZXJhYmxlfSkpKSxpLmZvckVhY2goZnVuY3Rpb24odCl7TChlLHQsblt0XSl9KX1yZXR1cm4gZX0oe25hbWU6dGhpcy5uYW1lLHJlZjp0aGlzLiRyZWZzLm1vZGFsfHxudWxsfSxlKX0sb25Nb2RhbFJlc2l6ZTpmdW5jdGlvbih0KXt0aGlzLm1vZGFsLndpZHRoVHlwZT1cInB4XCIsdGhpcy5tb2RhbC53aWR0aD10LnNpemUud2lkdGgsdGhpcy5tb2RhbC5oZWlnaHRUeXBlPVwicHhcIix0aGlzLm1vZGFsLmhlaWdodD10LnNpemUuaGVpZ2h0LHRoaXMuY2VudGVyUmVzaXplfHwodGhpcy5zaGlmdExlZnQ9dGhpcy5nZXRSZXNpemVkU2hpZnRMZWZ0KHQpLHRoaXMuc2hpZnRUb3A9dGhpcy5nZXRSZXNpemVkU2hpZnRUb3AodCkpO3ZhciBlPXRoaXMubW9kYWwuc2l6ZTt0aGlzLiRlbWl0KFwicmVzaXplXCIsdGhpcy5jcmVhdGVNb2RhbEV2ZW50KHtzaXplOmV9KSl9LGdldFJlc2l6ZWRTaGlmdExlZnQ6ZnVuY3Rpb24odCl7dGhpcy52aWV3cG9ydEhlaWdodCx0aGlzLnZpZXdwb3J0V2lkdGgsdGhpcy50cnVlTW9kYWxXaWR0aCx0aGlzLnRydWVNb2RhbEhlaWdodDt2YXIgZT10aGlzLnNoaWZ0TGVmdDtzd2l0Y2godC5kaXJlY3Rpb24pe2Nhc2VcInZ1ZS1tb2RhbC10b3BSaWdodFwiOmNhc2VcInZ1ZS1tb2RhbC1ib3R0b21SaWdodFwiOmNhc2VcInZ1ZS1tb2RhbC1yaWdodFwiOmUrPS41KnQuZGltR3Jvd3RoLndpZHRoO2JyZWFrO2Nhc2VcInZ1ZS1tb2RhbC1ib3R0b21MZWZ0XCI6Y2FzZVwidnVlLW1vZGFsLXRvcExlZnRcIjpjYXNlXCJ2dWUtbW9kYWwtbGVmdFwiOmUtPS41KnQuZGltR3Jvd3RoLndpZHRoO2JyZWFrO2Nhc2VcInZ1ZS1tb2RhbC10b3BcIjpjYXNlXCJ2dWUtbW9kYWwtYm90dG9tXCI6YnJlYWs7ZGVmYXVsdDpjb25zb2xlLmVycm9yKFwiQ291bGQgbm90IEZpbmQgUmVzaXplIERpcmVjdGlvbiBJbiBTaGlmdExlZnRcIil9cmV0dXJuIGV9LGdldFJlc2l6ZWRTaGlmdFRvcDpmdW5jdGlvbih0KXt0aGlzLnZpZXdwb3J0SGVpZ2h0LHRoaXMudmlld3BvcnRXaWR0aCx0aGlzLnRydWVNb2RhbFdpZHRoLHRoaXMudHJ1ZU1vZGFsSGVpZ2h0O3ZhciBlPXRoaXMuc2hpZnRUb3A7c3dpdGNoKHQuZGlyZWN0aW9uKXtjYXNlXCJ2dWUtbW9kYWwtYm90dG9tXCI6Y2FzZVwidnVlLW1vZGFsLWJvdHRvbVJpZ2h0XCI6Y2FzZVwidnVlLW1vZGFsLWJvdHRvbUxlZnRcIjplKz0uNSp0LmRpbUdyb3d0aC5oZWlnaHQ7YnJlYWs7Y2FzZVwidnVlLW1vZGFsLXRvcFwiOmNhc2VcInZ1ZS1tb2RhbC10b3BSaWdodFwiOmNhc2VcInZ1ZS1tb2RhbC10b3BMZWZ0XCI6ZS09LjUqdC5kaW1Hcm93dGguaGVpZ2h0O2JyZWFrO2Nhc2VcInZ1ZS1tb2RhbC1sZWZ0XCI6Y2FzZVwidnVlLW1vZGFsLXJpZ2h0XCI6YnJlYWs7ZGVmYXVsdDpjb25zb2xlLmVycm9yKFwiQ291bGQgbm90IEZpbmQgUmVzaXplIERpcmVjdGlvbiBJbiBTaGlmdFRvcFwiKX1yZXR1cm4gZX0sb3BlbjpmdW5jdGlvbih0KXt2YXIgZT10aGlzO3RoaXMucmVzZXQmJih0aGlzLnNldEluaXRpYWxTaXplKCksdGhpcy5zaGlmdExlZnQ9MCx0aGlzLnNoaWZ0VG9wPTApLHRoaXMuc2Nyb2xsYWJsZSYmZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKFwidm0tLWJsb2NrLXNjcm9sbFwiKTt2YXIgbj0hMSxpPXRoaXMuY3JlYXRlTW9kYWxFdmVudCh7Y2FuY2VsOmZ1bmN0aW9uKCl7bj0hMH0sc3RhdGU6XCJiZWZvcmUtb3BlblwiLHBhcmFtczp0fSk7dGhpcy4kZW1pdChcImJlZm9yZS1vcGVuXCIsaSksbj90aGlzLnNjcm9sbGFibGUmJmRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZShcInZtLS1ibG9jay1zY3JvbGxcIik6KFwidW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudCYmZG9jdW1lbnQuYWN0aXZlRWxlbWVudCYmXCJCT0RZXCIhPT1kb2N1bWVudC5hY3RpdmVFbGVtZW50LnRhZ05hbWUmJmRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1ciYmZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ibHVyKCksdGhpcy52aXNpYmxlPSEwLHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uKCl7ZS5zdGFydFRyYW5zaXRpb25FbnRlcigpfSkpfSxjbG9zZTpmdW5jdGlvbih0KXt0aGlzLnNjcm9sbGFibGUmJmRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZShcInZtLS1ibG9jay1zY3JvbGxcIik7dmFyIGU9ITEsbj10aGlzLmNyZWF0ZU1vZGFsRXZlbnQoe2NhbmNlbDpmdW5jdGlvbigpe2U9ITB9LHN0YXRlOlwiYmVmb3JlLWNsb3NlXCIscGFyYW1zOnR9KTt0aGlzLiRlbWl0KFwiYmVmb3JlLWNsb3NlXCIsbiksZXx8dGhpcy5zdGFydFRyYW5zaXRpb25MZWF2ZSgpfSx0b2dnbGU6ZnVuY3Rpb24odCxlKXt0aGlzLnZpc2libGUhPT10JiYodD90aGlzLm9wZW4oZSk6dGhpcy5jbG9zZShlKSl9LGdldERyYWdnYWJsZUVsZW1lbnQ6ZnVuY3Rpb24oKXtyZXR1cm4hMD09PXRoaXMuZHJhZ2dhYmxlP3RoaXMuJHJlZnMubW9kYWw6XCJzdHJpbmdcIj09dHlwZW9mIHRoaXMuZHJhZ2dhYmxlP3RoaXMuJHJlZnMubW9kYWwucXVlcnlTZWxlY3Rvcih0aGlzLmRyYWdnYWJsZSk6bnVsbH0sb25PdmVybGF5Q2xpY2s6ZnVuY3Rpb24oKXt0aGlzLmNsaWNrVG9DbG9zZSYmdGhpcy50b2dnbGUoITEpfSxhZGREcmFnZ2FibGVMaXN0ZW5lcnM6ZnVuY3Rpb24oKXt2YXIgcz10aGlzLHQ9dGhpcy5nZXREcmFnZ2FibGVFbGVtZW50KCk7aWYodCl7dmFyIGE9MCxsPTAsdT0wLGM9MCxlPWZ1bmN0aW9uKHQpe3ZhciBlPXQudGFyZ2V0O2lmKCEobj1lKXx8LTE9PT12LmluZGV4T2Yobi5ub2RlTmFtZSkpe3ZhciBuLGk9Zih0KSxvPWkuY2xpZW50WCxyPWkuY2xpZW50WTtkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsZCksZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLGQpLGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsaCksZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsaCksYT1vLGw9cix1PXMuc2hpZnRMZWZ0LGM9cy5zaGlmdFRvcH19LGQ9ZnVuY3Rpb24odCl7dmFyIGU9Zih0KSxuPWUuY2xpZW50WCxpPWUuY2xpZW50WTtzLnNoaWZ0TGVmdD11K24tYSxzLnNoaWZ0VG9wPWMraS1sLHQucHJldmVudERlZmF1bHQoKX0saD1mdW5jdGlvbiB0KGUpe3MuZW5zdXJlU2hpZnRJbldpbmRvd0JvdW5kcygpLGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIixkKSxkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsZCksZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIix0KSxkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIix0KSxlLnByZXZlbnREZWZhdWx0KCl9O3QuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLGUpLHQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIixlKX19LGVuc3VyZVNoaWZ0SW5XaW5kb3dCb3VuZHM6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnZpZXdwb3J0SGVpZ2h0LGU9dGhpcy52aWV3cG9ydFdpZHRoLG49dGhpcy5zaGlmdExlZnQsaT10aGlzLnNoaWZ0VG9wLG89dGhpcy5zaGlmdFgscj10aGlzLnNoaWZ0WSxzPXRoaXMudHJ1ZU1vZGFsV2lkdGgsYT10aGlzLnRydWVNb2RhbEhlaWdodCxsPWUtcyx1PU1hdGgubWF4KHQtYSwwKSxjPW4rbypsLGQ9aStyKnU7dGhpcy5zaGlmdExlZnQtPWMtaCgwLGwsYyksdGhpcy5zaGlmdFRvcC09ZC1oKDAsdSxkKX19fSxOPShuKDkpLGQoSCxpLFtdLCExLG51bGwsbnVsbCxudWxsKSk7Ti5vcHRpb25zLl9fZmlsZT1cInNyYy9jb21wb25lbnRzL01vZGFsLnZ1ZVwiO2Z1bmN0aW9uIEQoKXt2YXIgbj10aGlzLHQ9bi4kY3JlYXRlRWxlbWVudCxpPW4uX3NlbGYuX2N8fHQ7cmV0dXJuIGkobi4kbW9kYWwuY29udGV4dC5jb21wb25lbnROYW1lLHt0YWc6XCJjb21wb25lbnRcIixhdHRyczp7bmFtZTpcImRpYWxvZ1wiLGhlaWdodDpcImF1dG9cIixjbGFzc2VzOltcInZ1ZS1kaWFsb2dcIix0aGlzLnBhcmFtcy5jbGFzc10sd2lkdGg6bi53aWR0aCxcInNoaWZ0LXlcIjouMyxhZGFwdGl2ZTohMCxcImZvY3VzLXRyYXBcIjohMCxjbGlja1RvQ2xvc2U6bi5jbGlja1RvQ2xvc2UsdHJhbnNpdGlvbjpuLnRyYW5zaXRpb259LG9uOntcImJlZm9yZS1vcGVuXCI6bi5iZWZvcmVPcGVuZWQsXCJiZWZvcmUtY2xvc2VcIjpuLmJlZm9yZUNsb3NlZCxvcGVuZWQ6ZnVuY3Rpb24odCl7cmV0dXJuIG4uJGVtaXQoXCJvcGVuZWRcIix0KX0sY2xvc2VkOmZ1bmN0aW9uKHQpe3JldHVybiBuLiRlbWl0KFwiY2xvc2VkXCIsdCl9fX0sW2koXCJkaXZcIix7c3RhdGljQ2xhc3M6XCJ2dWUtZGlhbG9nLWNvbnRlbnRcIn0sW24ucGFyYW1zLnRpdGxlP2koXCJkaXZcIix7c3RhdGljQ2xhc3M6XCJ2dWUtZGlhbG9nLWNvbnRlbnQtdGl0bGVcIixkb21Qcm9wczp7aW5uZXJIVE1MOm4uX3Mobi5wYXJhbXMudGl0bGV8fFwiXCIpfX0pOm4uX2UoKSxuLl92KFwiIFwiKSxuLnBhcmFtcy5jb21wb25lbnQ/aShuLnBhcmFtcy5jb21wb25lbnQsbi5fYih7dGFnOlwiY29tcG9uZW50XCJ9LFwiY29tcG9uZW50XCIsbi5wYXJhbXMucHJvcHMsITEpKTppKFwiZGl2XCIse2RvbVByb3BzOntpbm5lckhUTUw6bi5fcyhuLnBhcmFtcy50ZXh0fHxcIlwiKX19KV0sMSksbi5fdihcIiBcIiksbi5idXR0b25zP2koXCJkaXZcIix7c3RhdGljQ2xhc3M6XCJ2dWUtZGlhbG9nLWJ1dHRvbnNcIn0sbi5fbChuLmJ1dHRvbnMsZnVuY3Rpb24odCxlKXtyZXR1cm4gaShcImJ1dHRvblwiLHtrZXk6ZSxjbGFzczp0LmNsYXNzfHxcInZ1ZS1kaWFsb2ctYnV0dG9uXCIsc3R5bGU6bi5idXR0b25TdHlsZSxhdHRyczp7dHlwZTpcImJ1dHRvblwiLHRhYmluZGV4OlwiMFwifSxkb21Qcm9wczp7aW5uZXJIVE1MOm4uX3ModC50aXRsZSl9LG9uOntjbGljazpmdW5jdGlvbih0KXtyZXR1cm4gdC5zdG9wUHJvcGFnYXRpb24oKSxuLmNsaWNrKGUsdCl9fX0sW24uX3Yobi5fcyh0LnRpdGxlKSldKX0pLDApOmkoXCJkaXZcIix7c3RhdGljQ2xhc3M6XCJ2dWUtZGlhbG9nLWJ1dHRvbnMtbm9uZVwifSldKX12YXIgVz1OLmV4cG9ydHM7RC5fd2l0aFN0cmlwcGVkPSEwO3ZhciBJPXtuYW1lOlwiVnVlSnNEaWFsb2dcIixwcm9wczp7d2lkdGg6e3R5cGU6W051bWJlcixTdHJpbmddLGRlZmF1bHQ6NDAwfSxjbGlja1RvQ2xvc2U6e3R5cGU6Qm9vbGVhbixkZWZhdWx0OiEwfSx0cmFuc2l0aW9uOnt0eXBlOlN0cmluZ319LGRhdGE6ZnVuY3Rpb24oKXtyZXR1cm57cGFyYW1zOnt9fX0sY29tcHV0ZWQ6e2J1dHRvbnM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wYXJhbXMuYnV0dG9uc3x8W119LGJ1dHRvblN0eWxlOmZ1bmN0aW9uKCl7cmV0dXJue2ZsZXg6XCIxIDEgXCIuY29uY2F0KDEwMC90aGlzLmJ1dHRvbnMubGVuZ3RoLFwiJVwiKX19fSxtZXRob2RzOntiZWZvcmVPcGVuZWQ6ZnVuY3Rpb24odCl7dGhpcy5wYXJhbXM9dC5wYXJhbXN8fHt9LHRoaXMuJGVtaXQoXCJiZWZvcmUtb3BlbmVkXCIsdCl9LGJlZm9yZUNsb3NlZDpmdW5jdGlvbih0KXt0aGlzLnBhcmFtcz17fSx0aGlzLiRlbWl0KFwiYmVmb3JlLWNsb3NlZFwiLHQpfSxjbGljazpmdW5jdGlvbih0LGUsbil7dmFyIGk9Mjxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1uP246XCJjbGlja1wiLG89dGhpcy5idXR0b25zW3RdLHI9bnVsbD09bz92b2lkIDA6by5oYW5kbGVyO1wiZnVuY3Rpb25cIj09dHlwZW9mIHImJnIodCxlLHtzb3VyY2U6aX0pfX19LFA9KG4oMTEpLGQoSSxELFtdLCExLG51bGwsbnVsbCxudWxsKSk7UC5vcHRpb25zLl9fZmlsZT1cInNyYy9jb21wb25lbnRzL0RpYWxvZy52dWVcIjtmdW5jdGlvbiBCKCl7dmFyIG49dGhpcyx0PW4uJGNyZWF0ZUVsZW1lbnQsaT1uLl9zZWxmLl9jfHx0O3JldHVybiBpKFwiZGl2XCIse2F0dHJzOntpZDpcIm1vZGFscy1jb250YWluZXJcIn19LG4uX2wobi5tb2RhbHMsZnVuY3Rpb24oZSl7cmV0dXJuIGkoXCJtb2RhbFwiLG4uX2cobi5fYih7a2V5OmUuaWQsb246e2Nsb3NlZDpmdW5jdGlvbih0KXtyZXR1cm4gbi5yZW1vdmUoZS5pZCl9fX0sXCJtb2RhbFwiLGUubW9kYWxBdHRycywhMSksZS5tb2RhbExpc3RlbmVycyksW2koZS5jb21wb25lbnQsbi5fZyhuLl9iKHt0YWc6XCJjb21wb25lbnRcIixvbjp7Y2xvc2U6ZnVuY3Rpb24odCl7cmV0dXJuIG4uJG1vZGFsLmhpZGUoZS5tb2RhbEF0dHJzLm5hbWUsdCl9fX0sXCJjb21wb25lbnRcIixlLmNvbXBvbmVudEF0dHJzLCExKSxuLiRsaXN0ZW5lcnMpKV0sMSl9KSwxKX12YXIgWD1QLmV4cG9ydHM7ZnVuY3Rpb24gWSh0LGUsbil7cmV0dXJuIGUgaW4gdD9PYmplY3QuZGVmaW5lUHJvcGVydHkodCxlLHt2YWx1ZTpuLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6dFtlXT1uLHR9Qi5fd2l0aFN0cmlwcGVkPSEwO3ZhciBHPWQoe2RhdGE6ZnVuY3Rpb24oKXtyZXR1cm57bW9kYWxzOltdfX0sY3JlYXRlZDpmdW5jdGlvbigpe3RoaXMuJHJvb3QuX19tb2RhbENvbnRhaW5lcj10aGlzfSxtb3VudGVkOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpczt0aGlzLiRtb2RhbC5zdWJzY3JpcHRpb24uJG9uKFwiaGlkZS1hbGxcIixmdW5jdGlvbigpe3QubW9kYWxzPVtdfSl9LG1ldGhvZHM6e2FkZDpmdW5jdGlvbih0LGUsbixpKXt2YXIgbz10aGlzLHI9MTxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1lP2U6e30scz0yPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PW4/bjp7fSxhPTM8YXJndW1lbnRzLmxlbmd0aCYmdm9pZCAwIT09aT9pOnt9LGw9YygpLHU9cy5uYW1lfHxcImR5bmFtaWNfbW9kYWxfXCIrbDt0aGlzLm1vZGFscy5wdXNoKHtpZDpsLG1vZGFsQXR0cnM6ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PTE7dDxhcmd1bWVudHMubGVuZ3RoO3QrKyl7dmFyIG49bnVsbCE9YXJndW1lbnRzW3RdP2FyZ3VtZW50c1t0XTp7fSxpPU9iamVjdC5rZXlzKG4pO1wiZnVuY3Rpb25cIj09dHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMmJihpPWkuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMobikuZmlsdGVyKGZ1bmN0aW9uKHQpe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4sdCkuZW51bWVyYWJsZX0pKSksaS5mb3JFYWNoKGZ1bmN0aW9uKHQpe1koZSx0LG5bdF0pfSl9cmV0dXJuIGV9KHt9LHMse25hbWU6dX0pLG1vZGFsTGlzdGVuZXJzOmEsY29tcG9uZW50OnQsY29tcG9uZW50QXR0cnM6cn0pLHRoaXMuJG5leHRUaWNrKGZ1bmN0aW9uKCl7by4kbW9kYWwuc2hvdyh1KX0pfSxyZW1vdmU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5tb2RhbHMuZmluZEluZGV4KGZ1bmN0aW9uKHQpe3JldHVybiB0LmlkPT09ZX0pOy0xIT09dCYmdGhpcy5tb2RhbHMuc3BsaWNlKHQsMSl9fX0sQixbXSwhMSxudWxsLG51bGwsbnVsbCk7Ry5vcHRpb25zLl9fZmlsZT1cInNyYy9jb21wb25lbnRzL01vZGFsc0NvbnRhaW5lci52dWVcIjt2YXIgVT1HLmV4cG9ydHM7ZnVuY3Rpb24gRih0KXtyZXR1cm4oRj1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0fTpmdW5jdGlvbih0KXtyZXR1cm4gdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZ0LmNvbnN0cnVjdG9yPT09U3ltYm9sJiZ0IT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiB0fSkodCl9ZnVuY3Rpb24gcSh0LGUsbil7cmV0dXJuIGUgaW4gdD9PYmplY3QuZGVmaW5lUHJvcGVydHkodCxlLHt2YWx1ZTpuLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6dFtlXT1uLHR9dmFyIFY9ZnVuY3Rpb24oaSx0KXtmdW5jdGlvbiBvKHQsZSxuLGkpe3ZhciBvLHI9Mjxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1uP246e30scz0zPGFyZ3VtZW50cy5sZW5ndGg/aTp2b2lkIDAsYT1udWxsPT09KG89Yy5yb290KXx8dm9pZCAwPT09bz92b2lkIDA6by5fX21vZGFsQ29udGFpbmVyLGw9dS5keW5hbWljRGVmYXVsdHN8fHt9O251bGwhPWEmJmEuYWRkKHQsZSxmdW5jdGlvbihlKXtmb3IodmFyIHQ9MTt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKXt2YXIgbj1udWxsIT1hcmd1bWVudHNbdF0/YXJndW1lbnRzW3RdOnt9LGk9T2JqZWN0LmtleXMobik7XCJmdW5jdGlvblwiPT10eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyYmKGk9aS5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhuKS5maWx0ZXIoZnVuY3Rpb24odCl7cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iobix0KS5lbnVtZXJhYmxlfSkpKSxpLmZvckVhY2goZnVuY3Rpb24odCl7cShlLHQsblt0XSl9KX1yZXR1cm4gZX0oe30sbCxyKSxzKX12YXIgdT0xPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PXQ/dDp7fSxyPW5ldyBpLGM9e3Jvb3Q6bnVsbCxjb21wb25lbnROYW1lOnUuY29tcG9uZW50TmFtZXx8XCJNb2RhbFwifTtyZXR1cm57Y29udGV4dDpjLHN1YnNjcmlwdGlvbjpyLHNob3c6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9YXJndW1lbnRzLmxlbmd0aCxlPW5ldyBBcnJheSh0KSxuPTA7bjx0O24rKyllW25dPWFyZ3VtZW50c1tuXTt2YXIgaT1lWzBdO3N3aXRjaChGKGkpKXtjYXNlXCJzdHJpbmdcIjooZnVuY3Rpb24odCxlKXtyLiRlbWl0KFwidG9nZ2xlXCIsdCwhMCxlKX0pLmFwcGx5KHZvaWQgMCxlKTticmVhaztjYXNlXCJvYmplY3RcIjpjYXNlXCJmdW5jdGlvblwiOm8uYXBwbHkodm9pZCAwLGUpO2JyZWFrO2RlZmF1bHQ6Y29uc29sZS53YXJuKFwiW3Z1ZS1qcy1tb2RhbF0gJG1vZGFsKCkgcmVjZWl2ZWQgYW4gdW5zdXBwb3J0ZWQgYXJndW1lbnQgYXMgYSBmaXJzdCBhcmd1bWVudC5cIixpKX19LGhpZGU6ZnVuY3Rpb24odCxlKXtyLiRlbWl0KFwidG9nZ2xlXCIsdCwhMSxlKX0saGlkZUFsbDpmdW5jdGlvbigpe3IuJGVtaXQoXCJoaWRlLWFsbFwiKX0sdG9nZ2xlOmZ1bmN0aW9uKHQsZSl7ci4kZW1pdChcInRvZ2dsZVwiLHQsdm9pZCAwLGUpfSxzZXREeW5hbWljTW9kYWxDb250YWluZXI6ZnVuY3Rpb24odCl7Yy5yb290PXQ7dmFyIGUsbj0oZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZSksZSk7bmV3IGkoe3BhcmVudDp0LHJlbmRlcjpmdW5jdGlvbih0KXtyZXR1cm4gdChVKX19KS4kbW91bnQobil9fX0sSz17aW5zdGFsbDpmdW5jdGlvbihlLHQpe3ZhciBuPTE8YXJndW1lbnRzLmxlbmd0aCYmdm9pZCAwIT09dD90Ont9O2lmKCFlLnByb3RvdHlwZS4kbW9kYWwpe3ZhciBpPW5ldyBWKGUsbik7aWYoT2JqZWN0LmRlZmluZVByb3BlcnR5KGUucHJvdG90eXBlLFwiJG1vZGFsXCIse2dldDpmdW5jdGlvbigpe2lmKHRoaXMgaW5zdGFuY2VvZiBlKXt2YXIgdD10aGlzLiRyb290O2kuY29udGV4dC5yb290fHxpLnNldER5bmFtaWNNb2RhbENvbnRhaW5lcih0KX1yZXR1cm4gaX19KSxlLmNvbXBvbmVudChpLmNvbnRleHQuY29tcG9uZW50TmFtZSxXKSxuLmRpYWxvZyl7dmFyIG89bi5kaWFsb2dDb21wb25lbnROYW1lfHxcIlZEaWFsb2dcIjtlLmNvbXBvbmVudChvLFgpfX19fSxKPVwiX19WRVJTSU9OX19cIjtlLmRlZmF1bHQ9S31dLG8uYz1pLG8uZD1mdW5jdGlvbih0LGUsbil7by5vKHQsZSl8fE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGUse2VudW1lcmFibGU6ITAsZ2V0Om59KX0sby5yPWZ1bmN0aW9uKHQpe1widW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJlN5bWJvbC50b1N0cmluZ1RhZyYmT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsU3ltYm9sLnRvU3RyaW5nVGFnLHt2YWx1ZTpcIk1vZHVsZVwifSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSl9LG8udD1mdW5jdGlvbihlLHQpe2lmKDEmdCYmKGU9byhlKSksOCZ0KXJldHVybiBlO2lmKDQmdCYmXCJvYmplY3RcIj09dHlwZW9mIGUmJmUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgbj1PYmplY3QuY3JlYXRlKG51bGwpO2lmKG8ucihuKSxPYmplY3QuZGVmaW5lUHJvcGVydHkobixcImRlZmF1bHRcIix7ZW51bWVyYWJsZTohMCx2YWx1ZTplfSksMiZ0JiZcInN0cmluZ1wiIT10eXBlb2YgZSlmb3IodmFyIGkgaW4gZSlvLmQobixpLGZ1bmN0aW9uKHQpe3JldHVybiBlW3RdfS5iaW5kKG51bGwsaSkpO3JldHVybiBufSxvLm49ZnVuY3Rpb24odCl7dmFyIGU9dCYmdC5fX2VzTW9kdWxlP2Z1bmN0aW9uKCl7cmV0dXJuIHQuZGVmYXVsdH06ZnVuY3Rpb24oKXtyZXR1cm4gdH07cmV0dXJuIG8uZChlLFwiYVwiLGUpLGV9LG8ubz1mdW5jdGlvbih0LGUpe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxlKX0sby5wPVwiL2Rpc3QvXCIsbyhvLnM9MTMpO2Z1bmN0aW9uIG8odCl7aWYoaVt0XSlyZXR1cm4gaVt0XS5leHBvcnRzO3ZhciBlPWlbdF09e2k6dCxsOiExLGV4cG9ydHM6e319O3JldHVybiBuW3RdLmNhbGwoZS5leHBvcnRzLGUsZS5leHBvcnRzLG8pLGUubD0hMCxlLmV4cG9ydHN9dmFyIG4saX0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/vue-js-modal/dist/index.js\n");

/***/ }),

/***/ "./resources/js/App.vue":
/*!******************************!*\
  !*** ./resources/js/App.vue ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _App_vue_vue_type_template_id_f348271a___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./App.vue?vue&type=template&id=f348271a& */ \"./resources/js/App.vue?vue&type=template&id=f348271a&\");\n/* harmony import */ var _App_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./App.vue?vue&type=script&lang=js& */ \"./resources/js/App.vue?vue&type=script&lang=js&\");\n/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ \"./node_modules/vue-loader/lib/runtime/componentNormalizer.js\");\n\n\n\n\n\n/* normalize component */\n;\nvar component = (0,_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\n  _App_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n  _App_vue_vue_type_template_id_f348271a___WEBPACK_IMPORTED_MODULE_0__.render,\n  _App_vue_vue_type_template_id_f348271a___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* hot reload */\nif (false) { var api; }\ncomponent.options.__file = \"resources/js/App.vue\"\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvQXBwLnZ1ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWtGO0FBQzNCO0FBQ0w7OztBQUdsRDtBQUNBLENBQTBGO0FBQzFGLGdCQUFnQix1R0FBVTtBQUMxQixFQUFFLHlFQUFNO0FBQ1IsRUFBRSwyRUFBTTtBQUNSLEVBQUUsb0ZBQWU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSSxLQUFVLEVBQUUsWUFpQmY7QUFDRDtBQUNBLGlFQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2pzL0FwcC52dWU/OWZkNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IGZyb20gXCIuL0FwcC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9ZjM0ODI3MWEmXCJcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vQXBwLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuZXhwb3J0ICogZnJvbSBcIi4vQXBwLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbmltcG9ydCBub3JtYWxpemVyIGZyb20gXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qc1wiXG52YXIgY29tcG9uZW50ID0gbm9ybWFsaXplcihcbiAgc2NyaXB0LFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7XG4gIHZhciBhcGkgPSByZXF1aXJlKFwiL3Zhci93d3cvaHRtbC9rYW5iYW4tYm9hcmQvbm9kZV9tb2R1bGVzL3Z1ZS1ob3QtcmVsb2FkLWFwaS9kaXN0L2luZGV4LmpzXCIpXG4gIGFwaS5pbnN0YWxsKHJlcXVpcmUoJ3Z1ZScpKVxuICBpZiAoYXBpLmNvbXBhdGlibGUpIHtcbiAgICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gICAgaWYgKCFhcGkuaXNSZWNvcmRlZCgnZjM0ODI3MWEnKSkge1xuICAgICAgYXBpLmNyZWF0ZVJlY29yZCgnZjM0ODI3MWEnLCBjb21wb25lbnQub3B0aW9ucylcbiAgICB9IGVsc2Uge1xuICAgICAgYXBpLnJlbG9hZCgnZjM0ODI3MWEnLCBjb21wb25lbnQub3B0aW9ucylcbiAgICB9XG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIuL0FwcC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9ZjM0ODI3MWEmXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGFwaS5yZXJlbmRlcignZjM0ODI3MWEnLCB7XG4gICAgICAgIHJlbmRlcjogcmVuZGVyLFxuICAgICAgICBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZuc1xuICAgICAgfSlcbiAgICB9KVxuICB9XG59XG5jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInJlc291cmNlcy9qcy9BcHAudnVlXCJcbmV4cG9ydCBkZWZhdWx0IGNvbXBvbmVudC5leHBvcnRzIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/App.vue\n");

/***/ }),

/***/ "./resources/js/components/Child.vue":
/*!*******************************************!*\
  !*** ./resources/js/components/Child.vue ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Child_vue_vue_type_template_id_66ab007e___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Child.vue?vue&type=template&id=66ab007e& */ \"./resources/js/components/Child.vue?vue&type=template&id=66ab007e&\");\n/* harmony import */ var _Child_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Child.vue?vue&type=script&lang=js& */ \"./resources/js/components/Child.vue?vue&type=script&lang=js&\");\n/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ \"./node_modules/vue-loader/lib/runtime/componentNormalizer.js\");\n\n\n\n\n\n/* normalize component */\n;\nvar component = (0,_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\n  _Child_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n  _Child_vue_vue_type_template_id_66ab007e___WEBPACK_IMPORTED_MODULE_0__.render,\n  _Child_vue_vue_type_template_id_66ab007e___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* hot reload */\nif (false) { var api; }\ncomponent.options.__file = \"resources/js/components/Child.vue\"\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9DaGlsZC52dWUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFvRjtBQUMzQjtBQUNMOzs7QUFHcEQ7QUFDQSxDQUE2RjtBQUM3RixnQkFBZ0IsdUdBQVU7QUFDMUIsRUFBRSwyRUFBTTtBQUNSLEVBQUUsNkVBQU07QUFDUixFQUFFLHNGQUFlO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksS0FBVSxFQUFFLFlBaUJmO0FBQ0Q7QUFDQSxpRUFBZSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9qcy9jb21wb25lbnRzL0NoaWxkLnZ1ZT8xNDBmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0gZnJvbSBcIi4vQ2hpbGQudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTY2YWIwMDdlJlwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL0NoaWxkLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuZXhwb3J0ICogZnJvbSBcIi4vQ2hpbGQudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuaW1wb3J0IG5vcm1hbGl6ZXIgZnJvbSBcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzXCJcbnZhciBjb21wb25lbnQgPSBub3JtYWxpemVyKFxuICBzY3JpcHQsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHtcbiAgdmFyIGFwaSA9IHJlcXVpcmUoXCIvdmFyL3d3dy9odG1sL2thbmJhbi1ib2FyZC9ub2RlX21vZHVsZXMvdnVlLWhvdC1yZWxvYWQtYXBpL2Rpc3QvaW5kZXguanNcIilcbiAgYXBpLmluc3RhbGwocmVxdWlyZSgndnVlJykpXG4gIGlmIChhcGkuY29tcGF0aWJsZSkge1xuICAgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgICBpZiAoIWFwaS5pc1JlY29yZGVkKCc2NmFiMDA3ZScpKSB7XG4gICAgICBhcGkuY3JlYXRlUmVjb3JkKCc2NmFiMDA3ZScsIGNvbXBvbmVudC5vcHRpb25zKVxuICAgIH0gZWxzZSB7XG4gICAgICBhcGkucmVsb2FkKCc2NmFiMDA3ZScsIGNvbXBvbmVudC5vcHRpb25zKVxuICAgIH1cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcIi4vQ2hpbGQudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTY2YWIwMDdlJlwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBhcGkucmVyZW5kZXIoJzY2YWIwMDdlJywge1xuICAgICAgICByZW5kZXI6IHJlbmRlcixcbiAgICAgICAgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnNcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxufVxuY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJyZXNvdXJjZXMvanMvY29tcG9uZW50cy9DaGlsZC52dWVcIlxuZXhwb3J0IGRlZmF1bHQgY29tcG9uZW50LmV4cG9ydHMiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/js/components/Child.vue\n");

/***/ }),

/***/ "./resources/js/components/Loading.vue":
/*!*********************************************!*\
  !*** ./resources/js/components/Loading.vue ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Loading_vue_vue_type_template_id_6ca9e6be_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Loading.vue?vue&type=template&id=6ca9e6be&scoped=true& */ \"./resources/js/components/Loading.vue?vue&type=template&id=6ca9e6be&scoped=true&\");\n/* harmony import */ var _Loading_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Loading.vue?vue&type=script&lang=js& */ \"./resources/js/components/Loading.vue?vue&type=script&lang=js&\");\n/* harmony import */ var _Loading_vue_vue_type_style_index_0_id_6ca9e6be_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Loading.vue?vue&type=style&index=0&id=6ca9e6be&scoped=true&lang=css& */ \"./resources/js/components/Loading.vue?vue&type=style&index=0&id=6ca9e6be&scoped=true&lang=css&\");\n/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ \"./node_modules/vue-loader/lib/runtime/componentNormalizer.js\");\n\n\n\n;\n\n\n/* normalize component */\n\nvar component = (0,_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(\n  _Loading_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n  _Loading_vue_vue_type_template_id_6ca9e6be_scoped_true___WEBPACK_IMPORTED_MODULE_0__.render,\n  _Loading_vue_vue_type_template_id_6ca9e6be_scoped_true___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,\n  false,\n  null,\n  \"6ca9e6be\",\n  null\n  \n)\n\n/* hot reload */\nif (false) { var api; }\ncomponent.options.__file = \"resources/js/components/Loading.vue\"\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9Mb2FkaW5nLnZ1ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFrRztBQUN2QztBQUNMO0FBQ3RELENBQTJGOzs7QUFHM0Y7QUFDNkY7QUFDN0YsZ0JBQWdCLHVHQUFVO0FBQzFCLEVBQUUsNkVBQU07QUFDUixFQUFFLDJGQUFNO0FBQ1IsRUFBRSxvR0FBZTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLEtBQVUsRUFBRSxZQWlCZjtBQUNEO0FBQ0EsaUVBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9Mb2FkaW5nLnZ1ZT9hODQ3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0gZnJvbSBcIi4vTG9hZGluZy52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NmNhOWU2YmUmc2NvcGVkPXRydWUmXCJcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vTG9hZGluZy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCJcbmV4cG9ydCAqIGZyb20gXCIuL0xvYWRpbmcudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5pbXBvcnQgc3R5bGUwIGZyb20gXCIuL0xvYWRpbmcudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9NmNhOWU2YmUmc2NvcGVkPXRydWUmbGFuZz1jc3MmXCJcblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5pbXBvcnQgbm9ybWFsaXplciBmcm9tIFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudE5vcm1hbGl6ZXIuanNcIlxudmFyIGNvbXBvbmVudCA9IG5vcm1hbGl6ZXIoXG4gIHNjcmlwdCxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBcIjZjYTllNmJlXCIsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7XG4gIHZhciBhcGkgPSByZXF1aXJlKFwiL3Zhci93d3cvaHRtbC9rYW5iYW4tYm9hcmQvbm9kZV9tb2R1bGVzL3Z1ZS1ob3QtcmVsb2FkLWFwaS9kaXN0L2luZGV4LmpzXCIpXG4gIGFwaS5pbnN0YWxsKHJlcXVpcmUoJ3Z1ZScpKVxuICBpZiAoYXBpLmNvbXBhdGlibGUpIHtcbiAgICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gICAgaWYgKCFhcGkuaXNSZWNvcmRlZCgnNmNhOWU2YmUnKSkge1xuICAgICAgYXBpLmNyZWF0ZVJlY29yZCgnNmNhOWU2YmUnLCBjb21wb25lbnQub3B0aW9ucylcbiAgICB9IGVsc2Uge1xuICAgICAgYXBpLnJlbG9hZCgnNmNhOWU2YmUnLCBjb21wb25lbnQub3B0aW9ucylcbiAgICB9XG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIuL0xvYWRpbmcudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTZjYTllNmJlJnNjb3BlZD10cnVlJlwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBhcGkucmVyZW5kZXIoJzZjYTllNmJlJywge1xuICAgICAgICByZW5kZXI6IHJlbmRlcixcbiAgICAgICAgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnNcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxufVxuY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJyZXNvdXJjZXMvanMvY29tcG9uZW50cy9Mb2FkaW5nLnZ1ZVwiXG5leHBvcnQgZGVmYXVsdCBjb21wb25lbnQuZXhwb3J0cyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/js/components/Loading.vue\n");

/***/ }),

/***/ "./resources/js/layouts/default.vue":
/*!******************************************!*\
  !*** ./resources/js/layouts/default.vue ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _default_vue_vue_type_template_id_06bc2b2d___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./default.vue?vue&type=template&id=06bc2b2d& */ \"./resources/js/layouts/default.vue?vue&type=template&id=06bc2b2d&\");\n/* harmony import */ var _default_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./default.vue?vue&type=script&lang=js& */ \"./resources/js/layouts/default.vue?vue&type=script&lang=js&\");\n/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ \"./node_modules/vue-loader/lib/runtime/componentNormalizer.js\");\n\n\n\n\n\n/* normalize component */\n;\nvar component = (0,_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\n  _default_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n  _default_vue_vue_type_template_id_06bc2b2d___WEBPACK_IMPORTED_MODULE_0__.render,\n  _default_vue_vue_type_template_id_06bc2b2d___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* hot reload */\nif (false) { var api; }\ncomponent.options.__file = \"resources/js/layouts/default.vue\"\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvbGF5b3V0cy9kZWZhdWx0LnZ1ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXNGO0FBQzNCO0FBQ0w7OztBQUd0RDtBQUNBLENBQTZGO0FBQzdGLGdCQUFnQix1R0FBVTtBQUMxQixFQUFFLDZFQUFNO0FBQ1IsRUFBRSwrRUFBTTtBQUNSLEVBQUUsd0ZBQWU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSSxLQUFVLEVBQUUsWUFpQmY7QUFDRDtBQUNBLGlFQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2pzL2xheW91dHMvZGVmYXVsdC52dWU/MmRjYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IGZyb20gXCIuL2RlZmF1bHQudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTA2YmMyYjJkJlwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL2RlZmF1bHQudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5leHBvcnQgKiBmcm9tIFwiLi9kZWZhdWx0LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbmltcG9ydCBub3JtYWxpemVyIGZyb20gXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qc1wiXG52YXIgY29tcG9uZW50ID0gbm9ybWFsaXplcihcbiAgc2NyaXB0LFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIG51bGwsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7XG4gIHZhciBhcGkgPSByZXF1aXJlKFwiL3Zhci93d3cvaHRtbC9rYW5iYW4tYm9hcmQvbm9kZV9tb2R1bGVzL3Z1ZS1ob3QtcmVsb2FkLWFwaS9kaXN0L2luZGV4LmpzXCIpXG4gIGFwaS5pbnN0YWxsKHJlcXVpcmUoJ3Z1ZScpKVxuICBpZiAoYXBpLmNvbXBhdGlibGUpIHtcbiAgICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gICAgaWYgKCFhcGkuaXNSZWNvcmRlZCgnMDZiYzJiMmQnKSkge1xuICAgICAgYXBpLmNyZWF0ZVJlY29yZCgnMDZiYzJiMmQnLCBjb21wb25lbnQub3B0aW9ucylcbiAgICB9IGVsc2Uge1xuICAgICAgYXBpLnJlbG9hZCgnMDZiYzJiMmQnLCBjb21wb25lbnQub3B0aW9ucylcbiAgICB9XG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIuL2RlZmF1bHQudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTA2YmMyYjJkJlwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBhcGkucmVyZW5kZXIoJzA2YmMyYjJkJywge1xuICAgICAgICByZW5kZXI6IHJlbmRlcixcbiAgICAgICAgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnNcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxufVxuY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJyZXNvdXJjZXMvanMvbGF5b3V0cy9kZWZhdWx0LnZ1ZVwiXG5leHBvcnQgZGVmYXVsdCBjb21wb25lbnQuZXhwb3J0cyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/js/layouts/default.vue\n");

/***/ }),

/***/ "./resources/js/App.vue?vue&type=script&lang=js&":
/*!*******************************************************!*\
  !*** ./resources/js/App.vue?vue&type=script&lang=js& ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_App_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./App.vue?vue&type=script&lang=js& */ \"./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/App.vue?vue&type=script&lang=js&\");\n /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_App_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__[\"default\"]); //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvQXBwLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBMkwsQ0FBQyxpRUFBZSw4TEFBRyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2pzL0FwcC52dWU/YTJjZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbW9kIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTUudXNlWzBdIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vQXBwLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIjsgZXhwb3J0IGRlZmF1bHQgbW9kOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC01LnVzZVswXSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0FwcC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCIiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/js/App.vue?vue&type=script&lang=js&\n");

/***/ }),

/***/ "./resources/js/components/Child.vue?vue&type=script&lang=js&":
/*!********************************************************************!*\
  !*** ./resources/js/components/Child.vue?vue&type=script&lang=js& ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Child_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Child.vue?vue&type=script&lang=js& */ \"./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/components/Child.vue?vue&type=script&lang=js&\");\n /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Child_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__[\"default\"]); //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9DaGlsZC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQW1NLENBQUMsaUVBQWUsZ01BQUcsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3Jlc291cmNlcy9qcy9jb21wb25lbnRzL0NoaWxkLnZ1ZT81MDk1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtNS51c2VbMF0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9DaGlsZC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCI7IGV4cG9ydCBkZWZhdWx0IG1vZDsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtNS51c2VbMF0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9DaGlsZC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCIiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/js/components/Child.vue?vue&type=script&lang=js&\n");

/***/ }),

/***/ "./resources/js/components/Loading.vue?vue&type=script&lang=js&":
/*!**********************************************************************!*\
  !*** ./resources/js/components/Loading.vue?vue&type=script&lang=js& ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Loading_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Loading.vue?vue&type=script&lang=js& */ \"./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/components/Loading.vue?vue&type=script&lang=js&\");\n /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Loading_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__[\"default\"]); //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9Mb2FkaW5nLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBcU0sQ0FBQyxpRUFBZSxrTUFBRyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2pzL2NvbXBvbmVudHMvTG9hZGluZy52dWU/YmNjMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbW9kIGZyb20gXCItIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTUudXNlWzBdIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vTG9hZGluZy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCI7IGV4cG9ydCBkZWZhdWx0IG1vZDsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtNS51c2VbMF0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9Mb2FkaW5nLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/js/components/Loading.vue?vue&type=script&lang=js&\n");

/***/ }),

/***/ "./resources/js/layouts/default.vue?vue&type=script&lang=js&":
/*!*******************************************************************!*\
  !*** ./resources/js/layouts/default.vue?vue&type=script&lang=js& ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_default_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./default.vue?vue&type=script&lang=js& */ \"./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/layouts/default.vue?vue&type=script&lang=js&\");\n /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_default_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__[\"default\"]); //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvbGF5b3V0cy9kZWZhdWx0LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBcU0sQ0FBQyxpRUFBZSxrTUFBRyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2pzL2xheW91dHMvZGVmYXVsdC52dWU/ZmM0NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbW9kIGZyb20gXCItIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTUudXNlWzBdIS4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vZGVmYXVsdC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCI7IGV4cG9ydCBkZWZhdWx0IG1vZDsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtNS51c2VbMF0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9kZWZhdWx0LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/js/layouts/default.vue?vue&type=script&lang=js&\n");

/***/ }),

/***/ "./resources/js/App.vue?vue&type=template&id=f348271a&":
/*!*************************************************************!*\
  !*** ./resources/js/App.vue?vue&type=template&id=f348271a& ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_lib_index_js_vue_loader_options_App_vue_vue_type_template_id_f348271a___WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   "staticRenderFns": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_lib_index_js_vue_loader_options_App_vue_vue_type_template_id_f348271a___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_lib_index_js_vue_loader_options_App_vue_vue_type_template_id_f348271a___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[2]!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./App.vue?vue&type=template&id=f348271a& */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/App.vue?vue&type=template&id=f348271a&");


/***/ }),

/***/ "./resources/js/components/Child.vue?vue&type=template&id=66ab007e&":
/*!**************************************************************************!*\
  !*** ./resources/js/components/Child.vue?vue&type=template&id=66ab007e& ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Child_vue_vue_type_template_id_66ab007e___WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   "staticRenderFns": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Child_vue_vue_type_template_id_66ab007e___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Child_vue_vue_type_template_id_66ab007e___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[2]!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Child.vue?vue&type=template&id=66ab007e& */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/components/Child.vue?vue&type=template&id=66ab007e&");


/***/ }),

/***/ "./resources/js/components/Loading.vue?vue&type=template&id=6ca9e6be&scoped=true&":
/*!****************************************************************************************!*\
  !*** ./resources/js/components/Loading.vue?vue&type=template&id=6ca9e6be&scoped=true& ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Loading_vue_vue_type_template_id_6ca9e6be_scoped_true___WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   "staticRenderFns": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Loading_vue_vue_type_template_id_6ca9e6be_scoped_true___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Loading_vue_vue_type_template_id_6ca9e6be_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[2]!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Loading.vue?vue&type=template&id=6ca9e6be&scoped=true& */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/components/Loading.vue?vue&type=template&id=6ca9e6be&scoped=true&");


/***/ }),

/***/ "./resources/js/layouts/default.vue?vue&type=template&id=06bc2b2d&":
/*!*************************************************************************!*\
  !*** ./resources/js/layouts/default.vue?vue&type=template&id=06bc2b2d& ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_lib_index_js_vue_loader_options_default_vue_vue_type_template_id_06bc2b2d___WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   "staticRenderFns": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_lib_index_js_vue_loader_options_default_vue_vue_type_template_id_06bc2b2d___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_lib_loaders_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_lib_index_js_vue_loader_options_default_vue_vue_type_template_id_06bc2b2d___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[2]!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./default.vue?vue&type=template&id=06bc2b2d& */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/lib/loaders/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/layouts/default.vue?vue&type=template&id=06bc2b2d&");


/***/ }),

/***/ "./resources/js/components/Loading.vue?vue&type=style&index=0&id=6ca9e6be&scoped=true&lang=css&":
/*!******************************************************************************************************!*\
  !*** ./resources/js/components/Loading.vue?vue&type=style&index=0&id=6ca9e6be&scoped=true&lang=css& ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_clonedRuleSet_9_use_0_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_9_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_9_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Loading_vue_vue_type_style_index_0_id_6ca9e6be_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/mini-css-extract-plugin/dist/loader.js??clonedRuleSet-9.use[0]!../../../node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Loading.vue?vue&type=style&index=0&id=6ca9e6be&scoped=true&lang=css& */ "./node_modules/mini-css-extract-plugin/dist/loader.js??clonedRuleSet-9.use[0]!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/components/Loading.vue?vue&type=style&index=0&id=6ca9e6be&scoped=true&lang=css&");


/***/ }),

/***/ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js":
/*!********************************************************************!*\
  !*** ./node_modules/vue-loader/lib/runtime/componentNormalizer.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ normalizeComponent)\n/* harmony export */ });\n/* globals __VUE_SSR_CONTEXT__ */\n\n// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).\n// This module is a runtime utility for cleaner component module output and will\n// be included in the final webpack user bundle.\n\nfunction normalizeComponent(\n  scriptExports,\n  render,\n  staticRenderFns,\n  functionalTemplate,\n  injectStyles,\n  scopeId,\n  moduleIdentifier /* server only */,\n  shadowMode /* vue-cli only */\n) {\n  // Vue.extend constructor export interop\n  var options =\n    typeof scriptExports === 'function' ? scriptExports.options : scriptExports\n\n  // render functions\n  if (render) {\n    options.render = render\n    options.staticRenderFns = staticRenderFns\n    options._compiled = true\n  }\n\n  // functional template\n  if (functionalTemplate) {\n    options.functional = true\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = 'data-v-' + scopeId\n  }\n\n  var hook\n  if (moduleIdentifier) {\n    // server build\n    hook = function (context) {\n      // 2.3 injection\n      context =\n        context || // cached call\n        (this.$vnode && this.$vnode.ssrContext) || // stateful\n        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional\n      // 2.2 with runInNewContext: true\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n        context = __VUE_SSR_CONTEXT__\n      }\n      // inject component styles\n      if (injectStyles) {\n        injectStyles.call(this, context)\n      }\n      // register component module identifier for async chunk inferrence\n      if (context && context._registeredComponents) {\n        context._registeredComponents.add(moduleIdentifier)\n      }\n    }\n    // used by ssr in case component is cached and beforeCreate\n    // never gets called\n    options._ssrRegister = hook\n  } else if (injectStyles) {\n    hook = shadowMode\n      ? function () {\n          injectStyles.call(\n            this,\n            (options.functional ? this.parent : this).$root.$options.shadowRoot\n          )\n        }\n      : injectStyles\n  }\n\n  if (hook) {\n    if (options.functional) {\n      // for template-only hot-reload because in that case the render fn doesn't\n      // go through the normalizer\n      options._injectStyles = hook\n      // register for functional component in vue file\n      var originalRender = options.render\n      options.render = function renderWithStyleInjection(h, context) {\n        hook.call(context)\n        return originalRender(h, context)\n      }\n    } else {\n      // inject component registration as beforeCreate hook\n      var existing = options.beforeCreate\n      options.beforeCreate = existing ? [].concat(existing, hook) : [hook]\n    }\n  }\n\n  return {\n    exports: scriptExports,\n    options: options\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudE5vcm1hbGl6ZXIuanM/YWUwYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBnbG9iYWxzIF9fVlVFX1NTUl9DT05URVhUX18gKi9cblxuLy8gSU1QT1JUQU5UOiBEbyBOT1QgdXNlIEVTMjAxNSBmZWF0dXJlcyBpbiB0aGlzIGZpbGUgKGV4Y2VwdCBmb3IgbW9kdWxlcykuXG4vLyBUaGlzIG1vZHVsZSBpcyBhIHJ1bnRpbWUgdXRpbGl0eSBmb3IgY2xlYW5lciBjb21wb25lbnQgbW9kdWxlIG91dHB1dCBhbmQgd2lsbFxuLy8gYmUgaW5jbHVkZWQgaW4gdGhlIGZpbmFsIHdlYnBhY2sgdXNlciBidW5kbGUuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgc2NyaXB0RXhwb3J0cyxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZ1bmN0aW9uYWxUZW1wbGF0ZSxcbiAgaW5qZWN0U3R5bGVzLFxuICBzY29wZUlkLFxuICBtb2R1bGVJZGVudGlmaWVyIC8qIHNlcnZlciBvbmx5ICovLFxuICBzaGFkb3dNb2RlIC8qIHZ1ZS1jbGkgb25seSAqL1xuKSB7XG4gIC8vIFZ1ZS5leHRlbmQgY29uc3RydWN0b3IgZXhwb3J0IGludGVyb3BcbiAgdmFyIG9wdGlvbnMgPVxuICAgIHR5cGVvZiBzY3JpcHRFeHBvcnRzID09PSAnZnVuY3Rpb24nID8gc2NyaXB0RXhwb3J0cy5vcHRpb25zIDogc2NyaXB0RXhwb3J0c1xuXG4gIC8vIHJlbmRlciBmdW5jdGlvbnNcbiAgaWYgKHJlbmRlcikge1xuICAgIG9wdGlvbnMucmVuZGVyID0gcmVuZGVyXG4gICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnNcbiAgICBvcHRpb25zLl9jb21waWxlZCA9IHRydWVcbiAgfVxuXG4gIC8vIGZ1bmN0aW9uYWwgdGVtcGxhdGVcbiAgaWYgKGZ1bmN0aW9uYWxUZW1wbGF0ZSkge1xuICAgIG9wdGlvbnMuZnVuY3Rpb25hbCA9IHRydWVcbiAgfVxuXG4gIC8vIHNjb3BlZElkXG4gIGlmIChzY29wZUlkKSB7XG4gICAgb3B0aW9ucy5fc2NvcGVJZCA9ICdkYXRhLXYtJyArIHNjb3BlSWRcbiAgfVxuXG4gIHZhciBob29rXG4gIGlmIChtb2R1bGVJZGVudGlmaWVyKSB7XG4gICAgLy8gc2VydmVyIGJ1aWxkXG4gICAgaG9vayA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAvLyAyLjMgaW5qZWN0aW9uXG4gICAgICBjb250ZXh0ID1cbiAgICAgICAgY29udGV4dCB8fCAvLyBjYWNoZWQgY2FsbFxuICAgICAgICAodGhpcy4kdm5vZGUgJiYgdGhpcy4kdm5vZGUuc3NyQ29udGV4dCkgfHwgLy8gc3RhdGVmdWxcbiAgICAgICAgKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LiR2bm9kZSAmJiB0aGlzLnBhcmVudC4kdm5vZGUuc3NyQ29udGV4dCkgLy8gZnVuY3Rpb25hbFxuICAgICAgLy8gMi4yIHdpdGggcnVuSW5OZXdDb250ZXh0OiB0cnVlXG4gICAgICBpZiAoIWNvbnRleHQgJiYgdHlwZW9mIF9fVlVFX1NTUl9DT05URVhUX18gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnRleHQgPSBfX1ZVRV9TU1JfQ09OVEVYVF9fXG4gICAgICB9XG4gICAgICAvLyBpbmplY3QgY29tcG9uZW50IHN0eWxlc1xuICAgICAgaWYgKGluamVjdFN0eWxlcykge1xuICAgICAgICBpbmplY3RTdHlsZXMuY2FsbCh0aGlzLCBjb250ZXh0KVxuICAgICAgfVxuICAgICAgLy8gcmVnaXN0ZXIgY29tcG9uZW50IG1vZHVsZSBpZGVudGlmaWVyIGZvciBhc3luYyBjaHVuayBpbmZlcnJlbmNlXG4gICAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0Ll9yZWdpc3RlcmVkQ29tcG9uZW50cykge1xuICAgICAgICBjb250ZXh0Ll9yZWdpc3RlcmVkQ29tcG9uZW50cy5hZGQobW9kdWxlSWRlbnRpZmllcilcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdXNlZCBieSBzc3IgaW4gY2FzZSBjb21wb25lbnQgaXMgY2FjaGVkIGFuZCBiZWZvcmVDcmVhdGVcbiAgICAvLyBuZXZlciBnZXRzIGNhbGxlZFxuICAgIG9wdGlvbnMuX3NzclJlZ2lzdGVyID0gaG9va1xuICB9IGVsc2UgaWYgKGluamVjdFN0eWxlcykge1xuICAgIGhvb2sgPSBzaGFkb3dNb2RlXG4gICAgICA/IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpbmplY3RTdHlsZXMuY2FsbChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAob3B0aW9ucy5mdW5jdGlvbmFsID8gdGhpcy5wYXJlbnQgOiB0aGlzKS4kcm9vdC4kb3B0aW9ucy5zaGFkb3dSb290XG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICA6IGluamVjdFN0eWxlc1xuICB9XG5cbiAgaWYgKGhvb2spIHtcbiAgICBpZiAob3B0aW9ucy5mdW5jdGlvbmFsKSB7XG4gICAgICAvLyBmb3IgdGVtcGxhdGUtb25seSBob3QtcmVsb2FkIGJlY2F1c2UgaW4gdGhhdCBjYXNlIHRoZSByZW5kZXIgZm4gZG9lc24ndFxuICAgICAgLy8gZ28gdGhyb3VnaCB0aGUgbm9ybWFsaXplclxuICAgICAgb3B0aW9ucy5faW5qZWN0U3R5bGVzID0gaG9va1xuICAgICAgLy8gcmVnaXN0ZXIgZm9yIGZ1bmN0aW9uYWwgY29tcG9uZW50IGluIHZ1ZSBmaWxlXG4gICAgICB2YXIgb3JpZ2luYWxSZW5kZXIgPSBvcHRpb25zLnJlbmRlclxuICAgICAgb3B0aW9ucy5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXJXaXRoU3R5bGVJbmplY3Rpb24oaCwgY29udGV4dCkge1xuICAgICAgICBob29rLmNhbGwoY29udGV4dClcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsUmVuZGVyKGgsIGNvbnRleHQpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGluamVjdCBjb21wb25lbnQgcmVnaXN0cmF0aW9uIGFzIGJlZm9yZUNyZWF0ZSBob29rXG4gICAgICB2YXIgZXhpc3RpbmcgPSBvcHRpb25zLmJlZm9yZUNyZWF0ZVxuICAgICAgb3B0aW9ucy5iZWZvcmVDcmVhdGUgPSBleGlzdGluZyA/IFtdLmNvbmNhdChleGlzdGluZywgaG9vaykgOiBbaG9va11cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGV4cG9ydHM6IHNjcmlwdEV4cG9ydHMsXG4gICAgb3B0aW9uczogb3B0aW9uc1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/vue-loader/lib/runtime/componentNormalizer.js\n");

/***/ }),

/***/ "./node_modules/vue-meta/dist/vue-meta.esm.js":
/*!****************************************************!*\
  !*** ./node_modules/vue-meta/dist/vue-meta.esm.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var deepmerge__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! deepmerge */ \"./node_modules/deepmerge/dist/cjs.js\");\n/* harmony import */ var deepmerge__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(deepmerge__WEBPACK_IMPORTED_MODULE_0__);\n/**\n * vue-meta v2.4.0\n * (c) 2020\n * - Declan de Wet\n * - Sébastien Chopin (@Atinux)\n * - Pim (@pimlie)\n * - All the amazing contributors\n * @license MIT\n */\n\n\n\nvar version = \"2.4.0\";\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function () {};\n\n      return {\n        s: F,\n        n: function () {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function (e) {\n          throw e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function () {\n      it = o[Symbol.iterator]();\n    },\n    n: function () {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function (e) {\n      didErr = true;\n      err = e;\n    },\n    f: function () {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\n/**\n * checks if passed argument is an array\n * @param  {any}  arg - the object to check\n * @return {Boolean} - true if `arg` is an array\n */\nfunction isArray(arg) {\n  return Array.isArray(arg);\n}\nfunction isUndefined(arg) {\n  return typeof arg === 'undefined';\n}\nfunction isObject(arg) {\n  return _typeof(arg) === 'object';\n}\nfunction isPureObject(arg) {\n  return _typeof(arg) === 'object' && arg !== null;\n}\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\n\nfunction hasGlobalWindowFn() {\n  try {\n    return !isUndefined(window);\n  } catch (e) {\n    return false;\n  }\n}\nvar hasGlobalWindow = hasGlobalWindowFn();\n\nvar _global = hasGlobalWindow ? window : __webpack_require__.g;\n\nvar console = _global.console || {};\nfunction warn(str) {\n  /* istanbul ignore next */\n  if (!console || !console.warn) {\n    return;\n  }\n\n  console.warn(str);\n}\nvar showWarningNotSupported = function showWarningNotSupported() {\n  return warn('This vue app/component has no vue-meta configuration');\n};\n\n/**\n * These are constant variables used throughout the application.\n */\n// set some sane defaults\nvar defaultInfo = {\n  title: undefined,\n  titleChunk: '',\n  titleTemplate: '%s',\n  htmlAttrs: {},\n  bodyAttrs: {},\n  headAttrs: {},\n  base: [],\n  link: [],\n  meta: [],\n  style: [],\n  script: [],\n  noscript: [],\n  __dangerouslyDisableSanitizers: [],\n  __dangerouslyDisableSanitizersByTagID: {}\n};\nvar rootConfigKey = '_vueMeta'; // This is the name of the component option that contains all the information that\n// gets converted to the various meta tags & attributes for the page.\n\nvar keyName = 'metaInfo'; // This is the attribute vue-meta arguments on elements to know which it should\n// manage and which it should ignore.\n\nvar attribute = 'data-vue-meta'; // This is the attribute that goes on the `html` tag to inform `vue-meta`\n// that the server has already generated the meta tags for the initial render.\n\nvar ssrAttribute = 'data-vue-meta-server-rendered'; // This is the property that tells vue-meta to overwrite (instead of append)\n// an item in a tag list. For example, if you have two `meta` tag list items\n// that both have `vmid` of \"description\", then vue-meta will overwrite the\n// shallowest one with the deepest one.\n\nvar tagIDKeyName = 'vmid'; // This is the key name for possible meta templates\n\nvar metaTemplateKeyName = 'template'; // This is the key name for the content-holding property\n\nvar contentKeyName = 'content'; // The id used for the ssr app\n\nvar ssrAppId = 'ssr'; // How long meta update\n\nvar debounceWait = 10; // How long meta update\n\nvar waitOnDestroyed = true;\nvar defaultOptions = {\n  keyName: keyName,\n  attribute: attribute,\n  ssrAttribute: ssrAttribute,\n  tagIDKeyName: tagIDKeyName,\n  contentKeyName: contentKeyName,\n  metaTemplateKeyName: metaTemplateKeyName,\n  waitOnDestroyed: waitOnDestroyed,\n  debounceWait: debounceWait,\n  ssrAppId: ssrAppId\n}; // might be a bit ugly, but minimizes the browser bundles a bit\n\nvar defaultInfoKeys = Object.keys(defaultInfo); // The metaInfo property keys which are used to disable escaping\n\nvar disableOptionKeys = [defaultInfoKeys[12], defaultInfoKeys[13]]; // List of metaInfo property keys which are configuration options (and dont generate html)\n\nvar metaInfoOptionKeys = [defaultInfoKeys[1], defaultInfoKeys[2], 'changed'].concat(disableOptionKeys); // List of metaInfo property keys which only generates attributes and no tags\n\nvar metaInfoAttributeKeys = [defaultInfoKeys[3], defaultInfoKeys[4], defaultInfoKeys[5]]; // HTML elements which support the onload event\n\nvar tagsSupportingOnload = ['link', 'style', 'script']; // HTML elements which dont have a head tag (shortened to our needs)\n// see: https://www.w3.org/TR/html52/document-metadata.html\n\nvar tagsWithoutEndTag = ['base', 'meta', 'link']; // HTML elements which can have inner content (shortened to our needs)\n\nvar tagsWithInnerContent = ['noscript', 'script', 'style']; // Attributes which are inserted as childNodes instead of HTMLAttribute\n\nvar tagAttributeAsInnerContent = ['innerHTML', 'cssText', 'json'];\nvar tagProperties = ['once', 'skip', 'template']; // Attributes which should be added with data- prefix\n\nvar commonDataAttributes = ['body', 'pbody']; // from: https://github.com/kangax/html-minifier/blob/gh-pages/src/htmlminifier.js#L202\n\nvar booleanHtmlAttributes = ['allowfullscreen', 'amp', 'amp-boilerplate', 'async', 'autofocus', 'autoplay', 'checked', 'compact', 'controls', 'declare', 'default', 'defaultchecked', 'defaultmuted', 'defaultselected', 'defer', 'disabled', 'enabled', 'formnovalidate', 'hidden', 'indeterminate', 'inert', 'ismap', 'itemscope', 'loop', 'multiple', 'muted', 'nohref', 'noresize', 'noshade', 'novalidate', 'nowrap', 'open', 'pauseonexit', 'readonly', 'required', 'reversed', 'scoped', 'seamless', 'selected', 'sortable', 'truespeed', 'typemustmatch', 'visible'];\n\nvar batchId = null;\nfunction triggerUpdate(_ref, rootVm, hookName) {\n  var debounceWait = _ref.debounceWait;\n\n  // if an update was triggered during initialization or when an update was triggered by the\n  // metaInfo watcher, set initialized to null\n  // then we keep falsy value but know we need to run a triggerUpdate after initialization\n  if (!rootVm[rootConfigKey].initialized && (rootVm[rootConfigKey].initializing || hookName === 'watcher')) {\n    rootVm[rootConfigKey].initialized = null;\n  }\n\n  if (rootVm[rootConfigKey].initialized && !rootVm[rootConfigKey].pausing) {\n    // batch potential DOM updates to prevent extraneous re-rendering\n    // eslint-disable-next-line no-void\n    batchUpdate(function () {\n      return void rootVm.$meta().refresh();\n    }, debounceWait);\n  }\n}\n/**\n * Performs a batched update.\n *\n * @param  {(null|Number)} id - the ID of this update\n * @param  {Function} callback - the update to perform\n * @return {Number} id - a new ID\n */\n\nfunction batchUpdate(callback, timeout) {\n  timeout = timeout === undefined ? 10 : timeout;\n\n  if (!timeout) {\n    callback();\n    return;\n  }\n\n  clearTimeout(batchId);\n  batchId = setTimeout(function () {\n    callback();\n  }, timeout);\n  return batchId;\n}\n\n/*\n * To reduce build size, this file provides simple polyfills without\n * overly excessive type checking and without modifying\n * the global Array.prototype\n * The polyfills are automatically removed in the commonjs build\n * Also, only files in client/ & shared/ should use these functions\n * files in server/ still use normal js function\n */\nfunction find(array, predicate, thisArg) {\n  if ( !Array.prototype.find) {\n    // idx needs to be a Number, for..in returns string\n    for (var idx = 0; idx < array.length; idx++) {\n      if (predicate.call(thisArg, array[idx], idx, array)) {\n        return array[idx];\n      }\n    }\n\n    return;\n  }\n\n  return array.find(predicate, thisArg);\n}\nfunction findIndex(array, predicate, thisArg) {\n  if ( !Array.prototype.findIndex) {\n    // idx needs to be a Number, for..in returns string\n    for (var idx = 0; idx < array.length; idx++) {\n      if (predicate.call(thisArg, array[idx], idx, array)) {\n        return idx;\n      }\n    }\n\n    return -1;\n  }\n\n  return array.findIndex(predicate, thisArg);\n}\nfunction toArray(arg) {\n  if ( !Array.from) {\n    return Array.prototype.slice.call(arg);\n  }\n\n  return Array.from(arg);\n}\nfunction includes(array, value) {\n  if ( !Array.prototype.includes) {\n    for (var idx in array) {\n      if (array[idx] === value) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  return array.includes(value);\n}\n\nvar querySelector = function querySelector(arg, el) {\n  return (el || document).querySelectorAll(arg);\n};\nfunction getTag(tags, tag) {\n  if (!tags[tag]) {\n    tags[tag] = document.getElementsByTagName(tag)[0];\n  }\n\n  return tags[tag];\n}\nfunction getElementsKey(_ref) {\n  var body = _ref.body,\n      pbody = _ref.pbody;\n  return body ? 'body' : pbody ? 'pbody' : 'head';\n}\nfunction queryElements(parentNode, _ref2, attributes) {\n  var appId = _ref2.appId,\n      attribute = _ref2.attribute,\n      type = _ref2.type,\n      tagIDKeyName = _ref2.tagIDKeyName;\n  attributes = attributes || {};\n  var queries = [\"\".concat(type, \"[\").concat(attribute, \"=\\\"\").concat(appId, \"\\\"]\"), \"\".concat(type, \"[data-\").concat(tagIDKeyName, \"]\")].map(function (query) {\n    for (var key in attributes) {\n      var val = attributes[key];\n      var attributeValue = val && val !== true ? \"=\\\"\".concat(val, \"\\\"\") : '';\n      query += \"[data-\".concat(key).concat(attributeValue, \"]\");\n    }\n\n    return query;\n  });\n  return toArray(querySelector(queries.join(', '), parentNode));\n}\nfunction removeElementsByAppId(_ref3, appId) {\n  var attribute = _ref3.attribute;\n  toArray(querySelector(\"[\".concat(attribute, \"=\\\"\").concat(appId, \"\\\"]\"))).map(function (el) {\n    return el.remove();\n  });\n}\nfunction removeAttribute(el, attributeName) {\n  el.removeAttribute(attributeName);\n}\n\nfunction hasMetaInfo(vm) {\n  vm = vm || this;\n  return vm && (vm[rootConfigKey] === true || isObject(vm[rootConfigKey]));\n} // a component is in a metaInfo branch when itself has meta info or one of its (grand-)children has\n\nfunction inMetaInfoBranch(vm) {\n  vm = vm || this;\n  return vm && !isUndefined(vm[rootConfigKey]);\n}\n\nfunction pause(rootVm, refresh) {\n  rootVm[rootConfigKey].pausing = true;\n  return function () {\n    return resume(rootVm, refresh);\n  };\n}\nfunction resume(rootVm, refresh) {\n  rootVm[rootConfigKey].pausing = false;\n\n  if (refresh || refresh === undefined) {\n    return rootVm.$meta().refresh();\n  }\n}\n\nfunction addNavGuards(rootVm) {\n  var router = rootVm.$router; // return when nav guards already added or no router exists\n\n  if (rootVm[rootConfigKey].navGuards || !router) {\n    /* istanbul ignore next */\n    return;\n  }\n\n  rootVm[rootConfigKey].navGuards = true;\n  router.beforeEach(function (to, from, next) {\n    pause(rootVm);\n    next();\n  });\n  router.afterEach(function () {\n    rootVm.$nextTick(function () {\n      var _resume = resume(rootVm),\n          metaInfo = _resume.metaInfo;\n\n      if (metaInfo && isFunction(metaInfo.afterNavigation)) {\n        metaInfo.afterNavigation(metaInfo);\n      }\n    });\n  });\n}\n\nvar appId = 1;\nfunction createMixin(Vue, options) {\n  // for which Vue lifecycle hooks should the metaInfo be refreshed\n  var updateOnLifecycleHook = ['activated', 'deactivated', 'beforeMount'];\n  var wasServerRendered = false; // watch for client side component updates\n\n  return {\n    beforeCreate: function beforeCreate() {\n      var _this2 = this;\n\n      var rootKey = '$root';\n      var $root = this[rootKey];\n      var $options = this.$options;\n      var devtoolsEnabled = Vue.config.devtools;\n      Object.defineProperty(this, '_hasMetaInfo', {\n        configurable: true,\n        get: function get() {\n          // Show deprecation warning once when devtools enabled\n          if (devtoolsEnabled && !$root[rootConfigKey].deprecationWarningShown) {\n            warn('VueMeta DeprecationWarning: _hasMetaInfo has been deprecated and will be removed in a future version. Please use hasMetaInfo(vm) instead');\n            $root[rootConfigKey].deprecationWarningShown = true;\n          }\n\n          return hasMetaInfo(this);\n        }\n      });\n\n      if (this === $root) {\n        $root.$once('hook:beforeMount', function () {\n          wasServerRendered = this.$el && this.$el.nodeType === 1 && this.$el.hasAttribute('data-server-rendered'); // In most cases when you have a SSR app it will be the first app thats gonna be\n          // initiated, if we cant detect the data-server-rendered attribute from Vue but we\n          // do see our own ssrAttribute then _assume_ the Vue app with appId 1 is the ssr app\n          // attempted fix for #404 & #562, but we rly need to refactor how we pass appIds from\n          // ssr to the client\n\n          if (!wasServerRendered && $root[rootConfigKey] && $root[rootConfigKey].appId === 1) {\n            var htmlTag = getTag({}, 'html');\n            wasServerRendered = htmlTag && htmlTag.hasAttribute(options.ssrAttribute);\n          }\n        });\n      } // Add a marker to know if it uses metaInfo\n      // _vnode is used to know that it's attached to a real component\n      // useful if we use some mixin to add some meta tags (like nuxt-i18n)\n\n\n      if (isUndefined($options[options.keyName]) || $options[options.keyName] === null) {\n        return;\n      }\n\n      if (!$root[rootConfigKey]) {\n        $root[rootConfigKey] = {\n          appId: appId\n        };\n        appId++;\n\n        if (devtoolsEnabled && $root.$options[options.keyName]) {\n          // use nextTick so the children should be added to $root\n          this.$nextTick(function () {\n            // find the first child that lists fnOptions\n            var child = find($root.$children, function (c) {\n              return c.$vnode && c.$vnode.fnOptions;\n            });\n\n            if (child && child.$vnode.fnOptions[options.keyName]) {\n              warn(\"VueMeta has detected a possible global mixin which adds a \".concat(options.keyName, \" property to all Vue components on the page. This could cause severe performance issues. If possible, use $meta().addApp to add meta information instead\"));\n            }\n          });\n        }\n      } // to speed up updates we keep track of branches which have a component with vue-meta info defined\n      // if _vueMeta = true it has info, if _vueMeta = false a child has info\n\n\n      if (!this[rootConfigKey]) {\n        this[rootConfigKey] = true;\n        var parent = this.$parent;\n\n        while (parent && parent !== $root) {\n          if (isUndefined(parent[rootConfigKey])) {\n            parent[rootConfigKey] = false;\n          }\n\n          parent = parent.$parent;\n        }\n      } // coerce function-style metaInfo to a computed prop so we can observe\n      // it on creation\n\n\n      if (isFunction($options[options.keyName])) {\n        $options.computed = $options.computed || {};\n        $options.computed.$metaInfo = $options[options.keyName];\n\n        if (!this.$isServer) {\n          // if computed $metaInfo exists, watch it for updates & trigger a refresh\n          // when it changes (i.e. automatically handle async actions that affect metaInfo)\n          // credit for this suggestion goes to [Sébastien Chopin](https://github.com/Atinux)\n          this.$on('hook:created', function () {\n            this.$watch('$metaInfo', function () {\n              triggerUpdate(options, this[rootKey], 'watcher');\n            });\n          });\n        }\n      } // force an initial refresh on page load and prevent other lifecycleHooks\n      // to triggerUpdate until this initial refresh is finished\n      // this is to make sure that when a page is opened in an inactive tab which\n      // has throttled rAF/timers we still immediately set the page title\n\n\n      if (isUndefined($root[rootConfigKey].initialized)) {\n        $root[rootConfigKey].initialized = this.$isServer;\n\n        if (!$root[rootConfigKey].initialized) {\n          if (!$root[rootConfigKey].initializedSsr) {\n            $root[rootConfigKey].initializedSsr = true;\n            this.$on('hook:beforeMount', function () {\n              var $root = this[rootKey]; // if this Vue-app was server rendered, set the appId to 'ssr'\n              // only one SSR app per page is supported\n\n              if (wasServerRendered) {\n                $root[rootConfigKey].appId = options.ssrAppId;\n              }\n            });\n          } // we use the mounted hook here as on page load\n\n\n          this.$on('hook:mounted', function () {\n            var $root = this[rootKey];\n\n            if ($root[rootConfigKey].initialized) {\n              return;\n            } // used in triggerUpdate to check if a change was triggered\n            // during initialization\n\n\n            $root[rootConfigKey].initializing = true; // refresh meta in nextTick so all child components have loaded\n\n            this.$nextTick(function () {\n              var _$root$$meta$refresh = $root.$meta().refresh(),\n                  tags = _$root$$meta$refresh.tags,\n                  metaInfo = _$root$$meta$refresh.metaInfo; // After ssr hydration (identifier by tags === false) check\n              // if initialized was set to null in triggerUpdate. That'd mean\n              // that during initilazation changes where triggered which need\n              // to be applied OR a metaInfo watcher was triggered before the\n              // current hook was called\n              // (during initialization all changes are blocked)\n\n\n              if (tags === false && $root[rootConfigKey].initialized === null) {\n                this.$nextTick(function () {\n                  return triggerUpdate(options, $root, 'init');\n                });\n              }\n\n              $root[rootConfigKey].initialized = true;\n              delete $root[rootConfigKey].initializing; // add the navigation guards if they havent been added yet\n              // they are needed for the afterNavigation callback\n\n              if (!options.refreshOnceOnNavigation && metaInfo.afterNavigation) {\n                addNavGuards($root);\n              }\n            });\n          }); // add the navigation guards if requested\n\n          if (options.refreshOnceOnNavigation) {\n            addNavGuards($root);\n          }\n        }\n      }\n\n      this.$on('hook:destroyed', function () {\n        var _this = this;\n\n        // do not trigger refresh:\n        // - when user configured to not wait for transitions on destroyed\n        // - when the component doesnt have a parent\n        // - doesnt have metaInfo defined\n        if (!this.$parent || !hasMetaInfo(this)) {\n          return;\n        }\n\n        delete this._hasMetaInfo;\n        this.$nextTick(function () {\n          if (!options.waitOnDestroyed || !_this.$el || !_this.$el.offsetParent) {\n            triggerUpdate(options, _this.$root, 'destroyed');\n            return;\n          } // Wait that element is hidden before refreshing meta tags (to support animations)\n\n\n          var interval = setInterval(function () {\n            if (_this.$el && _this.$el.offsetParent !== null) {\n              /* istanbul ignore next line */\n              return;\n            }\n\n            clearInterval(interval);\n            triggerUpdate(options, _this.$root, 'destroyed');\n          }, 50);\n        });\n      }); // do not trigger refresh on the server side\n\n      if (this.$isServer) {\n        /* istanbul ignore next */\n        return;\n      } // no need to add this hooks on server side\n\n\n      updateOnLifecycleHook.forEach(function (lifecycleHook) {\n        _this2.$on(\"hook:\".concat(lifecycleHook), function () {\n          triggerUpdate(options, this[rootKey], lifecycleHook);\n        });\n      });\n    }\n  };\n}\n\nfunction setOptions(options) {\n  // combine options\n  options = isObject(options) ? options : {}; // The options are set like this so they can\n  // be minified by terser while keeping the\n  // user api intact\n  // terser --mangle-properties keep_quoted=strict\n\n  /* eslint-disable dot-notation */\n\n  return {\n    keyName: options['keyName'] || defaultOptions.keyName,\n    attribute: options['attribute'] || defaultOptions.attribute,\n    ssrAttribute: options['ssrAttribute'] || defaultOptions.ssrAttribute,\n    tagIDKeyName: options['tagIDKeyName'] || defaultOptions.tagIDKeyName,\n    contentKeyName: options['contentKeyName'] || defaultOptions.contentKeyName,\n    metaTemplateKeyName: options['metaTemplateKeyName'] || defaultOptions.metaTemplateKeyName,\n    debounceWait: isUndefined(options['debounceWait']) ? defaultOptions.debounceWait : options['debounceWait'],\n    waitOnDestroyed: isUndefined(options['waitOnDestroyed']) ? defaultOptions.waitOnDestroyed : options['waitOnDestroyed'],\n    ssrAppId: options['ssrAppId'] || defaultOptions.ssrAppId,\n    refreshOnceOnNavigation: !!options['refreshOnceOnNavigation']\n  };\n  /* eslint-enable dot-notation */\n}\nfunction getOptions(options) {\n  var optionsCopy = {};\n\n  for (var key in options) {\n    optionsCopy[key] = options[key];\n  }\n\n  return optionsCopy;\n}\n\nfunction ensureIsArray(arg, key) {\n  if (!key || !isObject(arg)) {\n    return isArray(arg) ? arg : [];\n  }\n\n  if (!isArray(arg[key])) {\n    arg[key] = [];\n  }\n\n  return arg;\n}\n\nvar serverSequences = [[/&/g, '&amp;'], [/</g, '&lt;'], [/>/g, '&gt;'], [/\"/g, '&quot;'], [/'/g, '&#x27;']];\nvar clientSequences = [[/&/g, \"&\"], [/</g, \"<\"], [/>/g, \">\"], [/\"/g, \"\\\"\"], [/'/g, \"'\"]]; // sanitizes potentially dangerous characters\n\nfunction escape(info, options, escapeOptions, escapeKeys) {\n  var tagIDKeyName = options.tagIDKeyName;\n  var _escapeOptions$doEsca = escapeOptions.doEscape,\n      doEscape = _escapeOptions$doEsca === void 0 ? function (v) {\n    return v;\n  } : _escapeOptions$doEsca;\n  var escaped = {};\n\n  for (var key in info) {\n    var value = info[key]; // no need to escape configuration options\n\n    if (includes(metaInfoOptionKeys, key)) {\n      escaped[key] = value;\n      continue;\n    } // do not use destructuring for disableOptionKeys, it increases transpiled size\n    // due to var checks while we are guaranteed the structure of the cb\n\n\n    var disableKey = disableOptionKeys[0];\n\n    if (escapeOptions[disableKey] && includes(escapeOptions[disableKey], key)) {\n      // this info[key] doesnt need to escaped if the option is listed in __dangerouslyDisableSanitizers\n      escaped[key] = value;\n      continue;\n    }\n\n    var tagId = info[tagIDKeyName];\n\n    if (tagId) {\n      disableKey = disableOptionKeys[1]; // keys which are listed in __dangerouslyDisableSanitizersByTagID for the current vmid do not need to be escaped\n\n      if (escapeOptions[disableKey] && escapeOptions[disableKey][tagId] && includes(escapeOptions[disableKey][tagId], key)) {\n        escaped[key] = value;\n        continue;\n      }\n    }\n\n    if (isString(value)) {\n      escaped[key] = doEscape(value);\n    } else if (isArray(value)) {\n      escaped[key] = value.map(function (v) {\n        if (isPureObject(v)) {\n          return escape(v, options, escapeOptions, true);\n        }\n\n        return doEscape(v);\n      });\n    } else if (isPureObject(value)) {\n      escaped[key] = escape(value, options, escapeOptions, true);\n    } else {\n      escaped[key] = value;\n    }\n\n    if (escapeKeys) {\n      var escapedKey = doEscape(key);\n\n      if (key !== escapedKey) {\n        escaped[escapedKey] = escaped[key];\n        delete escaped[key];\n      }\n    }\n  }\n\n  return escaped;\n}\nfunction escapeMetaInfo(options, info, escapeSequences) {\n  escapeSequences = escapeSequences || []; // do not use destructuring for seq, it increases transpiled size\n  // due to var checks while we are guaranteed the structure of the cb\n\n  var escapeOptions = {\n    doEscape: function doEscape(value) {\n      return escapeSequences.reduce(function (val, seq) {\n        return val.replace(seq[0], seq[1]);\n      }, value);\n    }\n  };\n  disableOptionKeys.forEach(function (disableKey, index) {\n    if (index === 0) {\n      ensureIsArray(info, disableKey);\n    } else if (index === 1) {\n      for (var key in info[disableKey]) {\n        ensureIsArray(info[disableKey], key);\n      }\n    }\n\n    escapeOptions[disableKey] = info[disableKey];\n  }); // begin sanitization\n\n  return escape(info, options, escapeOptions);\n}\n\nfunction applyTemplate(_ref, headObject, template, chunk) {\n  var component = _ref.component,\n      metaTemplateKeyName = _ref.metaTemplateKeyName,\n      contentKeyName = _ref.contentKeyName;\n\n  if (template === true || headObject[metaTemplateKeyName] === true) {\n    // abort, template was already applied\n    return false;\n  }\n\n  if (isUndefined(template) && headObject[metaTemplateKeyName]) {\n    template = headObject[metaTemplateKeyName];\n    headObject[metaTemplateKeyName] = true;\n  } // return early if no template defined\n\n\n  if (!template) {\n    // cleanup faulty template properties\n    delete headObject[metaTemplateKeyName];\n    return false;\n  }\n\n  if (isUndefined(chunk)) {\n    chunk = headObject[contentKeyName];\n  }\n\n  headObject[contentKeyName] = isFunction(template) ? template.call(component, chunk) : template.replace(/%s/g, chunk);\n  return true;\n}\n\nfunction _arrayMerge(_ref, target, source) {\n  var component = _ref.component,\n      tagIDKeyName = _ref.tagIDKeyName,\n      metaTemplateKeyName = _ref.metaTemplateKeyName,\n      contentKeyName = _ref.contentKeyName;\n  // we concat the arrays without merging objects contained in,\n  // but we check for a `vmid` property on each object in the array\n  // using an O(1) lookup associative array exploit\n  var destination = [];\n\n  if (!target.length && !source.length) {\n    return destination;\n  }\n\n  target.forEach(function (targetItem, targetIndex) {\n    // no tagID so no need to check for duplicity\n    if (!targetItem[tagIDKeyName]) {\n      destination.push(targetItem);\n      return;\n    }\n\n    var sourceIndex = findIndex(source, function (item) {\n      return item[tagIDKeyName] === targetItem[tagIDKeyName];\n    });\n    var sourceItem = source[sourceIndex]; // source doesnt contain any duplicate vmid's, we can keep targetItem\n\n    if (sourceIndex === -1) {\n      destination.push(targetItem);\n      return;\n    } // when sourceItem explictly defines contentKeyName or innerHTML as undefined, its\n    // an indication that we need to skip the default behaviour or child has preference over parent\n    // which means we keep the targetItem and ignore/remove the sourceItem\n\n\n    if (contentKeyName in sourceItem && sourceItem[contentKeyName] === undefined || 'innerHTML' in sourceItem && sourceItem.innerHTML === undefined) {\n      destination.push(targetItem); // remove current index from source array so its not concatenated to destination below\n\n      source.splice(sourceIndex, 1);\n      return;\n    } // we now know that targetItem is a duplicate and we should ignore it in favor of sourceItem\n    // if source specifies null as content then ignore both the target as the source\n\n\n    if (sourceItem[contentKeyName] === null || sourceItem.innerHTML === null) {\n      // remove current index from source array so its not concatenated to destination below\n      source.splice(sourceIndex, 1);\n      return;\n    } // now we only need to check if the target has a template to combine it with the source\n\n\n    var targetTemplate = targetItem[metaTemplateKeyName];\n\n    if (!targetTemplate) {\n      return;\n    }\n\n    var sourceTemplate = sourceItem[metaTemplateKeyName];\n\n    if (!sourceTemplate) {\n      // use parent template and child content\n      applyTemplate({\n        component: component,\n        metaTemplateKeyName: metaTemplateKeyName,\n        contentKeyName: contentKeyName\n      }, sourceItem, targetTemplate); // set template to true to indicate template was already applied\n\n      sourceItem.template = true;\n      return;\n    }\n\n    if (!sourceItem[contentKeyName]) {\n      // use parent content and child template\n      applyTemplate({\n        component: component,\n        metaTemplateKeyName: metaTemplateKeyName,\n        contentKeyName: contentKeyName\n      }, sourceItem, undefined, targetItem[contentKeyName]);\n    }\n  });\n  return destination.concat(source);\n}\nvar warningShown = false;\nfunction merge(target, source, options) {\n  options = options || {}; // remove properties explicitly set to false so child components can\n  // optionally _not_ overwrite the parents content\n  // (for array properties this is checked in arrayMerge)\n\n  if (source.title === undefined) {\n    delete source.title;\n  }\n\n  metaInfoAttributeKeys.forEach(function (attrKey) {\n    if (!source[attrKey]) {\n      return;\n    }\n\n    for (var key in source[attrKey]) {\n      if (key in source[attrKey] && source[attrKey][key] === undefined) {\n        if (includes(booleanHtmlAttributes, key) && !warningShown) {\n          warn('VueMeta: Please note that since v2 the value undefined is not used to indicate boolean attributes anymore, see migration guide for details');\n          warningShown = true;\n        }\n\n        delete source[attrKey][key];\n      }\n    }\n  });\n  return deepmerge__WEBPACK_IMPORTED_MODULE_0___default()(target, source, {\n    arrayMerge: function arrayMerge(t, s) {\n      return _arrayMerge(options, t, s);\n    }\n  });\n}\n\nfunction getComponentMetaInfo(options, component) {\n  return getComponentOption(options || {}, component, defaultInfo);\n}\n/**\n * Returns the `opts.option` $option value of the given `opts.component`.\n * If methods are encountered, they will be bound to the component context.\n * If `opts.deep` is true, will recursively merge all child component\n * `opts.option` $option values into the returned result.\n *\n * @param  {Object} opts - options\n * @param  {Object} opts.component - Vue component to fetch option data from\n * @param  {Boolean} opts.deep - look for data in child components as well?\n * @param  {Function} opts.arrayMerge - how should arrays be merged?\n * @param  {String} opts.keyName - the name of the option to look for\n * @param  {Object} [result={}] - result so far\n * @return {Object} result - final aggregated result\n */\n\nfunction getComponentOption(options, component, result) {\n  result = result || {};\n\n  if (component._inactive) {\n    return result;\n  }\n\n  options = options || {};\n  var _options = options,\n      keyName = _options.keyName;\n  var $metaInfo = component.$metaInfo,\n      $options = component.$options,\n      $children = component.$children; // only collect option data if it exists\n\n  if ($options[keyName]) {\n    // if $metaInfo exists then [keyName] was defined as a function\n    // and set to the computed prop $metaInfo in the mixin\n    // using the computed prop should be a small performance increase\n    // because Vue caches those internally\n    var data = $metaInfo || $options[keyName]; // only merge data with result when its an object\n    // eg it could be a function when metaInfo() returns undefined\n    // dueo to the or statement above\n\n    if (isObject(data)) {\n      result = merge(result, data, options);\n    }\n  } // collect & aggregate child options if deep = true\n\n\n  if ($children.length) {\n    $children.forEach(function (childComponent) {\n      // check if the childComponent is in a branch\n      // return otherwise so we dont walk all component branches unnecessarily\n      if (!inMetaInfoBranch(childComponent)) {\n        return;\n      }\n\n      result = getComponentOption(options, childComponent, result);\n    });\n  }\n\n  return result;\n}\n\nvar callbacks = [];\nfunction isDOMComplete(d) {\n  return (d || document).readyState === 'complete';\n}\nfunction addCallback(query, callback) {\n  if (arguments.length === 1) {\n    callback = query;\n    query = '';\n  }\n\n  callbacks.push([query, callback]);\n}\nfunction addCallbacks(_ref, type, tags, autoAddListeners) {\n  var tagIDKeyName = _ref.tagIDKeyName;\n  var hasAsyncCallback = false;\n  tags.forEach(function (tag) {\n    if (!tag[tagIDKeyName] || !tag.callback) {\n      return;\n    }\n\n    hasAsyncCallback = true;\n    addCallback(\"\".concat(type, \"[data-\").concat(tagIDKeyName, \"=\\\"\").concat(tag[tagIDKeyName], \"\\\"]\"), tag.callback);\n  });\n\n  if (!autoAddListeners || !hasAsyncCallback) {\n    return hasAsyncCallback;\n  }\n\n  return addListeners();\n}\nfunction addListeners() {\n  if (isDOMComplete()) {\n    applyCallbacks();\n    return;\n  } // Instead of using a MutationObserver, we just apply\n\n  /* istanbul ignore next */\n\n\n  document.onreadystatechange = function () {\n    applyCallbacks();\n  };\n}\nfunction applyCallbacks(matchElement) {\n  callbacks.forEach(function (args) {\n    // do not use destructuring for args, it increases transpiled size\n    // due to var checks while we are guaranteed the structure of the cb\n    var query = args[0];\n    var callback = args[1];\n    var selector = \"\".concat(query, \"[onload=\\\"this.__vm_l=1\\\"]\");\n    var elements = [];\n\n    if (!matchElement) {\n      elements = toArray(querySelector(selector));\n    }\n\n    if (matchElement && matchElement.matches(selector)) {\n      elements = [matchElement];\n    }\n\n    elements.forEach(function (element) {\n      /* __vm_cb: whether the load callback has been called\n       * __vm_l: set by onload attribute, whether the element was loaded\n       * __vm_ev: whether the event listener was added or not\n       */\n      if (element.__vm_cb) {\n        return;\n      }\n\n      var onload = function onload() {\n        /* Mark that the callback for this element has already been called,\n         * this prevents the callback to run twice in some (rare) conditions\n         */\n        element.__vm_cb = true;\n        /* onload needs to be removed because we only need the\n         * attribute after ssr and if we dont remove it the node\n         * will fail isEqualNode on the client\n         */\n\n        removeAttribute(element, 'onload');\n        callback(element);\n      };\n      /* IE9 doesnt seem to load scripts synchronously,\n       * causing a script sometimes/often already to be loaded\n       * when we add the event listener below (thus adding an onload event\n       * listener has no use because it will never be triggered).\n       * Therefore we add the onload attribute during ssr, and\n       * check here if it was already loaded or not\n       */\n\n\n      if (element.__vm_l) {\n        onload();\n        return;\n      }\n\n      if (!element.__vm_ev) {\n        element.__vm_ev = true;\n        element.addEventListener('load', onload);\n      }\n    });\n  });\n}\n\n// instead of adding it to the html\n\nvar attributeMap = {};\n/**\n * Updates the document's html tag attributes\n *\n * @param  {Object} attrs - the new document html attributes\n * @param  {HTMLElement} tag - the HTMLElement tag to update with new attrs\n */\n\nfunction updateAttribute(appId, options, type, attrs, tag) {\n  var _ref = options || {},\n      attribute = _ref.attribute;\n\n  var vueMetaAttrString = tag.getAttribute(attribute);\n\n  if (vueMetaAttrString) {\n    attributeMap[type] = JSON.parse(decodeURI(vueMetaAttrString));\n    removeAttribute(tag, attribute);\n  }\n\n  var data = attributeMap[type] || {};\n  var toUpdate = []; // remove attributes from the map\n  // which have been removed for this appId\n\n  for (var attr in data) {\n    if (data[attr] !== undefined && appId in data[attr]) {\n      toUpdate.push(attr);\n\n      if (!attrs[attr]) {\n        delete data[attr][appId];\n      }\n    }\n  }\n\n  for (var _attr in attrs) {\n    var attrData = data[_attr];\n\n    if (!attrData || attrData[appId] !== attrs[_attr]) {\n      toUpdate.push(_attr);\n\n      if (attrs[_attr] !== undefined) {\n        data[_attr] = data[_attr] || {};\n        data[_attr][appId] = attrs[_attr];\n      }\n    }\n  }\n\n  for (var _i = 0, _toUpdate = toUpdate; _i < _toUpdate.length; _i++) {\n    var _attr2 = _toUpdate[_i];\n    var _attrData = data[_attr2];\n    var attrValues = [];\n\n    for (var _appId in _attrData) {\n      Array.prototype.push.apply(attrValues, [].concat(_attrData[_appId]));\n    }\n\n    if (attrValues.length) {\n      var attrValue = includes(booleanHtmlAttributes, _attr2) && attrValues.some(Boolean) ? '' : attrValues.filter(function (v) {\n        return v !== undefined;\n      }).join(' ');\n      tag.setAttribute(_attr2, attrValue);\n    } else {\n      removeAttribute(tag, _attr2);\n    }\n  }\n\n  attributeMap[type] = data;\n}\n\n/**\n * Updates the document title\n *\n * @param  {String} title - the new title of the document\n */\nfunction updateTitle(title) {\n  if (!title && title !== '') {\n    return;\n  }\n\n  document.title = title;\n}\n\n/**\n * Updates meta tags inside <head> and <body> on the client. Borrowed from `react-helmet`:\n * https://github.com/nfl/react-helmet/blob/004d448f8de5f823d10f838b02317521180f34da/src/Helmet.js#L195-L245\n *\n * @param  {('meta'|'base'|'link'|'style'|'script'|'noscript')} type - the name of the tag\n * @param  {(Array<Object>|Object)} tags - an array of tag objects or a single object in case of base\n * @return {Object} - a representation of what tags changed\n */\n\nfunction updateTag(appId, options, type, tags, head, body) {\n  var _ref = options || {},\n      attribute = _ref.attribute,\n      tagIDKeyName = _ref.tagIDKeyName;\n\n  var dataAttributes = commonDataAttributes.slice();\n  dataAttributes.push(tagIDKeyName);\n  var newElements = [];\n  var queryOptions = {\n    appId: appId,\n    attribute: attribute,\n    type: type,\n    tagIDKeyName: tagIDKeyName\n  };\n  var currentElements = {\n    head: queryElements(head, queryOptions),\n    pbody: queryElements(body, queryOptions, {\n      pbody: true\n    }),\n    body: queryElements(body, queryOptions, {\n      body: true\n    })\n  };\n\n  if (tags.length > 1) {\n    // remove duplicates that could have been found by merging tags\n    // which include a mixin with metaInfo and that mixin is used\n    // by multiple components on the same page\n    var found = [];\n    tags = tags.filter(function (x) {\n      var k = JSON.stringify(x);\n      var res = !includes(found, k);\n      found.push(k);\n      return res;\n    });\n  }\n\n  tags.forEach(function (tag) {\n    if (tag.skip) {\n      return;\n    }\n\n    var newElement = document.createElement(type);\n\n    if (!tag.once) {\n      newElement.setAttribute(attribute, appId);\n    }\n\n    Object.keys(tag).forEach(function (attr) {\n      /* istanbul ignore next */\n      if (includes(tagProperties, attr)) {\n        return;\n      }\n\n      if (attr === 'innerHTML') {\n        newElement.innerHTML = tag.innerHTML;\n        return;\n      }\n\n      if (attr === 'json') {\n        newElement.innerHTML = JSON.stringify(tag.json);\n        return;\n      }\n\n      if (attr === 'cssText') {\n        if (newElement.styleSheet) {\n          /* istanbul ignore next */\n          newElement.styleSheet.cssText = tag.cssText;\n        } else {\n          newElement.appendChild(document.createTextNode(tag.cssText));\n        }\n\n        return;\n      }\n\n      if (attr === 'callback') {\n        newElement.onload = function () {\n          return tag[attr](newElement);\n        };\n\n        return;\n      }\n\n      var _attr = includes(dataAttributes, attr) ? \"data-\".concat(attr) : attr;\n\n      var isBooleanAttribute = includes(booleanHtmlAttributes, attr);\n\n      if (isBooleanAttribute && !tag[attr]) {\n        return;\n      }\n\n      var value = isBooleanAttribute ? '' : tag[attr];\n      newElement.setAttribute(_attr, value);\n    });\n    var oldElements = currentElements[getElementsKey(tag)]; // Remove a duplicate tag from domTagstoRemove, so it isn't cleared.\n\n    var indexToDelete;\n    var hasEqualElement = oldElements.some(function (existingTag, index) {\n      indexToDelete = index;\n      return newElement.isEqualNode(existingTag);\n    });\n\n    if (hasEqualElement && (indexToDelete || indexToDelete === 0)) {\n      oldElements.splice(indexToDelete, 1);\n    } else {\n      newElements.push(newElement);\n    }\n  });\n  var oldElements = [];\n\n  for (var _type in currentElements) {\n    Array.prototype.push.apply(oldElements, currentElements[_type]);\n  } // remove old elements\n\n\n  oldElements.forEach(function (element) {\n    element.parentNode.removeChild(element);\n  }); // insert new elements\n\n  newElements.forEach(function (element) {\n    if (element.hasAttribute('data-body')) {\n      body.appendChild(element);\n      return;\n    }\n\n    if (element.hasAttribute('data-pbody')) {\n      body.insertBefore(element, body.firstChild);\n      return;\n    }\n\n    head.appendChild(element);\n  });\n  return {\n    oldTags: oldElements,\n    newTags: newElements\n  };\n}\n\n/**\n * Performs client-side updates when new meta info is received\n *\n * @param  {Object} newInfo - the meta info to update to\n */\n\nfunction updateClientMetaInfo(appId, options, newInfo) {\n  options = options || {};\n  var _options = options,\n      ssrAttribute = _options.ssrAttribute,\n      ssrAppId = _options.ssrAppId; // only cache tags for current update\n\n  var tags = {};\n  var htmlTag = getTag(tags, 'html'); // if this is a server render, then dont update\n\n  if (appId === ssrAppId && htmlTag.hasAttribute(ssrAttribute)) {\n    // remove the server render attribute so we can update on (next) changes\n    removeAttribute(htmlTag, ssrAttribute); // add load callbacks if the\n\n    var addLoadListeners = false;\n    tagsSupportingOnload.forEach(function (type) {\n      if (newInfo[type] && addCallbacks(options, type, newInfo[type])) {\n        addLoadListeners = true;\n      }\n    });\n\n    if (addLoadListeners) {\n      addListeners();\n    }\n\n    return false;\n  } // initialize tracked changes\n\n\n  var tagsAdded = {};\n  var tagsRemoved = {};\n\n  for (var type in newInfo) {\n    // ignore these\n    if (includes(metaInfoOptionKeys, type)) {\n      continue;\n    }\n\n    if (type === 'title') {\n      // update the title\n      updateTitle(newInfo.title);\n      continue;\n    }\n\n    if (includes(metaInfoAttributeKeys, type)) {\n      var tagName = type.substr(0, 4);\n      updateAttribute(appId, options, type, newInfo[type], getTag(tags, tagName));\n      continue;\n    } // tags should always be an array, ignore if it isnt\n\n\n    if (!isArray(newInfo[type])) {\n      continue;\n    }\n\n    var _updateTag = updateTag(appId, options, type, newInfo[type], getTag(tags, 'head'), getTag(tags, 'body')),\n        oldTags = _updateTag.oldTags,\n        newTags = _updateTag.newTags;\n\n    if (newTags.length) {\n      tagsAdded[type] = newTags;\n      tagsRemoved[type] = oldTags;\n    }\n  }\n\n  return {\n    tagsAdded: tagsAdded,\n    tagsRemoved: tagsRemoved\n  };\n}\n\nvar appsMetaInfo;\nfunction addApp(rootVm, appId, options) {\n  return {\n    set: function set(metaInfo) {\n      return setMetaInfo(rootVm, appId, options, metaInfo);\n    },\n    remove: function remove() {\n      return removeMetaInfo(rootVm, appId, options);\n    }\n  };\n}\nfunction setMetaInfo(rootVm, appId, options, metaInfo) {\n  // if a vm exists _and_ its mounted then immediately update\n  if (rootVm && rootVm.$el) {\n    return updateClientMetaInfo(appId, options, metaInfo);\n  } // store for later, the info\n  // will be set on the first refresh\n\n\n  appsMetaInfo = appsMetaInfo || {};\n  appsMetaInfo[appId] = metaInfo;\n}\nfunction removeMetaInfo(rootVm, appId, options) {\n  if (rootVm && rootVm.$el) {\n    var tags = {};\n\n    var _iterator = _createForOfIteratorHelper(metaInfoAttributeKeys),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var type = _step.value;\n        var tagName = type.substr(0, 4);\n        updateAttribute(appId, options, type, {}, getTag(tags, tagName));\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return removeElementsByAppId(options, appId);\n  }\n\n  if (appsMetaInfo[appId]) {\n    delete appsMetaInfo[appId];\n    clearAppsMetaInfo();\n  }\n}\nfunction getAppsMetaInfo() {\n  return appsMetaInfo;\n}\nfunction clearAppsMetaInfo(force) {\n  if (force || !Object.keys(appsMetaInfo).length) {\n    appsMetaInfo = undefined;\n  }\n}\n\n/**\n * Returns the correct meta info for the given component\n * (child components will overwrite parent meta info)\n *\n * @param  {Object} component - the Vue instance to get meta info from\n * @return {Object} - returned meta info\n */\n\nfunction getMetaInfo(options, info, escapeSequences, component) {\n  options = options || {};\n  escapeSequences = escapeSequences || [];\n  var _options = options,\n      tagIDKeyName = _options.tagIDKeyName; // Remove all \"template\" tags from meta\n  // backup the title chunk in case user wants access to it\n\n  if (info.title) {\n    info.titleChunk = info.title;\n  } // replace title with populated template\n\n\n  if (info.titleTemplate && info.titleTemplate !== '%s') {\n    applyTemplate({\n      component: component,\n      contentKeyName: 'title'\n    }, info, info.titleTemplate, info.titleChunk || '');\n  } // convert base tag to an array so it can be handled the same way\n  // as the other tags\n\n\n  if (info.base) {\n    info.base = Object.keys(info.base).length ? [info.base] : [];\n  }\n\n  if (info.meta) {\n    // remove meta items with duplicate vmid's\n    info.meta = info.meta.filter(function (metaItem, index, arr) {\n      var hasVmid = !!metaItem[tagIDKeyName];\n\n      if (!hasVmid) {\n        return true;\n      }\n\n      var isFirstItemForVmid = index === findIndex(arr, function (item) {\n        return item[tagIDKeyName] === metaItem[tagIDKeyName];\n      });\n      return isFirstItemForVmid;\n    }); // apply templates if needed\n\n    info.meta.forEach(function (metaObject) {\n      return applyTemplate(options, metaObject);\n    });\n  }\n\n  return escapeMetaInfo(options, info, escapeSequences);\n}\n\n/**\n * When called, will update the current meta info with new meta info.\n * Useful when updating meta info as the result of an asynchronous\n * action that resolves after the initial render takes place.\n *\n * Credit to [Sébastien Chopin](https://github.com/Atinux) for the suggestion\n * to implement this method.\n *\n * @return {Object} - new meta info\n */\n\nfunction refresh(rootVm, options) {\n  options = options || {}; // make sure vue-meta was initiated\n\n  if (!rootVm[rootConfigKey]) {\n    showWarningNotSupported();\n    return {};\n  } // collect & aggregate all metaInfo $options\n\n\n  var rawInfo = getComponentMetaInfo(options, rootVm);\n  var metaInfo = getMetaInfo(options, rawInfo, clientSequences, rootVm);\n  var appId = rootVm[rootConfigKey].appId;\n  var tags = updateClientMetaInfo(appId, options, metaInfo); // emit \"event\" with new info\n\n  if (tags && isFunction(metaInfo.changed)) {\n    metaInfo.changed(metaInfo, tags.tagsAdded, tags.tagsRemoved);\n    tags = {\n      addedTags: tags.tagsAdded,\n      removedTags: tags.tagsRemoved\n    };\n  }\n\n  var appsMetaInfo = getAppsMetaInfo();\n\n  if (appsMetaInfo) {\n    for (var additionalAppId in appsMetaInfo) {\n      updateClientMetaInfo(additionalAppId, options, appsMetaInfo[additionalAppId]);\n      delete appsMetaInfo[additionalAppId];\n    }\n\n    clearAppsMetaInfo(true);\n  }\n\n  return {\n    vm: rootVm,\n    metaInfo: metaInfo,\n    // eslint-disable-line object-shorthand\n    tags: tags\n  };\n}\n\n/**\n * Generates tag attributes for use on the server.\n *\n * @param  {('bodyAttrs'|'htmlAttrs'|'headAttrs')} type - the type of attributes to generate\n * @param  {Object} data - the attributes to generate\n * @return {Object} - the attribute generator\n */\n\nfunction attributeGenerator(options, type, data, _ref) {\n  var addSsrAttribute = _ref.addSsrAttribute;\n\n  var _ref2 = options || {},\n      attribute = _ref2.attribute,\n      ssrAttribute = _ref2.ssrAttribute;\n\n  var attributeStr = '';\n\n  for (var attr in data) {\n    var attrData = data[attr];\n    var attrValues = [];\n\n    for (var appId in attrData) {\n      attrValues.push.apply(attrValues, _toConsumableArray([].concat(attrData[appId])));\n    }\n\n    if (attrValues.length) {\n      attributeStr += booleanHtmlAttributes.includes(attr) && attrValues.some(Boolean) ? \"\".concat(attr) : \"\".concat(attr, \"=\\\"\").concat(attrValues.join(' '), \"\\\"\");\n      attributeStr += ' ';\n    }\n  }\n\n  if (attributeStr) {\n    attributeStr += \"\".concat(attribute, \"=\\\"\").concat(encodeURI(JSON.stringify(data)), \"\\\"\");\n  }\n\n  if (type === 'htmlAttrs' && addSsrAttribute) {\n    return \"\".concat(ssrAttribute).concat(attributeStr ? ' ' : '').concat(attributeStr);\n  }\n\n  return attributeStr;\n}\n\n/**\n * Generates title output for the server\n *\n * @param  {'title'} type - the string \"title\"\n * @param  {String} data - the title text\n * @return {Object} - the title generator\n */\nfunction titleGenerator(options, type, data, generatorOptions) {\n  var _ref = generatorOptions || {},\n      ln = _ref.ln;\n\n  if (!data) {\n    return '';\n  }\n\n  return \"<\".concat(type, \">\").concat(data, \"</\").concat(type, \">\").concat(ln ? '\\n' : '');\n}\n\n/**\n * Generates meta, base, link, style, script, noscript tags for use on the server\n *\n * @param  {('meta'|'base'|'link'|'style'|'script'|'noscript')} the name of the tag\n * @param  {(Array<Object>|Object)} tags - an array of tag objects or a single object in case of base\n * @return {Object} - the tag generator\n */\n\nfunction tagGenerator(options, type, tags, generatorOptions) {\n  var _ref = options || {},\n      ssrAppId = _ref.ssrAppId,\n      attribute = _ref.attribute,\n      tagIDKeyName = _ref.tagIDKeyName;\n\n  var _ref2 = generatorOptions || {},\n      appId = _ref2.appId,\n      _ref2$isSSR = _ref2.isSSR,\n      isSSR = _ref2$isSSR === void 0 ? true : _ref2$isSSR,\n      _ref2$body = _ref2.body,\n      body = _ref2$body === void 0 ? false : _ref2$body,\n      _ref2$pbody = _ref2.pbody,\n      pbody = _ref2$pbody === void 0 ? false : _ref2$pbody,\n      _ref2$ln = _ref2.ln,\n      ln = _ref2$ln === void 0 ? false : _ref2$ln;\n\n  var dataAttributes = [tagIDKeyName].concat(_toConsumableArray(commonDataAttributes));\n\n  if (!tags || !tags.length) {\n    return '';\n  } // build a string containing all tags of this type\n\n\n  return tags.reduce(function (tagsStr, tag) {\n    if (tag.skip) {\n      return tagsStr;\n    }\n\n    var tagKeys = Object.keys(tag);\n\n    if (tagKeys.length === 0) {\n      return tagsStr; // Bail on empty tag object\n    }\n\n    if (Boolean(tag.body) !== body || Boolean(tag.pbody) !== pbody) {\n      return tagsStr;\n    }\n\n    var attrs = tag.once ? '' : \" \".concat(attribute, \"=\\\"\").concat(appId || (isSSR === false ? '1' : ssrAppId), \"\\\"\"); // build a string containing all attributes of this tag\n\n    for (var attr in tag) {\n      // these attributes are treated as children on the tag\n      if (tagAttributeAsInnerContent.includes(attr) || tagProperties.includes(attr)) {\n        continue;\n      }\n\n      if (attr === 'callback') {\n        attrs += ' onload=\"this.__vm_l=1\"';\n        continue;\n      } // these form the attribute list for this tag\n\n\n      var prefix = '';\n\n      if (dataAttributes.includes(attr)) {\n        prefix = 'data-';\n      }\n\n      var isBooleanAttr = !prefix && booleanHtmlAttributes.includes(attr);\n\n      if (isBooleanAttr && !tag[attr]) {\n        continue;\n      }\n\n      attrs += \" \".concat(prefix).concat(attr) + (isBooleanAttr ? '' : \"=\\\"\".concat(tag[attr], \"\\\"\"));\n    }\n\n    var json = '';\n\n    if (tag.json) {\n      json = JSON.stringify(tag.json);\n    } // grab child content from one of these attributes, if possible\n\n\n    var content = tag.innerHTML || tag.cssText || json; // generate tag exactly without any other redundant attribute\n    // these tags have no end tag\n\n    var hasEndTag = !tagsWithoutEndTag.includes(type); // these tag types will have content inserted\n\n    var hasContent = hasEndTag && tagsWithInnerContent.includes(type); // the final string for this specific tag\n\n    return \"\".concat(tagsStr, \"<\").concat(type).concat(attrs).concat(!hasContent && hasEndTag ? '/' : '', \">\") + (hasContent ? \"\".concat(content, \"</\").concat(type, \">\") : '') + (ln ? '\\n' : '');\n  }, '');\n}\n\n/**\n * Converts a meta info property to one that can be stringified on the server\n *\n * @param  {String} type - the type of data to convert\n * @param  {(String|Object|Array<Object>)} data - the data value\n * @return {Object} - the new injector\n */\n\nfunction generateServerInjector(options, metaInfo, globalInjectOptions) {\n  var serverInjector = {\n    data: metaInfo,\n    extraData: undefined,\n    addInfo: function addInfo(appId, metaInfo) {\n      this.extraData = this.extraData || {};\n      this.extraData[appId] = metaInfo;\n    },\n    callInjectors: function callInjectors(opts) {\n      var m = this.injectors; // only call title for the head\n\n      return (opts.body || opts.pbody ? '' : m.title.text(opts)) + m.meta.text(opts) + m.base.text(opts) + m.link.text(opts) + m.style.text(opts) + m.script.text(opts) + m.noscript.text(opts);\n    },\n    injectors: {\n      head: function head(ln) {\n        return serverInjector.callInjectors(_objectSpread2(_objectSpread2({}, globalInjectOptions), {}, {\n          ln: ln\n        }));\n      },\n      bodyPrepend: function bodyPrepend(ln) {\n        return serverInjector.callInjectors(_objectSpread2(_objectSpread2({}, globalInjectOptions), {}, {\n          ln: ln,\n          pbody: true\n        }));\n      },\n      bodyAppend: function bodyAppend(ln) {\n        return serverInjector.callInjectors(_objectSpread2(_objectSpread2({}, globalInjectOptions), {}, {\n          ln: ln,\n          body: true\n        }));\n      }\n    }\n  };\n\n  var _loop = function _loop(type) {\n    if (metaInfoOptionKeys.includes(type)) {\n      return \"continue\";\n    }\n\n    serverInjector.injectors[type] = {\n      text: function text(injectOptions) {\n        var addSsrAttribute = injectOptions === true;\n        injectOptions = _objectSpread2(_objectSpread2({\n          addSsrAttribute: addSsrAttribute\n        }, globalInjectOptions), injectOptions);\n\n        if (type === 'title') {\n          return titleGenerator(options, type, serverInjector.data[type], injectOptions);\n        }\n\n        if (metaInfoAttributeKeys.includes(type)) {\n          var attributeData = {};\n          var data = serverInjector.data[type];\n\n          if (data) {\n            var appId = injectOptions.isSSR === false ? '1' : options.ssrAppId;\n\n            for (var attr in data) {\n              attributeData[attr] = _defineProperty({}, appId, data[attr]);\n            }\n          }\n\n          if (serverInjector.extraData) {\n            for (var _appId in serverInjector.extraData) {\n              var _data = serverInjector.extraData[_appId][type];\n\n              if (_data) {\n                for (var _attr in _data) {\n                  attributeData[_attr] = _objectSpread2(_objectSpread2({}, attributeData[_attr]), {}, _defineProperty({}, _appId, _data[_attr]));\n                }\n              }\n            }\n          }\n\n          return attributeGenerator(options, type, attributeData, injectOptions);\n        }\n\n        var str = tagGenerator(options, type, serverInjector.data[type], injectOptions);\n\n        if (serverInjector.extraData) {\n          for (var _appId2 in serverInjector.extraData) {\n            var _data2 = serverInjector.extraData[_appId2][type];\n            var extraStr = tagGenerator(options, type, _data2, _objectSpread2({\n              appId: _appId2\n            }, injectOptions));\n            str = \"\".concat(str).concat(extraStr);\n          }\n        }\n\n        return str;\n      }\n    };\n  };\n\n  for (var type in defaultInfo) {\n    var _ret = _loop(type);\n\n    if (_ret === \"continue\") continue;\n  }\n\n  return serverInjector;\n}\n\n/**\n * Converts the state of the meta info object such that each item\n * can be compiled to a tag string on the server\n *\n * @vm {Object} - Vue instance - ideally the root component\n * @return {Object} - server meta info with `toString` methods\n */\n\nfunction inject(rootVm, options, injectOptions) {\n  // make sure vue-meta was initiated\n  if (!rootVm[rootConfigKey]) {\n    showWarningNotSupported();\n    return {};\n  } // collect & aggregate all metaInfo $options\n\n\n  var rawInfo = getComponentMetaInfo(options, rootVm);\n  var metaInfo = getMetaInfo(options, rawInfo, serverSequences, rootVm); // generate server injector\n\n  var serverInjector = generateServerInjector(options, metaInfo, injectOptions); // add meta info from additional apps\n\n  var appsMetaInfo = getAppsMetaInfo();\n\n  if (appsMetaInfo) {\n    for (var additionalAppId in appsMetaInfo) {\n      serverInjector.addInfo(additionalAppId, appsMetaInfo[additionalAppId]);\n      delete appsMetaInfo[additionalAppId];\n    }\n\n    clearAppsMetaInfo(true);\n  }\n\n  return serverInjector.injectors;\n}\n\nfunction $meta(options) {\n  options = options || {};\n  /**\n   * Returns an injector for server-side rendering.\n   * @this {Object} - the Vue instance (a root component)\n   * @return {Object} - injector\n   */\n\n  var $root = this.$root;\n  return {\n    getOptions: function getOptions$1() {\n      return getOptions(options);\n    },\n    setOptions: function setOptions(newOptions) {\n      var refreshNavKey = 'refreshOnceOnNavigation';\n\n      if (newOptions && newOptions[refreshNavKey]) {\n        options.refreshOnceOnNavigation = !!newOptions[refreshNavKey];\n        addNavGuards($root);\n      }\n\n      var debounceWaitKey = 'debounceWait';\n\n      if (newOptions && debounceWaitKey in newOptions) {\n        var debounceWait = parseInt(newOptions[debounceWaitKey]);\n\n        if (!isNaN(debounceWait)) {\n          options.debounceWait = debounceWait;\n        }\n      }\n\n      var waitOnDestroyedKey = 'waitOnDestroyed';\n\n      if (newOptions && waitOnDestroyedKey in newOptions) {\n        options.waitOnDestroyed = !!newOptions[waitOnDestroyedKey];\n      }\n    },\n    refresh: function refresh$1() {\n      return refresh($root, options);\n    },\n    inject: function inject$1(injectOptions) {\n      return  inject($root, options, injectOptions) ;\n    },\n    pause: function pause$1() {\n      return pause($root);\n    },\n    resume: function resume$1() {\n      return resume($root);\n    },\n    addApp: function addApp$1(appId) {\n      return addApp($root, appId, options);\n    }\n  };\n}\n\nfunction generate(rawInfo, options) {\n  options = setOptions(options);\n  var metaInfo = getMetaInfo(options, rawInfo, serverSequences);\n  var serverInjector = generateServerInjector(options, metaInfo);\n  return serverInjector.injectors;\n}\n\n/**\n * Plugin install function.\n * @param {Function} Vue - the Vue constructor.\n */\n\nfunction install(Vue, options) {\n  if (Vue.__vuemeta_installed) {\n    return;\n  }\n\n  Vue.__vuemeta_installed = true;\n  options = setOptions(options);\n\n  Vue.prototype.$meta = function () {\n    return $meta.call(this, options);\n  };\n\n  Vue.mixin(createMixin(Vue, options));\n}\n\nvar index = {\n  version: version,\n  install: install,\n  generate: function generate$1(metaInfo, options) {\n    return  generate(metaInfo, options) ;\n  },\n  hasMetaInfo: hasMetaInfo\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (index);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnVlLW1ldGEvZGlzdC92dWUtbWV0YS5lc20uanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVrQzs7QUFFbEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlDQUF5QyxTQUFTOztBQUVsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7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QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQSx5RUFBeUU7O0FBRXpFLGlGQUFpRjs7QUFFakY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsY0FBYyxRQUFRO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBLGlFQUFlLEtBQUssRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92dWUtbWV0YS9kaXN0L3Z1ZS1tZXRhLmVzbS5qcz80YmE5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogdnVlLW1ldGEgdjIuNC4wXG4gKiAoYykgMjAyMFxuICogLSBEZWNsYW4gZGUgV2V0XG4gKiAtIFPDqWJhc3RpZW4gQ2hvcGluIChAQXRpbnV4KVxuICogLSBQaW0gKEBwaW1saWUpXG4gKiAtIEFsbCB0aGUgYW1hemluZyBjb250cmlidXRvcnNcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cbmltcG9ydCBkZWVwbWVyZ2UgZnJvbSAnZGVlcG1lcmdlJztcblxudmFyIHZlcnNpb24gPSBcIjIuNC4wXCI7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBfdHlwZW9mID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgfSk7XG4gICAga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuXG4gICAgaWYgKGkgJSAyKSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gIHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KGFycik7XG59XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbn1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgcmV0dXJuIGFycjI7XG59XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7XG4gIHZhciBpdDtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBvW1N5bWJvbC5pdGVyYXRvcl0gPT0gbnVsbCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGlmIChpdCkgbyA9IGl0O1xuICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICB2YXIgRiA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzOiBGLFxuICAgICAgICBuOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7XG4gICAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogb1tpKytdXG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9LFxuICAgICAgICBmOiBGXG4gICAgICB9O1xuICAgIH1cblxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbiAgfVxuXG4gIHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSxcbiAgICAgIGRpZEVyciA9IGZhbHNlLFxuICAgICAgZXJyO1xuICByZXR1cm4ge1xuICAgIHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGl0ID0gb1tTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgfSxcbiAgICBuOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3RlcCA9IGl0Lm5leHQoKTtcbiAgICAgIG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7XG4gICAgICByZXR1cm4gc3RlcDtcbiAgICB9LFxuICAgIGU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICBkaWRFcnIgPSB0cnVlO1xuICAgICAgZXJyID0gZTtcbiAgICB9LFxuICAgIGY6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdC5yZXR1cm4gIT0gbnVsbCkgaXQucmV0dXJuKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIGNoZWNrcyBpZiBwYXNzZWQgYXJndW1lbnQgaXMgYW4gYXJyYXlcbiAqIEBwYXJhbSAge2FueX0gIGFyZyAtIHRoZSBvYmplY3QgdG8gY2hlY2tcbiAqIEByZXR1cm4ge0Jvb2xlYW59IC0gdHJ1ZSBpZiBgYXJnYCBpcyBhbiBhcnJheVxuICovXG5mdW5jdGlvbiBpc0FycmF5KGFyZykge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcmcpO1xufVxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gX3R5cGVvZihhcmcpID09PSAnb2JqZWN0Jztcbn1cbmZ1bmN0aW9uIGlzUHVyZU9iamVjdChhcmcpIHtcbiAgcmV0dXJuIF90eXBlb2YoYXJnKSA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuXG5mdW5jdGlvbiBoYXNHbG9iYWxXaW5kb3dGbigpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gIWlzVW5kZWZpbmVkKHdpbmRvdyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbnZhciBoYXNHbG9iYWxXaW5kb3cgPSBoYXNHbG9iYWxXaW5kb3dGbigpO1xuXG52YXIgX2dsb2JhbCA9IGhhc0dsb2JhbFdpbmRvdyA/IHdpbmRvdyA6IGdsb2JhbDtcblxudmFyIGNvbnNvbGUgPSBfZ2xvYmFsLmNvbnNvbGUgfHwge307XG5mdW5jdGlvbiB3YXJuKHN0cikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBpZiAoIWNvbnNvbGUgfHwgIWNvbnNvbGUud2Fybikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnNvbGUud2FybihzdHIpO1xufVxudmFyIHNob3dXYXJuaW5nTm90U3VwcG9ydGVkID0gZnVuY3Rpb24gc2hvd1dhcm5pbmdOb3RTdXBwb3J0ZWQoKSB7XG4gIHJldHVybiB3YXJuKCdUaGlzIHZ1ZSBhcHAvY29tcG9uZW50IGhhcyBubyB2dWUtbWV0YSBjb25maWd1cmF0aW9uJyk7XG59O1xuXG4vKipcbiAqIFRoZXNlIGFyZSBjb25zdGFudCB2YXJpYWJsZXMgdXNlZCB0aHJvdWdob3V0IHRoZSBhcHBsaWNhdGlvbi5cbiAqL1xuLy8gc2V0IHNvbWUgc2FuZSBkZWZhdWx0c1xudmFyIGRlZmF1bHRJbmZvID0ge1xuICB0aXRsZTogdW5kZWZpbmVkLFxuICB0aXRsZUNodW5rOiAnJyxcbiAgdGl0bGVUZW1wbGF0ZTogJyVzJyxcbiAgaHRtbEF0dHJzOiB7fSxcbiAgYm9keUF0dHJzOiB7fSxcbiAgaGVhZEF0dHJzOiB7fSxcbiAgYmFzZTogW10sXG4gIGxpbms6IFtdLFxuICBtZXRhOiBbXSxcbiAgc3R5bGU6IFtdLFxuICBzY3JpcHQ6IFtdLFxuICBub3NjcmlwdDogW10sXG4gIF9fZGFuZ2Vyb3VzbHlEaXNhYmxlU2FuaXRpemVyczogW10sXG4gIF9fZGFuZ2Vyb3VzbHlEaXNhYmxlU2FuaXRpemVyc0J5VGFnSUQ6IHt9XG59O1xudmFyIHJvb3RDb25maWdLZXkgPSAnX3Z1ZU1ldGEnOyAvLyBUaGlzIGlzIHRoZSBuYW1lIG9mIHRoZSBjb21wb25lbnQgb3B0aW9uIHRoYXQgY29udGFpbnMgYWxsIHRoZSBpbmZvcm1hdGlvbiB0aGF0XG4vLyBnZXRzIGNvbnZlcnRlZCB0byB0aGUgdmFyaW91cyBtZXRhIHRhZ3MgJiBhdHRyaWJ1dGVzIGZvciB0aGUgcGFnZS5cblxudmFyIGtleU5hbWUgPSAnbWV0YUluZm8nOyAvLyBUaGlzIGlzIHRoZSBhdHRyaWJ1dGUgdnVlLW1ldGEgYXJndW1lbnRzIG9uIGVsZW1lbnRzIHRvIGtub3cgd2hpY2ggaXQgc2hvdWxkXG4vLyBtYW5hZ2UgYW5kIHdoaWNoIGl0IHNob3VsZCBpZ25vcmUuXG5cbnZhciBhdHRyaWJ1dGUgPSAnZGF0YS12dWUtbWV0YSc7IC8vIFRoaXMgaXMgdGhlIGF0dHJpYnV0ZSB0aGF0IGdvZXMgb24gdGhlIGBodG1sYCB0YWcgdG8gaW5mb3JtIGB2dWUtbWV0YWBcbi8vIHRoYXQgdGhlIHNlcnZlciBoYXMgYWxyZWFkeSBnZW5lcmF0ZWQgdGhlIG1ldGEgdGFncyBmb3IgdGhlIGluaXRpYWwgcmVuZGVyLlxuXG52YXIgc3NyQXR0cmlidXRlID0gJ2RhdGEtdnVlLW1ldGEtc2VydmVyLXJlbmRlcmVkJzsgLy8gVGhpcyBpcyB0aGUgcHJvcGVydHkgdGhhdCB0ZWxscyB2dWUtbWV0YSB0byBvdmVyd3JpdGUgKGluc3RlYWQgb2YgYXBwZW5kKVxuLy8gYW4gaXRlbSBpbiBhIHRhZyBsaXN0LiBGb3IgZXhhbXBsZSwgaWYgeW91IGhhdmUgdHdvIGBtZXRhYCB0YWcgbGlzdCBpdGVtc1xuLy8gdGhhdCBib3RoIGhhdmUgYHZtaWRgIG9mIFwiZGVzY3JpcHRpb25cIiwgdGhlbiB2dWUtbWV0YSB3aWxsIG92ZXJ3cml0ZSB0aGVcbi8vIHNoYWxsb3dlc3Qgb25lIHdpdGggdGhlIGRlZXBlc3Qgb25lLlxuXG52YXIgdGFnSURLZXlOYW1lID0gJ3ZtaWQnOyAvLyBUaGlzIGlzIHRoZSBrZXkgbmFtZSBmb3IgcG9zc2libGUgbWV0YSB0ZW1wbGF0ZXNcblxudmFyIG1ldGFUZW1wbGF0ZUtleU5hbWUgPSAndGVtcGxhdGUnOyAvLyBUaGlzIGlzIHRoZSBrZXkgbmFtZSBmb3IgdGhlIGNvbnRlbnQtaG9sZGluZyBwcm9wZXJ0eVxuXG52YXIgY29udGVudEtleU5hbWUgPSAnY29udGVudCc7IC8vIFRoZSBpZCB1c2VkIGZvciB0aGUgc3NyIGFwcFxuXG52YXIgc3NyQXBwSWQgPSAnc3NyJzsgLy8gSG93IGxvbmcgbWV0YSB1cGRhdGVcblxudmFyIGRlYm91bmNlV2FpdCA9IDEwOyAvLyBIb3cgbG9uZyBtZXRhIHVwZGF0ZVxuXG52YXIgd2FpdE9uRGVzdHJveWVkID0gdHJ1ZTtcbnZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAga2V5TmFtZToga2V5TmFtZSxcbiAgYXR0cmlidXRlOiBhdHRyaWJ1dGUsXG4gIHNzckF0dHJpYnV0ZTogc3NyQXR0cmlidXRlLFxuICB0YWdJREtleU5hbWU6IHRhZ0lES2V5TmFtZSxcbiAgY29udGVudEtleU5hbWU6IGNvbnRlbnRLZXlOYW1lLFxuICBtZXRhVGVtcGxhdGVLZXlOYW1lOiBtZXRhVGVtcGxhdGVLZXlOYW1lLFxuICB3YWl0T25EZXN0cm95ZWQ6IHdhaXRPbkRlc3Ryb3llZCxcbiAgZGVib3VuY2VXYWl0OiBkZWJvdW5jZVdhaXQsXG4gIHNzckFwcElkOiBzc3JBcHBJZFxufTsgLy8gbWlnaHQgYmUgYSBiaXQgdWdseSwgYnV0IG1pbmltaXplcyB0aGUgYnJvd3NlciBidW5kbGVzIGEgYml0XG5cbnZhciBkZWZhdWx0SW5mb0tleXMgPSBPYmplY3Qua2V5cyhkZWZhdWx0SW5mbyk7IC8vIFRoZSBtZXRhSW5mbyBwcm9wZXJ0eSBrZXlzIHdoaWNoIGFyZSB1c2VkIHRvIGRpc2FibGUgZXNjYXBpbmdcblxudmFyIGRpc2FibGVPcHRpb25LZXlzID0gW2RlZmF1bHRJbmZvS2V5c1sxMl0sIGRlZmF1bHRJbmZvS2V5c1sxM11dOyAvLyBMaXN0IG9mIG1ldGFJbmZvIHByb3BlcnR5IGtleXMgd2hpY2ggYXJlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyAoYW5kIGRvbnQgZ2VuZXJhdGUgaHRtbClcblxudmFyIG1ldGFJbmZvT3B0aW9uS2V5cyA9IFtkZWZhdWx0SW5mb0tleXNbMV0sIGRlZmF1bHRJbmZvS2V5c1syXSwgJ2NoYW5nZWQnXS5jb25jYXQoZGlzYWJsZU9wdGlvbktleXMpOyAvLyBMaXN0IG9mIG1ldGFJbmZvIHByb3BlcnR5IGtleXMgd2hpY2ggb25seSBnZW5lcmF0ZXMgYXR0cmlidXRlcyBhbmQgbm8gdGFnc1xuXG52YXIgbWV0YUluZm9BdHRyaWJ1dGVLZXlzID0gW2RlZmF1bHRJbmZvS2V5c1szXSwgZGVmYXVsdEluZm9LZXlzWzRdLCBkZWZhdWx0SW5mb0tleXNbNV1dOyAvLyBIVE1MIGVsZW1lbnRzIHdoaWNoIHN1cHBvcnQgdGhlIG9ubG9hZCBldmVudFxuXG52YXIgdGFnc1N1cHBvcnRpbmdPbmxvYWQgPSBbJ2xpbmsnLCAnc3R5bGUnLCAnc2NyaXB0J107IC8vIEhUTUwgZWxlbWVudHMgd2hpY2ggZG9udCBoYXZlIGEgaGVhZCB0YWcgKHNob3J0ZW5lZCB0byBvdXIgbmVlZHMpXG4vLyBzZWU6IGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNTIvZG9jdW1lbnQtbWV0YWRhdGEuaHRtbFxuXG52YXIgdGFnc1dpdGhvdXRFbmRUYWcgPSBbJ2Jhc2UnLCAnbWV0YScsICdsaW5rJ107IC8vIEhUTUwgZWxlbWVudHMgd2hpY2ggY2FuIGhhdmUgaW5uZXIgY29udGVudCAoc2hvcnRlbmVkIHRvIG91ciBuZWVkcylcblxudmFyIHRhZ3NXaXRoSW5uZXJDb250ZW50ID0gWydub3NjcmlwdCcsICdzY3JpcHQnLCAnc3R5bGUnXTsgLy8gQXR0cmlidXRlcyB3aGljaCBhcmUgaW5zZXJ0ZWQgYXMgY2hpbGROb2RlcyBpbnN0ZWFkIG9mIEhUTUxBdHRyaWJ1dGVcblxudmFyIHRhZ0F0dHJpYnV0ZUFzSW5uZXJDb250ZW50ID0gWydpbm5lckhUTUwnLCAnY3NzVGV4dCcsICdqc29uJ107XG52YXIgdGFnUHJvcGVydGllcyA9IFsnb25jZScsICdza2lwJywgJ3RlbXBsYXRlJ107IC8vIEF0dHJpYnV0ZXMgd2hpY2ggc2hvdWxkIGJlIGFkZGVkIHdpdGggZGF0YS0gcHJlZml4XG5cbnZhciBjb21tb25EYXRhQXR0cmlidXRlcyA9IFsnYm9keScsICdwYm9keSddOyAvLyBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20va2FuZ2F4L2h0bWwtbWluaWZpZXIvYmxvYi9naC1wYWdlcy9zcmMvaHRtbG1pbmlmaWVyLmpzI0wyMDJcblxudmFyIGJvb2xlYW5IdG1sQXR0cmlidXRlcyA9IFsnYWxsb3dmdWxsc2NyZWVuJywgJ2FtcCcsICdhbXAtYm9pbGVycGxhdGUnLCAnYXN5bmMnLCAnYXV0b2ZvY3VzJywgJ2F1dG9wbGF5JywgJ2NoZWNrZWQnLCAnY29tcGFjdCcsICdjb250cm9scycsICdkZWNsYXJlJywgJ2RlZmF1bHQnLCAnZGVmYXVsdGNoZWNrZWQnLCAnZGVmYXVsdG11dGVkJywgJ2RlZmF1bHRzZWxlY3RlZCcsICdkZWZlcicsICdkaXNhYmxlZCcsICdlbmFibGVkJywgJ2Zvcm1ub3ZhbGlkYXRlJywgJ2hpZGRlbicsICdpbmRldGVybWluYXRlJywgJ2luZXJ0JywgJ2lzbWFwJywgJ2l0ZW1zY29wZScsICdsb29wJywgJ211bHRpcGxlJywgJ211dGVkJywgJ25vaHJlZicsICdub3Jlc2l6ZScsICdub3NoYWRlJywgJ25vdmFsaWRhdGUnLCAnbm93cmFwJywgJ29wZW4nLCAncGF1c2VvbmV4aXQnLCAncmVhZG9ubHknLCAncmVxdWlyZWQnLCAncmV2ZXJzZWQnLCAnc2NvcGVkJywgJ3NlYW1sZXNzJywgJ3NlbGVjdGVkJywgJ3NvcnRhYmxlJywgJ3RydWVzcGVlZCcsICd0eXBlbXVzdG1hdGNoJywgJ3Zpc2libGUnXTtcblxudmFyIGJhdGNoSWQgPSBudWxsO1xuZnVuY3Rpb24gdHJpZ2dlclVwZGF0ZShfcmVmLCByb290Vm0sIGhvb2tOYW1lKSB7XG4gIHZhciBkZWJvdW5jZVdhaXQgPSBfcmVmLmRlYm91bmNlV2FpdDtcblxuICAvLyBpZiBhbiB1cGRhdGUgd2FzIHRyaWdnZXJlZCBkdXJpbmcgaW5pdGlhbGl6YXRpb24gb3Igd2hlbiBhbiB1cGRhdGUgd2FzIHRyaWdnZXJlZCBieSB0aGVcbiAgLy8gbWV0YUluZm8gd2F0Y2hlciwgc2V0IGluaXRpYWxpemVkIHRvIG51bGxcbiAgLy8gdGhlbiB3ZSBrZWVwIGZhbHN5IHZhbHVlIGJ1dCBrbm93IHdlIG5lZWQgdG8gcnVuIGEgdHJpZ2dlclVwZGF0ZSBhZnRlciBpbml0aWFsaXphdGlvblxuICBpZiAoIXJvb3RWbVtyb290Q29uZmlnS2V5XS5pbml0aWFsaXplZCAmJiAocm9vdFZtW3Jvb3RDb25maWdLZXldLmluaXRpYWxpemluZyB8fCBob29rTmFtZSA9PT0gJ3dhdGNoZXInKSkge1xuICAgIHJvb3RWbVtyb290Q29uZmlnS2V5XS5pbml0aWFsaXplZCA9IG51bGw7XG4gIH1cblxuICBpZiAocm9vdFZtW3Jvb3RDb25maWdLZXldLmluaXRpYWxpemVkICYmICFyb290Vm1bcm9vdENvbmZpZ0tleV0ucGF1c2luZykge1xuICAgIC8vIGJhdGNoIHBvdGVudGlhbCBET00gdXBkYXRlcyB0byBwcmV2ZW50IGV4dHJhbmVvdXMgcmUtcmVuZGVyaW5nXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXZvaWRcbiAgICBiYXRjaFVwZGF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdm9pZCByb290Vm0uJG1ldGEoKS5yZWZyZXNoKCk7XG4gICAgfSwgZGVib3VuY2VXYWl0KTtcbiAgfVxufVxuLyoqXG4gKiBQZXJmb3JtcyBhIGJhdGNoZWQgdXBkYXRlLlxuICpcbiAqIEBwYXJhbSAgeyhudWxsfE51bWJlcil9IGlkIC0gdGhlIElEIG9mIHRoaXMgdXBkYXRlXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSB0aGUgdXBkYXRlIHRvIHBlcmZvcm1cbiAqIEByZXR1cm4ge051bWJlcn0gaWQgLSBhIG5ldyBJRFxuICovXG5cbmZ1bmN0aW9uIGJhdGNoVXBkYXRlKGNhbGxiYWNrLCB0aW1lb3V0KSB7XG4gIHRpbWVvdXQgPSB0aW1lb3V0ID09PSB1bmRlZmluZWQgPyAxMCA6IHRpbWVvdXQ7XG5cbiAgaWYgKCF0aW1lb3V0KSB7XG4gICAgY2FsbGJhY2soKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjbGVhclRpbWVvdXQoYmF0Y2hJZCk7XG4gIGJhdGNoSWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBjYWxsYmFjaygpO1xuICB9LCB0aW1lb3V0KTtcbiAgcmV0dXJuIGJhdGNoSWQ7XG59XG5cbi8qXG4gKiBUbyByZWR1Y2UgYnVpbGQgc2l6ZSwgdGhpcyBmaWxlIHByb3ZpZGVzIHNpbXBsZSBwb2x5ZmlsbHMgd2l0aG91dFxuICogb3Zlcmx5IGV4Y2Vzc2l2ZSB0eXBlIGNoZWNraW5nIGFuZCB3aXRob3V0IG1vZGlmeWluZ1xuICogdGhlIGdsb2JhbCBBcnJheS5wcm90b3R5cGVcbiAqIFRoZSBwb2x5ZmlsbHMgYXJlIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZCBpbiB0aGUgY29tbW9uanMgYnVpbGRcbiAqIEFsc28sIG9ubHkgZmlsZXMgaW4gY2xpZW50LyAmIHNoYXJlZC8gc2hvdWxkIHVzZSB0aGVzZSBmdW5jdGlvbnNcbiAqIGZpbGVzIGluIHNlcnZlci8gc3RpbGwgdXNlIG5vcm1hbCBqcyBmdW5jdGlvblxuICovXG5mdW5jdGlvbiBmaW5kKGFycmF5LCBwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgaWYgKCAhQXJyYXkucHJvdG90eXBlLmZpbmQpIHtcbiAgICAvLyBpZHggbmVlZHMgdG8gYmUgYSBOdW1iZXIsIGZvci4uaW4gcmV0dXJucyBzdHJpbmdcbiAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBhcnJheS5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICBpZiAocHJlZGljYXRlLmNhbGwodGhpc0FyZywgYXJyYXlbaWR4XSwgaWR4LCBhcnJheSkpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5W2lkeF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcmV0dXJuIGFycmF5LmZpbmQocHJlZGljYXRlLCB0aGlzQXJnKTtcbn1cbmZ1bmN0aW9uIGZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gIGlmICggIUFycmF5LnByb3RvdHlwZS5maW5kSW5kZXgpIHtcbiAgICAvLyBpZHggbmVlZHMgdG8gYmUgYSBOdW1iZXIsIGZvci4uaW4gcmV0dXJucyBzdHJpbmdcbiAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBhcnJheS5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICBpZiAocHJlZGljYXRlLmNhbGwodGhpc0FyZywgYXJyYXlbaWR4XSwgaWR4LCBhcnJheSkpIHtcbiAgICAgICAgcmV0dXJuIGlkeDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICByZXR1cm4gYXJyYXkuZmluZEluZGV4KHByZWRpY2F0ZSwgdGhpc0FyZyk7XG59XG5mdW5jdGlvbiB0b0FycmF5KGFyZykge1xuICBpZiAoICFBcnJheS5mcm9tKSB7XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZyk7XG4gIH1cblxuICByZXR1cm4gQXJyYXkuZnJvbShhcmcpO1xufVxuZnVuY3Rpb24gaW5jbHVkZXMoYXJyYXksIHZhbHVlKSB7XG4gIGlmICggIUFycmF5LnByb3RvdHlwZS5pbmNsdWRlcykge1xuICAgIGZvciAodmFyIGlkeCBpbiBhcnJheSkge1xuICAgICAgaWYgKGFycmF5W2lkeF0gPT09IHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBhcnJheS5pbmNsdWRlcyh2YWx1ZSk7XG59XG5cbnZhciBxdWVyeVNlbGVjdG9yID0gZnVuY3Rpb24gcXVlcnlTZWxlY3RvcihhcmcsIGVsKSB7XG4gIHJldHVybiAoZWwgfHwgZG9jdW1lbnQpLnF1ZXJ5U2VsZWN0b3JBbGwoYXJnKTtcbn07XG5mdW5jdGlvbiBnZXRUYWcodGFncywgdGFnKSB7XG4gIGlmICghdGFnc1t0YWddKSB7XG4gICAgdGFnc1t0YWddID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUodGFnKVswXTtcbiAgfVxuXG4gIHJldHVybiB0YWdzW3RhZ107XG59XG5mdW5jdGlvbiBnZXRFbGVtZW50c0tleShfcmVmKSB7XG4gIHZhciBib2R5ID0gX3JlZi5ib2R5LFxuICAgICAgcGJvZHkgPSBfcmVmLnBib2R5O1xuICByZXR1cm4gYm9keSA/ICdib2R5JyA6IHBib2R5ID8gJ3Bib2R5JyA6ICdoZWFkJztcbn1cbmZ1bmN0aW9uIHF1ZXJ5RWxlbWVudHMocGFyZW50Tm9kZSwgX3JlZjIsIGF0dHJpYnV0ZXMpIHtcbiAgdmFyIGFwcElkID0gX3JlZjIuYXBwSWQsXG4gICAgICBhdHRyaWJ1dGUgPSBfcmVmMi5hdHRyaWJ1dGUsXG4gICAgICB0eXBlID0gX3JlZjIudHlwZSxcbiAgICAgIHRhZ0lES2V5TmFtZSA9IF9yZWYyLnRhZ0lES2V5TmFtZTtcbiAgYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXMgfHwge307XG4gIHZhciBxdWVyaWVzID0gW1wiXCIuY29uY2F0KHR5cGUsIFwiW1wiKS5jb25jYXQoYXR0cmlidXRlLCBcIj1cXFwiXCIpLmNvbmNhdChhcHBJZCwgXCJcXFwiXVwiKSwgXCJcIi5jb25jYXQodHlwZSwgXCJbZGF0YS1cIikuY29uY2F0KHRhZ0lES2V5TmFtZSwgXCJdXCIpXS5tYXAoZnVuY3Rpb24gKHF1ZXJ5KSB7XG4gICAgZm9yICh2YXIga2V5IGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIHZhciB2YWwgPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICB2YXIgYXR0cmlidXRlVmFsdWUgPSB2YWwgJiYgdmFsICE9PSB0cnVlID8gXCI9XFxcIlwiLmNvbmNhdCh2YWwsIFwiXFxcIlwiKSA6ICcnO1xuICAgICAgcXVlcnkgKz0gXCJbZGF0YS1cIi5jb25jYXQoa2V5KS5jb25jYXQoYXR0cmlidXRlVmFsdWUsIFwiXVwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcXVlcnk7XG4gIH0pO1xuICByZXR1cm4gdG9BcnJheShxdWVyeVNlbGVjdG9yKHF1ZXJpZXMuam9pbignLCAnKSwgcGFyZW50Tm9kZSkpO1xufVxuZnVuY3Rpb24gcmVtb3ZlRWxlbWVudHNCeUFwcElkKF9yZWYzLCBhcHBJZCkge1xuICB2YXIgYXR0cmlidXRlID0gX3JlZjMuYXR0cmlidXRlO1xuICB0b0FycmF5KHF1ZXJ5U2VsZWN0b3IoXCJbXCIuY29uY2F0KGF0dHJpYnV0ZSwgXCI9XFxcIlwiKS5jb25jYXQoYXBwSWQsIFwiXFxcIl1cIikpKS5tYXAoZnVuY3Rpb24gKGVsKSB7XG4gICAgcmV0dXJuIGVsLnJlbW92ZSgpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUF0dHJpYnV0ZShlbCwgYXR0cmlidXRlTmFtZSkge1xuICBlbC5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7XG59XG5cbmZ1bmN0aW9uIGhhc01ldGFJbmZvKHZtKSB7XG4gIHZtID0gdm0gfHwgdGhpcztcbiAgcmV0dXJuIHZtICYmICh2bVtyb290Q29uZmlnS2V5XSA9PT0gdHJ1ZSB8fCBpc09iamVjdCh2bVtyb290Q29uZmlnS2V5XSkpO1xufSAvLyBhIGNvbXBvbmVudCBpcyBpbiBhIG1ldGFJbmZvIGJyYW5jaCB3aGVuIGl0c2VsZiBoYXMgbWV0YSBpbmZvIG9yIG9uZSBvZiBpdHMgKGdyYW5kLSljaGlsZHJlbiBoYXNcblxuZnVuY3Rpb24gaW5NZXRhSW5mb0JyYW5jaCh2bSkge1xuICB2bSA9IHZtIHx8IHRoaXM7XG4gIHJldHVybiB2bSAmJiAhaXNVbmRlZmluZWQodm1bcm9vdENvbmZpZ0tleV0pO1xufVxuXG5mdW5jdGlvbiBwYXVzZShyb290Vm0sIHJlZnJlc2gpIHtcbiAgcm9vdFZtW3Jvb3RDb25maWdLZXldLnBhdXNpbmcgPSB0cnVlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByZXN1bWUocm9vdFZtLCByZWZyZXNoKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHJlc3VtZShyb290Vm0sIHJlZnJlc2gpIHtcbiAgcm9vdFZtW3Jvb3RDb25maWdLZXldLnBhdXNpbmcgPSBmYWxzZTtcblxuICBpZiAocmVmcmVzaCB8fCByZWZyZXNoID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gcm9vdFZtLiRtZXRhKCkucmVmcmVzaCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFkZE5hdkd1YXJkcyhyb290Vm0pIHtcbiAgdmFyIHJvdXRlciA9IHJvb3RWbS4kcm91dGVyOyAvLyByZXR1cm4gd2hlbiBuYXYgZ3VhcmRzIGFscmVhZHkgYWRkZWQgb3Igbm8gcm91dGVyIGV4aXN0c1xuXG4gIGlmIChyb290Vm1bcm9vdENvbmZpZ0tleV0ubmF2R3VhcmRzIHx8ICFyb3V0ZXIpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJvb3RWbVtyb290Q29uZmlnS2V5XS5uYXZHdWFyZHMgPSB0cnVlO1xuICByb3V0ZXIuYmVmb3JlRWFjaChmdW5jdGlvbiAodG8sIGZyb20sIG5leHQpIHtcbiAgICBwYXVzZShyb290Vm0pO1xuICAgIG5leHQoKTtcbiAgfSk7XG4gIHJvdXRlci5hZnRlckVhY2goZnVuY3Rpb24gKCkge1xuICAgIHJvb3RWbS4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9yZXN1bWUgPSByZXN1bWUocm9vdFZtKSxcbiAgICAgICAgICBtZXRhSW5mbyA9IF9yZXN1bWUubWV0YUluZm87XG5cbiAgICAgIGlmIChtZXRhSW5mbyAmJiBpc0Z1bmN0aW9uKG1ldGFJbmZvLmFmdGVyTmF2aWdhdGlvbikpIHtcbiAgICAgICAgbWV0YUluZm8uYWZ0ZXJOYXZpZ2F0aW9uKG1ldGFJbmZvKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbnZhciBhcHBJZCA9IDE7XG5mdW5jdGlvbiBjcmVhdGVNaXhpbihWdWUsIG9wdGlvbnMpIHtcbiAgLy8gZm9yIHdoaWNoIFZ1ZSBsaWZlY3ljbGUgaG9va3Mgc2hvdWxkIHRoZSBtZXRhSW5mbyBiZSByZWZyZXNoZWRcbiAgdmFyIHVwZGF0ZU9uTGlmZWN5Y2xlSG9vayA9IFsnYWN0aXZhdGVkJywgJ2RlYWN0aXZhdGVkJywgJ2JlZm9yZU1vdW50J107XG4gIHZhciB3YXNTZXJ2ZXJSZW5kZXJlZCA9IGZhbHNlOyAvLyB3YXRjaCBmb3IgY2xpZW50IHNpZGUgY29tcG9uZW50IHVwZGF0ZXNcblxuICByZXR1cm4ge1xuICAgIGJlZm9yZUNyZWF0ZTogZnVuY3Rpb24gYmVmb3JlQ3JlYXRlKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciByb290S2V5ID0gJyRyb290JztcbiAgICAgIHZhciAkcm9vdCA9IHRoaXNbcm9vdEtleV07XG4gICAgICB2YXIgJG9wdGlvbnMgPSB0aGlzLiRvcHRpb25zO1xuICAgICAgdmFyIGRldnRvb2xzRW5hYmxlZCA9IFZ1ZS5jb25maWcuZGV2dG9vbHM7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ19oYXNNZXRhSW5mbycsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAvLyBTaG93IGRlcHJlY2F0aW9uIHdhcm5pbmcgb25jZSB3aGVuIGRldnRvb2xzIGVuYWJsZWRcbiAgICAgICAgICBpZiAoZGV2dG9vbHNFbmFibGVkICYmICEkcm9vdFtyb290Q29uZmlnS2V5XS5kZXByZWNhdGlvbldhcm5pbmdTaG93bikge1xuICAgICAgICAgICAgd2FybignVnVlTWV0YSBEZXByZWNhdGlvbldhcm5pbmc6IF9oYXNNZXRhSW5mbyBoYXMgYmVlbiBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbi4gUGxlYXNlIHVzZSBoYXNNZXRhSW5mbyh2bSkgaW5zdGVhZCcpO1xuICAgICAgICAgICAgJHJvb3Rbcm9vdENvbmZpZ0tleV0uZGVwcmVjYXRpb25XYXJuaW5nU2hvd24gPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBoYXNNZXRhSW5mbyh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0aGlzID09PSAkcm9vdCkge1xuICAgICAgICAkcm9vdC4kb25jZSgnaG9vazpiZWZvcmVNb3VudCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB3YXNTZXJ2ZXJSZW5kZXJlZCA9IHRoaXMuJGVsICYmIHRoaXMuJGVsLm5vZGVUeXBlID09PSAxICYmIHRoaXMuJGVsLmhhc0F0dHJpYnV0ZSgnZGF0YS1zZXJ2ZXItcmVuZGVyZWQnKTsgLy8gSW4gbW9zdCBjYXNlcyB3aGVuIHlvdSBoYXZlIGEgU1NSIGFwcCBpdCB3aWxsIGJlIHRoZSBmaXJzdCBhcHAgdGhhdHMgZ29ubmEgYmVcbiAgICAgICAgICAvLyBpbml0aWF0ZWQsIGlmIHdlIGNhbnQgZGV0ZWN0IHRoZSBkYXRhLXNlcnZlci1yZW5kZXJlZCBhdHRyaWJ1dGUgZnJvbSBWdWUgYnV0IHdlXG4gICAgICAgICAgLy8gZG8gc2VlIG91ciBvd24gc3NyQXR0cmlidXRlIHRoZW4gX2Fzc3VtZV8gdGhlIFZ1ZSBhcHAgd2l0aCBhcHBJZCAxIGlzIHRoZSBzc3IgYXBwXG4gICAgICAgICAgLy8gYXR0ZW1wdGVkIGZpeCBmb3IgIzQwNCAmICM1NjIsIGJ1dCB3ZSBybHkgbmVlZCB0byByZWZhY3RvciBob3cgd2UgcGFzcyBhcHBJZHMgZnJvbVxuICAgICAgICAgIC8vIHNzciB0byB0aGUgY2xpZW50XG5cbiAgICAgICAgICBpZiAoIXdhc1NlcnZlclJlbmRlcmVkICYmICRyb290W3Jvb3RDb25maWdLZXldICYmICRyb290W3Jvb3RDb25maWdLZXldLmFwcElkID09PSAxKSB7XG4gICAgICAgICAgICB2YXIgaHRtbFRhZyA9IGdldFRhZyh7fSwgJ2h0bWwnKTtcbiAgICAgICAgICAgIHdhc1NlcnZlclJlbmRlcmVkID0gaHRtbFRhZyAmJiBodG1sVGFnLmhhc0F0dHJpYnV0ZShvcHRpb25zLnNzckF0dHJpYnV0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gLy8gQWRkIGEgbWFya2VyIHRvIGtub3cgaWYgaXQgdXNlcyBtZXRhSW5mb1xuICAgICAgLy8gX3Zub2RlIGlzIHVzZWQgdG8ga25vdyB0aGF0IGl0J3MgYXR0YWNoZWQgdG8gYSByZWFsIGNvbXBvbmVudFxuICAgICAgLy8gdXNlZnVsIGlmIHdlIHVzZSBzb21lIG1peGluIHRvIGFkZCBzb21lIG1ldGEgdGFncyAobGlrZSBudXh0LWkxOG4pXG5cblxuICAgICAgaWYgKGlzVW5kZWZpbmVkKCRvcHRpb25zW29wdGlvbnMua2V5TmFtZV0pIHx8ICRvcHRpb25zW29wdGlvbnMua2V5TmFtZV0gPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoISRyb290W3Jvb3RDb25maWdLZXldKSB7XG4gICAgICAgICRyb290W3Jvb3RDb25maWdLZXldID0ge1xuICAgICAgICAgIGFwcElkOiBhcHBJZFxuICAgICAgICB9O1xuICAgICAgICBhcHBJZCsrO1xuXG4gICAgICAgIGlmIChkZXZ0b29sc0VuYWJsZWQgJiYgJHJvb3QuJG9wdGlvbnNbb3B0aW9ucy5rZXlOYW1lXSkge1xuICAgICAgICAgIC8vIHVzZSBuZXh0VGljayBzbyB0aGUgY2hpbGRyZW4gc2hvdWxkIGJlIGFkZGVkIHRvICRyb290XG4gICAgICAgICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gZmluZCB0aGUgZmlyc3QgY2hpbGQgdGhhdCBsaXN0cyBmbk9wdGlvbnNcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IGZpbmQoJHJvb3QuJGNoaWxkcmVuLCBmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgICByZXR1cm4gYy4kdm5vZGUgJiYgYy4kdm5vZGUuZm5PcHRpb25zO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChjaGlsZCAmJiBjaGlsZC4kdm5vZGUuZm5PcHRpb25zW29wdGlvbnMua2V5TmFtZV0pIHtcbiAgICAgICAgICAgICAgd2FybihcIlZ1ZU1ldGEgaGFzIGRldGVjdGVkIGEgcG9zc2libGUgZ2xvYmFsIG1peGluIHdoaWNoIGFkZHMgYSBcIi5jb25jYXQob3B0aW9ucy5rZXlOYW1lLCBcIiBwcm9wZXJ0eSB0byBhbGwgVnVlIGNvbXBvbmVudHMgb24gdGhlIHBhZ2UuIFRoaXMgY291bGQgY2F1c2Ugc2V2ZXJlIHBlcmZvcm1hbmNlIGlzc3Vlcy4gSWYgcG9zc2libGUsIHVzZSAkbWV0YSgpLmFkZEFwcCB0byBhZGQgbWV0YSBpbmZvcm1hdGlvbiBpbnN0ZWFkXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSAvLyB0byBzcGVlZCB1cCB1cGRhdGVzIHdlIGtlZXAgdHJhY2sgb2YgYnJhbmNoZXMgd2hpY2ggaGF2ZSBhIGNvbXBvbmVudCB3aXRoIHZ1ZS1tZXRhIGluZm8gZGVmaW5lZFxuICAgICAgLy8gaWYgX3Z1ZU1ldGEgPSB0cnVlIGl0IGhhcyBpbmZvLCBpZiBfdnVlTWV0YSA9IGZhbHNlIGEgY2hpbGQgaGFzIGluZm9cblxuXG4gICAgICBpZiAoIXRoaXNbcm9vdENvbmZpZ0tleV0pIHtcbiAgICAgICAgdGhpc1tyb290Q29uZmlnS2V5XSA9IHRydWU7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLiRwYXJlbnQ7XG5cbiAgICAgICAgd2hpbGUgKHBhcmVudCAmJiBwYXJlbnQgIT09ICRyb290KSB7XG4gICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHBhcmVudFtyb290Q29uZmlnS2V5XSkpIHtcbiAgICAgICAgICAgIHBhcmVudFtyb290Q29uZmlnS2V5XSA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhcmVudCA9IHBhcmVudC4kcGFyZW50O1xuICAgICAgICB9XG4gICAgICB9IC8vIGNvZXJjZSBmdW5jdGlvbi1zdHlsZSBtZXRhSW5mbyB0byBhIGNvbXB1dGVkIHByb3Agc28gd2UgY2FuIG9ic2VydmVcbiAgICAgIC8vIGl0IG9uIGNyZWF0aW9uXG5cblxuICAgICAgaWYgKGlzRnVuY3Rpb24oJG9wdGlvbnNbb3B0aW9ucy5rZXlOYW1lXSkpIHtcbiAgICAgICAgJG9wdGlvbnMuY29tcHV0ZWQgPSAkb3B0aW9ucy5jb21wdXRlZCB8fCB7fTtcbiAgICAgICAgJG9wdGlvbnMuY29tcHV0ZWQuJG1ldGFJbmZvID0gJG9wdGlvbnNbb3B0aW9ucy5rZXlOYW1lXTtcblxuICAgICAgICBpZiAoIXRoaXMuJGlzU2VydmVyKSB7XG4gICAgICAgICAgLy8gaWYgY29tcHV0ZWQgJG1ldGFJbmZvIGV4aXN0cywgd2F0Y2ggaXQgZm9yIHVwZGF0ZXMgJiB0cmlnZ2VyIGEgcmVmcmVzaFxuICAgICAgICAgIC8vIHdoZW4gaXQgY2hhbmdlcyAoaS5lLiBhdXRvbWF0aWNhbGx5IGhhbmRsZSBhc3luYyBhY3Rpb25zIHRoYXQgYWZmZWN0IG1ldGFJbmZvKVxuICAgICAgICAgIC8vIGNyZWRpdCBmb3IgdGhpcyBzdWdnZXN0aW9uIGdvZXMgdG8gW1PDqWJhc3RpZW4gQ2hvcGluXShodHRwczovL2dpdGh1Yi5jb20vQXRpbnV4KVxuICAgICAgICAgIHRoaXMuJG9uKCdob29rOmNyZWF0ZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLiR3YXRjaCgnJG1ldGFJbmZvJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB0cmlnZ2VyVXBkYXRlKG9wdGlvbnMsIHRoaXNbcm9vdEtleV0sICd3YXRjaGVyJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBmb3JjZSBhbiBpbml0aWFsIHJlZnJlc2ggb24gcGFnZSBsb2FkIGFuZCBwcmV2ZW50IG90aGVyIGxpZmVjeWNsZUhvb2tzXG4gICAgICAvLyB0byB0cmlnZ2VyVXBkYXRlIHVudGlsIHRoaXMgaW5pdGlhbCByZWZyZXNoIGlzIGZpbmlzaGVkXG4gICAgICAvLyB0aGlzIGlzIHRvIG1ha2Ugc3VyZSB0aGF0IHdoZW4gYSBwYWdlIGlzIG9wZW5lZCBpbiBhbiBpbmFjdGl2ZSB0YWIgd2hpY2hcbiAgICAgIC8vIGhhcyB0aHJvdHRsZWQgckFGL3RpbWVycyB3ZSBzdGlsbCBpbW1lZGlhdGVseSBzZXQgdGhlIHBhZ2UgdGl0bGVcblxuXG4gICAgICBpZiAoaXNVbmRlZmluZWQoJHJvb3Rbcm9vdENvbmZpZ0tleV0uaW5pdGlhbGl6ZWQpKSB7XG4gICAgICAgICRyb290W3Jvb3RDb25maWdLZXldLmluaXRpYWxpemVkID0gdGhpcy4kaXNTZXJ2ZXI7XG5cbiAgICAgICAgaWYgKCEkcm9vdFtyb290Q29uZmlnS2V5XS5pbml0aWFsaXplZCkge1xuICAgICAgICAgIGlmICghJHJvb3Rbcm9vdENvbmZpZ0tleV0uaW5pdGlhbGl6ZWRTc3IpIHtcbiAgICAgICAgICAgICRyb290W3Jvb3RDb25maWdLZXldLmluaXRpYWxpemVkU3NyID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuJG9uKCdob29rOmJlZm9yZU1vdW50JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgJHJvb3QgPSB0aGlzW3Jvb3RLZXldOyAvLyBpZiB0aGlzIFZ1ZS1hcHAgd2FzIHNlcnZlciByZW5kZXJlZCwgc2V0IHRoZSBhcHBJZCB0byAnc3NyJ1xuICAgICAgICAgICAgICAvLyBvbmx5IG9uZSBTU1IgYXBwIHBlciBwYWdlIGlzIHN1cHBvcnRlZFxuXG4gICAgICAgICAgICAgIGlmICh3YXNTZXJ2ZXJSZW5kZXJlZCkge1xuICAgICAgICAgICAgICAgICRyb290W3Jvb3RDb25maWdLZXldLmFwcElkID0gb3B0aW9ucy5zc3JBcHBJZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSAvLyB3ZSB1c2UgdGhlIG1vdW50ZWQgaG9vayBoZXJlIGFzIG9uIHBhZ2UgbG9hZFxuXG5cbiAgICAgICAgICB0aGlzLiRvbignaG9vazptb3VudGVkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyICRyb290ID0gdGhpc1tyb290S2V5XTtcblxuICAgICAgICAgICAgaWYgKCRyb290W3Jvb3RDb25maWdLZXldLmluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gLy8gdXNlZCBpbiB0cmlnZ2VyVXBkYXRlIHRvIGNoZWNrIGlmIGEgY2hhbmdlIHdhcyB0cmlnZ2VyZWRcbiAgICAgICAgICAgIC8vIGR1cmluZyBpbml0aWFsaXphdGlvblxuXG5cbiAgICAgICAgICAgICRyb290W3Jvb3RDb25maWdLZXldLmluaXRpYWxpemluZyA9IHRydWU7IC8vIHJlZnJlc2ggbWV0YSBpbiBuZXh0VGljayBzbyBhbGwgY2hpbGQgY29tcG9uZW50cyBoYXZlIGxvYWRlZFxuXG4gICAgICAgICAgICB0aGlzLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciBfJHJvb3QkJG1ldGEkcmVmcmVzaCA9ICRyb290LiRtZXRhKCkucmVmcmVzaCgpLFxuICAgICAgICAgICAgICAgICAgdGFncyA9IF8kcm9vdCQkbWV0YSRyZWZyZXNoLnRhZ3MsXG4gICAgICAgICAgICAgICAgICBtZXRhSW5mbyA9IF8kcm9vdCQkbWV0YSRyZWZyZXNoLm1ldGFJbmZvOyAvLyBBZnRlciBzc3IgaHlkcmF0aW9uIChpZGVudGlmaWVyIGJ5IHRhZ3MgPT09IGZhbHNlKSBjaGVja1xuICAgICAgICAgICAgICAvLyBpZiBpbml0aWFsaXplZCB3YXMgc2V0IHRvIG51bGwgaW4gdHJpZ2dlclVwZGF0ZS4gVGhhdCdkIG1lYW5cbiAgICAgICAgICAgICAgLy8gdGhhdCBkdXJpbmcgaW5pdGlsYXphdGlvbiBjaGFuZ2VzIHdoZXJlIHRyaWdnZXJlZCB3aGljaCBuZWVkXG4gICAgICAgICAgICAgIC8vIHRvIGJlIGFwcGxpZWQgT1IgYSBtZXRhSW5mbyB3YXRjaGVyIHdhcyB0cmlnZ2VyZWQgYmVmb3JlIHRoZVxuICAgICAgICAgICAgICAvLyBjdXJyZW50IGhvb2sgd2FzIGNhbGxlZFxuICAgICAgICAgICAgICAvLyAoZHVyaW5nIGluaXRpYWxpemF0aW9uIGFsbCBjaGFuZ2VzIGFyZSBibG9ja2VkKVxuXG5cbiAgICAgICAgICAgICAgaWYgKHRhZ3MgPT09IGZhbHNlICYmICRyb290W3Jvb3RDb25maWdLZXldLmluaXRpYWxpemVkID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyaWdnZXJVcGRhdGUob3B0aW9ucywgJHJvb3QsICdpbml0Jyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAkcm9vdFtyb290Q29uZmlnS2V5XS5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgICAgIGRlbGV0ZSAkcm9vdFtyb290Q29uZmlnS2V5XS5pbml0aWFsaXppbmc7IC8vIGFkZCB0aGUgbmF2aWdhdGlvbiBndWFyZHMgaWYgdGhleSBoYXZlbnQgYmVlbiBhZGRlZCB5ZXRcbiAgICAgICAgICAgICAgLy8gdGhleSBhcmUgbmVlZGVkIGZvciB0aGUgYWZ0ZXJOYXZpZ2F0aW9uIGNhbGxiYWNrXG5cbiAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLnJlZnJlc2hPbmNlT25OYXZpZ2F0aW9uICYmIG1ldGFJbmZvLmFmdGVyTmF2aWdhdGlvbikge1xuICAgICAgICAgICAgICAgIGFkZE5hdkd1YXJkcygkcm9vdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pOyAvLyBhZGQgdGhlIG5hdmlnYXRpb24gZ3VhcmRzIGlmIHJlcXVlc3RlZFxuXG4gICAgICAgICAgaWYgKG9wdGlvbnMucmVmcmVzaE9uY2VPbk5hdmlnYXRpb24pIHtcbiAgICAgICAgICAgIGFkZE5hdkd1YXJkcygkcm9vdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuJG9uKCdob29rOmRlc3Ryb3llZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICAvLyBkbyBub3QgdHJpZ2dlciByZWZyZXNoOlxuICAgICAgICAvLyAtIHdoZW4gdXNlciBjb25maWd1cmVkIHRvIG5vdCB3YWl0IGZvciB0cmFuc2l0aW9ucyBvbiBkZXN0cm95ZWRcbiAgICAgICAgLy8gLSB3aGVuIHRoZSBjb21wb25lbnQgZG9lc250IGhhdmUgYSBwYXJlbnRcbiAgICAgICAgLy8gLSBkb2VzbnQgaGF2ZSBtZXRhSW5mbyBkZWZpbmVkXG4gICAgICAgIGlmICghdGhpcy4kcGFyZW50IHx8ICFoYXNNZXRhSW5mbyh0aGlzKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlbGV0ZSB0aGlzLl9oYXNNZXRhSW5mbztcbiAgICAgICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICghb3B0aW9ucy53YWl0T25EZXN0cm95ZWQgfHwgIV90aGlzLiRlbCB8fCAhX3RoaXMuJGVsLm9mZnNldFBhcmVudCkge1xuICAgICAgICAgICAgdHJpZ2dlclVwZGF0ZShvcHRpb25zLCBfdGhpcy4kcm9vdCwgJ2Rlc3Ryb3llZCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gLy8gV2FpdCB0aGF0IGVsZW1lbnQgaXMgaGlkZGVuIGJlZm9yZSByZWZyZXNoaW5nIG1ldGEgdGFncyAodG8gc3VwcG9ydCBhbmltYXRpb25zKVxuXG5cbiAgICAgICAgICB2YXIgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuJGVsICYmIF90aGlzLiRlbC5vZmZzZXRQYXJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgbGluZSAqL1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgICAgICAgdHJpZ2dlclVwZGF0ZShvcHRpb25zLCBfdGhpcy4kcm9vdCwgJ2Rlc3Ryb3llZCcpO1xuICAgICAgICAgIH0sIDUwKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTsgLy8gZG8gbm90IHRyaWdnZXIgcmVmcmVzaCBvbiB0aGUgc2VydmVyIHNpZGVcblxuICAgICAgaWYgKHRoaXMuJGlzU2VydmVyKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gbm8gbmVlZCB0byBhZGQgdGhpcyBob29rcyBvbiBzZXJ2ZXIgc2lkZVxuXG5cbiAgICAgIHVwZGF0ZU9uTGlmZWN5Y2xlSG9vay5mb3JFYWNoKGZ1bmN0aW9uIChsaWZlY3ljbGVIb29rKSB7XG4gICAgICAgIF90aGlzMi4kb24oXCJob29rOlwiLmNvbmNhdChsaWZlY3ljbGVIb29rKSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRyaWdnZXJVcGRhdGUob3B0aW9ucywgdGhpc1tyb290S2V5XSwgbGlmZWN5Y2xlSG9vayk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgLy8gY29tYmluZSBvcHRpb25zXG4gIG9wdGlvbnMgPSBpc09iamVjdChvcHRpb25zKSA/IG9wdGlvbnMgOiB7fTsgLy8gVGhlIG9wdGlvbnMgYXJlIHNldCBsaWtlIHRoaXMgc28gdGhleSBjYW5cbiAgLy8gYmUgbWluaWZpZWQgYnkgdGVyc2VyIHdoaWxlIGtlZXBpbmcgdGhlXG4gIC8vIHVzZXIgYXBpIGludGFjdFxuICAvLyB0ZXJzZXIgLS1tYW5nbGUtcHJvcGVydGllcyBrZWVwX3F1b3RlZD1zdHJpY3RcblxuICAvKiBlc2xpbnQtZGlzYWJsZSBkb3Qtbm90YXRpb24gKi9cblxuICByZXR1cm4ge1xuICAgIGtleU5hbWU6IG9wdGlvbnNbJ2tleU5hbWUnXSB8fCBkZWZhdWx0T3B0aW9ucy5rZXlOYW1lLFxuICAgIGF0dHJpYnV0ZTogb3B0aW9uc1snYXR0cmlidXRlJ10gfHwgZGVmYXVsdE9wdGlvbnMuYXR0cmlidXRlLFxuICAgIHNzckF0dHJpYnV0ZTogb3B0aW9uc1snc3NyQXR0cmlidXRlJ10gfHwgZGVmYXVsdE9wdGlvbnMuc3NyQXR0cmlidXRlLFxuICAgIHRhZ0lES2V5TmFtZTogb3B0aW9uc1sndGFnSURLZXlOYW1lJ10gfHwgZGVmYXVsdE9wdGlvbnMudGFnSURLZXlOYW1lLFxuICAgIGNvbnRlbnRLZXlOYW1lOiBvcHRpb25zWydjb250ZW50S2V5TmFtZSddIHx8IGRlZmF1bHRPcHRpb25zLmNvbnRlbnRLZXlOYW1lLFxuICAgIG1ldGFUZW1wbGF0ZUtleU5hbWU6IG9wdGlvbnNbJ21ldGFUZW1wbGF0ZUtleU5hbWUnXSB8fCBkZWZhdWx0T3B0aW9ucy5tZXRhVGVtcGxhdGVLZXlOYW1lLFxuICAgIGRlYm91bmNlV2FpdDogaXNVbmRlZmluZWQob3B0aW9uc1snZGVib3VuY2VXYWl0J10pID8gZGVmYXVsdE9wdGlvbnMuZGVib3VuY2VXYWl0IDogb3B0aW9uc1snZGVib3VuY2VXYWl0J10sXG4gICAgd2FpdE9uRGVzdHJveWVkOiBpc1VuZGVmaW5lZChvcHRpb25zWyd3YWl0T25EZXN0cm95ZWQnXSkgPyBkZWZhdWx0T3B0aW9ucy53YWl0T25EZXN0cm95ZWQgOiBvcHRpb25zWyd3YWl0T25EZXN0cm95ZWQnXSxcbiAgICBzc3JBcHBJZDogb3B0aW9uc1snc3NyQXBwSWQnXSB8fCBkZWZhdWx0T3B0aW9ucy5zc3JBcHBJZCxcbiAgICByZWZyZXNoT25jZU9uTmF2aWdhdGlvbjogISFvcHRpb25zWydyZWZyZXNoT25jZU9uTmF2aWdhdGlvbiddXG4gIH07XG4gIC8qIGVzbGludC1lbmFibGUgZG90LW5vdGF0aW9uICovXG59XG5mdW5jdGlvbiBnZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgdmFyIG9wdGlvbnNDb3B5ID0ge307XG5cbiAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zQ29weVtrZXldID0gb3B0aW9uc1trZXldO1xuICB9XG5cbiAgcmV0dXJuIG9wdGlvbnNDb3B5O1xufVxuXG5mdW5jdGlvbiBlbnN1cmVJc0FycmF5KGFyZywga2V5KSB7XG4gIGlmICgha2V5IHx8ICFpc09iamVjdChhcmcpKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkoYXJnKSA/IGFyZyA6IFtdO1xuICB9XG5cbiAgaWYgKCFpc0FycmF5KGFyZ1trZXldKSkge1xuICAgIGFyZ1trZXldID0gW107XG4gIH1cblxuICByZXR1cm4gYXJnO1xufVxuXG52YXIgc2VydmVyU2VxdWVuY2VzID0gW1svJi9nLCAnJmFtcDsnXSwgWy88L2csICcmbHQ7J10sIFsvPi9nLCAnJmd0OyddLCBbL1wiL2csICcmcXVvdDsnXSwgWy8nL2csICcmI3gyNzsnXV07XG52YXIgY2xpZW50U2VxdWVuY2VzID0gW1svJi9nLCBcIiZcIl0sIFsvPC9nLCBcIjxcIl0sIFsvPi9nLCBcIj5cIl0sIFsvXCIvZywgXCJcXFwiXCJdLCBbLycvZywgXCInXCJdXTsgLy8gc2FuaXRpemVzIHBvdGVudGlhbGx5IGRhbmdlcm91cyBjaGFyYWN0ZXJzXG5cbmZ1bmN0aW9uIGVzY2FwZShpbmZvLCBvcHRpb25zLCBlc2NhcGVPcHRpb25zLCBlc2NhcGVLZXlzKSB7XG4gIHZhciB0YWdJREtleU5hbWUgPSBvcHRpb25zLnRhZ0lES2V5TmFtZTtcbiAgdmFyIF9lc2NhcGVPcHRpb25zJGRvRXNjYSA9IGVzY2FwZU9wdGlvbnMuZG9Fc2NhcGUsXG4gICAgICBkb0VzY2FwZSA9IF9lc2NhcGVPcHRpb25zJGRvRXNjYSA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKHYpIHtcbiAgICByZXR1cm4gdjtcbiAgfSA6IF9lc2NhcGVPcHRpb25zJGRvRXNjYTtcbiAgdmFyIGVzY2FwZWQgPSB7fTtcblxuICBmb3IgKHZhciBrZXkgaW4gaW5mbykge1xuICAgIHZhciB2YWx1ZSA9IGluZm9ba2V5XTsgLy8gbm8gbmVlZCB0byBlc2NhcGUgY29uZmlndXJhdGlvbiBvcHRpb25zXG5cbiAgICBpZiAoaW5jbHVkZXMobWV0YUluZm9PcHRpb25LZXlzLCBrZXkpKSB7XG4gICAgICBlc2NhcGVkW2tleV0gPSB2YWx1ZTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gLy8gZG8gbm90IHVzZSBkZXN0cnVjdHVyaW5nIGZvciBkaXNhYmxlT3B0aW9uS2V5cywgaXQgaW5jcmVhc2VzIHRyYW5zcGlsZWQgc2l6ZVxuICAgIC8vIGR1ZSB0byB2YXIgY2hlY2tzIHdoaWxlIHdlIGFyZSBndWFyYW50ZWVkIHRoZSBzdHJ1Y3R1cmUgb2YgdGhlIGNiXG5cblxuICAgIHZhciBkaXNhYmxlS2V5ID0gZGlzYWJsZU9wdGlvbktleXNbMF07XG5cbiAgICBpZiAoZXNjYXBlT3B0aW9uc1tkaXNhYmxlS2V5XSAmJiBpbmNsdWRlcyhlc2NhcGVPcHRpb25zW2Rpc2FibGVLZXldLCBrZXkpKSB7XG4gICAgICAvLyB0aGlzIGluZm9ba2V5XSBkb2VzbnQgbmVlZCB0byBlc2NhcGVkIGlmIHRoZSBvcHRpb24gaXMgbGlzdGVkIGluIF9fZGFuZ2Vyb3VzbHlEaXNhYmxlU2FuaXRpemVyc1xuICAgICAgZXNjYXBlZFtrZXldID0gdmFsdWU7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgdGFnSWQgPSBpbmZvW3RhZ0lES2V5TmFtZV07XG5cbiAgICBpZiAodGFnSWQpIHtcbiAgICAgIGRpc2FibGVLZXkgPSBkaXNhYmxlT3B0aW9uS2V5c1sxXTsgLy8ga2V5cyB3aGljaCBhcmUgbGlzdGVkIGluIF9fZGFuZ2Vyb3VzbHlEaXNhYmxlU2FuaXRpemVyc0J5VGFnSUQgZm9yIHRoZSBjdXJyZW50IHZtaWQgZG8gbm90IG5lZWQgdG8gYmUgZXNjYXBlZFxuXG4gICAgICBpZiAoZXNjYXBlT3B0aW9uc1tkaXNhYmxlS2V5XSAmJiBlc2NhcGVPcHRpb25zW2Rpc2FibGVLZXldW3RhZ0lkXSAmJiBpbmNsdWRlcyhlc2NhcGVPcHRpb25zW2Rpc2FibGVLZXldW3RhZ0lkXSwga2V5KSkge1xuICAgICAgICBlc2NhcGVkW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgZXNjYXBlZFtrZXldID0gZG9Fc2NhcGUodmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGVzY2FwZWRba2V5XSA9IHZhbHVlLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgICBpZiAoaXNQdXJlT2JqZWN0KHYpKSB7XG4gICAgICAgICAgcmV0dXJuIGVzY2FwZSh2LCBvcHRpb25zLCBlc2NhcGVPcHRpb25zLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkb0VzY2FwZSh2KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoaXNQdXJlT2JqZWN0KHZhbHVlKSkge1xuICAgICAgZXNjYXBlZFtrZXldID0gZXNjYXBlKHZhbHVlLCBvcHRpb25zLCBlc2NhcGVPcHRpb25zLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXNjYXBlZFtrZXldID0gdmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKGVzY2FwZUtleXMpIHtcbiAgICAgIHZhciBlc2NhcGVkS2V5ID0gZG9Fc2NhcGUoa2V5KTtcblxuICAgICAgaWYgKGtleSAhPT0gZXNjYXBlZEtleSkge1xuICAgICAgICBlc2NhcGVkW2VzY2FwZWRLZXldID0gZXNjYXBlZFtrZXldO1xuICAgICAgICBkZWxldGUgZXNjYXBlZFtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlc2NhcGVkO1xufVxuZnVuY3Rpb24gZXNjYXBlTWV0YUluZm8ob3B0aW9ucywgaW5mbywgZXNjYXBlU2VxdWVuY2VzKSB7XG4gIGVzY2FwZVNlcXVlbmNlcyA9IGVzY2FwZVNlcXVlbmNlcyB8fCBbXTsgLy8gZG8gbm90IHVzZSBkZXN0cnVjdHVyaW5nIGZvciBzZXEsIGl0IGluY3JlYXNlcyB0cmFuc3BpbGVkIHNpemVcbiAgLy8gZHVlIHRvIHZhciBjaGVja3Mgd2hpbGUgd2UgYXJlIGd1YXJhbnRlZWQgdGhlIHN0cnVjdHVyZSBvZiB0aGUgY2JcblxuICB2YXIgZXNjYXBlT3B0aW9ucyA9IHtcbiAgICBkb0VzY2FwZTogZnVuY3Rpb24gZG9Fc2NhcGUodmFsdWUpIHtcbiAgICAgIHJldHVybiBlc2NhcGVTZXF1ZW5jZXMucmVkdWNlKGZ1bmN0aW9uICh2YWwsIHNlcSkge1xuICAgICAgICByZXR1cm4gdmFsLnJlcGxhY2Uoc2VxWzBdLCBzZXFbMV0pO1xuICAgICAgfSwgdmFsdWUpO1xuICAgIH1cbiAgfTtcbiAgZGlzYWJsZU9wdGlvbktleXMuZm9yRWFjaChmdW5jdGlvbiAoZGlzYWJsZUtleSwgaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgIGVuc3VyZUlzQXJyYXkoaW5mbywgZGlzYWJsZUtleSk7XG4gICAgfSBlbHNlIGlmIChpbmRleCA9PT0gMSkge1xuICAgICAgZm9yICh2YXIga2V5IGluIGluZm9bZGlzYWJsZUtleV0pIHtcbiAgICAgICAgZW5zdXJlSXNBcnJheShpbmZvW2Rpc2FibGVLZXldLCBrZXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGVzY2FwZU9wdGlvbnNbZGlzYWJsZUtleV0gPSBpbmZvW2Rpc2FibGVLZXldO1xuICB9KTsgLy8gYmVnaW4gc2FuaXRpemF0aW9uXG5cbiAgcmV0dXJuIGVzY2FwZShpbmZvLCBvcHRpb25zLCBlc2NhcGVPcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gYXBwbHlUZW1wbGF0ZShfcmVmLCBoZWFkT2JqZWN0LCB0ZW1wbGF0ZSwgY2h1bmspIHtcbiAgdmFyIGNvbXBvbmVudCA9IF9yZWYuY29tcG9uZW50LFxuICAgICAgbWV0YVRlbXBsYXRlS2V5TmFtZSA9IF9yZWYubWV0YVRlbXBsYXRlS2V5TmFtZSxcbiAgICAgIGNvbnRlbnRLZXlOYW1lID0gX3JlZi5jb250ZW50S2V5TmFtZTtcblxuICBpZiAodGVtcGxhdGUgPT09IHRydWUgfHwgaGVhZE9iamVjdFttZXRhVGVtcGxhdGVLZXlOYW1lXSA9PT0gdHJ1ZSkge1xuICAgIC8vIGFib3J0LCB0ZW1wbGF0ZSB3YXMgYWxyZWFkeSBhcHBsaWVkXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGlzVW5kZWZpbmVkKHRlbXBsYXRlKSAmJiBoZWFkT2JqZWN0W21ldGFUZW1wbGF0ZUtleU5hbWVdKSB7XG4gICAgdGVtcGxhdGUgPSBoZWFkT2JqZWN0W21ldGFUZW1wbGF0ZUtleU5hbWVdO1xuICAgIGhlYWRPYmplY3RbbWV0YVRlbXBsYXRlS2V5TmFtZV0gPSB0cnVlO1xuICB9IC8vIHJldHVybiBlYXJseSBpZiBubyB0ZW1wbGF0ZSBkZWZpbmVkXG5cblxuICBpZiAoIXRlbXBsYXRlKSB7XG4gICAgLy8gY2xlYW51cCBmYXVsdHkgdGVtcGxhdGUgcHJvcGVydGllc1xuICAgIGRlbGV0ZSBoZWFkT2JqZWN0W21ldGFUZW1wbGF0ZUtleU5hbWVdO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChpc1VuZGVmaW5lZChjaHVuaykpIHtcbiAgICBjaHVuayA9IGhlYWRPYmplY3RbY29udGVudEtleU5hbWVdO1xuICB9XG5cbiAgaGVhZE9iamVjdFtjb250ZW50S2V5TmFtZV0gPSBpc0Z1bmN0aW9uKHRlbXBsYXRlKSA/IHRlbXBsYXRlLmNhbGwoY29tcG9uZW50LCBjaHVuaykgOiB0ZW1wbGF0ZS5yZXBsYWNlKC8lcy9nLCBjaHVuayk7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlNZXJnZShfcmVmLCB0YXJnZXQsIHNvdXJjZSkge1xuICB2YXIgY29tcG9uZW50ID0gX3JlZi5jb21wb25lbnQsXG4gICAgICB0YWdJREtleU5hbWUgPSBfcmVmLnRhZ0lES2V5TmFtZSxcbiAgICAgIG1ldGFUZW1wbGF0ZUtleU5hbWUgPSBfcmVmLm1ldGFUZW1wbGF0ZUtleU5hbWUsXG4gICAgICBjb250ZW50S2V5TmFtZSA9IF9yZWYuY29udGVudEtleU5hbWU7XG4gIC8vIHdlIGNvbmNhdCB0aGUgYXJyYXlzIHdpdGhvdXQgbWVyZ2luZyBvYmplY3RzIGNvbnRhaW5lZCBpbixcbiAgLy8gYnV0IHdlIGNoZWNrIGZvciBhIGB2bWlkYCBwcm9wZXJ0eSBvbiBlYWNoIG9iamVjdCBpbiB0aGUgYXJyYXlcbiAgLy8gdXNpbmcgYW4gTygxKSBsb29rdXAgYXNzb2NpYXRpdmUgYXJyYXkgZXhwbG9pdFxuICB2YXIgZGVzdGluYXRpb24gPSBbXTtcblxuICBpZiAoIXRhcmdldC5sZW5ndGggJiYgIXNvdXJjZS5sZW5ndGgpIHtcbiAgICByZXR1cm4gZGVzdGluYXRpb247XG4gIH1cblxuICB0YXJnZXQuZm9yRWFjaChmdW5jdGlvbiAodGFyZ2V0SXRlbSwgdGFyZ2V0SW5kZXgpIHtcbiAgICAvLyBubyB0YWdJRCBzbyBubyBuZWVkIHRvIGNoZWNrIGZvciBkdXBsaWNpdHlcbiAgICBpZiAoIXRhcmdldEl0ZW1bdGFnSURLZXlOYW1lXSkge1xuICAgICAgZGVzdGluYXRpb24ucHVzaCh0YXJnZXRJdGVtKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc291cmNlSW5kZXggPSBmaW5kSW5kZXgoc291cmNlLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIGl0ZW1bdGFnSURLZXlOYW1lXSA9PT0gdGFyZ2V0SXRlbVt0YWdJREtleU5hbWVdO1xuICAgIH0pO1xuICAgIHZhciBzb3VyY2VJdGVtID0gc291cmNlW3NvdXJjZUluZGV4XTsgLy8gc291cmNlIGRvZXNudCBjb250YWluIGFueSBkdXBsaWNhdGUgdm1pZCdzLCB3ZSBjYW4ga2VlcCB0YXJnZXRJdGVtXG5cbiAgICBpZiAoc291cmNlSW5kZXggPT09IC0xKSB7XG4gICAgICBkZXN0aW5hdGlvbi5wdXNoKHRhcmdldEl0ZW0pO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gd2hlbiBzb3VyY2VJdGVtIGV4cGxpY3RseSBkZWZpbmVzIGNvbnRlbnRLZXlOYW1lIG9yIGlubmVySFRNTCBhcyB1bmRlZmluZWQsIGl0c1xuICAgIC8vIGFuIGluZGljYXRpb24gdGhhdCB3ZSBuZWVkIHRvIHNraXAgdGhlIGRlZmF1bHQgYmVoYXZpb3VyIG9yIGNoaWxkIGhhcyBwcmVmZXJlbmNlIG92ZXIgcGFyZW50XG4gICAgLy8gd2hpY2ggbWVhbnMgd2Uga2VlcCB0aGUgdGFyZ2V0SXRlbSBhbmQgaWdub3JlL3JlbW92ZSB0aGUgc291cmNlSXRlbVxuXG5cbiAgICBpZiAoY29udGVudEtleU5hbWUgaW4gc291cmNlSXRlbSAmJiBzb3VyY2VJdGVtW2NvbnRlbnRLZXlOYW1lXSA9PT0gdW5kZWZpbmVkIHx8ICdpbm5lckhUTUwnIGluIHNvdXJjZUl0ZW0gJiYgc291cmNlSXRlbS5pbm5lckhUTUwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZGVzdGluYXRpb24ucHVzaCh0YXJnZXRJdGVtKTsgLy8gcmVtb3ZlIGN1cnJlbnQgaW5kZXggZnJvbSBzb3VyY2UgYXJyYXkgc28gaXRzIG5vdCBjb25jYXRlbmF0ZWQgdG8gZGVzdGluYXRpb24gYmVsb3dcblxuICAgICAgc291cmNlLnNwbGljZShzb3VyY2VJbmRleCwgMSk7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyB3ZSBub3cga25vdyB0aGF0IHRhcmdldEl0ZW0gaXMgYSBkdXBsaWNhdGUgYW5kIHdlIHNob3VsZCBpZ25vcmUgaXQgaW4gZmF2b3Igb2Ygc291cmNlSXRlbVxuICAgIC8vIGlmIHNvdXJjZSBzcGVjaWZpZXMgbnVsbCBhcyBjb250ZW50IHRoZW4gaWdub3JlIGJvdGggdGhlIHRhcmdldCBhcyB0aGUgc291cmNlXG5cblxuICAgIGlmIChzb3VyY2VJdGVtW2NvbnRlbnRLZXlOYW1lXSA9PT0gbnVsbCB8fCBzb3VyY2VJdGVtLmlubmVySFRNTCA9PT0gbnVsbCkge1xuICAgICAgLy8gcmVtb3ZlIGN1cnJlbnQgaW5kZXggZnJvbSBzb3VyY2UgYXJyYXkgc28gaXRzIG5vdCBjb25jYXRlbmF0ZWQgdG8gZGVzdGluYXRpb24gYmVsb3dcbiAgICAgIHNvdXJjZS5zcGxpY2Uoc291cmNlSW5kZXgsIDEpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gbm93IHdlIG9ubHkgbmVlZCB0byBjaGVjayBpZiB0aGUgdGFyZ2V0IGhhcyBhIHRlbXBsYXRlIHRvIGNvbWJpbmUgaXQgd2l0aCB0aGUgc291cmNlXG5cblxuICAgIHZhciB0YXJnZXRUZW1wbGF0ZSA9IHRhcmdldEl0ZW1bbWV0YVRlbXBsYXRlS2V5TmFtZV07XG5cbiAgICBpZiAoIXRhcmdldFRlbXBsYXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZVRlbXBsYXRlID0gc291cmNlSXRlbVttZXRhVGVtcGxhdGVLZXlOYW1lXTtcblxuICAgIGlmICghc291cmNlVGVtcGxhdGUpIHtcbiAgICAgIC8vIHVzZSBwYXJlbnQgdGVtcGxhdGUgYW5kIGNoaWxkIGNvbnRlbnRcbiAgICAgIGFwcGx5VGVtcGxhdGUoe1xuICAgICAgICBjb21wb25lbnQ6IGNvbXBvbmVudCxcbiAgICAgICAgbWV0YVRlbXBsYXRlS2V5TmFtZTogbWV0YVRlbXBsYXRlS2V5TmFtZSxcbiAgICAgICAgY29udGVudEtleU5hbWU6IGNvbnRlbnRLZXlOYW1lXG4gICAgICB9LCBzb3VyY2VJdGVtLCB0YXJnZXRUZW1wbGF0ZSk7IC8vIHNldCB0ZW1wbGF0ZSB0byB0cnVlIHRvIGluZGljYXRlIHRlbXBsYXRlIHdhcyBhbHJlYWR5IGFwcGxpZWRcblxuICAgICAgc291cmNlSXRlbS50ZW1wbGF0ZSA9IHRydWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFzb3VyY2VJdGVtW2NvbnRlbnRLZXlOYW1lXSkge1xuICAgICAgLy8gdXNlIHBhcmVudCBjb250ZW50IGFuZCBjaGlsZCB0ZW1wbGF0ZVxuICAgICAgYXBwbHlUZW1wbGF0ZSh7XG4gICAgICAgIGNvbXBvbmVudDogY29tcG9uZW50LFxuICAgICAgICBtZXRhVGVtcGxhdGVLZXlOYW1lOiBtZXRhVGVtcGxhdGVLZXlOYW1lLFxuICAgICAgICBjb250ZW50S2V5TmFtZTogY29udGVudEtleU5hbWVcbiAgICAgIH0sIHNvdXJjZUl0ZW0sIHVuZGVmaW5lZCwgdGFyZ2V0SXRlbVtjb250ZW50S2V5TmFtZV0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBkZXN0aW5hdGlvbi5jb25jYXQoc291cmNlKTtcbn1cbnZhciB3YXJuaW5nU2hvd24gPSBmYWxzZTtcbmZ1bmN0aW9uIG1lcmdlKHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OyAvLyByZW1vdmUgcHJvcGVydGllcyBleHBsaWNpdGx5IHNldCB0byBmYWxzZSBzbyBjaGlsZCBjb21wb25lbnRzIGNhblxuICAvLyBvcHRpb25hbGx5IF9ub3RfIG92ZXJ3cml0ZSB0aGUgcGFyZW50cyBjb250ZW50XG4gIC8vIChmb3IgYXJyYXkgcHJvcGVydGllcyB0aGlzIGlzIGNoZWNrZWQgaW4gYXJyYXlNZXJnZSlcblxuICBpZiAoc291cmNlLnRpdGxlID09PSB1bmRlZmluZWQpIHtcbiAgICBkZWxldGUgc291cmNlLnRpdGxlO1xuICB9XG5cbiAgbWV0YUluZm9BdHRyaWJ1dGVLZXlzLmZvckVhY2goZnVuY3Rpb24gKGF0dHJLZXkpIHtcbiAgICBpZiAoIXNvdXJjZVthdHRyS2V5XSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2VbYXR0cktleV0pIHtcbiAgICAgIGlmIChrZXkgaW4gc291cmNlW2F0dHJLZXldICYmIHNvdXJjZVthdHRyS2V5XVtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGluY2x1ZGVzKGJvb2xlYW5IdG1sQXR0cmlidXRlcywga2V5KSAmJiAhd2FybmluZ1Nob3duKSB7XG4gICAgICAgICAgd2FybignVnVlTWV0YTogUGxlYXNlIG5vdGUgdGhhdCBzaW5jZSB2MiB0aGUgdmFsdWUgdW5kZWZpbmVkIGlzIG5vdCB1c2VkIHRvIGluZGljYXRlIGJvb2xlYW4gYXR0cmlidXRlcyBhbnltb3JlLCBzZWUgbWlncmF0aW9uIGd1aWRlIGZvciBkZXRhaWxzJyk7XG4gICAgICAgICAgd2FybmluZ1Nob3duID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlbGV0ZSBzb3VyY2VbYXR0cktleV1ba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZGVlcG1lcmdlKHRhcmdldCwgc291cmNlLCB7XG4gICAgYXJyYXlNZXJnZTogZnVuY3Rpb24gYXJyYXlNZXJnZSh0LCBzKSB7XG4gICAgICByZXR1cm4gX2FycmF5TWVyZ2Uob3B0aW9ucywgdCwgcyk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TWV0YUluZm8ob3B0aW9ucywgY29tcG9uZW50KSB7XG4gIHJldHVybiBnZXRDb21wb25lbnRPcHRpb24ob3B0aW9ucyB8fCB7fSwgY29tcG9uZW50LCBkZWZhdWx0SW5mbyk7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGBvcHRzLm9wdGlvbmAgJG9wdGlvbiB2YWx1ZSBvZiB0aGUgZ2l2ZW4gYG9wdHMuY29tcG9uZW50YC5cbiAqIElmIG1ldGhvZHMgYXJlIGVuY291bnRlcmVkLCB0aGV5IHdpbGwgYmUgYm91bmQgdG8gdGhlIGNvbXBvbmVudCBjb250ZXh0LlxuICogSWYgYG9wdHMuZGVlcGAgaXMgdHJ1ZSwgd2lsbCByZWN1cnNpdmVseSBtZXJnZSBhbGwgY2hpbGQgY29tcG9uZW50XG4gKiBgb3B0cy5vcHRpb25gICRvcHRpb24gdmFsdWVzIGludG8gdGhlIHJldHVybmVkIHJlc3VsdC5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdHMuY29tcG9uZW50IC0gVnVlIGNvbXBvbmVudCB0byBmZXRjaCBvcHRpb24gZGF0YSBmcm9tXG4gKiBAcGFyYW0gIHtCb29sZWFufSBvcHRzLmRlZXAgLSBsb29rIGZvciBkYXRhIGluIGNoaWxkIGNvbXBvbmVudHMgYXMgd2VsbD9cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBvcHRzLmFycmF5TWVyZ2UgLSBob3cgc2hvdWxkIGFycmF5cyBiZSBtZXJnZWQ/XG4gKiBAcGFyYW0gIHtTdHJpbmd9IG9wdHMua2V5TmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBvcHRpb24gdG8gbG9vayBmb3JcbiAqIEBwYXJhbSAge09iamVjdH0gW3Jlc3VsdD17fV0gLSByZXN1bHQgc28gZmFyXG4gKiBAcmV0dXJuIHtPYmplY3R9IHJlc3VsdCAtIGZpbmFsIGFnZ3JlZ2F0ZWQgcmVzdWx0XG4gKi9cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50T3B0aW9uKG9wdGlvbnMsIGNvbXBvbmVudCwgcmVzdWx0KSB7XG4gIHJlc3VsdCA9IHJlc3VsdCB8fCB7fTtcblxuICBpZiAoY29tcG9uZW50Ll9pbmFjdGl2ZSkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIF9vcHRpb25zID0gb3B0aW9ucyxcbiAgICAgIGtleU5hbWUgPSBfb3B0aW9ucy5rZXlOYW1lO1xuICB2YXIgJG1ldGFJbmZvID0gY29tcG9uZW50LiRtZXRhSW5mbyxcbiAgICAgICRvcHRpb25zID0gY29tcG9uZW50LiRvcHRpb25zLFxuICAgICAgJGNoaWxkcmVuID0gY29tcG9uZW50LiRjaGlsZHJlbjsgLy8gb25seSBjb2xsZWN0IG9wdGlvbiBkYXRhIGlmIGl0IGV4aXN0c1xuXG4gIGlmICgkb3B0aW9uc1trZXlOYW1lXSkge1xuICAgIC8vIGlmICRtZXRhSW5mbyBleGlzdHMgdGhlbiBba2V5TmFtZV0gd2FzIGRlZmluZWQgYXMgYSBmdW5jdGlvblxuICAgIC8vIGFuZCBzZXQgdG8gdGhlIGNvbXB1dGVkIHByb3AgJG1ldGFJbmZvIGluIHRoZSBtaXhpblxuICAgIC8vIHVzaW5nIHRoZSBjb21wdXRlZCBwcm9wIHNob3VsZCBiZSBhIHNtYWxsIHBlcmZvcm1hbmNlIGluY3JlYXNlXG4gICAgLy8gYmVjYXVzZSBWdWUgY2FjaGVzIHRob3NlIGludGVybmFsbHlcbiAgICB2YXIgZGF0YSA9ICRtZXRhSW5mbyB8fCAkb3B0aW9uc1trZXlOYW1lXTsgLy8gb25seSBtZXJnZSBkYXRhIHdpdGggcmVzdWx0IHdoZW4gaXRzIGFuIG9iamVjdFxuICAgIC8vIGVnIGl0IGNvdWxkIGJlIGEgZnVuY3Rpb24gd2hlbiBtZXRhSW5mbygpIHJldHVybnMgdW5kZWZpbmVkXG4gICAgLy8gZHVlbyB0byB0aGUgb3Igc3RhdGVtZW50IGFib3ZlXG5cbiAgICBpZiAoaXNPYmplY3QoZGF0YSkpIHtcbiAgICAgIHJlc3VsdCA9IG1lcmdlKHJlc3VsdCwgZGF0YSwgb3B0aW9ucyk7XG4gICAgfVxuICB9IC8vIGNvbGxlY3QgJiBhZ2dyZWdhdGUgY2hpbGQgb3B0aW9ucyBpZiBkZWVwID0gdHJ1ZVxuXG5cbiAgaWYgKCRjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAkY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGRDb21wb25lbnQpIHtcbiAgICAgIC8vIGNoZWNrIGlmIHRoZSBjaGlsZENvbXBvbmVudCBpcyBpbiBhIGJyYW5jaFxuICAgICAgLy8gcmV0dXJuIG90aGVyd2lzZSBzbyB3ZSBkb250IHdhbGsgYWxsIGNvbXBvbmVudCBicmFuY2hlcyB1bm5lY2Vzc2FyaWx5XG4gICAgICBpZiAoIWluTWV0YUluZm9CcmFuY2goY2hpbGRDb21wb25lbnQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0ID0gZ2V0Q29tcG9uZW50T3B0aW9uKG9wdGlvbnMsIGNoaWxkQ29tcG9uZW50LCByZXN1bHQpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIGNhbGxiYWNrcyA9IFtdO1xuZnVuY3Rpb24gaXNET01Db21wbGV0ZShkKSB7XG4gIHJldHVybiAoZCB8fCBkb2N1bWVudCkucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJztcbn1cbmZ1bmN0aW9uIGFkZENhbGxiYWNrKHF1ZXJ5LCBjYWxsYmFjaykge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGNhbGxiYWNrID0gcXVlcnk7XG4gICAgcXVlcnkgPSAnJztcbiAgfVxuXG4gIGNhbGxiYWNrcy5wdXNoKFtxdWVyeSwgY2FsbGJhY2tdKTtcbn1cbmZ1bmN0aW9uIGFkZENhbGxiYWNrcyhfcmVmLCB0eXBlLCB0YWdzLCBhdXRvQWRkTGlzdGVuZXJzKSB7XG4gIHZhciB0YWdJREtleU5hbWUgPSBfcmVmLnRhZ0lES2V5TmFtZTtcbiAgdmFyIGhhc0FzeW5jQ2FsbGJhY2sgPSBmYWxzZTtcbiAgdGFncy5mb3JFYWNoKGZ1bmN0aW9uICh0YWcpIHtcbiAgICBpZiAoIXRhZ1t0YWdJREtleU5hbWVdIHx8ICF0YWcuY2FsbGJhY2spIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBoYXNBc3luY0NhbGxiYWNrID0gdHJ1ZTtcbiAgICBhZGRDYWxsYmFjayhcIlwiLmNvbmNhdCh0eXBlLCBcIltkYXRhLVwiKS5jb25jYXQodGFnSURLZXlOYW1lLCBcIj1cXFwiXCIpLmNvbmNhdCh0YWdbdGFnSURLZXlOYW1lXSwgXCJcXFwiXVwiKSwgdGFnLmNhbGxiYWNrKTtcbiAgfSk7XG5cbiAgaWYgKCFhdXRvQWRkTGlzdGVuZXJzIHx8ICFoYXNBc3luY0NhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGhhc0FzeW5jQ2FsbGJhY2s7XG4gIH1cblxuICByZXR1cm4gYWRkTGlzdGVuZXJzKCk7XG59XG5mdW5jdGlvbiBhZGRMaXN0ZW5lcnMoKSB7XG4gIGlmIChpc0RPTUNvbXBsZXRlKCkpIHtcbiAgICBhcHBseUNhbGxiYWNrcygpO1xuICAgIHJldHVybjtcbiAgfSAvLyBJbnN0ZWFkIG9mIHVzaW5nIGEgTXV0YXRpb25PYnNlcnZlciwgd2UganVzdCBhcHBseVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cblxuICBkb2N1bWVudC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgYXBwbHlDYWxsYmFja3MoKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGFwcGx5Q2FsbGJhY2tzKG1hdGNoRWxlbWVudCkge1xuICBjYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbiAoYXJncykge1xuICAgIC8vIGRvIG5vdCB1c2UgZGVzdHJ1Y3R1cmluZyBmb3IgYXJncywgaXQgaW5jcmVhc2VzIHRyYW5zcGlsZWQgc2l6ZVxuICAgIC8vIGR1ZSB0byB2YXIgY2hlY2tzIHdoaWxlIHdlIGFyZSBndWFyYW50ZWVkIHRoZSBzdHJ1Y3R1cmUgb2YgdGhlIGNiXG4gICAgdmFyIHF1ZXJ5ID0gYXJnc1swXTtcbiAgICB2YXIgY2FsbGJhY2sgPSBhcmdzWzFdO1xuICAgIHZhciBzZWxlY3RvciA9IFwiXCIuY29uY2F0KHF1ZXJ5LCBcIltvbmxvYWQ9XFxcInRoaXMuX192bV9sPTFcXFwiXVwiKTtcbiAgICB2YXIgZWxlbWVudHMgPSBbXTtcblxuICAgIGlmICghbWF0Y2hFbGVtZW50KSB7XG4gICAgICBlbGVtZW50cyA9IHRvQXJyYXkocXVlcnlTZWxlY3RvcihzZWxlY3RvcikpO1xuICAgIH1cblxuICAgIGlmIChtYXRjaEVsZW1lbnQgJiYgbWF0Y2hFbGVtZW50Lm1hdGNoZXMoc2VsZWN0b3IpKSB7XG4gICAgICBlbGVtZW50cyA9IFttYXRjaEVsZW1lbnRdO1xuICAgIH1cblxuICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgIC8qIF9fdm1fY2I6IHdoZXRoZXIgdGhlIGxvYWQgY2FsbGJhY2sgaGFzIGJlZW4gY2FsbGVkXG4gICAgICAgKiBfX3ZtX2w6IHNldCBieSBvbmxvYWQgYXR0cmlidXRlLCB3aGV0aGVyIHRoZSBlbGVtZW50IHdhcyBsb2FkZWRcbiAgICAgICAqIF9fdm1fZXY6IHdoZXRoZXIgdGhlIGV2ZW50IGxpc3RlbmVyIHdhcyBhZGRlZCBvciBub3RcbiAgICAgICAqL1xuICAgICAgaWYgKGVsZW1lbnQuX192bV9jYikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBvbmxvYWQgPSBmdW5jdGlvbiBvbmxvYWQoKSB7XG4gICAgICAgIC8qIE1hcmsgdGhhdCB0aGUgY2FsbGJhY2sgZm9yIHRoaXMgZWxlbWVudCBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZCxcbiAgICAgICAgICogdGhpcyBwcmV2ZW50cyB0aGUgY2FsbGJhY2sgdG8gcnVuIHR3aWNlIGluIHNvbWUgKHJhcmUpIGNvbmRpdGlvbnNcbiAgICAgICAgICovXG4gICAgICAgIGVsZW1lbnQuX192bV9jYiA9IHRydWU7XG4gICAgICAgIC8qIG9ubG9hZCBuZWVkcyB0byBiZSByZW1vdmVkIGJlY2F1c2Ugd2Ugb25seSBuZWVkIHRoZVxuICAgICAgICAgKiBhdHRyaWJ1dGUgYWZ0ZXIgc3NyIGFuZCBpZiB3ZSBkb250IHJlbW92ZSBpdCB0aGUgbm9kZVxuICAgICAgICAgKiB3aWxsIGZhaWwgaXNFcXVhbE5vZGUgb24gdGhlIGNsaWVudFxuICAgICAgICAgKi9cblxuICAgICAgICByZW1vdmVBdHRyaWJ1dGUoZWxlbWVudCwgJ29ubG9hZCcpO1xuICAgICAgICBjYWxsYmFjayhlbGVtZW50KTtcbiAgICAgIH07XG4gICAgICAvKiBJRTkgZG9lc250IHNlZW0gdG8gbG9hZCBzY3JpcHRzIHN5bmNocm9ub3VzbHksXG4gICAgICAgKiBjYXVzaW5nIGEgc2NyaXB0IHNvbWV0aW1lcy9vZnRlbiBhbHJlYWR5IHRvIGJlIGxvYWRlZFxuICAgICAgICogd2hlbiB3ZSBhZGQgdGhlIGV2ZW50IGxpc3RlbmVyIGJlbG93ICh0aHVzIGFkZGluZyBhbiBvbmxvYWQgZXZlbnRcbiAgICAgICAqIGxpc3RlbmVyIGhhcyBubyB1c2UgYmVjYXVzZSBpdCB3aWxsIG5ldmVyIGJlIHRyaWdnZXJlZCkuXG4gICAgICAgKiBUaGVyZWZvcmUgd2UgYWRkIHRoZSBvbmxvYWQgYXR0cmlidXRlIGR1cmluZyBzc3IsIGFuZFxuICAgICAgICogY2hlY2sgaGVyZSBpZiBpdCB3YXMgYWxyZWFkeSBsb2FkZWQgb3Igbm90XG4gICAgICAgKi9cblxuXG4gICAgICBpZiAoZWxlbWVudC5fX3ZtX2wpIHtcbiAgICAgICAgb25sb2FkKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFlbGVtZW50Ll9fdm1fZXYpIHtcbiAgICAgICAgZWxlbWVudC5fX3ZtX2V2ID0gdHJ1ZTtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgb25sb2FkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbi8vIGluc3RlYWQgb2YgYWRkaW5nIGl0IHRvIHRoZSBodG1sXG5cbnZhciBhdHRyaWJ1dGVNYXAgPSB7fTtcbi8qKlxuICogVXBkYXRlcyB0aGUgZG9jdW1lbnQncyBodG1sIHRhZyBhdHRyaWJ1dGVzXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBhdHRycyAtIHRoZSBuZXcgZG9jdW1lbnQgaHRtbCBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gdGFnIC0gdGhlIEhUTUxFbGVtZW50IHRhZyB0byB1cGRhdGUgd2l0aCBuZXcgYXR0cnNcbiAqL1xuXG5mdW5jdGlvbiB1cGRhdGVBdHRyaWJ1dGUoYXBwSWQsIG9wdGlvbnMsIHR5cGUsIGF0dHJzLCB0YWcpIHtcbiAgdmFyIF9yZWYgPSBvcHRpb25zIHx8IHt9LFxuICAgICAgYXR0cmlidXRlID0gX3JlZi5hdHRyaWJ1dGU7XG5cbiAgdmFyIHZ1ZU1ldGFBdHRyU3RyaW5nID0gdGFnLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuXG4gIGlmICh2dWVNZXRhQXR0clN0cmluZykge1xuICAgIGF0dHJpYnV0ZU1hcFt0eXBlXSA9IEpTT04ucGFyc2UoZGVjb2RlVVJJKHZ1ZU1ldGFBdHRyU3RyaW5nKSk7XG4gICAgcmVtb3ZlQXR0cmlidXRlKHRhZywgYXR0cmlidXRlKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gYXR0cmlidXRlTWFwW3R5cGVdIHx8IHt9O1xuICB2YXIgdG9VcGRhdGUgPSBbXTsgLy8gcmVtb3ZlIGF0dHJpYnV0ZXMgZnJvbSB0aGUgbWFwXG4gIC8vIHdoaWNoIGhhdmUgYmVlbiByZW1vdmVkIGZvciB0aGlzIGFwcElkXG5cbiAgZm9yICh2YXIgYXR0ciBpbiBkYXRhKSB7XG4gICAgaWYgKGRhdGFbYXR0cl0gIT09IHVuZGVmaW5lZCAmJiBhcHBJZCBpbiBkYXRhW2F0dHJdKSB7XG4gICAgICB0b1VwZGF0ZS5wdXNoKGF0dHIpO1xuXG4gICAgICBpZiAoIWF0dHJzW2F0dHJdKSB7XG4gICAgICAgIGRlbGV0ZSBkYXRhW2F0dHJdW2FwcElkXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBfYXR0ciBpbiBhdHRycykge1xuICAgIHZhciBhdHRyRGF0YSA9IGRhdGFbX2F0dHJdO1xuXG4gICAgaWYgKCFhdHRyRGF0YSB8fCBhdHRyRGF0YVthcHBJZF0gIT09IGF0dHJzW19hdHRyXSkge1xuICAgICAgdG9VcGRhdGUucHVzaChfYXR0cik7XG5cbiAgICAgIGlmIChhdHRyc1tfYXR0cl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkYXRhW19hdHRyXSA9IGRhdGFbX2F0dHJdIHx8IHt9O1xuICAgICAgICBkYXRhW19hdHRyXVthcHBJZF0gPSBhdHRyc1tfYXR0cl07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgX2kgPSAwLCBfdG9VcGRhdGUgPSB0b1VwZGF0ZTsgX2kgPCBfdG9VcGRhdGUubGVuZ3RoOyBfaSsrKSB7XG4gICAgdmFyIF9hdHRyMiA9IF90b1VwZGF0ZVtfaV07XG4gICAgdmFyIF9hdHRyRGF0YSA9IGRhdGFbX2F0dHIyXTtcbiAgICB2YXIgYXR0clZhbHVlcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgX2FwcElkIGluIF9hdHRyRGF0YSkge1xuICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoYXR0clZhbHVlcywgW10uY29uY2F0KF9hdHRyRGF0YVtfYXBwSWRdKSk7XG4gICAgfVxuXG4gICAgaWYgKGF0dHJWYWx1ZXMubGVuZ3RoKSB7XG4gICAgICB2YXIgYXR0clZhbHVlID0gaW5jbHVkZXMoYm9vbGVhbkh0bWxBdHRyaWJ1dGVzLCBfYXR0cjIpICYmIGF0dHJWYWx1ZXMuc29tZShCb29sZWFuKSA/ICcnIDogYXR0clZhbHVlcy5maWx0ZXIoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIHYgIT09IHVuZGVmaW5lZDtcbiAgICAgIH0pLmpvaW4oJyAnKTtcbiAgICAgIHRhZy5zZXRBdHRyaWJ1dGUoX2F0dHIyLCBhdHRyVmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmVBdHRyaWJ1dGUodGFnLCBfYXR0cjIpO1xuICAgIH1cbiAgfVxuXG4gIGF0dHJpYnV0ZU1hcFt0eXBlXSA9IGRhdGE7XG59XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgZG9jdW1lbnQgdGl0bGVcbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHRpdGxlIC0gdGhlIG5ldyB0aXRsZSBvZiB0aGUgZG9jdW1lbnRcbiAqL1xuZnVuY3Rpb24gdXBkYXRlVGl0bGUodGl0bGUpIHtcbiAgaWYgKCF0aXRsZSAmJiB0aXRsZSAhPT0gJycpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBkb2N1bWVudC50aXRsZSA9IHRpdGxlO1xufVxuXG4vKipcbiAqIFVwZGF0ZXMgbWV0YSB0YWdzIGluc2lkZSA8aGVhZD4gYW5kIDxib2R5PiBvbiB0aGUgY2xpZW50LiBCb3Jyb3dlZCBmcm9tIGByZWFjdC1oZWxtZXRgOlxuICogaHR0cHM6Ly9naXRodWIuY29tL25mbC9yZWFjdC1oZWxtZXQvYmxvYi8wMDRkNDQ4ZjhkZTVmODIzZDEwZjgzOGIwMjMxNzUyMTE4MGYzNGRhL3NyYy9IZWxtZXQuanMjTDE5NS1MMjQ1XG4gKlxuICogQHBhcmFtICB7KCdtZXRhJ3wnYmFzZSd8J2xpbmsnfCdzdHlsZSd8J3NjcmlwdCd8J25vc2NyaXB0Jyl9IHR5cGUgLSB0aGUgbmFtZSBvZiB0aGUgdGFnXG4gKiBAcGFyYW0gIHsoQXJyYXk8T2JqZWN0PnxPYmplY3QpfSB0YWdzIC0gYW4gYXJyYXkgb2YgdGFnIG9iamVjdHMgb3IgYSBzaW5nbGUgb2JqZWN0IGluIGNhc2Ugb2YgYmFzZVxuICogQHJldHVybiB7T2JqZWN0fSAtIGEgcmVwcmVzZW50YXRpb24gb2Ygd2hhdCB0YWdzIGNoYW5nZWRcbiAqL1xuXG5mdW5jdGlvbiB1cGRhdGVUYWcoYXBwSWQsIG9wdGlvbnMsIHR5cGUsIHRhZ3MsIGhlYWQsIGJvZHkpIHtcbiAgdmFyIF9yZWYgPSBvcHRpb25zIHx8IHt9LFxuICAgICAgYXR0cmlidXRlID0gX3JlZi5hdHRyaWJ1dGUsXG4gICAgICB0YWdJREtleU5hbWUgPSBfcmVmLnRhZ0lES2V5TmFtZTtcblxuICB2YXIgZGF0YUF0dHJpYnV0ZXMgPSBjb21tb25EYXRhQXR0cmlidXRlcy5zbGljZSgpO1xuICBkYXRhQXR0cmlidXRlcy5wdXNoKHRhZ0lES2V5TmFtZSk7XG4gIHZhciBuZXdFbGVtZW50cyA9IFtdO1xuICB2YXIgcXVlcnlPcHRpb25zID0ge1xuICAgIGFwcElkOiBhcHBJZCxcbiAgICBhdHRyaWJ1dGU6IGF0dHJpYnV0ZSxcbiAgICB0eXBlOiB0eXBlLFxuICAgIHRhZ0lES2V5TmFtZTogdGFnSURLZXlOYW1lXG4gIH07XG4gIHZhciBjdXJyZW50RWxlbWVudHMgPSB7XG4gICAgaGVhZDogcXVlcnlFbGVtZW50cyhoZWFkLCBxdWVyeU9wdGlvbnMpLFxuICAgIHBib2R5OiBxdWVyeUVsZW1lbnRzKGJvZHksIHF1ZXJ5T3B0aW9ucywge1xuICAgICAgcGJvZHk6IHRydWVcbiAgICB9KSxcbiAgICBib2R5OiBxdWVyeUVsZW1lbnRzKGJvZHksIHF1ZXJ5T3B0aW9ucywge1xuICAgICAgYm9keTogdHJ1ZVxuICAgIH0pXG4gIH07XG5cbiAgaWYgKHRhZ3MubGVuZ3RoID4gMSkge1xuICAgIC8vIHJlbW92ZSBkdXBsaWNhdGVzIHRoYXQgY291bGQgaGF2ZSBiZWVuIGZvdW5kIGJ5IG1lcmdpbmcgdGFnc1xuICAgIC8vIHdoaWNoIGluY2x1ZGUgYSBtaXhpbiB3aXRoIG1ldGFJbmZvIGFuZCB0aGF0IG1peGluIGlzIHVzZWRcbiAgICAvLyBieSBtdWx0aXBsZSBjb21wb25lbnRzIG9uIHRoZSBzYW1lIHBhZ2VcbiAgICB2YXIgZm91bmQgPSBbXTtcbiAgICB0YWdzID0gdGFncy5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICAgIHZhciBrID0gSlNPTi5zdHJpbmdpZnkoeCk7XG4gICAgICB2YXIgcmVzID0gIWluY2x1ZGVzKGZvdW5kLCBrKTtcbiAgICAgIGZvdW5kLnB1c2goayk7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0pO1xuICB9XG5cbiAgdGFncy5mb3JFYWNoKGZ1bmN0aW9uICh0YWcpIHtcbiAgICBpZiAodGFnLnNraXApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmV3RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodHlwZSk7XG5cbiAgICBpZiAoIXRhZy5vbmNlKSB7XG4gICAgICBuZXdFbGVtZW50LnNldEF0dHJpYnV0ZShhdHRyaWJ1dGUsIGFwcElkKTtcbiAgICB9XG5cbiAgICBPYmplY3Qua2V5cyh0YWcpLmZvckVhY2goZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICBpZiAoaW5jbHVkZXModGFnUHJvcGVydGllcywgYXR0cikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXR0ciA9PT0gJ2lubmVySFRNTCcpIHtcbiAgICAgICAgbmV3RWxlbWVudC5pbm5lckhUTUwgPSB0YWcuaW5uZXJIVE1MO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChhdHRyID09PSAnanNvbicpIHtcbiAgICAgICAgbmV3RWxlbWVudC5pbm5lckhUTUwgPSBKU09OLnN0cmluZ2lmeSh0YWcuanNvbik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGF0dHIgPT09ICdjc3NUZXh0Jykge1xuICAgICAgICBpZiAobmV3RWxlbWVudC5zdHlsZVNoZWV0KSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICBuZXdFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IHRhZy5jc3NUZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0VsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGFnLmNzc1RleHQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGF0dHIgPT09ICdjYWxsYmFjaycpIHtcbiAgICAgICAgbmV3RWxlbWVudC5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHRhZ1thdHRyXShuZXdFbGVtZW50KTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBfYXR0ciA9IGluY2x1ZGVzKGRhdGFBdHRyaWJ1dGVzLCBhdHRyKSA/IFwiZGF0YS1cIi5jb25jYXQoYXR0cikgOiBhdHRyO1xuXG4gICAgICB2YXIgaXNCb29sZWFuQXR0cmlidXRlID0gaW5jbHVkZXMoYm9vbGVhbkh0bWxBdHRyaWJ1dGVzLCBhdHRyKTtcblxuICAgICAgaWYgKGlzQm9vbGVhbkF0dHJpYnV0ZSAmJiAhdGFnW2F0dHJdKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlID0gaXNCb29sZWFuQXR0cmlidXRlID8gJycgOiB0YWdbYXR0cl07XG4gICAgICBuZXdFbGVtZW50LnNldEF0dHJpYnV0ZShfYXR0ciwgdmFsdWUpO1xuICAgIH0pO1xuICAgIHZhciBvbGRFbGVtZW50cyA9IGN1cnJlbnRFbGVtZW50c1tnZXRFbGVtZW50c0tleSh0YWcpXTsgLy8gUmVtb3ZlIGEgZHVwbGljYXRlIHRhZyBmcm9tIGRvbVRhZ3N0b1JlbW92ZSwgc28gaXQgaXNuJ3QgY2xlYXJlZC5cblxuICAgIHZhciBpbmRleFRvRGVsZXRlO1xuICAgIHZhciBoYXNFcXVhbEVsZW1lbnQgPSBvbGRFbGVtZW50cy5zb21lKGZ1bmN0aW9uIChleGlzdGluZ1RhZywgaW5kZXgpIHtcbiAgICAgIGluZGV4VG9EZWxldGUgPSBpbmRleDtcbiAgICAgIHJldHVybiBuZXdFbGVtZW50LmlzRXF1YWxOb2RlKGV4aXN0aW5nVGFnKTtcbiAgICB9KTtcblxuICAgIGlmIChoYXNFcXVhbEVsZW1lbnQgJiYgKGluZGV4VG9EZWxldGUgfHwgaW5kZXhUb0RlbGV0ZSA9PT0gMCkpIHtcbiAgICAgIG9sZEVsZW1lbnRzLnNwbGljZShpbmRleFRvRGVsZXRlLCAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3RWxlbWVudHMucHVzaChuZXdFbGVtZW50KTtcbiAgICB9XG4gIH0pO1xuICB2YXIgb2xkRWxlbWVudHMgPSBbXTtcblxuICBmb3IgKHZhciBfdHlwZSBpbiBjdXJyZW50RWxlbWVudHMpIHtcbiAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShvbGRFbGVtZW50cywgY3VycmVudEVsZW1lbnRzW190eXBlXSk7XG4gIH0gLy8gcmVtb3ZlIG9sZCBlbGVtZW50c1xuXG5cbiAgb2xkRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIGVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbGVtZW50KTtcbiAgfSk7IC8vIGluc2VydCBuZXcgZWxlbWVudHNcblxuICBuZXdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgaWYgKGVsZW1lbnQuaGFzQXR0cmlidXRlKCdkYXRhLWJvZHknKSkge1xuICAgICAgYm9keS5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2RhdGEtcGJvZHknKSkge1xuICAgICAgYm9keS5pbnNlcnRCZWZvcmUoZWxlbWVudCwgYm9keS5maXJzdENoaWxkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBoZWFkLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBvbGRUYWdzOiBvbGRFbGVtZW50cyxcbiAgICBuZXdUYWdzOiBuZXdFbGVtZW50c1xuICB9O1xufVxuXG4vKipcbiAqIFBlcmZvcm1zIGNsaWVudC1zaWRlIHVwZGF0ZXMgd2hlbiBuZXcgbWV0YSBpbmZvIGlzIHJlY2VpdmVkXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBuZXdJbmZvIC0gdGhlIG1ldGEgaW5mbyB0byB1cGRhdGUgdG9cbiAqL1xuXG5mdW5jdGlvbiB1cGRhdGVDbGllbnRNZXRhSW5mbyhhcHBJZCwgb3B0aW9ucywgbmV3SW5mbykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIF9vcHRpb25zID0gb3B0aW9ucyxcbiAgICAgIHNzckF0dHJpYnV0ZSA9IF9vcHRpb25zLnNzckF0dHJpYnV0ZSxcbiAgICAgIHNzckFwcElkID0gX29wdGlvbnMuc3NyQXBwSWQ7IC8vIG9ubHkgY2FjaGUgdGFncyBmb3IgY3VycmVudCB1cGRhdGVcblxuICB2YXIgdGFncyA9IHt9O1xuICB2YXIgaHRtbFRhZyA9IGdldFRhZyh0YWdzLCAnaHRtbCcpOyAvLyBpZiB0aGlzIGlzIGEgc2VydmVyIHJlbmRlciwgdGhlbiBkb250IHVwZGF0ZVxuXG4gIGlmIChhcHBJZCA9PT0gc3NyQXBwSWQgJiYgaHRtbFRhZy5oYXNBdHRyaWJ1dGUoc3NyQXR0cmlidXRlKSkge1xuICAgIC8vIHJlbW92ZSB0aGUgc2VydmVyIHJlbmRlciBhdHRyaWJ1dGUgc28gd2UgY2FuIHVwZGF0ZSBvbiAobmV4dCkgY2hhbmdlc1xuICAgIHJlbW92ZUF0dHJpYnV0ZShodG1sVGFnLCBzc3JBdHRyaWJ1dGUpOyAvLyBhZGQgbG9hZCBjYWxsYmFja3MgaWYgdGhlXG5cbiAgICB2YXIgYWRkTG9hZExpc3RlbmVycyA9IGZhbHNlO1xuICAgIHRhZ3NTdXBwb3J0aW5nT25sb2FkLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIGlmIChuZXdJbmZvW3R5cGVdICYmIGFkZENhbGxiYWNrcyhvcHRpb25zLCB0eXBlLCBuZXdJbmZvW3R5cGVdKSkge1xuICAgICAgICBhZGRMb2FkTGlzdGVuZXJzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChhZGRMb2FkTGlzdGVuZXJzKSB7XG4gICAgICBhZGRMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gaW5pdGlhbGl6ZSB0cmFja2VkIGNoYW5nZXNcblxuXG4gIHZhciB0YWdzQWRkZWQgPSB7fTtcbiAgdmFyIHRhZ3NSZW1vdmVkID0ge307XG5cbiAgZm9yICh2YXIgdHlwZSBpbiBuZXdJbmZvKSB7XG4gICAgLy8gaWdub3JlIHRoZXNlXG4gICAgaWYgKGluY2x1ZGVzKG1ldGFJbmZvT3B0aW9uS2V5cywgdHlwZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlID09PSAndGl0bGUnKSB7XG4gICAgICAvLyB1cGRhdGUgdGhlIHRpdGxlXG4gICAgICB1cGRhdGVUaXRsZShuZXdJbmZvLnRpdGxlKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChpbmNsdWRlcyhtZXRhSW5mb0F0dHJpYnV0ZUtleXMsIHR5cGUpKSB7XG4gICAgICB2YXIgdGFnTmFtZSA9IHR5cGUuc3Vic3RyKDAsIDQpO1xuICAgICAgdXBkYXRlQXR0cmlidXRlKGFwcElkLCBvcHRpb25zLCB0eXBlLCBuZXdJbmZvW3R5cGVdLCBnZXRUYWcodGFncywgdGFnTmFtZSkpO1xuICAgICAgY29udGludWU7XG4gICAgfSAvLyB0YWdzIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXksIGlnbm9yZSBpZiBpdCBpc250XG5cblxuICAgIGlmICghaXNBcnJheShuZXdJbmZvW3R5cGVdKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIF91cGRhdGVUYWcgPSB1cGRhdGVUYWcoYXBwSWQsIG9wdGlvbnMsIHR5cGUsIG5ld0luZm9bdHlwZV0sIGdldFRhZyh0YWdzLCAnaGVhZCcpLCBnZXRUYWcodGFncywgJ2JvZHknKSksXG4gICAgICAgIG9sZFRhZ3MgPSBfdXBkYXRlVGFnLm9sZFRhZ3MsXG4gICAgICAgIG5ld1RhZ3MgPSBfdXBkYXRlVGFnLm5ld1RhZ3M7XG5cbiAgICBpZiAobmV3VGFncy5sZW5ndGgpIHtcbiAgICAgIHRhZ3NBZGRlZFt0eXBlXSA9IG5ld1RhZ3M7XG4gICAgICB0YWdzUmVtb3ZlZFt0eXBlXSA9IG9sZFRhZ3M7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0YWdzQWRkZWQ6IHRhZ3NBZGRlZCxcbiAgICB0YWdzUmVtb3ZlZDogdGFnc1JlbW92ZWRcbiAgfTtcbn1cblxudmFyIGFwcHNNZXRhSW5mbztcbmZ1bmN0aW9uIGFkZEFwcChyb290Vm0sIGFwcElkLCBvcHRpb25zKSB7XG4gIHJldHVybiB7XG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobWV0YUluZm8pIHtcbiAgICAgIHJldHVybiBzZXRNZXRhSW5mbyhyb290Vm0sIGFwcElkLCBvcHRpb25zLCBtZXRhSW5mbyk7XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgIHJldHVybiByZW1vdmVNZXRhSW5mbyhyb290Vm0sIGFwcElkLCBvcHRpb25zKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBzZXRNZXRhSW5mbyhyb290Vm0sIGFwcElkLCBvcHRpb25zLCBtZXRhSW5mbykge1xuICAvLyBpZiBhIHZtIGV4aXN0cyBfYW5kXyBpdHMgbW91bnRlZCB0aGVuIGltbWVkaWF0ZWx5IHVwZGF0ZVxuICBpZiAocm9vdFZtICYmIHJvb3RWbS4kZWwpIHtcbiAgICByZXR1cm4gdXBkYXRlQ2xpZW50TWV0YUluZm8oYXBwSWQsIG9wdGlvbnMsIG1ldGFJbmZvKTtcbiAgfSAvLyBzdG9yZSBmb3IgbGF0ZXIsIHRoZSBpbmZvXG4gIC8vIHdpbGwgYmUgc2V0IG9uIHRoZSBmaXJzdCByZWZyZXNoXG5cblxuICBhcHBzTWV0YUluZm8gPSBhcHBzTWV0YUluZm8gfHwge307XG4gIGFwcHNNZXRhSW5mb1thcHBJZF0gPSBtZXRhSW5mbztcbn1cbmZ1bmN0aW9uIHJlbW92ZU1ldGFJbmZvKHJvb3RWbSwgYXBwSWQsIG9wdGlvbnMpIHtcbiAgaWYgKHJvb3RWbSAmJiByb290Vm0uJGVsKSB7XG4gICAgdmFyIHRhZ3MgPSB7fTtcblxuICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihtZXRhSW5mb0F0dHJpYnV0ZUtleXMpLFxuICAgICAgICBfc3RlcDtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICB2YXIgdHlwZSA9IF9zdGVwLnZhbHVlO1xuICAgICAgICB2YXIgdGFnTmFtZSA9IHR5cGUuc3Vic3RyKDAsIDQpO1xuICAgICAgICB1cGRhdGVBdHRyaWJ1dGUoYXBwSWQsIG9wdGlvbnMsIHR5cGUsIHt9LCBnZXRUYWcodGFncywgdGFnTmFtZSkpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVtb3ZlRWxlbWVudHNCeUFwcElkKG9wdGlvbnMsIGFwcElkKTtcbiAgfVxuXG4gIGlmIChhcHBzTWV0YUluZm9bYXBwSWRdKSB7XG4gICAgZGVsZXRlIGFwcHNNZXRhSW5mb1thcHBJZF07XG4gICAgY2xlYXJBcHBzTWV0YUluZm8oKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0QXBwc01ldGFJbmZvKCkge1xuICByZXR1cm4gYXBwc01ldGFJbmZvO1xufVxuZnVuY3Rpb24gY2xlYXJBcHBzTWV0YUluZm8oZm9yY2UpIHtcbiAgaWYgKGZvcmNlIHx8ICFPYmplY3Qua2V5cyhhcHBzTWV0YUluZm8pLmxlbmd0aCkge1xuICAgIGFwcHNNZXRhSW5mbyA9IHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGNvcnJlY3QgbWV0YSBpbmZvIGZvciB0aGUgZ2l2ZW4gY29tcG9uZW50XG4gKiAoY2hpbGQgY29tcG9uZW50cyB3aWxsIG92ZXJ3cml0ZSBwYXJlbnQgbWV0YSBpbmZvKVxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gY29tcG9uZW50IC0gdGhlIFZ1ZSBpbnN0YW5jZSB0byBnZXQgbWV0YSBpbmZvIGZyb21cbiAqIEByZXR1cm4ge09iamVjdH0gLSByZXR1cm5lZCBtZXRhIGluZm9cbiAqL1xuXG5mdW5jdGlvbiBnZXRNZXRhSW5mbyhvcHRpb25zLCBpbmZvLCBlc2NhcGVTZXF1ZW5jZXMsIGNvbXBvbmVudCkge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgZXNjYXBlU2VxdWVuY2VzID0gZXNjYXBlU2VxdWVuY2VzIHx8IFtdO1xuICB2YXIgX29wdGlvbnMgPSBvcHRpb25zLFxuICAgICAgdGFnSURLZXlOYW1lID0gX29wdGlvbnMudGFnSURLZXlOYW1lOyAvLyBSZW1vdmUgYWxsIFwidGVtcGxhdGVcIiB0YWdzIGZyb20gbWV0YVxuICAvLyBiYWNrdXAgdGhlIHRpdGxlIGNodW5rIGluIGNhc2UgdXNlciB3YW50cyBhY2Nlc3MgdG8gaXRcblxuICBpZiAoaW5mby50aXRsZSkge1xuICAgIGluZm8udGl0bGVDaHVuayA9IGluZm8udGl0bGU7XG4gIH0gLy8gcmVwbGFjZSB0aXRsZSB3aXRoIHBvcHVsYXRlZCB0ZW1wbGF0ZVxuXG5cbiAgaWYgKGluZm8udGl0bGVUZW1wbGF0ZSAmJiBpbmZvLnRpdGxlVGVtcGxhdGUgIT09ICclcycpIHtcbiAgICBhcHBseVRlbXBsYXRlKHtcbiAgICAgIGNvbXBvbmVudDogY29tcG9uZW50LFxuICAgICAgY29udGVudEtleU5hbWU6ICd0aXRsZSdcbiAgICB9LCBpbmZvLCBpbmZvLnRpdGxlVGVtcGxhdGUsIGluZm8udGl0bGVDaHVuayB8fCAnJyk7XG4gIH0gLy8gY29udmVydCBiYXNlIHRhZyB0byBhbiBhcnJheSBzbyBpdCBjYW4gYmUgaGFuZGxlZCB0aGUgc2FtZSB3YXlcbiAgLy8gYXMgdGhlIG90aGVyIHRhZ3NcblxuXG4gIGlmIChpbmZvLmJhc2UpIHtcbiAgICBpbmZvLmJhc2UgPSBPYmplY3Qua2V5cyhpbmZvLmJhc2UpLmxlbmd0aCA/IFtpbmZvLmJhc2VdIDogW107XG4gIH1cblxuICBpZiAoaW5mby5tZXRhKSB7XG4gICAgLy8gcmVtb3ZlIG1ldGEgaXRlbXMgd2l0aCBkdXBsaWNhdGUgdm1pZCdzXG4gICAgaW5mby5tZXRhID0gaW5mby5tZXRhLmZpbHRlcihmdW5jdGlvbiAobWV0YUl0ZW0sIGluZGV4LCBhcnIpIHtcbiAgICAgIHZhciBoYXNWbWlkID0gISFtZXRhSXRlbVt0YWdJREtleU5hbWVdO1xuXG4gICAgICBpZiAoIWhhc1ZtaWQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBpc0ZpcnN0SXRlbUZvclZtaWQgPSBpbmRleCA9PT0gZmluZEluZGV4KGFyciwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW1bdGFnSURLZXlOYW1lXSA9PT0gbWV0YUl0ZW1bdGFnSURLZXlOYW1lXTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGlzRmlyc3RJdGVtRm9yVm1pZDtcbiAgICB9KTsgLy8gYXBwbHkgdGVtcGxhdGVzIGlmIG5lZWRlZFxuXG4gICAgaW5mby5tZXRhLmZvckVhY2goZnVuY3Rpb24gKG1ldGFPYmplY3QpIHtcbiAgICAgIHJldHVybiBhcHBseVRlbXBsYXRlKG9wdGlvbnMsIG1ldGFPYmplY3QpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGVzY2FwZU1ldGFJbmZvKG9wdGlvbnMsIGluZm8sIGVzY2FwZVNlcXVlbmNlcyk7XG59XG5cbi8qKlxuICogV2hlbiBjYWxsZWQsIHdpbGwgdXBkYXRlIHRoZSBjdXJyZW50IG1ldGEgaW5mbyB3aXRoIG5ldyBtZXRhIGluZm8uXG4gKiBVc2VmdWwgd2hlbiB1cGRhdGluZyBtZXRhIGluZm8gYXMgdGhlIHJlc3VsdCBvZiBhbiBhc3luY2hyb25vdXNcbiAqIGFjdGlvbiB0aGF0IHJlc29sdmVzIGFmdGVyIHRoZSBpbml0aWFsIHJlbmRlciB0YWtlcyBwbGFjZS5cbiAqXG4gKiBDcmVkaXQgdG8gW1PDqWJhc3RpZW4gQ2hvcGluXShodHRwczovL2dpdGh1Yi5jb20vQXRpbnV4KSBmb3IgdGhlIHN1Z2dlc3Rpb25cbiAqIHRvIGltcGxlbWVudCB0aGlzIG1ldGhvZC5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IC0gbmV3IG1ldGEgaW5mb1xuICovXG5cbmZ1bmN0aW9uIHJlZnJlc2gocm9vdFZtLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OyAvLyBtYWtlIHN1cmUgdnVlLW1ldGEgd2FzIGluaXRpYXRlZFxuXG4gIGlmICghcm9vdFZtW3Jvb3RDb25maWdLZXldKSB7XG4gICAgc2hvd1dhcm5pbmdOb3RTdXBwb3J0ZWQoKTtcbiAgICByZXR1cm4ge307XG4gIH0gLy8gY29sbGVjdCAmIGFnZ3JlZ2F0ZSBhbGwgbWV0YUluZm8gJG9wdGlvbnNcblxuXG4gIHZhciByYXdJbmZvID0gZ2V0Q29tcG9uZW50TWV0YUluZm8ob3B0aW9ucywgcm9vdFZtKTtcbiAgdmFyIG1ldGFJbmZvID0gZ2V0TWV0YUluZm8ob3B0aW9ucywgcmF3SW5mbywgY2xpZW50U2VxdWVuY2VzLCByb290Vm0pO1xuICB2YXIgYXBwSWQgPSByb290Vm1bcm9vdENvbmZpZ0tleV0uYXBwSWQ7XG4gIHZhciB0YWdzID0gdXBkYXRlQ2xpZW50TWV0YUluZm8oYXBwSWQsIG9wdGlvbnMsIG1ldGFJbmZvKTsgLy8gZW1pdCBcImV2ZW50XCIgd2l0aCBuZXcgaW5mb1xuXG4gIGlmICh0YWdzICYmIGlzRnVuY3Rpb24obWV0YUluZm8uY2hhbmdlZCkpIHtcbiAgICBtZXRhSW5mby5jaGFuZ2VkKG1ldGFJbmZvLCB0YWdzLnRhZ3NBZGRlZCwgdGFncy50YWdzUmVtb3ZlZCk7XG4gICAgdGFncyA9IHtcbiAgICAgIGFkZGVkVGFnczogdGFncy50YWdzQWRkZWQsXG4gICAgICByZW1vdmVkVGFnczogdGFncy50YWdzUmVtb3ZlZFxuICAgIH07XG4gIH1cblxuICB2YXIgYXBwc01ldGFJbmZvID0gZ2V0QXBwc01ldGFJbmZvKCk7XG5cbiAgaWYgKGFwcHNNZXRhSW5mbykge1xuICAgIGZvciAodmFyIGFkZGl0aW9uYWxBcHBJZCBpbiBhcHBzTWV0YUluZm8pIHtcbiAgICAgIHVwZGF0ZUNsaWVudE1ldGFJbmZvKGFkZGl0aW9uYWxBcHBJZCwgb3B0aW9ucywgYXBwc01ldGFJbmZvW2FkZGl0aW9uYWxBcHBJZF0pO1xuICAgICAgZGVsZXRlIGFwcHNNZXRhSW5mb1thZGRpdGlvbmFsQXBwSWRdO1xuICAgIH1cblxuICAgIGNsZWFyQXBwc01ldGFJbmZvKHRydWUpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB2bTogcm9vdFZtLFxuICAgIG1ldGFJbmZvOiBtZXRhSW5mbyxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG9iamVjdC1zaG9ydGhhbmRcbiAgICB0YWdzOiB0YWdzXG4gIH07XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIHRhZyBhdHRyaWJ1dGVzIGZvciB1c2Ugb24gdGhlIHNlcnZlci5cbiAqXG4gKiBAcGFyYW0gIHsoJ2JvZHlBdHRycyd8J2h0bWxBdHRycyd8J2hlYWRBdHRycycpfSB0eXBlIC0gdGhlIHR5cGUgb2YgYXR0cmlidXRlcyB0byBnZW5lcmF0ZVxuICogQHBhcmFtICB7T2JqZWN0fSBkYXRhIC0gdGhlIGF0dHJpYnV0ZXMgdG8gZ2VuZXJhdGVcbiAqIEByZXR1cm4ge09iamVjdH0gLSB0aGUgYXR0cmlidXRlIGdlbmVyYXRvclxuICovXG5cbmZ1bmN0aW9uIGF0dHJpYnV0ZUdlbmVyYXRvcihvcHRpb25zLCB0eXBlLCBkYXRhLCBfcmVmKSB7XG4gIHZhciBhZGRTc3JBdHRyaWJ1dGUgPSBfcmVmLmFkZFNzckF0dHJpYnV0ZTtcblxuICB2YXIgX3JlZjIgPSBvcHRpb25zIHx8IHt9LFxuICAgICAgYXR0cmlidXRlID0gX3JlZjIuYXR0cmlidXRlLFxuICAgICAgc3NyQXR0cmlidXRlID0gX3JlZjIuc3NyQXR0cmlidXRlO1xuXG4gIHZhciBhdHRyaWJ1dGVTdHIgPSAnJztcblxuICBmb3IgKHZhciBhdHRyIGluIGRhdGEpIHtcbiAgICB2YXIgYXR0ckRhdGEgPSBkYXRhW2F0dHJdO1xuICAgIHZhciBhdHRyVmFsdWVzID0gW107XG5cbiAgICBmb3IgKHZhciBhcHBJZCBpbiBhdHRyRGF0YSkge1xuICAgICAgYXR0clZhbHVlcy5wdXNoLmFwcGx5KGF0dHJWYWx1ZXMsIF90b0NvbnN1bWFibGVBcnJheShbXS5jb25jYXQoYXR0ckRhdGFbYXBwSWRdKSkpO1xuICAgIH1cblxuICAgIGlmIChhdHRyVmFsdWVzLmxlbmd0aCkge1xuICAgICAgYXR0cmlidXRlU3RyICs9IGJvb2xlYW5IdG1sQXR0cmlidXRlcy5pbmNsdWRlcyhhdHRyKSAmJiBhdHRyVmFsdWVzLnNvbWUoQm9vbGVhbikgPyBcIlwiLmNvbmNhdChhdHRyKSA6IFwiXCIuY29uY2F0KGF0dHIsIFwiPVxcXCJcIikuY29uY2F0KGF0dHJWYWx1ZXMuam9pbignICcpLCBcIlxcXCJcIik7XG4gICAgICBhdHRyaWJ1dGVTdHIgKz0gJyAnO1xuICAgIH1cbiAgfVxuXG4gIGlmIChhdHRyaWJ1dGVTdHIpIHtcbiAgICBhdHRyaWJ1dGVTdHIgKz0gXCJcIi5jb25jYXQoYXR0cmlidXRlLCBcIj1cXFwiXCIpLmNvbmNhdChlbmNvZGVVUkkoSlNPTi5zdHJpbmdpZnkoZGF0YSkpLCBcIlxcXCJcIik7XG4gIH1cblxuICBpZiAodHlwZSA9PT0gJ2h0bWxBdHRycycgJiYgYWRkU3NyQXR0cmlidXRlKSB7XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KHNzckF0dHJpYnV0ZSkuY29uY2F0KGF0dHJpYnV0ZVN0ciA/ICcgJyA6ICcnKS5jb25jYXQoYXR0cmlidXRlU3RyKTtcbiAgfVxuXG4gIHJldHVybiBhdHRyaWJ1dGVTdHI7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIHRpdGxlIG91dHB1dCBmb3IgdGhlIHNlcnZlclxuICpcbiAqIEBwYXJhbSAgeyd0aXRsZSd9IHR5cGUgLSB0aGUgc3RyaW5nIFwidGl0bGVcIlxuICogQHBhcmFtICB7U3RyaW5nfSBkYXRhIC0gdGhlIHRpdGxlIHRleHRcbiAqIEByZXR1cm4ge09iamVjdH0gLSB0aGUgdGl0bGUgZ2VuZXJhdG9yXG4gKi9cbmZ1bmN0aW9uIHRpdGxlR2VuZXJhdG9yKG9wdGlvbnMsIHR5cGUsIGRhdGEsIGdlbmVyYXRvck9wdGlvbnMpIHtcbiAgdmFyIF9yZWYgPSBnZW5lcmF0b3JPcHRpb25zIHx8IHt9LFxuICAgICAgbG4gPSBfcmVmLmxuO1xuXG4gIGlmICghZGF0YSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHJldHVybiBcIjxcIi5jb25jYXQodHlwZSwgXCI+XCIpLmNvbmNhdChkYXRhLCBcIjwvXCIpLmNvbmNhdCh0eXBlLCBcIj5cIikuY29uY2F0KGxuID8gJ1xcbicgOiAnJyk7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIG1ldGEsIGJhc2UsIGxpbmssIHN0eWxlLCBzY3JpcHQsIG5vc2NyaXB0IHRhZ3MgZm9yIHVzZSBvbiB0aGUgc2VydmVyXG4gKlxuICogQHBhcmFtICB7KCdtZXRhJ3wnYmFzZSd8J2xpbmsnfCdzdHlsZSd8J3NjcmlwdCd8J25vc2NyaXB0Jyl9IHRoZSBuYW1lIG9mIHRoZSB0YWdcbiAqIEBwYXJhbSAgeyhBcnJheTxPYmplY3Q+fE9iamVjdCl9IHRhZ3MgLSBhbiBhcnJheSBvZiB0YWcgb2JqZWN0cyBvciBhIHNpbmdsZSBvYmplY3QgaW4gY2FzZSBvZiBiYXNlXG4gKiBAcmV0dXJuIHtPYmplY3R9IC0gdGhlIHRhZyBnZW5lcmF0b3JcbiAqL1xuXG5mdW5jdGlvbiB0YWdHZW5lcmF0b3Iob3B0aW9ucywgdHlwZSwgdGFncywgZ2VuZXJhdG9yT3B0aW9ucykge1xuICB2YXIgX3JlZiA9IG9wdGlvbnMgfHwge30sXG4gICAgICBzc3JBcHBJZCA9IF9yZWYuc3NyQXBwSWQsXG4gICAgICBhdHRyaWJ1dGUgPSBfcmVmLmF0dHJpYnV0ZSxcbiAgICAgIHRhZ0lES2V5TmFtZSA9IF9yZWYudGFnSURLZXlOYW1lO1xuXG4gIHZhciBfcmVmMiA9IGdlbmVyYXRvck9wdGlvbnMgfHwge30sXG4gICAgICBhcHBJZCA9IF9yZWYyLmFwcElkLFxuICAgICAgX3JlZjIkaXNTU1IgPSBfcmVmMi5pc1NTUixcbiAgICAgIGlzU1NSID0gX3JlZjIkaXNTU1IgPT09IHZvaWQgMCA/IHRydWUgOiBfcmVmMiRpc1NTUixcbiAgICAgIF9yZWYyJGJvZHkgPSBfcmVmMi5ib2R5LFxuICAgICAgYm9keSA9IF9yZWYyJGJvZHkgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZjIkYm9keSxcbiAgICAgIF9yZWYyJHBib2R5ID0gX3JlZjIucGJvZHksXG4gICAgICBwYm9keSA9IF9yZWYyJHBib2R5ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYyJHBib2R5LFxuICAgICAgX3JlZjIkbG4gPSBfcmVmMi5sbixcbiAgICAgIGxuID0gX3JlZjIkbG4gPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZjIkbG47XG5cbiAgdmFyIGRhdGFBdHRyaWJ1dGVzID0gW3RhZ0lES2V5TmFtZV0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShjb21tb25EYXRhQXR0cmlidXRlcykpO1xuXG4gIGlmICghdGFncyB8fCAhdGFncy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJyc7XG4gIH0gLy8gYnVpbGQgYSBzdHJpbmcgY29udGFpbmluZyBhbGwgdGFncyBvZiB0aGlzIHR5cGVcblxuXG4gIHJldHVybiB0YWdzLnJlZHVjZShmdW5jdGlvbiAodGFnc1N0ciwgdGFnKSB7XG4gICAgaWYgKHRhZy5za2lwKSB7XG4gICAgICByZXR1cm4gdGFnc1N0cjtcbiAgICB9XG5cbiAgICB2YXIgdGFnS2V5cyA9IE9iamVjdC5rZXlzKHRhZyk7XG5cbiAgICBpZiAodGFnS2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0YWdzU3RyOyAvLyBCYWlsIG9uIGVtcHR5IHRhZyBvYmplY3RcbiAgICB9XG5cbiAgICBpZiAoQm9vbGVhbih0YWcuYm9keSkgIT09IGJvZHkgfHwgQm9vbGVhbih0YWcucGJvZHkpICE9PSBwYm9keSkge1xuICAgICAgcmV0dXJuIHRhZ3NTdHI7XG4gICAgfVxuXG4gICAgdmFyIGF0dHJzID0gdGFnLm9uY2UgPyAnJyA6IFwiIFwiLmNvbmNhdChhdHRyaWJ1dGUsIFwiPVxcXCJcIikuY29uY2F0KGFwcElkIHx8IChpc1NTUiA9PT0gZmFsc2UgPyAnMScgOiBzc3JBcHBJZCksIFwiXFxcIlwiKTsgLy8gYnVpbGQgYSBzdHJpbmcgY29udGFpbmluZyBhbGwgYXR0cmlidXRlcyBvZiB0aGlzIHRhZ1xuXG4gICAgZm9yICh2YXIgYXR0ciBpbiB0YWcpIHtcbiAgICAgIC8vIHRoZXNlIGF0dHJpYnV0ZXMgYXJlIHRyZWF0ZWQgYXMgY2hpbGRyZW4gb24gdGhlIHRhZ1xuICAgICAgaWYgKHRhZ0F0dHJpYnV0ZUFzSW5uZXJDb250ZW50LmluY2x1ZGVzKGF0dHIpIHx8IHRhZ1Byb3BlcnRpZXMuaW5jbHVkZXMoYXR0cikpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChhdHRyID09PSAnY2FsbGJhY2snKSB7XG4gICAgICAgIGF0dHJzICs9ICcgb25sb2FkPVwidGhpcy5fX3ZtX2w9MVwiJztcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIHRoZXNlIGZvcm0gdGhlIGF0dHJpYnV0ZSBsaXN0IGZvciB0aGlzIHRhZ1xuXG5cbiAgICAgIHZhciBwcmVmaXggPSAnJztcblxuICAgICAgaWYgKGRhdGFBdHRyaWJ1dGVzLmluY2x1ZGVzKGF0dHIpKSB7XG4gICAgICAgIHByZWZpeCA9ICdkYXRhLSc7XG4gICAgICB9XG5cbiAgICAgIHZhciBpc0Jvb2xlYW5BdHRyID0gIXByZWZpeCAmJiBib29sZWFuSHRtbEF0dHJpYnV0ZXMuaW5jbHVkZXMoYXR0cik7XG5cbiAgICAgIGlmIChpc0Jvb2xlYW5BdHRyICYmICF0YWdbYXR0cl0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGF0dHJzICs9IFwiIFwiLmNvbmNhdChwcmVmaXgpLmNvbmNhdChhdHRyKSArIChpc0Jvb2xlYW5BdHRyID8gJycgOiBcIj1cXFwiXCIuY29uY2F0KHRhZ1thdHRyXSwgXCJcXFwiXCIpKTtcbiAgICB9XG5cbiAgICB2YXIganNvbiA9ICcnO1xuXG4gICAgaWYgKHRhZy5qc29uKSB7XG4gICAgICBqc29uID0gSlNPTi5zdHJpbmdpZnkodGFnLmpzb24pO1xuICAgIH0gLy8gZ3JhYiBjaGlsZCBjb250ZW50IGZyb20gb25lIG9mIHRoZXNlIGF0dHJpYnV0ZXMsIGlmIHBvc3NpYmxlXG5cblxuICAgIHZhciBjb250ZW50ID0gdGFnLmlubmVySFRNTCB8fCB0YWcuY3NzVGV4dCB8fCBqc29uOyAvLyBnZW5lcmF0ZSB0YWcgZXhhY3RseSB3aXRob3V0IGFueSBvdGhlciByZWR1bmRhbnQgYXR0cmlidXRlXG4gICAgLy8gdGhlc2UgdGFncyBoYXZlIG5vIGVuZCB0YWdcblxuICAgIHZhciBoYXNFbmRUYWcgPSAhdGFnc1dpdGhvdXRFbmRUYWcuaW5jbHVkZXModHlwZSk7IC8vIHRoZXNlIHRhZyB0eXBlcyB3aWxsIGhhdmUgY29udGVudCBpbnNlcnRlZFxuXG4gICAgdmFyIGhhc0NvbnRlbnQgPSBoYXNFbmRUYWcgJiYgdGFnc1dpdGhJbm5lckNvbnRlbnQuaW5jbHVkZXModHlwZSk7IC8vIHRoZSBmaW5hbCBzdHJpbmcgZm9yIHRoaXMgc3BlY2lmaWMgdGFnXG5cbiAgICByZXR1cm4gXCJcIi5jb25jYXQodGFnc1N0ciwgXCI8XCIpLmNvbmNhdCh0eXBlKS5jb25jYXQoYXR0cnMpLmNvbmNhdCghaGFzQ29udGVudCAmJiBoYXNFbmRUYWcgPyAnLycgOiAnJywgXCI+XCIpICsgKGhhc0NvbnRlbnQgPyBcIlwiLmNvbmNhdChjb250ZW50LCBcIjwvXCIpLmNvbmNhdCh0eXBlLCBcIj5cIikgOiAnJykgKyAobG4gPyAnXFxuJyA6ICcnKTtcbiAgfSwgJycpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgbWV0YSBpbmZvIHByb3BlcnR5IHRvIG9uZSB0aGF0IGNhbiBiZSBzdHJpbmdpZmllZCBvbiB0aGUgc2VydmVyXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSB0eXBlIC0gdGhlIHR5cGUgb2YgZGF0YSB0byBjb252ZXJ0XG4gKiBAcGFyYW0gIHsoU3RyaW5nfE9iamVjdHxBcnJheTxPYmplY3Q+KX0gZGF0YSAtIHRoZSBkYXRhIHZhbHVlXG4gKiBAcmV0dXJuIHtPYmplY3R9IC0gdGhlIG5ldyBpbmplY3RvclxuICovXG5cbmZ1bmN0aW9uIGdlbmVyYXRlU2VydmVySW5qZWN0b3Iob3B0aW9ucywgbWV0YUluZm8sIGdsb2JhbEluamVjdE9wdGlvbnMpIHtcbiAgdmFyIHNlcnZlckluamVjdG9yID0ge1xuICAgIGRhdGE6IG1ldGFJbmZvLFxuICAgIGV4dHJhRGF0YTogdW5kZWZpbmVkLFxuICAgIGFkZEluZm86IGZ1bmN0aW9uIGFkZEluZm8oYXBwSWQsIG1ldGFJbmZvKSB7XG4gICAgICB0aGlzLmV4dHJhRGF0YSA9IHRoaXMuZXh0cmFEYXRhIHx8IHt9O1xuICAgICAgdGhpcy5leHRyYURhdGFbYXBwSWRdID0gbWV0YUluZm87XG4gICAgfSxcbiAgICBjYWxsSW5qZWN0b3JzOiBmdW5jdGlvbiBjYWxsSW5qZWN0b3JzKG9wdHMpIHtcbiAgICAgIHZhciBtID0gdGhpcy5pbmplY3RvcnM7IC8vIG9ubHkgY2FsbCB0aXRsZSBmb3IgdGhlIGhlYWRcblxuICAgICAgcmV0dXJuIChvcHRzLmJvZHkgfHwgb3B0cy5wYm9keSA/ICcnIDogbS50aXRsZS50ZXh0KG9wdHMpKSArIG0ubWV0YS50ZXh0KG9wdHMpICsgbS5iYXNlLnRleHQob3B0cykgKyBtLmxpbmsudGV4dChvcHRzKSArIG0uc3R5bGUudGV4dChvcHRzKSArIG0uc2NyaXB0LnRleHQob3B0cykgKyBtLm5vc2NyaXB0LnRleHQob3B0cyk7XG4gICAgfSxcbiAgICBpbmplY3RvcnM6IHtcbiAgICAgIGhlYWQ6IGZ1bmN0aW9uIGhlYWQobG4pIHtcbiAgICAgICAgcmV0dXJuIHNlcnZlckluamVjdG9yLmNhbGxJbmplY3RvcnMoX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGdsb2JhbEluamVjdE9wdGlvbnMpLCB7fSwge1xuICAgICAgICAgIGxuOiBsblxuICAgICAgICB9KSk7XG4gICAgICB9LFxuICAgICAgYm9keVByZXBlbmQ6IGZ1bmN0aW9uIGJvZHlQcmVwZW5kKGxuKSB7XG4gICAgICAgIHJldHVybiBzZXJ2ZXJJbmplY3Rvci5jYWxsSW5qZWN0b3JzKF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBnbG9iYWxJbmplY3RPcHRpb25zKSwge30sIHtcbiAgICAgICAgICBsbjogbG4sXG4gICAgICAgICAgcGJvZHk6IHRydWVcbiAgICAgICAgfSkpO1xuICAgICAgfSxcbiAgICAgIGJvZHlBcHBlbmQ6IGZ1bmN0aW9uIGJvZHlBcHBlbmQobG4pIHtcbiAgICAgICAgcmV0dXJuIHNlcnZlckluamVjdG9yLmNhbGxJbmplY3RvcnMoX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGdsb2JhbEluamVjdE9wdGlvbnMpLCB7fSwge1xuICAgICAgICAgIGxuOiBsbixcbiAgICAgICAgICBib2R5OiB0cnVlXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AodHlwZSkge1xuICAgIGlmIChtZXRhSW5mb09wdGlvbktleXMuaW5jbHVkZXModHlwZSkpIHtcbiAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XG4gICAgfVxuXG4gICAgc2VydmVySW5qZWN0b3IuaW5qZWN0b3JzW3R5cGVdID0ge1xuICAgICAgdGV4dDogZnVuY3Rpb24gdGV4dChpbmplY3RPcHRpb25zKSB7XG4gICAgICAgIHZhciBhZGRTc3JBdHRyaWJ1dGUgPSBpbmplY3RPcHRpb25zID09PSB0cnVlO1xuICAgICAgICBpbmplY3RPcHRpb25zID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe1xuICAgICAgICAgIGFkZFNzckF0dHJpYnV0ZTogYWRkU3NyQXR0cmlidXRlXG4gICAgICAgIH0sIGdsb2JhbEluamVjdE9wdGlvbnMpLCBpbmplY3RPcHRpb25zKTtcblxuICAgICAgICBpZiAodHlwZSA9PT0gJ3RpdGxlJykge1xuICAgICAgICAgIHJldHVybiB0aXRsZUdlbmVyYXRvcihvcHRpb25zLCB0eXBlLCBzZXJ2ZXJJbmplY3Rvci5kYXRhW3R5cGVdLCBpbmplY3RPcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZXRhSW5mb0F0dHJpYnV0ZUtleXMuaW5jbHVkZXModHlwZSkpIHtcbiAgICAgICAgICB2YXIgYXR0cmlidXRlRGF0YSA9IHt9O1xuICAgICAgICAgIHZhciBkYXRhID0gc2VydmVySW5qZWN0b3IuZGF0YVt0eXBlXTtcblxuICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICB2YXIgYXBwSWQgPSBpbmplY3RPcHRpb25zLmlzU1NSID09PSBmYWxzZSA/ICcxJyA6IG9wdGlvbnMuc3NyQXBwSWQ7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGF0dHIgaW4gZGF0YSkge1xuICAgICAgICAgICAgICBhdHRyaWJ1dGVEYXRhW2F0dHJdID0gX2RlZmluZVByb3BlcnR5KHt9LCBhcHBJZCwgZGF0YVthdHRyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlcnZlckluamVjdG9yLmV4dHJhRGF0YSkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2FwcElkIGluIHNlcnZlckluamVjdG9yLmV4dHJhRGF0YSkge1xuICAgICAgICAgICAgICB2YXIgX2RhdGEgPSBzZXJ2ZXJJbmplY3Rvci5leHRyYURhdGFbX2FwcElkXVt0eXBlXTtcblxuICAgICAgICAgICAgICBpZiAoX2RhdGEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfYXR0ciBpbiBfZGF0YSkge1xuICAgICAgICAgICAgICAgICAgYXR0cmlidXRlRGF0YVtfYXR0cl0gPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgYXR0cmlidXRlRGF0YVtfYXR0cl0pLCB7fSwgX2RlZmluZVByb3BlcnR5KHt9LCBfYXBwSWQsIF9kYXRhW19hdHRyXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBhdHRyaWJ1dGVHZW5lcmF0b3Iob3B0aW9ucywgdHlwZSwgYXR0cmlidXRlRGF0YSwgaW5qZWN0T3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3RyID0gdGFnR2VuZXJhdG9yKG9wdGlvbnMsIHR5cGUsIHNlcnZlckluamVjdG9yLmRhdGFbdHlwZV0sIGluamVjdE9wdGlvbnMpO1xuXG4gICAgICAgIGlmIChzZXJ2ZXJJbmplY3Rvci5leHRyYURhdGEpIHtcbiAgICAgICAgICBmb3IgKHZhciBfYXBwSWQyIGluIHNlcnZlckluamVjdG9yLmV4dHJhRGF0YSkge1xuICAgICAgICAgICAgdmFyIF9kYXRhMiA9IHNlcnZlckluamVjdG9yLmV4dHJhRGF0YVtfYXBwSWQyXVt0eXBlXTtcbiAgICAgICAgICAgIHZhciBleHRyYVN0ciA9IHRhZ0dlbmVyYXRvcihvcHRpb25zLCB0eXBlLCBfZGF0YTIsIF9vYmplY3RTcHJlYWQyKHtcbiAgICAgICAgICAgICAgYXBwSWQ6IF9hcHBJZDJcbiAgICAgICAgICAgIH0sIGluamVjdE9wdGlvbnMpKTtcbiAgICAgICAgICAgIHN0ciA9IFwiXCIuY29uY2F0KHN0cikuY29uY2F0KGV4dHJhU3RyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgZm9yICh2YXIgdHlwZSBpbiBkZWZhdWx0SW5mbykge1xuICAgIHZhciBfcmV0ID0gX2xvb3AodHlwZSk7XG5cbiAgICBpZiAoX3JldCA9PT0gXCJjb250aW51ZVwiKSBjb250aW51ZTtcbiAgfVxuXG4gIHJldHVybiBzZXJ2ZXJJbmplY3Rvcjtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgc3RhdGUgb2YgdGhlIG1ldGEgaW5mbyBvYmplY3Qgc3VjaCB0aGF0IGVhY2ggaXRlbVxuICogY2FuIGJlIGNvbXBpbGVkIHRvIGEgdGFnIHN0cmluZyBvbiB0aGUgc2VydmVyXG4gKlxuICogQHZtIHtPYmplY3R9IC0gVnVlIGluc3RhbmNlIC0gaWRlYWxseSB0aGUgcm9vdCBjb21wb25lbnRcbiAqIEByZXR1cm4ge09iamVjdH0gLSBzZXJ2ZXIgbWV0YSBpbmZvIHdpdGggYHRvU3RyaW5nYCBtZXRob2RzXG4gKi9cblxuZnVuY3Rpb24gaW5qZWN0KHJvb3RWbSwgb3B0aW9ucywgaW5qZWN0T3B0aW9ucykge1xuICAvLyBtYWtlIHN1cmUgdnVlLW1ldGEgd2FzIGluaXRpYXRlZFxuICBpZiAoIXJvb3RWbVtyb290Q29uZmlnS2V5XSkge1xuICAgIHNob3dXYXJuaW5nTm90U3VwcG9ydGVkKCk7XG4gICAgcmV0dXJuIHt9O1xuICB9IC8vIGNvbGxlY3QgJiBhZ2dyZWdhdGUgYWxsIG1ldGFJbmZvICRvcHRpb25zXG5cblxuICB2YXIgcmF3SW5mbyA9IGdldENvbXBvbmVudE1ldGFJbmZvKG9wdGlvbnMsIHJvb3RWbSk7XG4gIHZhciBtZXRhSW5mbyA9IGdldE1ldGFJbmZvKG9wdGlvbnMsIHJhd0luZm8sIHNlcnZlclNlcXVlbmNlcywgcm9vdFZtKTsgLy8gZ2VuZXJhdGUgc2VydmVyIGluamVjdG9yXG5cbiAgdmFyIHNlcnZlckluamVjdG9yID0gZ2VuZXJhdGVTZXJ2ZXJJbmplY3RvcihvcHRpb25zLCBtZXRhSW5mbywgaW5qZWN0T3B0aW9ucyk7IC8vIGFkZCBtZXRhIGluZm8gZnJvbSBhZGRpdGlvbmFsIGFwcHNcblxuICB2YXIgYXBwc01ldGFJbmZvID0gZ2V0QXBwc01ldGFJbmZvKCk7XG5cbiAgaWYgKGFwcHNNZXRhSW5mbykge1xuICAgIGZvciAodmFyIGFkZGl0aW9uYWxBcHBJZCBpbiBhcHBzTWV0YUluZm8pIHtcbiAgICAgIHNlcnZlckluamVjdG9yLmFkZEluZm8oYWRkaXRpb25hbEFwcElkLCBhcHBzTWV0YUluZm9bYWRkaXRpb25hbEFwcElkXSk7XG4gICAgICBkZWxldGUgYXBwc01ldGFJbmZvW2FkZGl0aW9uYWxBcHBJZF07XG4gICAgfVxuXG4gICAgY2xlYXJBcHBzTWV0YUluZm8odHJ1ZSk7XG4gIH1cblxuICByZXR1cm4gc2VydmVySW5qZWN0b3IuaW5qZWN0b3JzO1xufVxuXG5mdW5jdGlvbiAkbWV0YShvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAvKipcbiAgICogUmV0dXJucyBhbiBpbmplY3RvciBmb3Igc2VydmVyLXNpZGUgcmVuZGVyaW5nLlxuICAgKiBAdGhpcyB7T2JqZWN0fSAtIHRoZSBWdWUgaW5zdGFuY2UgKGEgcm9vdCBjb21wb25lbnQpXG4gICAqIEByZXR1cm4ge09iamVjdH0gLSBpbmplY3RvclxuICAgKi9cblxuICB2YXIgJHJvb3QgPSB0aGlzLiRyb290O1xuICByZXR1cm4ge1xuICAgIGdldE9wdGlvbnM6IGZ1bmN0aW9uIGdldE9wdGlvbnMkMSgpIHtcbiAgICAgIHJldHVybiBnZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIH0sXG4gICAgc2V0T3B0aW9uczogZnVuY3Rpb24gc2V0T3B0aW9ucyhuZXdPcHRpb25zKSB7XG4gICAgICB2YXIgcmVmcmVzaE5hdktleSA9ICdyZWZyZXNoT25jZU9uTmF2aWdhdGlvbic7XG5cbiAgICAgIGlmIChuZXdPcHRpb25zICYmIG5ld09wdGlvbnNbcmVmcmVzaE5hdktleV0pIHtcbiAgICAgICAgb3B0aW9ucy5yZWZyZXNoT25jZU9uTmF2aWdhdGlvbiA9ICEhbmV3T3B0aW9uc1tyZWZyZXNoTmF2S2V5XTtcbiAgICAgICAgYWRkTmF2R3VhcmRzKCRyb290KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRlYm91bmNlV2FpdEtleSA9ICdkZWJvdW5jZVdhaXQnO1xuXG4gICAgICBpZiAobmV3T3B0aW9ucyAmJiBkZWJvdW5jZVdhaXRLZXkgaW4gbmV3T3B0aW9ucykge1xuICAgICAgICB2YXIgZGVib3VuY2VXYWl0ID0gcGFyc2VJbnQobmV3T3B0aW9uc1tkZWJvdW5jZVdhaXRLZXldKTtcblxuICAgICAgICBpZiAoIWlzTmFOKGRlYm91bmNlV2FpdCkpIHtcbiAgICAgICAgICBvcHRpb25zLmRlYm91bmNlV2FpdCA9IGRlYm91bmNlV2FpdDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgd2FpdE9uRGVzdHJveWVkS2V5ID0gJ3dhaXRPbkRlc3Ryb3llZCc7XG5cbiAgICAgIGlmIChuZXdPcHRpb25zICYmIHdhaXRPbkRlc3Ryb3llZEtleSBpbiBuZXdPcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMud2FpdE9uRGVzdHJveWVkID0gISFuZXdPcHRpb25zW3dhaXRPbkRlc3Ryb3llZEtleV07XG4gICAgICB9XG4gICAgfSxcbiAgICByZWZyZXNoOiBmdW5jdGlvbiByZWZyZXNoJDEoKSB7XG4gICAgICByZXR1cm4gcmVmcmVzaCgkcm9vdCwgb3B0aW9ucyk7XG4gICAgfSxcbiAgICBpbmplY3Q6IGZ1bmN0aW9uIGluamVjdCQxKGluamVjdE9wdGlvbnMpIHtcbiAgICAgIHJldHVybiAgaW5qZWN0KCRyb290LCBvcHRpb25zLCBpbmplY3RPcHRpb25zKSA7XG4gICAgfSxcbiAgICBwYXVzZTogZnVuY3Rpb24gcGF1c2UkMSgpIHtcbiAgICAgIHJldHVybiBwYXVzZSgkcm9vdCk7XG4gICAgfSxcbiAgICByZXN1bWU6IGZ1bmN0aW9uIHJlc3VtZSQxKCkge1xuICAgICAgcmV0dXJuIHJlc3VtZSgkcm9vdCk7XG4gICAgfSxcbiAgICBhZGRBcHA6IGZ1bmN0aW9uIGFkZEFwcCQxKGFwcElkKSB7XG4gICAgICByZXR1cm4gYWRkQXBwKCRyb290LCBhcHBJZCwgb3B0aW9ucyk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZShyYXdJbmZvLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBzZXRPcHRpb25zKG9wdGlvbnMpO1xuICB2YXIgbWV0YUluZm8gPSBnZXRNZXRhSW5mbyhvcHRpb25zLCByYXdJbmZvLCBzZXJ2ZXJTZXF1ZW5jZXMpO1xuICB2YXIgc2VydmVySW5qZWN0b3IgPSBnZW5lcmF0ZVNlcnZlckluamVjdG9yKG9wdGlvbnMsIG1ldGFJbmZvKTtcbiAgcmV0dXJuIHNlcnZlckluamVjdG9yLmluamVjdG9ycztcbn1cblxuLyoqXG4gKiBQbHVnaW4gaW5zdGFsbCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFZ1ZSAtIHRoZSBWdWUgY29uc3RydWN0b3IuXG4gKi9cblxuZnVuY3Rpb24gaW5zdGFsbChWdWUsIG9wdGlvbnMpIHtcbiAgaWYgKFZ1ZS5fX3Z1ZW1ldGFfaW5zdGFsbGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgVnVlLl9fdnVlbWV0YV9pbnN0YWxsZWQgPSB0cnVlO1xuICBvcHRpb25zID0gc2V0T3B0aW9ucyhvcHRpb25zKTtcblxuICBWdWUucHJvdG90eXBlLiRtZXRhID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAkbWV0YS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICB9O1xuXG4gIFZ1ZS5taXhpbihjcmVhdGVNaXhpbihWdWUsIG9wdGlvbnMpKTtcbn1cblxudmFyIGluZGV4ID0ge1xuICB2ZXJzaW9uOiB2ZXJzaW9uLFxuICBpbnN0YWxsOiBpbnN0YWxsLFxuICBnZW5lcmF0ZTogZnVuY3Rpb24gZ2VuZXJhdGUkMShtZXRhSW5mbywgb3B0aW9ucykge1xuICAgIHJldHVybiAgZ2VuZXJhdGUobWV0YUluZm8sIG9wdGlvbnMpIDtcbiAgfSxcbiAgaGFzTWV0YUluZm86IGhhc01ldGFJbmZvXG59O1xuXG5leHBvcnQgZGVmYXVsdCBpbmRleDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/vue-meta/dist/vue-meta.esm.js\n");

/***/ }),

/***/ "./node_modules/vue-router/dist/vue-router.esm.js":
/*!********************************************************!*\
  !*** ./node_modules/vue-router/dist/vue-router.esm.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*!\n  * vue-router v3.5.4\n  * (c) 2022 Evan You\n  * @license MIT\n  */\n/*  */\n\nfunction assert (condition, message) {\n  if (!condition) {\n    throw new Error((\"[vue-router] \" + message))\n  }\n}\n\nfunction warn (condition, message) {\n  if (!condition) {\n    typeof console !== 'undefined' && console.warn((\"[vue-router] \" + message));\n  }\n}\n\nfunction extend (a, b) {\n  for (var key in b) {\n    a[key] = b[key];\n  }\n  return a\n}\n\n/*  */\n\nvar encodeReserveRE = /[!'()*]/g;\nvar encodeReserveReplacer = function (c) { return '%' + c.charCodeAt(0).toString(16); };\nvar commaRE = /%2C/g;\n\n// fixed encodeURIComponent which is more conformant to RFC3986:\n// - escapes [!'()*]\n// - preserve commas\nvar encode = function (str) { return encodeURIComponent(str)\n    .replace(encodeReserveRE, encodeReserveReplacer)\n    .replace(commaRE, ','); };\n\nfunction decode (str) {\n  try {\n    return decodeURIComponent(str)\n  } catch (err) {\n    if (true) {\n      warn(false, (\"Error decoding \\\"\" + str + \"\\\". Leaving it intact.\"));\n    }\n  }\n  return str\n}\n\nfunction resolveQuery (\n  query,\n  extraQuery,\n  _parseQuery\n) {\n  if ( extraQuery === void 0 ) extraQuery = {};\n\n  var parse = _parseQuery || parseQuery;\n  var parsedQuery;\n  try {\n    parsedQuery = parse(query || '');\n  } catch (e) {\n     true && warn(false, e.message);\n    parsedQuery = {};\n  }\n  for (var key in extraQuery) {\n    var value = extraQuery[key];\n    parsedQuery[key] = Array.isArray(value)\n      ? value.map(castQueryParamValue)\n      : castQueryParamValue(value);\n  }\n  return parsedQuery\n}\n\nvar castQueryParamValue = function (value) { return (value == null || typeof value === 'object' ? value : String(value)); };\n\nfunction parseQuery (query) {\n  var res = {};\n\n  query = query.trim().replace(/^(\\?|#|&)/, '');\n\n  if (!query) {\n    return res\n  }\n\n  query.split('&').forEach(function (param) {\n    var parts = param.replace(/\\+/g, ' ').split('=');\n    var key = decode(parts.shift());\n    var val = parts.length > 0 ? decode(parts.join('=')) : null;\n\n    if (res[key] === undefined) {\n      res[key] = val;\n    } else if (Array.isArray(res[key])) {\n      res[key].push(val);\n    } else {\n      res[key] = [res[key], val];\n    }\n  });\n\n  return res\n}\n\nfunction stringifyQuery (obj) {\n  var res = obj\n    ? Object.keys(obj)\n      .map(function (key) {\n        var val = obj[key];\n\n        if (val === undefined) {\n          return ''\n        }\n\n        if (val === null) {\n          return encode(key)\n        }\n\n        if (Array.isArray(val)) {\n          var result = [];\n          val.forEach(function (val2) {\n            if (val2 === undefined) {\n              return\n            }\n            if (val2 === null) {\n              result.push(encode(key));\n            } else {\n              result.push(encode(key) + '=' + encode(val2));\n            }\n          });\n          return result.join('&')\n        }\n\n        return encode(key) + '=' + encode(val)\n      })\n      .filter(function (x) { return x.length > 0; })\n      .join('&')\n    : null;\n  return res ? (\"?\" + res) : ''\n}\n\n/*  */\n\nvar trailingSlashRE = /\\/?$/;\n\nfunction createRoute (\n  record,\n  location,\n  redirectedFrom,\n  router\n) {\n  var stringifyQuery = router && router.options.stringifyQuery;\n\n  var query = location.query || {};\n  try {\n    query = clone(query);\n  } catch (e) {}\n\n  var route = {\n    name: location.name || (record && record.name),\n    meta: (record && record.meta) || {},\n    path: location.path || '/',\n    hash: location.hash || '',\n    query: query,\n    params: location.params || {},\n    fullPath: getFullPath(location, stringifyQuery),\n    matched: record ? formatMatch(record) : []\n  };\n  if (redirectedFrom) {\n    route.redirectedFrom = getFullPath(redirectedFrom, stringifyQuery);\n  }\n  return Object.freeze(route)\n}\n\nfunction clone (value) {\n  if (Array.isArray(value)) {\n    return value.map(clone)\n  } else if (value && typeof value === 'object') {\n    var res = {};\n    for (var key in value) {\n      res[key] = clone(value[key]);\n    }\n    return res\n  } else {\n    return value\n  }\n}\n\n// the starting route that represents the initial state\nvar START = createRoute(null, {\n  path: '/'\n});\n\nfunction formatMatch (record) {\n  var res = [];\n  while (record) {\n    res.unshift(record);\n    record = record.parent;\n  }\n  return res\n}\n\nfunction getFullPath (\n  ref,\n  _stringifyQuery\n) {\n  var path = ref.path;\n  var query = ref.query; if ( query === void 0 ) query = {};\n  var hash = ref.hash; if ( hash === void 0 ) hash = '';\n\n  var stringify = _stringifyQuery || stringifyQuery;\n  return (path || '/') + stringify(query) + hash\n}\n\nfunction isSameRoute (a, b, onlyPath) {\n  if (b === START) {\n    return a === b\n  } else if (!b) {\n    return false\n  } else if (a.path && b.path) {\n    return a.path.replace(trailingSlashRE, '') === b.path.replace(trailingSlashRE, '') && (onlyPath ||\n      a.hash === b.hash &&\n      isObjectEqual(a.query, b.query))\n  } else if (a.name && b.name) {\n    return (\n      a.name === b.name &&\n      (onlyPath || (\n        a.hash === b.hash &&\n      isObjectEqual(a.query, b.query) &&\n      isObjectEqual(a.params, b.params))\n      )\n    )\n  } else {\n    return false\n  }\n}\n\nfunction isObjectEqual (a, b) {\n  if ( a === void 0 ) a = {};\n  if ( b === void 0 ) b = {};\n\n  // handle null value #1566\n  if (!a || !b) { return a === b }\n  var aKeys = Object.keys(a).sort();\n  var bKeys = Object.keys(b).sort();\n  if (aKeys.length !== bKeys.length) {\n    return false\n  }\n  return aKeys.every(function (key, i) {\n    var aVal = a[key];\n    var bKey = bKeys[i];\n    if (bKey !== key) { return false }\n    var bVal = b[key];\n    // query values can be null and undefined\n    if (aVal == null || bVal == null) { return aVal === bVal }\n    // check nested equality\n    if (typeof aVal === 'object' && typeof bVal === 'object') {\n      return isObjectEqual(aVal, bVal)\n    }\n    return String(aVal) === String(bVal)\n  })\n}\n\nfunction isIncludedRoute (current, target) {\n  return (\n    current.path.replace(trailingSlashRE, '/').indexOf(\n      target.path.replace(trailingSlashRE, '/')\n    ) === 0 &&\n    (!target.hash || current.hash === target.hash) &&\n    queryIncludes(current.query, target.query)\n  )\n}\n\nfunction queryIncludes (current, target) {\n  for (var key in target) {\n    if (!(key in current)) {\n      return false\n    }\n  }\n  return true\n}\n\nfunction handleRouteEntered (route) {\n  for (var i = 0; i < route.matched.length; i++) {\n    var record = route.matched[i];\n    for (var name in record.instances) {\n      var instance = record.instances[name];\n      var cbs = record.enteredCbs[name];\n      if (!instance || !cbs) { continue }\n      delete record.enteredCbs[name];\n      for (var i$1 = 0; i$1 < cbs.length; i$1++) {\n        if (!instance._isBeingDestroyed) { cbs[i$1](instance); }\n      }\n    }\n  }\n}\n\nvar View = {\n  name: 'RouterView',\n  functional: true,\n  props: {\n    name: {\n      type: String,\n      default: 'default'\n    }\n  },\n  render: function render (_, ref) {\n    var props = ref.props;\n    var children = ref.children;\n    var parent = ref.parent;\n    var data = ref.data;\n\n    // used by devtools to display a router-view badge\n    data.routerView = true;\n\n    // directly use parent context's createElement() function\n    // so that components rendered by router-view can resolve named slots\n    var h = parent.$createElement;\n    var name = props.name;\n    var route = parent.$route;\n    var cache = parent._routerViewCache || (parent._routerViewCache = {});\n\n    // determine current view depth, also check to see if the tree\n    // has been toggled inactive but kept-alive.\n    var depth = 0;\n    var inactive = false;\n    while (parent && parent._routerRoot !== parent) {\n      var vnodeData = parent.$vnode ? parent.$vnode.data : {};\n      if (vnodeData.routerView) {\n        depth++;\n      }\n      if (vnodeData.keepAlive && parent._directInactive && parent._inactive) {\n        inactive = true;\n      }\n      parent = parent.$parent;\n    }\n    data.routerViewDepth = depth;\n\n    // render previous view if the tree is inactive and kept-alive\n    if (inactive) {\n      var cachedData = cache[name];\n      var cachedComponent = cachedData && cachedData.component;\n      if (cachedComponent) {\n        // #2301\n        // pass props\n        if (cachedData.configProps) {\n          fillPropsinData(cachedComponent, data, cachedData.route, cachedData.configProps);\n        }\n        return h(cachedComponent, data, children)\n      } else {\n        // render previous empty view\n        return h()\n      }\n    }\n\n    var matched = route.matched[depth];\n    var component = matched && matched.components[name];\n\n    // render empty node if no matched route or no config component\n    if (!matched || !component) {\n      cache[name] = null;\n      return h()\n    }\n\n    // cache component\n    cache[name] = { component: component };\n\n    // attach instance registration hook\n    // this will be called in the instance's injected lifecycle hooks\n    data.registerRouteInstance = function (vm, val) {\n      // val could be undefined for unregistration\n      var current = matched.instances[name];\n      if (\n        (val && current !== vm) ||\n        (!val && current === vm)\n      ) {\n        matched.instances[name] = val;\n      }\n    }\n\n    // also register instance in prepatch hook\n    // in case the same component instance is reused across different routes\n    ;(data.hook || (data.hook = {})).prepatch = function (_, vnode) {\n      matched.instances[name] = vnode.componentInstance;\n    };\n\n    // register instance in init hook\n    // in case kept-alive component be actived when routes changed\n    data.hook.init = function (vnode) {\n      if (vnode.data.keepAlive &&\n        vnode.componentInstance &&\n        vnode.componentInstance !== matched.instances[name]\n      ) {\n        matched.instances[name] = vnode.componentInstance;\n      }\n\n      // if the route transition has already been confirmed then we weren't\n      // able to call the cbs during confirmation as the component was not\n      // registered yet, so we call it here.\n      handleRouteEntered(route);\n    };\n\n    var configProps = matched.props && matched.props[name];\n    // save route and configProps in cache\n    if (configProps) {\n      extend(cache[name], {\n        route: route,\n        configProps: configProps\n      });\n      fillPropsinData(component, data, route, configProps);\n    }\n\n    return h(component, data, children)\n  }\n};\n\nfunction fillPropsinData (component, data, route, configProps) {\n  // resolve props\n  var propsToPass = data.props = resolveProps(route, configProps);\n  if (propsToPass) {\n    // clone to prevent mutation\n    propsToPass = data.props = extend({}, propsToPass);\n    // pass non-declared props as attrs\n    var attrs = data.attrs = data.attrs || {};\n    for (var key in propsToPass) {\n      if (!component.props || !(key in component.props)) {\n        attrs[key] = propsToPass[key];\n        delete propsToPass[key];\n      }\n    }\n  }\n}\n\nfunction resolveProps (route, config) {\n  switch (typeof config) {\n    case 'undefined':\n      return\n    case 'object':\n      return config\n    case 'function':\n      return config(route)\n    case 'boolean':\n      return config ? route.params : undefined\n    default:\n      if (true) {\n        warn(\n          false,\n          \"props in \\\"\" + (route.path) + \"\\\" is a \" + (typeof config) + \", \" +\n          \"expecting an object, function or boolean.\"\n        );\n      }\n  }\n}\n\n/*  */\n\nfunction resolvePath (\n  relative,\n  base,\n  append\n) {\n  var firstChar = relative.charAt(0);\n  if (firstChar === '/') {\n    return relative\n  }\n\n  if (firstChar === '?' || firstChar === '#') {\n    return base + relative\n  }\n\n  var stack = base.split('/');\n\n  // remove trailing segment if:\n  // - not appending\n  // - appending to trailing slash (last segment is empty)\n  if (!append || !stack[stack.length - 1]) {\n    stack.pop();\n  }\n\n  // resolve relative path\n  var segments = relative.replace(/^\\//, '').split('/');\n  for (var i = 0; i < segments.length; i++) {\n    var segment = segments[i];\n    if (segment === '..') {\n      stack.pop();\n    } else if (segment !== '.') {\n      stack.push(segment);\n    }\n  }\n\n  // ensure leading slash\n  if (stack[0] !== '') {\n    stack.unshift('');\n  }\n\n  return stack.join('/')\n}\n\nfunction parsePath (path) {\n  var hash = '';\n  var query = '';\n\n  var hashIndex = path.indexOf('#');\n  if (hashIndex >= 0) {\n    hash = path.slice(hashIndex);\n    path = path.slice(0, hashIndex);\n  }\n\n  var queryIndex = path.indexOf('?');\n  if (queryIndex >= 0) {\n    query = path.slice(queryIndex + 1);\n    path = path.slice(0, queryIndex);\n  }\n\n  return {\n    path: path,\n    query: query,\n    hash: hash\n  }\n}\n\nfunction cleanPath (path) {\n  return path.replace(/\\/(?:\\s*\\/)+/g, '/')\n}\n\nvar isarray = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n\n/**\n * Expose `pathToRegexp`.\n */\nvar pathToRegexp_1 = pathToRegexp;\nvar parse_1 = parse;\nvar compile_1 = compile;\nvar tokensToFunction_1 = tokensToFunction;\nvar tokensToRegExp_1 = tokensToRegExp;\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n  // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n  // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n  '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?|(\\\\*))'\n].join('|'), 'g');\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {string}  str\n * @param  {Object=} options\n * @return {!Array}\n */\nfunction parse (str, options) {\n  var tokens = [];\n  var key = 0;\n  var index = 0;\n  var path = '';\n  var defaultDelimiter = options && options.delimiter || '/';\n  var res;\n\n  while ((res = PATH_REGEXP.exec(str)) != null) {\n    var m = res[0];\n    var escaped = res[1];\n    var offset = res.index;\n    path += str.slice(index, offset);\n    index = offset + m.length;\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1];\n      continue\n    }\n\n    var next = str[index];\n    var prefix = res[2];\n    var name = res[3];\n    var capture = res[4];\n    var group = res[5];\n    var modifier = res[6];\n    var asterisk = res[7];\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path);\n      path = '';\n    }\n\n    var partial = prefix != null && next != null && next !== prefix;\n    var repeat = modifier === '+' || modifier === '*';\n    var optional = modifier === '?' || modifier === '*';\n    var delimiter = res[2] || defaultDelimiter;\n    var pattern = capture || group;\n\n    tokens.push({\n      name: name || key++,\n      prefix: prefix || '',\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      partial: partial,\n      asterisk: !!asterisk,\n      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')\n    });\n  }\n\n  // Match any characters still remaining.\n  if (index < str.length) {\n    path += str.substr(index);\n  }\n\n  // If the path exists, push it onto the end.\n  if (path) {\n    tokens.push(path);\n  }\n\n  return tokens\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {string}             str\n * @param  {Object=}            options\n * @return {!function(Object=, Object=)}\n */\nfunction compile (str, options) {\n  return tokensToFunction(parse(str, options), options)\n}\n\n/**\n * Prettier encoding of URI path segments.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeURIComponentPretty (str) {\n  return encodeURI(str).replace(/[\\/?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeAsterisk (str) {\n  return encodeURI(str).replace(/[?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens, options) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length);\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$', flags(options));\n    }\n  }\n\n  return function (obj, opts) {\n    var path = '';\n    var data = obj || {};\n    var options = opts || {};\n    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i];\n\n      if (typeof token === 'string') {\n        path += token;\n\n        continue\n      }\n\n      var value = data[token.name];\n      var segment;\n\n      if (value == null) {\n        if (token.optional) {\n          // Prepend partial segment prefixes.\n          if (token.partial) {\n            path += token.prefix;\n          }\n\n          continue\n        } else {\n          throw new TypeError('Expected \"' + token.name + '\" to be defined')\n        }\n      }\n\n      if (isarray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received `' + JSON.stringify(value) + '`')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) {\n            continue\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n          }\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encode(value[j]);\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received `' + JSON.stringify(segment) + '`')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment;\n        }\n\n        continue\n      }\n\n      segment = token.asterisk ? encodeAsterisk(value) : encode(value);\n\n      if (!matches[i].test(segment)) {\n        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n      }\n\n      path += token.prefix + segment;\n    }\n\n    return path\n  }\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {string} str\n * @return {string}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|\\/\\\\])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {string} group\n * @return {string}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1')\n}\n\n/**\n * Attach the keys as a property of the regexp.\n *\n * @param  {!RegExp} re\n * @param  {Array}   keys\n * @return {!RegExp}\n */\nfunction attachKeys (re, keys) {\n  re.keys = keys;\n  return re\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {string}\n */\nfunction flags (options) {\n  return options && options.sensitive ? '' : 'i'\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {!RegExp} path\n * @param  {!Array}  keys\n * @return {!RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g);\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        partial: false,\n        asterisk: false,\n        pattern: null\n      });\n    }\n  }\n\n  return attachKeys(path, keys)\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {!Array}  path\n * @param  {Array}   keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = [];\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source);\n  }\n\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));\n\n  return attachKeys(regexp, keys)\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {string}  path\n * @param  {!Array}  keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction stringToRegexp (path, keys, options) {\n  return tokensToRegExp(parse(path, options), keys, options)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {!Array}          tokens\n * @param  {(Array|Object)=} keys\n * @param  {Object=}         options\n * @return {!RegExp}\n */\nfunction tokensToRegExp (tokens, keys, options) {\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */ (keys || options);\n    keys = [];\n  }\n\n  options = options || {};\n\n  var strict = options.strict;\n  var end = options.end !== false;\n  var route = '';\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i];\n\n    if (typeof token === 'string') {\n      route += escapeString(token);\n    } else {\n      var prefix = escapeString(token.prefix);\n      var capture = '(?:' + token.pattern + ')';\n\n      keys.push(token);\n\n      if (token.repeat) {\n        capture += '(?:' + prefix + capture + ')*';\n      }\n\n      if (token.optional) {\n        if (!token.partial) {\n          capture = '(?:' + prefix + '(' + capture + '))?';\n        } else {\n          capture = prefix + '(' + capture + ')?';\n        }\n      } else {\n        capture = prefix + '(' + capture + ')';\n      }\n\n      route += capture;\n    }\n  }\n\n  var delimiter = escapeString(options.delimiter || '/');\n  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;\n\n  // In non-strict mode we allow a slash at the end of match. If the path to\n  // match already ends with a slash, we remove it for consistency. The slash\n  // is valid at the end of a path match, not in the middle. This is important\n  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n  if (!strict) {\n    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';\n  }\n\n  if (end) {\n    route += '$';\n  } else {\n    // In non-ending mode, we need the capturing groups to match as much as\n    // possible by using a positive lookahead to the end or next path segment.\n    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';\n  }\n\n  return attachKeys(new RegExp('^' + route, flags(options)), keys)\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(string|RegExp|Array)} path\n * @param  {(Array|Object)=}       keys\n * @param  {Object=}               options\n * @return {!RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */ (keys || options);\n    keys = [];\n  }\n\n  options = options || {};\n\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, /** @type {!Array} */ (keys))\n  }\n\n  if (isarray(path)) {\n    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)\n  }\n\n  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)\n}\npathToRegexp_1.parse = parse_1;\npathToRegexp_1.compile = compile_1;\npathToRegexp_1.tokensToFunction = tokensToFunction_1;\npathToRegexp_1.tokensToRegExp = tokensToRegExp_1;\n\n/*  */\n\n// $flow-disable-line\nvar regexpCompileCache = Object.create(null);\n\nfunction fillParams (\n  path,\n  params,\n  routeMsg\n) {\n  params = params || {};\n  try {\n    var filler =\n      regexpCompileCache[path] ||\n      (regexpCompileCache[path] = pathToRegexp_1.compile(path));\n\n    // Fix #2505 resolving asterisk routes { name: 'not-found', params: { pathMatch: '/not-found' }}\n    // and fix #3106 so that you can work with location descriptor object having params.pathMatch equal to empty string\n    if (typeof params.pathMatch === 'string') { params[0] = params.pathMatch; }\n\n    return filler(params, { pretty: true })\n  } catch (e) {\n    if (true) {\n      // Fix #3072 no warn if `pathMatch` is string\n      warn(typeof params.pathMatch === 'string', (\"missing param for \" + routeMsg + \": \" + (e.message)));\n    }\n    return ''\n  } finally {\n    // delete the 0 if it was added\n    delete params[0];\n  }\n}\n\n/*  */\n\nfunction normalizeLocation (\n  raw,\n  current,\n  append,\n  router\n) {\n  var next = typeof raw === 'string' ? { path: raw } : raw;\n  // named target\n  if (next._normalized) {\n    return next\n  } else if (next.name) {\n    next = extend({}, raw);\n    var params = next.params;\n    if (params && typeof params === 'object') {\n      next.params = extend({}, params);\n    }\n    return next\n  }\n\n  // relative params\n  if (!next.path && next.params && current) {\n    next = extend({}, next);\n    next._normalized = true;\n    var params$1 = extend(extend({}, current.params), next.params);\n    if (current.name) {\n      next.name = current.name;\n      next.params = params$1;\n    } else if (current.matched.length) {\n      var rawPath = current.matched[current.matched.length - 1].path;\n      next.path = fillParams(rawPath, params$1, (\"path \" + (current.path)));\n    } else if (true) {\n      warn(false, \"relative params navigation requires a current route.\");\n    }\n    return next\n  }\n\n  var parsedPath = parsePath(next.path || '');\n  var basePath = (current && current.path) || '/';\n  var path = parsedPath.path\n    ? resolvePath(parsedPath.path, basePath, append || next.append)\n    : basePath;\n\n  var query = resolveQuery(\n    parsedPath.query,\n    next.query,\n    router && router.options.parseQuery\n  );\n\n  var hash = next.hash || parsedPath.hash;\n  if (hash && hash.charAt(0) !== '#') {\n    hash = \"#\" + hash;\n  }\n\n  return {\n    _normalized: true,\n    path: path,\n    query: query,\n    hash: hash\n  }\n}\n\n/*  */\n\n// work around weird flow bug\nvar toTypes = [String, Object];\nvar eventTypes = [String, Array];\n\nvar noop = function () {};\n\nvar warnedCustomSlot;\nvar warnedTagProp;\nvar warnedEventProp;\n\nvar Link = {\n  name: 'RouterLink',\n  props: {\n    to: {\n      type: toTypes,\n      required: true\n    },\n    tag: {\n      type: String,\n      default: 'a'\n    },\n    custom: Boolean,\n    exact: Boolean,\n    exactPath: Boolean,\n    append: Boolean,\n    replace: Boolean,\n    activeClass: String,\n    exactActiveClass: String,\n    ariaCurrentValue: {\n      type: String,\n      default: 'page'\n    },\n    event: {\n      type: eventTypes,\n      default: 'click'\n    }\n  },\n  render: function render (h) {\n    var this$1 = this;\n\n    var router = this.$router;\n    var current = this.$route;\n    var ref = router.resolve(\n      this.to,\n      current,\n      this.append\n    );\n    var location = ref.location;\n    var route = ref.route;\n    var href = ref.href;\n\n    var classes = {};\n    var globalActiveClass = router.options.linkActiveClass;\n    var globalExactActiveClass = router.options.linkExactActiveClass;\n    // Support global empty active class\n    var activeClassFallback =\n      globalActiveClass == null ? 'router-link-active' : globalActiveClass;\n    var exactActiveClassFallback =\n      globalExactActiveClass == null\n        ? 'router-link-exact-active'\n        : globalExactActiveClass;\n    var activeClass =\n      this.activeClass == null ? activeClassFallback : this.activeClass;\n    var exactActiveClass =\n      this.exactActiveClass == null\n        ? exactActiveClassFallback\n        : this.exactActiveClass;\n\n    var compareTarget = route.redirectedFrom\n      ? createRoute(null, normalizeLocation(route.redirectedFrom), null, router)\n      : route;\n\n    classes[exactActiveClass] = isSameRoute(current, compareTarget, this.exactPath);\n    classes[activeClass] = this.exact || this.exactPath\n      ? classes[exactActiveClass]\n      : isIncludedRoute(current, compareTarget);\n\n    var ariaCurrentValue = classes[exactActiveClass] ? this.ariaCurrentValue : null;\n\n    var handler = function (e) {\n      if (guardEvent(e)) {\n        if (this$1.replace) {\n          router.replace(location, noop);\n        } else {\n          router.push(location, noop);\n        }\n      }\n    };\n\n    var on = { click: guardEvent };\n    if (Array.isArray(this.event)) {\n      this.event.forEach(function (e) {\n        on[e] = handler;\n      });\n    } else {\n      on[this.event] = handler;\n    }\n\n    var data = { class: classes };\n\n    var scopedSlot =\n      !this.$scopedSlots.$hasNormal &&\n      this.$scopedSlots.default &&\n      this.$scopedSlots.default({\n        href: href,\n        route: route,\n        navigate: handler,\n        isActive: classes[activeClass],\n        isExactActive: classes[exactActiveClass]\n      });\n\n    if (scopedSlot) {\n      if ( true && !this.custom) {\n        !warnedCustomSlot && warn(false, 'In Vue Router 4, the v-slot API will by default wrap its content with an <a> element. Use the custom prop to remove this warning:\\n<router-link v-slot=\"{ navigate, href }\" custom></router-link>\\n');\n        warnedCustomSlot = true;\n      }\n      if (scopedSlot.length === 1) {\n        return scopedSlot[0]\n      } else if (scopedSlot.length > 1 || !scopedSlot.length) {\n        if (true) {\n          warn(\n            false,\n            (\"<router-link> with to=\\\"\" + (this.to) + \"\\\" is trying to use a scoped slot but it didn't provide exactly one child. Wrapping the content with a span element.\")\n          );\n        }\n        return scopedSlot.length === 0 ? h() : h('span', {}, scopedSlot)\n      }\n    }\n\n    if (true) {\n      if ('tag' in this.$options.propsData && !warnedTagProp) {\n        warn(\n          false,\n          \"<router-link>'s tag prop is deprecated and has been removed in Vue Router 4. Use the v-slot API to remove this warning: https://next.router.vuejs.org/guide/migration/#removal-of-event-and-tag-props-in-router-link.\"\n        );\n        warnedTagProp = true;\n      }\n      if ('event' in this.$options.propsData && !warnedEventProp) {\n        warn(\n          false,\n          \"<router-link>'s event prop is deprecated and has been removed in Vue Router 4. Use the v-slot API to remove this warning: https://next.router.vuejs.org/guide/migration/#removal-of-event-and-tag-props-in-router-link.\"\n        );\n        warnedEventProp = true;\n      }\n    }\n\n    if (this.tag === 'a') {\n      data.on = on;\n      data.attrs = { href: href, 'aria-current': ariaCurrentValue };\n    } else {\n      // find the first <a> child and apply listener and href\n      var a = findAnchor(this.$slots.default);\n      if (a) {\n        // in case the <a> is a static node\n        a.isStatic = false;\n        var aData = (a.data = extend({}, a.data));\n        aData.on = aData.on || {};\n        // transform existing events in both objects into arrays so we can push later\n        for (var event in aData.on) {\n          var handler$1 = aData.on[event];\n          if (event in on) {\n            aData.on[event] = Array.isArray(handler$1) ? handler$1 : [handler$1];\n          }\n        }\n        // append new listeners for router-link\n        for (var event$1 in on) {\n          if (event$1 in aData.on) {\n            // on[event] is always a function\n            aData.on[event$1].push(on[event$1]);\n          } else {\n            aData.on[event$1] = handler;\n          }\n        }\n\n        var aAttrs = (a.data.attrs = extend({}, a.data.attrs));\n        aAttrs.href = href;\n        aAttrs['aria-current'] = ariaCurrentValue;\n      } else {\n        // doesn't have <a> child, apply listener to self\n        data.on = on;\n      }\n    }\n\n    return h(this.tag, data, this.$slots.default)\n  }\n};\n\nfunction guardEvent (e) {\n  // don't redirect with control keys\n  if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) { return }\n  // don't redirect when preventDefault called\n  if (e.defaultPrevented) { return }\n  // don't redirect on right click\n  if (e.button !== undefined && e.button !== 0) { return }\n  // don't redirect if `target=\"_blank\"`\n  if (e.currentTarget && e.currentTarget.getAttribute) {\n    var target = e.currentTarget.getAttribute('target');\n    if (/\\b_blank\\b/i.test(target)) { return }\n  }\n  // this may be a Weex event which doesn't have this method\n  if (e.preventDefault) {\n    e.preventDefault();\n  }\n  return true\n}\n\nfunction findAnchor (children) {\n  if (children) {\n    var child;\n    for (var i = 0; i < children.length; i++) {\n      child = children[i];\n      if (child.tag === 'a') {\n        return child\n      }\n      if (child.children && (child = findAnchor(child.children))) {\n        return child\n      }\n    }\n  }\n}\n\nvar _Vue;\n\nfunction install (Vue) {\n  if (install.installed && _Vue === Vue) { return }\n  install.installed = true;\n\n  _Vue = Vue;\n\n  var isDef = function (v) { return v !== undefined; };\n\n  var registerInstance = function (vm, callVal) {\n    var i = vm.$options._parentVnode;\n    if (isDef(i) && isDef(i = i.data) && isDef(i = i.registerRouteInstance)) {\n      i(vm, callVal);\n    }\n  };\n\n  Vue.mixin({\n    beforeCreate: function beforeCreate () {\n      if (isDef(this.$options.router)) {\n        this._routerRoot = this;\n        this._router = this.$options.router;\n        this._router.init(this);\n        Vue.util.defineReactive(this, '_route', this._router.history.current);\n      } else {\n        this._routerRoot = (this.$parent && this.$parent._routerRoot) || this;\n      }\n      registerInstance(this, this);\n    },\n    destroyed: function destroyed () {\n      registerInstance(this);\n    }\n  });\n\n  Object.defineProperty(Vue.prototype, '$router', {\n    get: function get () { return this._routerRoot._router }\n  });\n\n  Object.defineProperty(Vue.prototype, '$route', {\n    get: function get () { return this._routerRoot._route }\n  });\n\n  Vue.component('RouterView', View);\n  Vue.component('RouterLink', Link);\n\n  var strats = Vue.config.optionMergeStrategies;\n  // use the same hook merging strategy for route hooks\n  strats.beforeRouteEnter = strats.beforeRouteLeave = strats.beforeRouteUpdate = strats.created;\n}\n\n/*  */\n\nvar inBrowser = typeof window !== 'undefined';\n\n/*  */\n\nfunction createRouteMap (\n  routes,\n  oldPathList,\n  oldPathMap,\n  oldNameMap,\n  parentRoute\n) {\n  // the path list is used to control path matching priority\n  var pathList = oldPathList || [];\n  // $flow-disable-line\n  var pathMap = oldPathMap || Object.create(null);\n  // $flow-disable-line\n  var nameMap = oldNameMap || Object.create(null);\n\n  routes.forEach(function (route) {\n    addRouteRecord(pathList, pathMap, nameMap, route, parentRoute);\n  });\n\n  // ensure wildcard routes are always at the end\n  for (var i = 0, l = pathList.length; i < l; i++) {\n    if (pathList[i] === '*') {\n      pathList.push(pathList.splice(i, 1)[0]);\n      l--;\n      i--;\n    }\n  }\n\n  if (true) {\n    // warn if routes do not include leading slashes\n    var found = pathList\n    // check for missing leading slash\n      .filter(function (path) { return path && path.charAt(0) !== '*' && path.charAt(0) !== '/'; });\n\n    if (found.length > 0) {\n      var pathNames = found.map(function (path) { return (\"- \" + path); }).join('\\n');\n      warn(false, (\"Non-nested routes must include a leading slash character. Fix the following routes: \\n\" + pathNames));\n    }\n  }\n\n  return {\n    pathList: pathList,\n    pathMap: pathMap,\n    nameMap: nameMap\n  }\n}\n\nfunction addRouteRecord (\n  pathList,\n  pathMap,\n  nameMap,\n  route,\n  parent,\n  matchAs\n) {\n  var path = route.path;\n  var name = route.name;\n  if (true) {\n    assert(path != null, \"\\\"path\\\" is required in a route configuration.\");\n    assert(\n      typeof route.component !== 'string',\n      \"route config \\\"component\\\" for path: \" + (String(\n        path || name\n      )) + \" cannot be a \" + \"string id. Use an actual component instead.\"\n    );\n\n    warn(\n      // eslint-disable-next-line no-control-regex\n      !/[^\\u0000-\\u007F]+/.test(path),\n      \"Route with path \\\"\" + path + \"\\\" contains unencoded characters, make sure \" +\n        \"your path is correctly encoded before passing it to the router. Use \" +\n        \"encodeURI to encode static segments of your path.\"\n    );\n  }\n\n  var pathToRegexpOptions =\n    route.pathToRegexpOptions || {};\n  var normalizedPath = normalizePath(path, parent, pathToRegexpOptions.strict);\n\n  if (typeof route.caseSensitive === 'boolean') {\n    pathToRegexpOptions.sensitive = route.caseSensitive;\n  }\n\n  var record = {\n    path: normalizedPath,\n    regex: compileRouteRegex(normalizedPath, pathToRegexpOptions),\n    components: route.components || { default: route.component },\n    alias: route.alias\n      ? typeof route.alias === 'string'\n        ? [route.alias]\n        : route.alias\n      : [],\n    instances: {},\n    enteredCbs: {},\n    name: name,\n    parent: parent,\n    matchAs: matchAs,\n    redirect: route.redirect,\n    beforeEnter: route.beforeEnter,\n    meta: route.meta || {},\n    props:\n      route.props == null\n        ? {}\n        : route.components\n          ? route.props\n          : { default: route.props }\n  };\n\n  if (route.children) {\n    // Warn if route is named, does not redirect and has a default child route.\n    // If users navigate to this route by name, the default child will\n    // not be rendered (GH Issue #629)\n    if (true) {\n      if (\n        route.name &&\n        !route.redirect &&\n        route.children.some(function (child) { return /^\\/?$/.test(child.path); })\n      ) {\n        warn(\n          false,\n          \"Named Route '\" + (route.name) + \"' has a default child route. \" +\n            \"When navigating to this named route (:to=\\\"{name: '\" + (route.name) + \"'}\\\"), \" +\n            \"the default child route will not be rendered. Remove the name from \" +\n            \"this route and use the name of the default child route for named \" +\n            \"links instead.\"\n        );\n      }\n    }\n    route.children.forEach(function (child) {\n      var childMatchAs = matchAs\n        ? cleanPath((matchAs + \"/\" + (child.path)))\n        : undefined;\n      addRouteRecord(pathList, pathMap, nameMap, child, record, childMatchAs);\n    });\n  }\n\n  if (!pathMap[record.path]) {\n    pathList.push(record.path);\n    pathMap[record.path] = record;\n  }\n\n  if (route.alias !== undefined) {\n    var aliases = Array.isArray(route.alias) ? route.alias : [route.alias];\n    for (var i = 0; i < aliases.length; ++i) {\n      var alias = aliases[i];\n      if ( true && alias === path) {\n        warn(\n          false,\n          (\"Found an alias with the same value as the path: \\\"\" + path + \"\\\". You have to remove that alias. It will be ignored in development.\")\n        );\n        // skip in dev to make it work\n        continue\n      }\n\n      var aliasRoute = {\n        path: alias,\n        children: route.children\n      };\n      addRouteRecord(\n        pathList,\n        pathMap,\n        nameMap,\n        aliasRoute,\n        parent,\n        record.path || '/' // matchAs\n      );\n    }\n  }\n\n  if (name) {\n    if (!nameMap[name]) {\n      nameMap[name] = record;\n    } else if ( true && !matchAs) {\n      warn(\n        false,\n        \"Duplicate named routes definition: \" +\n          \"{ name: \\\"\" + name + \"\\\", path: \\\"\" + (record.path) + \"\\\" }\"\n      );\n    }\n  }\n}\n\nfunction compileRouteRegex (\n  path,\n  pathToRegexpOptions\n) {\n  var regex = pathToRegexp_1(path, [], pathToRegexpOptions);\n  if (true) {\n    var keys = Object.create(null);\n    regex.keys.forEach(function (key) {\n      warn(\n        !keys[key.name],\n        (\"Duplicate param keys in route with path: \\\"\" + path + \"\\\"\")\n      );\n      keys[key.name] = true;\n    });\n  }\n  return regex\n}\n\nfunction normalizePath (\n  path,\n  parent,\n  strict\n) {\n  if (!strict) { path = path.replace(/\\/$/, ''); }\n  if (path[0] === '/') { return path }\n  if (parent == null) { return path }\n  return cleanPath(((parent.path) + \"/\" + path))\n}\n\n/*  */\n\n\n\nfunction createMatcher (\n  routes,\n  router\n) {\n  var ref = createRouteMap(routes);\n  var pathList = ref.pathList;\n  var pathMap = ref.pathMap;\n  var nameMap = ref.nameMap;\n\n  function addRoutes (routes) {\n    createRouteMap(routes, pathList, pathMap, nameMap);\n  }\n\n  function addRoute (parentOrRoute, route) {\n    var parent = (typeof parentOrRoute !== 'object') ? nameMap[parentOrRoute] : undefined;\n    // $flow-disable-line\n    createRouteMap([route || parentOrRoute], pathList, pathMap, nameMap, parent);\n\n    // add aliases of parent\n    if (parent && parent.alias.length) {\n      createRouteMap(\n        // $flow-disable-line route is defined if parent is\n        parent.alias.map(function (alias) { return ({ path: alias, children: [route] }); }),\n        pathList,\n        pathMap,\n        nameMap,\n        parent\n      );\n    }\n  }\n\n  function getRoutes () {\n    return pathList.map(function (path) { return pathMap[path]; })\n  }\n\n  function match (\n    raw,\n    currentRoute,\n    redirectedFrom\n  ) {\n    var location = normalizeLocation(raw, currentRoute, false, router);\n    var name = location.name;\n\n    if (name) {\n      var record = nameMap[name];\n      if (true) {\n        warn(record, (\"Route with name '\" + name + \"' does not exist\"));\n      }\n      if (!record) { return _createRoute(null, location) }\n      var paramNames = record.regex.keys\n        .filter(function (key) { return !key.optional; })\n        .map(function (key) { return key.name; });\n\n      if (typeof location.params !== 'object') {\n        location.params = {};\n      }\n\n      if (currentRoute && typeof currentRoute.params === 'object') {\n        for (var key in currentRoute.params) {\n          if (!(key in location.params) && paramNames.indexOf(key) > -1) {\n            location.params[key] = currentRoute.params[key];\n          }\n        }\n      }\n\n      location.path = fillParams(record.path, location.params, (\"named route \\\"\" + name + \"\\\"\"));\n      return _createRoute(record, location, redirectedFrom)\n    } else if (location.path) {\n      location.params = {};\n      for (var i = 0; i < pathList.length; i++) {\n        var path = pathList[i];\n        var record$1 = pathMap[path];\n        if (matchRoute(record$1.regex, location.path, location.params)) {\n          return _createRoute(record$1, location, redirectedFrom)\n        }\n      }\n    }\n    // no match\n    return _createRoute(null, location)\n  }\n\n  function redirect (\n    record,\n    location\n  ) {\n    var originalRedirect = record.redirect;\n    var redirect = typeof originalRedirect === 'function'\n      ? originalRedirect(createRoute(record, location, null, router))\n      : originalRedirect;\n\n    if (typeof redirect === 'string') {\n      redirect = { path: redirect };\n    }\n\n    if (!redirect || typeof redirect !== 'object') {\n      if (true) {\n        warn(\n          false, (\"invalid redirect option: \" + (JSON.stringify(redirect)))\n        );\n      }\n      return _createRoute(null, location)\n    }\n\n    var re = redirect;\n    var name = re.name;\n    var path = re.path;\n    var query = location.query;\n    var hash = location.hash;\n    var params = location.params;\n    query = re.hasOwnProperty('query') ? re.query : query;\n    hash = re.hasOwnProperty('hash') ? re.hash : hash;\n    params = re.hasOwnProperty('params') ? re.params : params;\n\n    if (name) {\n      // resolved named direct\n      var targetRecord = nameMap[name];\n      if (true) {\n        assert(targetRecord, (\"redirect failed: named route \\\"\" + name + \"\\\" not found.\"));\n      }\n      return match({\n        _normalized: true,\n        name: name,\n        query: query,\n        hash: hash,\n        params: params\n      }, undefined, location)\n    } else if (path) {\n      // 1. resolve relative redirect\n      var rawPath = resolveRecordPath(path, record);\n      // 2. resolve params\n      var resolvedPath = fillParams(rawPath, params, (\"redirect route with path \\\"\" + rawPath + \"\\\"\"));\n      // 3. rematch with existing query and hash\n      return match({\n        _normalized: true,\n        path: resolvedPath,\n        query: query,\n        hash: hash\n      }, undefined, location)\n    } else {\n      if (true) {\n        warn(false, (\"invalid redirect option: \" + (JSON.stringify(redirect))));\n      }\n      return _createRoute(null, location)\n    }\n  }\n\n  function alias (\n    record,\n    location,\n    matchAs\n  ) {\n    var aliasedPath = fillParams(matchAs, location.params, (\"aliased route with path \\\"\" + matchAs + \"\\\"\"));\n    var aliasedMatch = match({\n      _normalized: true,\n      path: aliasedPath\n    });\n    if (aliasedMatch) {\n      var matched = aliasedMatch.matched;\n      var aliasedRecord = matched[matched.length - 1];\n      location.params = aliasedMatch.params;\n      return _createRoute(aliasedRecord, location)\n    }\n    return _createRoute(null, location)\n  }\n\n  function _createRoute (\n    record,\n    location,\n    redirectedFrom\n  ) {\n    if (record && record.redirect) {\n      return redirect(record, redirectedFrom || location)\n    }\n    if (record && record.matchAs) {\n      return alias(record, location, record.matchAs)\n    }\n    return createRoute(record, location, redirectedFrom, router)\n  }\n\n  return {\n    match: match,\n    addRoute: addRoute,\n    getRoutes: getRoutes,\n    addRoutes: addRoutes\n  }\n}\n\nfunction matchRoute (\n  regex,\n  path,\n  params\n) {\n  var m = path.match(regex);\n\n  if (!m) {\n    return false\n  } else if (!params) {\n    return true\n  }\n\n  for (var i = 1, len = m.length; i < len; ++i) {\n    var key = regex.keys[i - 1];\n    if (key) {\n      // Fix #1994: using * with props: true generates a param named 0\n      params[key.name || 'pathMatch'] = typeof m[i] === 'string' ? decode(m[i]) : m[i];\n    }\n  }\n\n  return true\n}\n\nfunction resolveRecordPath (path, record) {\n  return resolvePath(path, record.parent ? record.parent.path : '/', true)\n}\n\n/*  */\n\n// use User Timing api (if present) for more accurate key precision\nvar Time =\n  inBrowser && window.performance && window.performance.now\n    ? window.performance\n    : Date;\n\nfunction genStateKey () {\n  return Time.now().toFixed(3)\n}\n\nvar _key = genStateKey();\n\nfunction getStateKey () {\n  return _key\n}\n\nfunction setStateKey (key) {\n  return (_key = key)\n}\n\n/*  */\n\nvar positionStore = Object.create(null);\n\nfunction setupScroll () {\n  // Prevent browser scroll behavior on History popstate\n  if ('scrollRestoration' in window.history) {\n    window.history.scrollRestoration = 'manual';\n  }\n  // Fix for #1585 for Firefox\n  // Fix for #2195 Add optional third attribute to workaround a bug in safari https://bugs.webkit.org/show_bug.cgi?id=182678\n  // Fix for #2774 Support for apps loaded from Windows file shares not mapped to network drives: replaced location.origin with\n  // window.location.protocol + '//' + window.location.host\n  // location.host contains the port and location.hostname doesn't\n  var protocolAndPath = window.location.protocol + '//' + window.location.host;\n  var absolutePath = window.location.href.replace(protocolAndPath, '');\n  // preserve existing history state as it could be overriden by the user\n  var stateCopy = extend({}, window.history.state);\n  stateCopy.key = getStateKey();\n  window.history.replaceState(stateCopy, '', absolutePath);\n  window.addEventListener('popstate', handlePopState);\n  return function () {\n    window.removeEventListener('popstate', handlePopState);\n  }\n}\n\nfunction handleScroll (\n  router,\n  to,\n  from,\n  isPop\n) {\n  if (!router.app) {\n    return\n  }\n\n  var behavior = router.options.scrollBehavior;\n  if (!behavior) {\n    return\n  }\n\n  if (true) {\n    assert(typeof behavior === 'function', \"scrollBehavior must be a function\");\n  }\n\n  // wait until re-render finishes before scrolling\n  router.app.$nextTick(function () {\n    var position = getScrollPosition();\n    var shouldScroll = behavior.call(\n      router,\n      to,\n      from,\n      isPop ? position : null\n    );\n\n    if (!shouldScroll) {\n      return\n    }\n\n    if (typeof shouldScroll.then === 'function') {\n      shouldScroll\n        .then(function (shouldScroll) {\n          scrollToPosition((shouldScroll), position);\n        })\n        .catch(function (err) {\n          if (true) {\n            assert(false, err.toString());\n          }\n        });\n    } else {\n      scrollToPosition(shouldScroll, position);\n    }\n  });\n}\n\nfunction saveScrollPosition () {\n  var key = getStateKey();\n  if (key) {\n    positionStore[key] = {\n      x: window.pageXOffset,\n      y: window.pageYOffset\n    };\n  }\n}\n\nfunction handlePopState (e) {\n  saveScrollPosition();\n  if (e.state && e.state.key) {\n    setStateKey(e.state.key);\n  }\n}\n\nfunction getScrollPosition () {\n  var key = getStateKey();\n  if (key) {\n    return positionStore[key]\n  }\n}\n\nfunction getElementPosition (el, offset) {\n  var docEl = document.documentElement;\n  var docRect = docEl.getBoundingClientRect();\n  var elRect = el.getBoundingClientRect();\n  return {\n    x: elRect.left - docRect.left - offset.x,\n    y: elRect.top - docRect.top - offset.y\n  }\n}\n\nfunction isValidPosition (obj) {\n  return isNumber(obj.x) || isNumber(obj.y)\n}\n\nfunction normalizePosition (obj) {\n  return {\n    x: isNumber(obj.x) ? obj.x : window.pageXOffset,\n    y: isNumber(obj.y) ? obj.y : window.pageYOffset\n  }\n}\n\nfunction normalizeOffset (obj) {\n  return {\n    x: isNumber(obj.x) ? obj.x : 0,\n    y: isNumber(obj.y) ? obj.y : 0\n  }\n}\n\nfunction isNumber (v) {\n  return typeof v === 'number'\n}\n\nvar hashStartsWithNumberRE = /^#\\d/;\n\nfunction scrollToPosition (shouldScroll, position) {\n  var isObject = typeof shouldScroll === 'object';\n  if (isObject && typeof shouldScroll.selector === 'string') {\n    // getElementById would still fail if the selector contains a more complicated query like #main[data-attr]\n    // but at the same time, it doesn't make much sense to select an element with an id and an extra selector\n    var el = hashStartsWithNumberRE.test(shouldScroll.selector) // $flow-disable-line\n      ? document.getElementById(shouldScroll.selector.slice(1)) // $flow-disable-line\n      : document.querySelector(shouldScroll.selector);\n\n    if (el) {\n      var offset =\n        shouldScroll.offset && typeof shouldScroll.offset === 'object'\n          ? shouldScroll.offset\n          : {};\n      offset = normalizeOffset(offset);\n      position = getElementPosition(el, offset);\n    } else if (isValidPosition(shouldScroll)) {\n      position = normalizePosition(shouldScroll);\n    }\n  } else if (isObject && isValidPosition(shouldScroll)) {\n    position = normalizePosition(shouldScroll);\n  }\n\n  if (position) {\n    // $flow-disable-line\n    if ('scrollBehavior' in document.documentElement.style) {\n      window.scrollTo({\n        left: position.x,\n        top: position.y,\n        // $flow-disable-line\n        behavior: shouldScroll.behavior\n      });\n    } else {\n      window.scrollTo(position.x, position.y);\n    }\n  }\n}\n\n/*  */\n\nvar supportsPushState =\n  inBrowser &&\n  (function () {\n    var ua = window.navigator.userAgent;\n\n    if (\n      (ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) &&\n      ua.indexOf('Mobile Safari') !== -1 &&\n      ua.indexOf('Chrome') === -1 &&\n      ua.indexOf('Windows Phone') === -1\n    ) {\n      return false\n    }\n\n    return window.history && typeof window.history.pushState === 'function'\n  })();\n\nfunction pushState (url, replace) {\n  saveScrollPosition();\n  // try...catch the pushState call to get around Safari\n  // DOM Exception 18 where it limits to 100 pushState calls\n  var history = window.history;\n  try {\n    if (replace) {\n      // preserve existing history state as it could be overriden by the user\n      var stateCopy = extend({}, history.state);\n      stateCopy.key = getStateKey();\n      history.replaceState(stateCopy, '', url);\n    } else {\n      history.pushState({ key: setStateKey(genStateKey()) }, '', url);\n    }\n  } catch (e) {\n    window.location[replace ? 'replace' : 'assign'](url);\n  }\n}\n\nfunction replaceState (url) {\n  pushState(url, true);\n}\n\n/*  */\n\nfunction runQueue (queue, fn, cb) {\n  var step = function (index) {\n    if (index >= queue.length) {\n      cb();\n    } else {\n      if (queue[index]) {\n        fn(queue[index], function () {\n          step(index + 1);\n        });\n      } else {\n        step(index + 1);\n      }\n    }\n  };\n  step(0);\n}\n\n// When changing thing, also edit router.d.ts\nvar NavigationFailureType = {\n  redirected: 2,\n  aborted: 4,\n  cancelled: 8,\n  duplicated: 16\n};\n\nfunction createNavigationRedirectedError (from, to) {\n  return createRouterError(\n    from,\n    to,\n    NavigationFailureType.redirected,\n    (\"Redirected when going from \\\"\" + (from.fullPath) + \"\\\" to \\\"\" + (stringifyRoute(\n      to\n    )) + \"\\\" via a navigation guard.\")\n  )\n}\n\nfunction createNavigationDuplicatedError (from, to) {\n  var error = createRouterError(\n    from,\n    to,\n    NavigationFailureType.duplicated,\n    (\"Avoided redundant navigation to current location: \\\"\" + (from.fullPath) + \"\\\".\")\n  );\n  // backwards compatible with the first introduction of Errors\n  error.name = 'NavigationDuplicated';\n  return error\n}\n\nfunction createNavigationCancelledError (from, to) {\n  return createRouterError(\n    from,\n    to,\n    NavigationFailureType.cancelled,\n    (\"Navigation cancelled from \\\"\" + (from.fullPath) + \"\\\" to \\\"\" + (to.fullPath) + \"\\\" with a new navigation.\")\n  )\n}\n\nfunction createNavigationAbortedError (from, to) {\n  return createRouterError(\n    from,\n    to,\n    NavigationFailureType.aborted,\n    (\"Navigation aborted from \\\"\" + (from.fullPath) + \"\\\" to \\\"\" + (to.fullPath) + \"\\\" via a navigation guard.\")\n  )\n}\n\nfunction createRouterError (from, to, type, message) {\n  var error = new Error(message);\n  error._isRouter = true;\n  error.from = from;\n  error.to = to;\n  error.type = type;\n\n  return error\n}\n\nvar propertiesToLog = ['params', 'query', 'hash'];\n\nfunction stringifyRoute (to) {\n  if (typeof to === 'string') { return to }\n  if ('path' in to) { return to.path }\n  var location = {};\n  propertiesToLog.forEach(function (key) {\n    if (key in to) { location[key] = to[key]; }\n  });\n  return JSON.stringify(location, null, 2)\n}\n\nfunction isError (err) {\n  return Object.prototype.toString.call(err).indexOf('Error') > -1\n}\n\nfunction isNavigationFailure (err, errorType) {\n  return (\n    isError(err) &&\n    err._isRouter &&\n    (errorType == null || err.type === errorType)\n  )\n}\n\n/*  */\n\nfunction resolveAsyncComponents (matched) {\n  return function (to, from, next) {\n    var hasAsync = false;\n    var pending = 0;\n    var error = null;\n\n    flatMapComponents(matched, function (def, _, match, key) {\n      // if it's a function and doesn't have cid attached,\n      // assume it's an async component resolve function.\n      // we are not using Vue's default async resolving mechanism because\n      // we want to halt the navigation until the incoming component has been\n      // resolved.\n      if (typeof def === 'function' && def.cid === undefined) {\n        hasAsync = true;\n        pending++;\n\n        var resolve = once(function (resolvedDef) {\n          if (isESModule(resolvedDef)) {\n            resolvedDef = resolvedDef.default;\n          }\n          // save resolved on async factory in case it's used elsewhere\n          def.resolved = typeof resolvedDef === 'function'\n            ? resolvedDef\n            : _Vue.extend(resolvedDef);\n          match.components[key] = resolvedDef;\n          pending--;\n          if (pending <= 0) {\n            next();\n          }\n        });\n\n        var reject = once(function (reason) {\n          var msg = \"Failed to resolve async component \" + key + \": \" + reason;\n           true && warn(false, msg);\n          if (!error) {\n            error = isError(reason)\n              ? reason\n              : new Error(msg);\n            next(error);\n          }\n        });\n\n        var res;\n        try {\n          res = def(resolve, reject);\n        } catch (e) {\n          reject(e);\n        }\n        if (res) {\n          if (typeof res.then === 'function') {\n            res.then(resolve, reject);\n          } else {\n            // new syntax in Vue 2.3\n            var comp = res.component;\n            if (comp && typeof comp.then === 'function') {\n              comp.then(resolve, reject);\n            }\n          }\n        }\n      }\n    });\n\n    if (!hasAsync) { next(); }\n  }\n}\n\nfunction flatMapComponents (\n  matched,\n  fn\n) {\n  return flatten(matched.map(function (m) {\n    return Object.keys(m.components).map(function (key) { return fn(\n      m.components[key],\n      m.instances[key],\n      m, key\n    ); })\n  }))\n}\n\nfunction flatten (arr) {\n  return Array.prototype.concat.apply([], arr)\n}\n\nvar hasSymbol =\n  typeof Symbol === 'function' &&\n  typeof Symbol.toStringTag === 'symbol';\n\nfunction isESModule (obj) {\n  return obj.__esModule || (hasSymbol && obj[Symbol.toStringTag] === 'Module')\n}\n\n// in Webpack 2, require.ensure now also returns a Promise\n// so the resolve/reject functions may get called an extra time\n// if the user uses an arrow function shorthand that happens to\n// return that Promise.\nfunction once (fn) {\n  var called = false;\n  return function () {\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n\n    if (called) { return }\n    called = true;\n    return fn.apply(this, args)\n  }\n}\n\n/*  */\n\nvar History = function History (router, base) {\n  this.router = router;\n  this.base = normalizeBase(base);\n  // start with a route object that stands for \"nowhere\"\n  this.current = START;\n  this.pending = null;\n  this.ready = false;\n  this.readyCbs = [];\n  this.readyErrorCbs = [];\n  this.errorCbs = [];\n  this.listeners = [];\n};\n\nHistory.prototype.listen = function listen (cb) {\n  this.cb = cb;\n};\n\nHistory.prototype.onReady = function onReady (cb, errorCb) {\n  if (this.ready) {\n    cb();\n  } else {\n    this.readyCbs.push(cb);\n    if (errorCb) {\n      this.readyErrorCbs.push(errorCb);\n    }\n  }\n};\n\nHistory.prototype.onError = function onError (errorCb) {\n  this.errorCbs.push(errorCb);\n};\n\nHistory.prototype.transitionTo = function transitionTo (\n  location,\n  onComplete,\n  onAbort\n) {\n    var this$1 = this;\n\n  var route;\n  // catch redirect option https://github.com/vuejs/vue-router/issues/3201\n  try {\n    route = this.router.match(location, this.current);\n  } catch (e) {\n    this.errorCbs.forEach(function (cb) {\n      cb(e);\n    });\n    // Exception should still be thrown\n    throw e\n  }\n  var prev = this.current;\n  this.confirmTransition(\n    route,\n    function () {\n      this$1.updateRoute(route);\n      onComplete && onComplete(route);\n      this$1.ensureURL();\n      this$1.router.afterHooks.forEach(function (hook) {\n        hook && hook(route, prev);\n      });\n\n      // fire ready cbs once\n      if (!this$1.ready) {\n        this$1.ready = true;\n        this$1.readyCbs.forEach(function (cb) {\n          cb(route);\n        });\n      }\n    },\n    function (err) {\n      if (onAbort) {\n        onAbort(err);\n      }\n      if (err && !this$1.ready) {\n        // Initial redirection should not mark the history as ready yet\n        // because it's triggered by the redirection instead\n        // https://github.com/vuejs/vue-router/issues/3225\n        // https://github.com/vuejs/vue-router/issues/3331\n        if (!isNavigationFailure(err, NavigationFailureType.redirected) || prev !== START) {\n          this$1.ready = true;\n          this$1.readyErrorCbs.forEach(function (cb) {\n            cb(err);\n          });\n        }\n      }\n    }\n  );\n};\n\nHistory.prototype.confirmTransition = function confirmTransition (route, onComplete, onAbort) {\n    var this$1 = this;\n\n  var current = this.current;\n  this.pending = route;\n  var abort = function (err) {\n    // changed after adding errors with\n    // https://github.com/vuejs/vue-router/pull/3047 before that change,\n    // redirect and aborted navigation would produce an err == null\n    if (!isNavigationFailure(err) && isError(err)) {\n      if (this$1.errorCbs.length) {\n        this$1.errorCbs.forEach(function (cb) {\n          cb(err);\n        });\n      } else {\n        if (true) {\n          warn(false, 'uncaught error during route navigation:');\n        }\n        console.error(err);\n      }\n    }\n    onAbort && onAbort(err);\n  };\n  var lastRouteIndex = route.matched.length - 1;\n  var lastCurrentIndex = current.matched.length - 1;\n  if (\n    isSameRoute(route, current) &&\n    // in the case the route map has been dynamically appended to\n    lastRouteIndex === lastCurrentIndex &&\n    route.matched[lastRouteIndex] === current.matched[lastCurrentIndex]\n  ) {\n    this.ensureURL();\n    if (route.hash) {\n      handleScroll(this.router, current, route, false);\n    }\n    return abort(createNavigationDuplicatedError(current, route))\n  }\n\n  var ref = resolveQueue(\n    this.current.matched,\n    route.matched\n  );\n    var updated = ref.updated;\n    var deactivated = ref.deactivated;\n    var activated = ref.activated;\n\n  var queue = [].concat(\n    // in-component leave guards\n    extractLeaveGuards(deactivated),\n    // global before hooks\n    this.router.beforeHooks,\n    // in-component update hooks\n    extractUpdateHooks(updated),\n    // in-config enter guards\n    activated.map(function (m) { return m.beforeEnter; }),\n    // async components\n    resolveAsyncComponents(activated)\n  );\n\n  var iterator = function (hook, next) {\n    if (this$1.pending !== route) {\n      return abort(createNavigationCancelledError(current, route))\n    }\n    try {\n      hook(route, current, function (to) {\n        if (to === false) {\n          // next(false) -> abort navigation, ensure current URL\n          this$1.ensureURL(true);\n          abort(createNavigationAbortedError(current, route));\n        } else if (isError(to)) {\n          this$1.ensureURL(true);\n          abort(to);\n        } else if (\n          typeof to === 'string' ||\n          (typeof to === 'object' &&\n            (typeof to.path === 'string' || typeof to.name === 'string'))\n        ) {\n          // next('/') or next({ path: '/' }) -> redirect\n          abort(createNavigationRedirectedError(current, route));\n          if (typeof to === 'object' && to.replace) {\n            this$1.replace(to);\n          } else {\n            this$1.push(to);\n          }\n        } else {\n          // confirm transition and pass on the value\n          next(to);\n        }\n      });\n    } catch (e) {\n      abort(e);\n    }\n  };\n\n  runQueue(queue, iterator, function () {\n    // wait until async components are resolved before\n    // extracting in-component enter guards\n    var enterGuards = extractEnterGuards(activated);\n    var queue = enterGuards.concat(this$1.router.resolveHooks);\n    runQueue(queue, iterator, function () {\n      if (this$1.pending !== route) {\n        return abort(createNavigationCancelledError(current, route))\n      }\n      this$1.pending = null;\n      onComplete(route);\n      if (this$1.router.app) {\n        this$1.router.app.$nextTick(function () {\n          handleRouteEntered(route);\n        });\n      }\n    });\n  });\n};\n\nHistory.prototype.updateRoute = function updateRoute (route) {\n  this.current = route;\n  this.cb && this.cb(route);\n};\n\nHistory.prototype.setupListeners = function setupListeners () {\n  // Default implementation is empty\n};\n\nHistory.prototype.teardown = function teardown () {\n  // clean up event listeners\n  // https://github.com/vuejs/vue-router/issues/2341\n  this.listeners.forEach(function (cleanupListener) {\n    cleanupListener();\n  });\n  this.listeners = [];\n\n  // reset current history route\n  // https://github.com/vuejs/vue-router/issues/3294\n  this.current = START;\n  this.pending = null;\n};\n\nfunction normalizeBase (base) {\n  if (!base) {\n    if (inBrowser) {\n      // respect <base> tag\n      var baseEl = document.querySelector('base');\n      base = (baseEl && baseEl.getAttribute('href')) || '/';\n      // strip full URL origin\n      base = base.replace(/^https?:\\/\\/[^\\/]+/, '');\n    } else {\n      base = '/';\n    }\n  }\n  // make sure there's the starting slash\n  if (base.charAt(0) !== '/') {\n    base = '/' + base;\n  }\n  // remove trailing slash\n  return base.replace(/\\/$/, '')\n}\n\nfunction resolveQueue (\n  current,\n  next\n) {\n  var i;\n  var max = Math.max(current.length, next.length);\n  for (i = 0; i < max; i++) {\n    if (current[i] !== next[i]) {\n      break\n    }\n  }\n  return {\n    updated: next.slice(0, i),\n    activated: next.slice(i),\n    deactivated: current.slice(i)\n  }\n}\n\nfunction extractGuards (\n  records,\n  name,\n  bind,\n  reverse\n) {\n  var guards = flatMapComponents(records, function (def, instance, match, key) {\n    var guard = extractGuard(def, name);\n    if (guard) {\n      return Array.isArray(guard)\n        ? guard.map(function (guard) { return bind(guard, instance, match, key); })\n        : bind(guard, instance, match, key)\n    }\n  });\n  return flatten(reverse ? guards.reverse() : guards)\n}\n\nfunction extractGuard (\n  def,\n  key\n) {\n  if (typeof def !== 'function') {\n    // extend now so that global mixins are applied.\n    def = _Vue.extend(def);\n  }\n  return def.options[key]\n}\n\nfunction extractLeaveGuards (deactivated) {\n  return extractGuards(deactivated, 'beforeRouteLeave', bindGuard, true)\n}\n\nfunction extractUpdateHooks (updated) {\n  return extractGuards(updated, 'beforeRouteUpdate', bindGuard)\n}\n\nfunction bindGuard (guard, instance) {\n  if (instance) {\n    return function boundRouteGuard () {\n      return guard.apply(instance, arguments)\n    }\n  }\n}\n\nfunction extractEnterGuards (\n  activated\n) {\n  return extractGuards(\n    activated,\n    'beforeRouteEnter',\n    function (guard, _, match, key) {\n      return bindEnterGuard(guard, match, key)\n    }\n  )\n}\n\nfunction bindEnterGuard (\n  guard,\n  match,\n  key\n) {\n  return function routeEnterGuard (to, from, next) {\n    return guard(to, from, function (cb) {\n      if (typeof cb === 'function') {\n        if (!match.enteredCbs[key]) {\n          match.enteredCbs[key] = [];\n        }\n        match.enteredCbs[key].push(cb);\n      }\n      next(cb);\n    })\n  }\n}\n\n/*  */\n\nvar HTML5History = /*@__PURE__*/(function (History) {\n  function HTML5History (router, base) {\n    History.call(this, router, base);\n\n    this._startLocation = getLocation(this.base);\n  }\n\n  if ( History ) HTML5History.__proto__ = History;\n  HTML5History.prototype = Object.create( History && History.prototype );\n  HTML5History.prototype.constructor = HTML5History;\n\n  HTML5History.prototype.setupListeners = function setupListeners () {\n    var this$1 = this;\n\n    if (this.listeners.length > 0) {\n      return\n    }\n\n    var router = this.router;\n    var expectScroll = router.options.scrollBehavior;\n    var supportsScroll = supportsPushState && expectScroll;\n\n    if (supportsScroll) {\n      this.listeners.push(setupScroll());\n    }\n\n    var handleRoutingEvent = function () {\n      var current = this$1.current;\n\n      // Avoiding first `popstate` event dispatched in some browsers but first\n      // history route not updated since async guard at the same time.\n      var location = getLocation(this$1.base);\n      if (this$1.current === START && location === this$1._startLocation) {\n        return\n      }\n\n      this$1.transitionTo(location, function (route) {\n        if (supportsScroll) {\n          handleScroll(router, route, current, true);\n        }\n      });\n    };\n    window.addEventListener('popstate', handleRoutingEvent);\n    this.listeners.push(function () {\n      window.removeEventListener('popstate', handleRoutingEvent);\n    });\n  };\n\n  HTML5History.prototype.go = function go (n) {\n    window.history.go(n);\n  };\n\n  HTML5History.prototype.push = function push (location, onComplete, onAbort) {\n    var this$1 = this;\n\n    var ref = this;\n    var fromRoute = ref.current;\n    this.transitionTo(location, function (route) {\n      pushState(cleanPath(this$1.base + route.fullPath));\n      handleScroll(this$1.router, route, fromRoute, false);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  HTML5History.prototype.replace = function replace (location, onComplete, onAbort) {\n    var this$1 = this;\n\n    var ref = this;\n    var fromRoute = ref.current;\n    this.transitionTo(location, function (route) {\n      replaceState(cleanPath(this$1.base + route.fullPath));\n      handleScroll(this$1.router, route, fromRoute, false);\n      onComplete && onComplete(route);\n    }, onAbort);\n  };\n\n  HTML5History.prototype.ensureURL = function ensureURL (push) {\n    if (getLocation(this.base) !== this.current.fullPath) {\n      var current = cleanPath(this.base + this.current.fullPath);\n      push ? pushState(current) : replaceState(current);\n    }\n  };\n\n  HTML5History.prototype.getCurrentLocation = function getCurrentLocation () {\n    return getLocation(this.base)\n  };\n\n  return HTML5History;\n}(History));\n\nfunction getLocation (base) {\n  var path = window.location.pathname;\n  var pathLowerCase = path.toLowerCase();\n  var baseLowerCase = base.toLowerCase();\n  // base=\"/a\" shouldn't turn path=\"/app\" into \"/a/pp\"\n  // https://github.com/vuejs/vue-router/issues/3555\n  // so we ensure the trailing slash in the base\n  if (base && ((pathLowerCase === baseLowerCase) ||\n    (pathLowerCase.indexOf(cleanPath(baseLowerCase + '/')) === 0))) {\n    path = path.slice(base.length);\n  }\n  return (path || '/') + window.location.search + window.location.hash\n}\n\n/*  */\n\nvar HashHistory = /*@__PURE__*/(function (History) {\n  function HashHistory (router, base, fallback) {\n    History.call(this, router, base);\n    // check history fallback deeplinking\n    if (fallback && checkFallback(this.base)) {\n      return\n    }\n    ensureSlash();\n  }\n\n  if ( History ) HashHistory.__proto__ = History;\n  HashHistory.prototype = Object.create( History && History.prototype );\n  HashHistory.prototype.constructor = HashHistory;\n\n  // this is delayed until the app mounts\n  // to avoid the hashchange listener being fired too early\n  HashHistory.prototype.setupListeners = function setupListeners () {\n    var this$1 = this;\n\n    if (this.listeners.length > 0) {\n      return\n    }\n\n    var router = this.router;\n    var expectScroll = router.options.scrollBehavior;\n    var supportsScroll = supportsPushState && expectScroll;\n\n    if (supportsScroll) {\n      this.listeners.push(setupScroll());\n    }\n\n    var handleRoutingEvent = function () {\n      var current = this$1.current;\n      if (!ensureSlash()) {\n        return\n      }\n      this$1.transitionTo(getHash(), function (route) {\n        if (supportsScroll) {\n          handleScroll(this$1.router, route, current, true);\n        }\n        if (!supportsPushState) {\n          replaceHash(route.fullPath);\n        }\n      });\n    };\n    var eventType = supportsPushState ? 'popstate' : 'hashchange';\n    window.addEventListener(\n      eventType,\n      handleRoutingEvent\n    );\n    this.listeners.push(function () {\n      window.removeEventListener(eventType, handleRoutingEvent);\n    });\n  };\n\n  HashHistory.prototype.push = function push (location, onComplete, onAbort) {\n    var this$1 = this;\n\n    var ref = this;\n    var fromRoute = ref.current;\n    this.transitionTo(\n      location,\n      function (route) {\n        pushHash(route.fullPath);\n        handleScroll(this$1.router, route, fromRoute, false);\n        onComplete && onComplete(route);\n      },\n      onAbort\n    );\n  };\n\n  HashHistory.prototype.replace = function replace (location, onComplete, onAbort) {\n    var this$1 = this;\n\n    var ref = this;\n    var fromRoute = ref.current;\n    this.transitionTo(\n      location,\n      function (route) {\n        replaceHash(route.fullPath);\n        handleScroll(this$1.router, route, fromRoute, false);\n        onComplete && onComplete(route);\n      },\n      onAbort\n    );\n  };\n\n  HashHistory.prototype.go = function go (n) {\n    window.history.go(n);\n  };\n\n  HashHistory.prototype.ensureURL = function ensureURL (push) {\n    var current = this.current.fullPath;\n    if (getHash() !== current) {\n      push ? pushHash(current) : replaceHash(current);\n    }\n  };\n\n  HashHistory.prototype.getCurrentLocation = function getCurrentLocation () {\n    return getHash()\n  };\n\n  return HashHistory;\n}(History));\n\nfunction checkFallback (base) {\n  var location = getLocation(base);\n  if (!/^\\/#/.test(location)) {\n    window.location.replace(cleanPath(base + '/#' + location));\n    return true\n  }\n}\n\nfunction ensureSlash () {\n  var path = getHash();\n  if (path.charAt(0) === '/') {\n    return true\n  }\n  replaceHash('/' + path);\n  return false\n}\n\nfunction getHash () {\n  // We can't use window.location.hash here because it's not\n  // consistent across browsers - Firefox will pre-decode it!\n  var href = window.location.href;\n  var index = href.indexOf('#');\n  // empty path\n  if (index < 0) { return '' }\n\n  href = href.slice(index + 1);\n\n  return href\n}\n\nfunction getUrl (path) {\n  var href = window.location.href;\n  var i = href.indexOf('#');\n  var base = i >= 0 ? href.slice(0, i) : href;\n  return (base + \"#\" + path)\n}\n\nfunction pushHash (path) {\n  if (supportsPushState) {\n    pushState(getUrl(path));\n  } else {\n    window.location.hash = path;\n  }\n}\n\nfunction replaceHash (path) {\n  if (supportsPushState) {\n    replaceState(getUrl(path));\n  } else {\n    window.location.replace(getUrl(path));\n  }\n}\n\n/*  */\n\nvar AbstractHistory = /*@__PURE__*/(function (History) {\n  function AbstractHistory (router, base) {\n    History.call(this, router, base);\n    this.stack = [];\n    this.index = -1;\n  }\n\n  if ( History ) AbstractHistory.__proto__ = History;\n  AbstractHistory.prototype = Object.create( History && History.prototype );\n  AbstractHistory.prototype.constructor = AbstractHistory;\n\n  AbstractHistory.prototype.push = function push (location, onComplete, onAbort) {\n    var this$1 = this;\n\n    this.transitionTo(\n      location,\n      function (route) {\n        this$1.stack = this$1.stack.slice(0, this$1.index + 1).concat(route);\n        this$1.index++;\n        onComplete && onComplete(route);\n      },\n      onAbort\n    );\n  };\n\n  AbstractHistory.prototype.replace = function replace (location, onComplete, onAbort) {\n    var this$1 = this;\n\n    this.transitionTo(\n      location,\n      function (route) {\n        this$1.stack = this$1.stack.slice(0, this$1.index).concat(route);\n        onComplete && onComplete(route);\n      },\n      onAbort\n    );\n  };\n\n  AbstractHistory.prototype.go = function go (n) {\n    var this$1 = this;\n\n    var targetIndex = this.index + n;\n    if (targetIndex < 0 || targetIndex >= this.stack.length) {\n      return\n    }\n    var route = this.stack[targetIndex];\n    this.confirmTransition(\n      route,\n      function () {\n        var prev = this$1.current;\n        this$1.index = targetIndex;\n        this$1.updateRoute(route);\n        this$1.router.afterHooks.forEach(function (hook) {\n          hook && hook(route, prev);\n        });\n      },\n      function (err) {\n        if (isNavigationFailure(err, NavigationFailureType.duplicated)) {\n          this$1.index = targetIndex;\n        }\n      }\n    );\n  };\n\n  AbstractHistory.prototype.getCurrentLocation = function getCurrentLocation () {\n    var current = this.stack[this.stack.length - 1];\n    return current ? current.fullPath : '/'\n  };\n\n  AbstractHistory.prototype.ensureURL = function ensureURL () {\n    // noop\n  };\n\n  return AbstractHistory;\n}(History));\n\n/*  */\n\nvar VueRouter = function VueRouter (options) {\n  if ( options === void 0 ) options = {};\n\n  if (true) {\n    warn(this instanceof VueRouter, \"Router must be called with the new operator.\");\n  }\n  this.app = null;\n  this.apps = [];\n  this.options = options;\n  this.beforeHooks = [];\n  this.resolveHooks = [];\n  this.afterHooks = [];\n  this.matcher = createMatcher(options.routes || [], this);\n\n  var mode = options.mode || 'hash';\n  this.fallback =\n    mode === 'history' && !supportsPushState && options.fallback !== false;\n  if (this.fallback) {\n    mode = 'hash';\n  }\n  if (!inBrowser) {\n    mode = 'abstract';\n  }\n  this.mode = mode;\n\n  switch (mode) {\n    case 'history':\n      this.history = new HTML5History(this, options.base);\n      break\n    case 'hash':\n      this.history = new HashHistory(this, options.base, this.fallback);\n      break\n    case 'abstract':\n      this.history = new AbstractHistory(this, options.base);\n      break\n    default:\n      if (true) {\n        assert(false, (\"invalid mode: \" + mode));\n      }\n  }\n};\n\nvar prototypeAccessors = { currentRoute: { configurable: true } };\n\nVueRouter.prototype.match = function match (raw, current, redirectedFrom) {\n  return this.matcher.match(raw, current, redirectedFrom)\n};\n\nprototypeAccessors.currentRoute.get = function () {\n  return this.history && this.history.current\n};\n\nVueRouter.prototype.init = function init (app /* Vue component instance */) {\n    var this$1 = this;\n\n   true &&\n    assert(\n      install.installed,\n      \"not installed. Make sure to call `Vue.use(VueRouter)` \" +\n        \"before creating root instance.\"\n    );\n\n  this.apps.push(app);\n\n  // set up app destroyed handler\n  // https://github.com/vuejs/vue-router/issues/2639\n  app.$once('hook:destroyed', function () {\n    // clean out app from this.apps array once destroyed\n    var index = this$1.apps.indexOf(app);\n    if (index > -1) { this$1.apps.splice(index, 1); }\n    // ensure we still have a main app or null if no apps\n    // we do not release the router so it can be reused\n    if (this$1.app === app) { this$1.app = this$1.apps[0] || null; }\n\n    if (!this$1.app) { this$1.history.teardown(); }\n  });\n\n  // main app previously initialized\n  // return as we don't need to set up new history listener\n  if (this.app) {\n    return\n  }\n\n  this.app = app;\n\n  var history = this.history;\n\n  if (history instanceof HTML5History || history instanceof HashHistory) {\n    var handleInitialScroll = function (routeOrError) {\n      var from = history.current;\n      var expectScroll = this$1.options.scrollBehavior;\n      var supportsScroll = supportsPushState && expectScroll;\n\n      if (supportsScroll && 'fullPath' in routeOrError) {\n        handleScroll(this$1, routeOrError, from, false);\n      }\n    };\n    var setupListeners = function (routeOrError) {\n      history.setupListeners();\n      handleInitialScroll(routeOrError);\n    };\n    history.transitionTo(\n      history.getCurrentLocation(),\n      setupListeners,\n      setupListeners\n    );\n  }\n\n  history.listen(function (route) {\n    this$1.apps.forEach(function (app) {\n      app._route = route;\n    });\n  });\n};\n\nVueRouter.prototype.beforeEach = function beforeEach (fn) {\n  return registerHook(this.beforeHooks, fn)\n};\n\nVueRouter.prototype.beforeResolve = function beforeResolve (fn) {\n  return registerHook(this.resolveHooks, fn)\n};\n\nVueRouter.prototype.afterEach = function afterEach (fn) {\n  return registerHook(this.afterHooks, fn)\n};\n\nVueRouter.prototype.onReady = function onReady (cb, errorCb) {\n  this.history.onReady(cb, errorCb);\n};\n\nVueRouter.prototype.onError = function onError (errorCb) {\n  this.history.onError(errorCb);\n};\n\nVueRouter.prototype.push = function push (location, onComplete, onAbort) {\n    var this$1 = this;\n\n  // $flow-disable-line\n  if (!onComplete && !onAbort && typeof Promise !== 'undefined') {\n    return new Promise(function (resolve, reject) {\n      this$1.history.push(location, resolve, reject);\n    })\n  } else {\n    this.history.push(location, onComplete, onAbort);\n  }\n};\n\nVueRouter.prototype.replace = function replace (location, onComplete, onAbort) {\n    var this$1 = this;\n\n  // $flow-disable-line\n  if (!onComplete && !onAbort && typeof Promise !== 'undefined') {\n    return new Promise(function (resolve, reject) {\n      this$1.history.replace(location, resolve, reject);\n    })\n  } else {\n    this.history.replace(location, onComplete, onAbort);\n  }\n};\n\nVueRouter.prototype.go = function go (n) {\n  this.history.go(n);\n};\n\nVueRouter.prototype.back = function back () {\n  this.go(-1);\n};\n\nVueRouter.prototype.forward = function forward () {\n  this.go(1);\n};\n\nVueRouter.prototype.getMatchedComponents = function getMatchedComponents (to) {\n  var route = to\n    ? to.matched\n      ? to\n      : this.resolve(to).route\n    : this.currentRoute;\n  if (!route) {\n    return []\n  }\n  return [].concat.apply(\n    [],\n    route.matched.map(function (m) {\n      return Object.keys(m.components).map(function (key) {\n        return m.components[key]\n      })\n    })\n  )\n};\n\nVueRouter.prototype.resolve = function resolve (\n  to,\n  current,\n  append\n) {\n  current = current || this.history.current;\n  var location = normalizeLocation(to, current, append, this);\n  var route = this.match(location, current);\n  var fullPath = route.redirectedFrom || route.fullPath;\n  var base = this.history.base;\n  var href = createHref(base, fullPath, this.mode);\n  return {\n    location: location,\n    route: route,\n    href: href,\n    // for backwards compat\n    normalizedTo: location,\n    resolved: route\n  }\n};\n\nVueRouter.prototype.getRoutes = function getRoutes () {\n  return this.matcher.getRoutes()\n};\n\nVueRouter.prototype.addRoute = function addRoute (parentOrRoute, route) {\n  this.matcher.addRoute(parentOrRoute, route);\n  if (this.history.current !== START) {\n    this.history.transitionTo(this.history.getCurrentLocation());\n  }\n};\n\nVueRouter.prototype.addRoutes = function addRoutes (routes) {\n  if (true) {\n    warn(false, 'router.addRoutes() is deprecated and has been removed in Vue Router 4. Use router.addRoute() instead.');\n  }\n  this.matcher.addRoutes(routes);\n  if (this.history.current !== START) {\n    this.history.transitionTo(this.history.getCurrentLocation());\n  }\n};\n\nObject.defineProperties( VueRouter.prototype, prototypeAccessors );\n\nfunction registerHook (list, fn) {\n  list.push(fn);\n  return function () {\n    var i = list.indexOf(fn);\n    if (i > -1) { list.splice(i, 1); }\n  }\n}\n\nfunction createHref (base, fullPath, mode) {\n  var path = mode === 'hash' ? '#' + fullPath : fullPath;\n  return base ? cleanPath(base + '/' + path) : path\n}\n\nVueRouter.install = install;\nVueRouter.version = '3.5.4';\nVueRouter.isNavigationFailure = isNavigationFailure;\nVueRouter.NavigationFailureType = NavigationFailureType;\nVueRouter.START_LOCATION = START;\n\nif (inBrowser && window.Vue) {\n  window.Vue.use(VueRouter);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (VueRouter);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnVlLXJvdXRlci9kaXN0L3Z1ZS1yb3V0ZXIuZXNtLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDJDQUEyQztBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osUUFBUSxJQUFxQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixJQUFJLEtBQXFDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZDQUE2Qzs7QUFFN0M7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUCw2QkFBNkIsc0JBQXNCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsMEJBQTBCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQywyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTs7QUFFeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUssNkJBQTZCO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsSUFBcUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGNBQWMsSUFBcUM7QUFDbkQ7QUFDQTtBQUNBLFNBQVM7QUFDVCxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLE1BQU07QUFDTiwwQkFBMEIsaUNBQWlDO0FBQzNEO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxnQ0FBZ0M7QUFDaEMsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsVUFBVSxLQUFxQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1IsWUFBWSxJQUFxQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx1QkFBdUI7QUFDeEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsV0FBVztBQUM1QztBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDJDQUEyQztBQUNsRjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7O0FBRUEsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsSUFBcUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLGdCQUFnQjs7QUFFM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEVBQUUsS0FBcUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSw4QkFBOEI7O0FBRTlCLHVCQUF1QjtBQUN2QixHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlFQUFlLFNBQVMsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92dWUtcm91dGVyL2Rpc3QvdnVlLXJvdXRlci5lc20uanM/MzQyMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAgKiB2dWUtcm91dGVyIHYzLjUuNFxuICAqIChjKSAyMDIyIEV2YW4gWW91XG4gICogQGxpY2Vuc2UgTUlUXG4gICovXG4vKiAgKi9cblxuZnVuY3Rpb24gYXNzZXJ0IChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoKFwiW3Z1ZS1yb3V0ZXJdIFwiICsgbWVzc2FnZSkpXG4gIH1cbn1cblxuZnVuY3Rpb24gd2FybiAoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGNvbnNvbGUud2FybigoXCJbdnVlLXJvdXRlcl0gXCIgKyBtZXNzYWdlKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0ZW5kIChhLCBiKSB7XG4gIGZvciAodmFyIGtleSBpbiBiKSB7XG4gICAgYVtrZXldID0gYltrZXldO1xuICB9XG4gIHJldHVybiBhXG59XG5cbi8qICAqL1xuXG52YXIgZW5jb2RlUmVzZXJ2ZVJFID0gL1shJygpKl0vZztcbnZhciBlbmNvZGVSZXNlcnZlUmVwbGFjZXIgPSBmdW5jdGlvbiAoYykgeyByZXR1cm4gJyUnICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KTsgfTtcbnZhciBjb21tYVJFID0gLyUyQy9nO1xuXG4vLyBmaXhlZCBlbmNvZGVVUklDb21wb25lbnQgd2hpY2ggaXMgbW9yZSBjb25mb3JtYW50IHRvIFJGQzM5ODY6XG4vLyAtIGVzY2FwZXMgWyEnKCkqXVxuLy8gLSBwcmVzZXJ2ZSBjb21tYXNcbnZhciBlbmNvZGUgPSBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyKVxuICAgIC5yZXBsYWNlKGVuY29kZVJlc2VydmVSRSwgZW5jb2RlUmVzZXJ2ZVJlcGxhY2VyKVxuICAgIC5yZXBsYWNlKGNvbW1hUkUsICcsJyk7IH07XG5cbmZ1bmN0aW9uIGRlY29kZSAoc3RyKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzdHIpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuKGZhbHNlLCAoXCJFcnJvciBkZWNvZGluZyBcXFwiXCIgKyBzdHIgKyBcIlxcXCIuIExlYXZpbmcgaXQgaW50YWN0LlwiKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVF1ZXJ5IChcbiAgcXVlcnksXG4gIGV4dHJhUXVlcnksXG4gIF9wYXJzZVF1ZXJ5XG4pIHtcbiAgaWYgKCBleHRyYVF1ZXJ5ID09PSB2b2lkIDAgKSBleHRyYVF1ZXJ5ID0ge307XG5cbiAgdmFyIHBhcnNlID0gX3BhcnNlUXVlcnkgfHwgcGFyc2VRdWVyeTtcbiAgdmFyIHBhcnNlZFF1ZXJ5O1xuICB0cnkge1xuICAgIHBhcnNlZFF1ZXJ5ID0gcGFyc2UocXVlcnkgfHwgJycpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKGZhbHNlLCBlLm1lc3NhZ2UpO1xuICAgIHBhcnNlZFF1ZXJ5ID0ge307XG4gIH1cbiAgZm9yICh2YXIga2V5IGluIGV4dHJhUXVlcnkpIHtcbiAgICB2YXIgdmFsdWUgPSBleHRyYVF1ZXJ5W2tleV07XG4gICAgcGFyc2VkUXVlcnlba2V5XSA9IEFycmF5LmlzQXJyYXkodmFsdWUpXG4gICAgICA/IHZhbHVlLm1hcChjYXN0UXVlcnlQYXJhbVZhbHVlKVxuICAgICAgOiBjYXN0UXVlcnlQYXJhbVZhbHVlKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gcGFyc2VkUXVlcnlcbn1cblxudmFyIGNhc3RRdWVyeVBhcmFtVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgPyB2YWx1ZSA6IFN0cmluZyh2YWx1ZSkpOyB9O1xuXG5mdW5jdGlvbiBwYXJzZVF1ZXJ5IChxdWVyeSkge1xuICB2YXIgcmVzID0ge307XG5cbiAgcXVlcnkgPSBxdWVyeS50cmltKCkucmVwbGFjZSgvXihcXD98I3wmKS8sICcnKTtcblxuICBpZiAoIXF1ZXJ5KSB7XG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgcXVlcnkuc3BsaXQoJyYnKS5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbSkge1xuICAgIHZhciBwYXJ0cyA9IHBhcmFtLnJlcGxhY2UoL1xcKy9nLCAnICcpLnNwbGl0KCc9Jyk7XG4gICAgdmFyIGtleSA9IGRlY29kZShwYXJ0cy5zaGlmdCgpKTtcbiAgICB2YXIgdmFsID0gcGFydHMubGVuZ3RoID4gMCA/IGRlY29kZShwYXJ0cy5qb2luKCc9JykpIDogbnVsbDtcblxuICAgIGlmIChyZXNba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXNba2V5XSA9IHZhbDtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmVzW2tleV0pKSB7XG4gICAgICByZXNba2V5XS5wdXNoKHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc1trZXldID0gW3Jlc1trZXldLCB2YWxdO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlRdWVyeSAob2JqKSB7XG4gIHZhciByZXMgPSBvYmpcbiAgICA/IE9iamVjdC5rZXlzKG9iailcbiAgICAgIC5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgdmFsID0gb2JqW2tleV07XG5cbiAgICAgICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuICcnXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGVuY29kZShrZXkpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgIHZhbC5mb3JFYWNoKGZ1bmN0aW9uICh2YWwyKSB7XG4gICAgICAgICAgICBpZiAodmFsMiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbDIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZW5jb2RlKGtleSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZW5jb2RlKGtleSkgKyAnPScgKyBlbmNvZGUodmFsMikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiByZXN1bHQuam9pbignJicpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZW5jb2RlKGtleSkgKyAnPScgKyBlbmNvZGUodmFsKVxuICAgICAgfSlcbiAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHgubGVuZ3RoID4gMDsgfSlcbiAgICAgIC5qb2luKCcmJylcbiAgICA6IG51bGw7XG4gIHJldHVybiByZXMgPyAoXCI/XCIgKyByZXMpIDogJydcbn1cblxuLyogICovXG5cbnZhciB0cmFpbGluZ1NsYXNoUkUgPSAvXFwvPyQvO1xuXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZSAoXG4gIHJlY29yZCxcbiAgbG9jYXRpb24sXG4gIHJlZGlyZWN0ZWRGcm9tLFxuICByb3V0ZXJcbikge1xuICB2YXIgc3RyaW5naWZ5UXVlcnkgPSByb3V0ZXIgJiYgcm91dGVyLm9wdGlvbnMuc3RyaW5naWZ5UXVlcnk7XG5cbiAgdmFyIHF1ZXJ5ID0gbG9jYXRpb24ucXVlcnkgfHwge307XG4gIHRyeSB7XG4gICAgcXVlcnkgPSBjbG9uZShxdWVyeSk7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJvdXRlID0ge1xuICAgIG5hbWU6IGxvY2F0aW9uLm5hbWUgfHwgKHJlY29yZCAmJiByZWNvcmQubmFtZSksXG4gICAgbWV0YTogKHJlY29yZCAmJiByZWNvcmQubWV0YSkgfHwge30sXG4gICAgcGF0aDogbG9jYXRpb24ucGF0aCB8fCAnLycsXG4gICAgaGFzaDogbG9jYXRpb24uaGFzaCB8fCAnJyxcbiAgICBxdWVyeTogcXVlcnksXG4gICAgcGFyYW1zOiBsb2NhdGlvbi5wYXJhbXMgfHwge30sXG4gICAgZnVsbFBhdGg6IGdldEZ1bGxQYXRoKGxvY2F0aW9uLCBzdHJpbmdpZnlRdWVyeSksXG4gICAgbWF0Y2hlZDogcmVjb3JkID8gZm9ybWF0TWF0Y2gocmVjb3JkKSA6IFtdXG4gIH07XG4gIGlmIChyZWRpcmVjdGVkRnJvbSkge1xuICAgIHJvdXRlLnJlZGlyZWN0ZWRGcm9tID0gZ2V0RnVsbFBhdGgocmVkaXJlY3RlZEZyb20sIHN0cmluZ2lmeVF1ZXJ5KTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShyb3V0ZSlcbn1cblxuZnVuY3Rpb24gY2xvbmUgKHZhbHVlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZS5tYXAoY2xvbmUpXG4gIH0gZWxzZSBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgIHZhciByZXMgPSB7fTtcbiAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgIHJlc1trZXldID0gY2xvbmUodmFsdWVba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxufVxuXG4vLyB0aGUgc3RhcnRpbmcgcm91dGUgdGhhdCByZXByZXNlbnRzIHRoZSBpbml0aWFsIHN0YXRlXG52YXIgU1RBUlQgPSBjcmVhdGVSb3V0ZShudWxsLCB7XG4gIHBhdGg6ICcvJ1xufSk7XG5cbmZ1bmN0aW9uIGZvcm1hdE1hdGNoIChyZWNvcmQpIHtcbiAgdmFyIHJlcyA9IFtdO1xuICB3aGlsZSAocmVjb3JkKSB7XG4gICAgcmVzLnVuc2hpZnQocmVjb3JkKTtcbiAgICByZWNvcmQgPSByZWNvcmQucGFyZW50O1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gZ2V0RnVsbFBhdGggKFxuICByZWYsXG4gIF9zdHJpbmdpZnlRdWVyeVxuKSB7XG4gIHZhciBwYXRoID0gcmVmLnBhdGg7XG4gIHZhciBxdWVyeSA9IHJlZi5xdWVyeTsgaWYgKCBxdWVyeSA9PT0gdm9pZCAwICkgcXVlcnkgPSB7fTtcbiAgdmFyIGhhc2ggPSByZWYuaGFzaDsgaWYgKCBoYXNoID09PSB2b2lkIDAgKSBoYXNoID0gJyc7XG5cbiAgdmFyIHN0cmluZ2lmeSA9IF9zdHJpbmdpZnlRdWVyeSB8fCBzdHJpbmdpZnlRdWVyeTtcbiAgcmV0dXJuIChwYXRoIHx8ICcvJykgKyBzdHJpbmdpZnkocXVlcnkpICsgaGFzaFxufVxuXG5mdW5jdGlvbiBpc1NhbWVSb3V0ZSAoYSwgYiwgb25seVBhdGgpIHtcbiAgaWYgKGIgPT09IFNUQVJUKSB7XG4gICAgcmV0dXJuIGEgPT09IGJcbiAgfSBlbHNlIGlmICghYikge1xuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYgKGEucGF0aCAmJiBiLnBhdGgpIHtcbiAgICByZXR1cm4gYS5wYXRoLnJlcGxhY2UodHJhaWxpbmdTbGFzaFJFLCAnJykgPT09IGIucGF0aC5yZXBsYWNlKHRyYWlsaW5nU2xhc2hSRSwgJycpICYmIChvbmx5UGF0aCB8fFxuICAgICAgYS5oYXNoID09PSBiLmhhc2ggJiZcbiAgICAgIGlzT2JqZWN0RXF1YWwoYS5xdWVyeSwgYi5xdWVyeSkpXG4gIH0gZWxzZSBpZiAoYS5uYW1lICYmIGIubmFtZSkge1xuICAgIHJldHVybiAoXG4gICAgICBhLm5hbWUgPT09IGIubmFtZSAmJlxuICAgICAgKG9ubHlQYXRoIHx8IChcbiAgICAgICAgYS5oYXNoID09PSBiLmhhc2ggJiZcbiAgICAgIGlzT2JqZWN0RXF1YWwoYS5xdWVyeSwgYi5xdWVyeSkgJiZcbiAgICAgIGlzT2JqZWN0RXF1YWwoYS5wYXJhbXMsIGIucGFyYW1zKSlcbiAgICAgIClcbiAgICApXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24gaXNPYmplY3RFcXVhbCAoYSwgYikge1xuICBpZiAoIGEgPT09IHZvaWQgMCApIGEgPSB7fTtcbiAgaWYgKCBiID09PSB2b2lkIDAgKSBiID0ge307XG5cbiAgLy8gaGFuZGxlIG51bGwgdmFsdWUgIzE1NjZcbiAgaWYgKCFhIHx8ICFiKSB7IHJldHVybiBhID09PSBiIH1cbiAgdmFyIGFLZXlzID0gT2JqZWN0LmtleXMoYSkuc29ydCgpO1xuICB2YXIgYktleXMgPSBPYmplY3Qua2V5cyhiKS5zb3J0KCk7XG4gIGlmIChhS2V5cy5sZW5ndGggIT09IGJLZXlzLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHJldHVybiBhS2V5cy5ldmVyeShmdW5jdGlvbiAoa2V5LCBpKSB7XG4gICAgdmFyIGFWYWwgPSBhW2tleV07XG4gICAgdmFyIGJLZXkgPSBiS2V5c1tpXTtcbiAgICBpZiAoYktleSAhPT0ga2V5KSB7IHJldHVybiBmYWxzZSB9XG4gICAgdmFyIGJWYWwgPSBiW2tleV07XG4gICAgLy8gcXVlcnkgdmFsdWVzIGNhbiBiZSBudWxsIGFuZCB1bmRlZmluZWRcbiAgICBpZiAoYVZhbCA9PSBudWxsIHx8IGJWYWwgPT0gbnVsbCkgeyByZXR1cm4gYVZhbCA9PT0gYlZhbCB9XG4gICAgLy8gY2hlY2sgbmVzdGVkIGVxdWFsaXR5XG4gICAgaWYgKHR5cGVvZiBhVmFsID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgYlZhbCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBpc09iamVjdEVxdWFsKGFWYWwsIGJWYWwpXG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcoYVZhbCkgPT09IFN0cmluZyhiVmFsKVxuICB9KVxufVxuXG5mdW5jdGlvbiBpc0luY2x1ZGVkUm91dGUgKGN1cnJlbnQsIHRhcmdldCkge1xuICByZXR1cm4gKFxuICAgIGN1cnJlbnQucGF0aC5yZXBsYWNlKHRyYWlsaW5nU2xhc2hSRSwgJy8nKS5pbmRleE9mKFxuICAgICAgdGFyZ2V0LnBhdGgucmVwbGFjZSh0cmFpbGluZ1NsYXNoUkUsICcvJylcbiAgICApID09PSAwICYmXG4gICAgKCF0YXJnZXQuaGFzaCB8fCBjdXJyZW50Lmhhc2ggPT09IHRhcmdldC5oYXNoKSAmJlxuICAgIHF1ZXJ5SW5jbHVkZXMoY3VycmVudC5xdWVyeSwgdGFyZ2V0LnF1ZXJ5KVxuICApXG59XG5cbmZ1bmN0aW9uIHF1ZXJ5SW5jbHVkZXMgKGN1cnJlbnQsIHRhcmdldCkge1xuICBmb3IgKHZhciBrZXkgaW4gdGFyZ2V0KSB7XG4gICAgaWYgKCEoa2V5IGluIGN1cnJlbnQpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gaGFuZGxlUm91dGVFbnRlcmVkIChyb3V0ZSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJvdXRlLm1hdGNoZWQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcmVjb3JkID0gcm91dGUubWF0Y2hlZFtpXTtcbiAgICBmb3IgKHZhciBuYW1lIGluIHJlY29yZC5pbnN0YW5jZXMpIHtcbiAgICAgIHZhciBpbnN0YW5jZSA9IHJlY29yZC5pbnN0YW5jZXNbbmFtZV07XG4gICAgICB2YXIgY2JzID0gcmVjb3JkLmVudGVyZWRDYnNbbmFtZV07XG4gICAgICBpZiAoIWluc3RhbmNlIHx8ICFjYnMpIHsgY29udGludWUgfVxuICAgICAgZGVsZXRlIHJlY29yZC5lbnRlcmVkQ2JzW25hbWVdO1xuICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2JzLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgaWYgKCFpbnN0YW5jZS5faXNCZWluZ0Rlc3Ryb3llZCkgeyBjYnNbaSQxXShpbnN0YW5jZSk7IH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIFZpZXcgPSB7XG4gIG5hbWU6ICdSb3V0ZXJWaWV3JyxcbiAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgcHJvcHM6IHtcbiAgICBuYW1lOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnZGVmYXVsdCdcbiAgICB9XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChfLCByZWYpIHtcbiAgICB2YXIgcHJvcHMgPSByZWYucHJvcHM7XG4gICAgdmFyIGNoaWxkcmVuID0gcmVmLmNoaWxkcmVuO1xuICAgIHZhciBwYXJlbnQgPSByZWYucGFyZW50O1xuICAgIHZhciBkYXRhID0gcmVmLmRhdGE7XG5cbiAgICAvLyB1c2VkIGJ5IGRldnRvb2xzIHRvIGRpc3BsYXkgYSByb3V0ZXItdmlldyBiYWRnZVxuICAgIGRhdGEucm91dGVyVmlldyA9IHRydWU7XG5cbiAgICAvLyBkaXJlY3RseSB1c2UgcGFyZW50IGNvbnRleHQncyBjcmVhdGVFbGVtZW50KCkgZnVuY3Rpb25cbiAgICAvLyBzbyB0aGF0IGNvbXBvbmVudHMgcmVuZGVyZWQgYnkgcm91dGVyLXZpZXcgY2FuIHJlc29sdmUgbmFtZWQgc2xvdHNcbiAgICB2YXIgaCA9IHBhcmVudC4kY3JlYXRlRWxlbWVudDtcbiAgICB2YXIgbmFtZSA9IHByb3BzLm5hbWU7XG4gICAgdmFyIHJvdXRlID0gcGFyZW50LiRyb3V0ZTtcbiAgICB2YXIgY2FjaGUgPSBwYXJlbnQuX3JvdXRlclZpZXdDYWNoZSB8fCAocGFyZW50Ll9yb3V0ZXJWaWV3Q2FjaGUgPSB7fSk7XG5cbiAgICAvLyBkZXRlcm1pbmUgY3VycmVudCB2aWV3IGRlcHRoLCBhbHNvIGNoZWNrIHRvIHNlZSBpZiB0aGUgdHJlZVxuICAgIC8vIGhhcyBiZWVuIHRvZ2dsZWQgaW5hY3RpdmUgYnV0IGtlcHQtYWxpdmUuXG4gICAgdmFyIGRlcHRoID0gMDtcbiAgICB2YXIgaW5hY3RpdmUgPSBmYWxzZTtcbiAgICB3aGlsZSAocGFyZW50ICYmIHBhcmVudC5fcm91dGVyUm9vdCAhPT0gcGFyZW50KSB7XG4gICAgICB2YXIgdm5vZGVEYXRhID0gcGFyZW50LiR2bm9kZSA/IHBhcmVudC4kdm5vZGUuZGF0YSA6IHt9O1xuICAgICAgaWYgKHZub2RlRGF0YS5yb3V0ZXJWaWV3KSB7XG4gICAgICAgIGRlcHRoKys7XG4gICAgICB9XG4gICAgICBpZiAodm5vZGVEYXRhLmtlZXBBbGl2ZSAmJiBwYXJlbnQuX2RpcmVjdEluYWN0aXZlICYmIHBhcmVudC5faW5hY3RpdmUpIHtcbiAgICAgICAgaW5hY3RpdmUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcGFyZW50ID0gcGFyZW50LiRwYXJlbnQ7XG4gICAgfVxuICAgIGRhdGEucm91dGVyVmlld0RlcHRoID0gZGVwdGg7XG5cbiAgICAvLyByZW5kZXIgcHJldmlvdXMgdmlldyBpZiB0aGUgdHJlZSBpcyBpbmFjdGl2ZSBhbmQga2VwdC1hbGl2ZVxuICAgIGlmIChpbmFjdGl2ZSkge1xuICAgICAgdmFyIGNhY2hlZERhdGEgPSBjYWNoZVtuYW1lXTtcbiAgICAgIHZhciBjYWNoZWRDb21wb25lbnQgPSBjYWNoZWREYXRhICYmIGNhY2hlZERhdGEuY29tcG9uZW50O1xuICAgICAgaWYgKGNhY2hlZENvbXBvbmVudCkge1xuICAgICAgICAvLyAjMjMwMVxuICAgICAgICAvLyBwYXNzIHByb3BzXG4gICAgICAgIGlmIChjYWNoZWREYXRhLmNvbmZpZ1Byb3BzKSB7XG4gICAgICAgICAgZmlsbFByb3BzaW5EYXRhKGNhY2hlZENvbXBvbmVudCwgZGF0YSwgY2FjaGVkRGF0YS5yb3V0ZSwgY2FjaGVkRGF0YS5jb25maWdQcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGgoY2FjaGVkQ29tcG9uZW50LCBkYXRhLCBjaGlsZHJlbilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJlbmRlciBwcmV2aW91cyBlbXB0eSB2aWV3XG4gICAgICAgIHJldHVybiBoKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbWF0Y2hlZCA9IHJvdXRlLm1hdGNoZWRbZGVwdGhdO1xuICAgIHZhciBjb21wb25lbnQgPSBtYXRjaGVkICYmIG1hdGNoZWQuY29tcG9uZW50c1tuYW1lXTtcblxuICAgIC8vIHJlbmRlciBlbXB0eSBub2RlIGlmIG5vIG1hdGNoZWQgcm91dGUgb3Igbm8gY29uZmlnIGNvbXBvbmVudFxuICAgIGlmICghbWF0Y2hlZCB8fCAhY29tcG9uZW50KSB7XG4gICAgICBjYWNoZVtuYW1lXSA9IG51bGw7XG4gICAgICByZXR1cm4gaCgpXG4gICAgfVxuXG4gICAgLy8gY2FjaGUgY29tcG9uZW50XG4gICAgY2FjaGVbbmFtZV0gPSB7IGNvbXBvbmVudDogY29tcG9uZW50IH07XG5cbiAgICAvLyBhdHRhY2ggaW5zdGFuY2UgcmVnaXN0cmF0aW9uIGhvb2tcbiAgICAvLyB0aGlzIHdpbGwgYmUgY2FsbGVkIGluIHRoZSBpbnN0YW5jZSdzIGluamVjdGVkIGxpZmVjeWNsZSBob29rc1xuICAgIGRhdGEucmVnaXN0ZXJSb3V0ZUluc3RhbmNlID0gZnVuY3Rpb24gKHZtLCB2YWwpIHtcbiAgICAgIC8vIHZhbCBjb3VsZCBiZSB1bmRlZmluZWQgZm9yIHVucmVnaXN0cmF0aW9uXG4gICAgICB2YXIgY3VycmVudCA9IG1hdGNoZWQuaW5zdGFuY2VzW25hbWVdO1xuICAgICAgaWYgKFxuICAgICAgICAodmFsICYmIGN1cnJlbnQgIT09IHZtKSB8fFxuICAgICAgICAoIXZhbCAmJiBjdXJyZW50ID09PSB2bSlcbiAgICAgICkge1xuICAgICAgICBtYXRjaGVkLmluc3RhbmNlc1tuYW1lXSA9IHZhbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhbHNvIHJlZ2lzdGVyIGluc3RhbmNlIGluIHByZXBhdGNoIGhvb2tcbiAgICAvLyBpbiBjYXNlIHRoZSBzYW1lIGNvbXBvbmVudCBpbnN0YW5jZSBpcyByZXVzZWQgYWNyb3NzIGRpZmZlcmVudCByb3V0ZXNcbiAgICA7KGRhdGEuaG9vayB8fCAoZGF0YS5ob29rID0ge30pKS5wcmVwYXRjaCA9IGZ1bmN0aW9uIChfLCB2bm9kZSkge1xuICAgICAgbWF0Y2hlZC5pbnN0YW5jZXNbbmFtZV0gPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICB9O1xuXG4gICAgLy8gcmVnaXN0ZXIgaW5zdGFuY2UgaW4gaW5pdCBob29rXG4gICAgLy8gaW4gY2FzZSBrZXB0LWFsaXZlIGNvbXBvbmVudCBiZSBhY3RpdmVkIHdoZW4gcm91dGVzIGNoYW5nZWRcbiAgICBkYXRhLmhvb2suaW5pdCA9IGZ1bmN0aW9uICh2bm9kZSkge1xuICAgICAgaWYgKHZub2RlLmRhdGEua2VlcEFsaXZlICYmXG4gICAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlICYmXG4gICAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlICE9PSBtYXRjaGVkLmluc3RhbmNlc1tuYW1lXVxuICAgICAgKSB7XG4gICAgICAgIG1hdGNoZWQuaW5zdGFuY2VzW25hbWVdID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHRoZSByb3V0ZSB0cmFuc2l0aW9uIGhhcyBhbHJlYWR5IGJlZW4gY29uZmlybWVkIHRoZW4gd2Ugd2VyZW4ndFxuICAgICAgLy8gYWJsZSB0byBjYWxsIHRoZSBjYnMgZHVyaW5nIGNvbmZpcm1hdGlvbiBhcyB0aGUgY29tcG9uZW50IHdhcyBub3RcbiAgICAgIC8vIHJlZ2lzdGVyZWQgeWV0LCBzbyB3ZSBjYWxsIGl0IGhlcmUuXG4gICAgICBoYW5kbGVSb3V0ZUVudGVyZWQocm91dGUpO1xuICAgIH07XG5cbiAgICB2YXIgY29uZmlnUHJvcHMgPSBtYXRjaGVkLnByb3BzICYmIG1hdGNoZWQucHJvcHNbbmFtZV07XG4gICAgLy8gc2F2ZSByb3V0ZSBhbmQgY29uZmlnUHJvcHMgaW4gY2FjaGVcbiAgICBpZiAoY29uZmlnUHJvcHMpIHtcbiAgICAgIGV4dGVuZChjYWNoZVtuYW1lXSwge1xuICAgICAgICByb3V0ZTogcm91dGUsXG4gICAgICAgIGNvbmZpZ1Byb3BzOiBjb25maWdQcm9wc1xuICAgICAgfSk7XG4gICAgICBmaWxsUHJvcHNpbkRhdGEoY29tcG9uZW50LCBkYXRhLCByb3V0ZSwgY29uZmlnUHJvcHMpO1xuICAgIH1cblxuICAgIHJldHVybiBoKGNvbXBvbmVudCwgZGF0YSwgY2hpbGRyZW4pXG4gIH1cbn07XG5cbmZ1bmN0aW9uIGZpbGxQcm9wc2luRGF0YSAoY29tcG9uZW50LCBkYXRhLCByb3V0ZSwgY29uZmlnUHJvcHMpIHtcbiAgLy8gcmVzb2x2ZSBwcm9wc1xuICB2YXIgcHJvcHNUb1Bhc3MgPSBkYXRhLnByb3BzID0gcmVzb2x2ZVByb3BzKHJvdXRlLCBjb25maWdQcm9wcyk7XG4gIGlmIChwcm9wc1RvUGFzcykge1xuICAgIC8vIGNsb25lIHRvIHByZXZlbnQgbXV0YXRpb25cbiAgICBwcm9wc1RvUGFzcyA9IGRhdGEucHJvcHMgPSBleHRlbmQoe30sIHByb3BzVG9QYXNzKTtcbiAgICAvLyBwYXNzIG5vbi1kZWNsYXJlZCBwcm9wcyBhcyBhdHRyc1xuICAgIHZhciBhdHRycyA9IGRhdGEuYXR0cnMgPSBkYXRhLmF0dHJzIHx8IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wc1RvUGFzcykge1xuICAgICAgaWYgKCFjb21wb25lbnQucHJvcHMgfHwgIShrZXkgaW4gY29tcG9uZW50LnByb3BzKSkge1xuICAgICAgICBhdHRyc1trZXldID0gcHJvcHNUb1Bhc3Nba2V5XTtcbiAgICAgICAgZGVsZXRlIHByb3BzVG9QYXNzW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVQcm9wcyAocm91dGUsIGNvbmZpZykge1xuICBzd2l0Y2ggKHR5cGVvZiBjb25maWcpIHtcbiAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgcmV0dXJuXG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIHJldHVybiBjb25maWdcbiAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICByZXR1cm4gY29uZmlnKHJvdXRlKVxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIGNvbmZpZyA/IHJvdXRlLnBhcmFtcyA6IHVuZGVmaW5lZFxuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIFwicHJvcHMgaW4gXFxcIlwiICsgKHJvdXRlLnBhdGgpICsgXCJcXFwiIGlzIGEgXCIgKyAodHlwZW9mIGNvbmZpZykgKyBcIiwgXCIgK1xuICAgICAgICAgIFwiZXhwZWN0aW5nIGFuIG9iamVjdCwgZnVuY3Rpb24gb3IgYm9vbGVhbi5cIlxuICAgICAgICApO1xuICAgICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiByZXNvbHZlUGF0aCAoXG4gIHJlbGF0aXZlLFxuICBiYXNlLFxuICBhcHBlbmRcbikge1xuICB2YXIgZmlyc3RDaGFyID0gcmVsYXRpdmUuY2hhckF0KDApO1xuICBpZiAoZmlyc3RDaGFyID09PSAnLycpIHtcbiAgICByZXR1cm4gcmVsYXRpdmVcbiAgfVxuXG4gIGlmIChmaXJzdENoYXIgPT09ICc/JyB8fCBmaXJzdENoYXIgPT09ICcjJykge1xuICAgIHJldHVybiBiYXNlICsgcmVsYXRpdmVcbiAgfVxuXG4gIHZhciBzdGFjayA9IGJhc2Uuc3BsaXQoJy8nKTtcblxuICAvLyByZW1vdmUgdHJhaWxpbmcgc2VnbWVudCBpZjpcbiAgLy8gLSBub3QgYXBwZW5kaW5nXG4gIC8vIC0gYXBwZW5kaW5nIHRvIHRyYWlsaW5nIHNsYXNoIChsYXN0IHNlZ21lbnQgaXMgZW1wdHkpXG4gIGlmICghYXBwZW5kIHx8ICFzdGFja1tzdGFjay5sZW5ndGggLSAxXSkge1xuICAgIHN0YWNrLnBvcCgpO1xuICB9XG5cbiAgLy8gcmVzb2x2ZSByZWxhdGl2ZSBwYXRoXG4gIHZhciBzZWdtZW50cyA9IHJlbGF0aXZlLnJlcGxhY2UoL15cXC8vLCAnJykuc3BsaXQoJy8nKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgaWYgKHNlZ21lbnQgPT09ICcuLicpIHtcbiAgICAgIHN0YWNrLnBvcCgpO1xuICAgIH0gZWxzZSBpZiAoc2VnbWVudCAhPT0gJy4nKSB7XG4gICAgICBzdGFjay5wdXNoKHNlZ21lbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGVuc3VyZSBsZWFkaW5nIHNsYXNoXG4gIGlmIChzdGFja1swXSAhPT0gJycpIHtcbiAgICBzdGFjay51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIHJldHVybiBzdGFjay5qb2luKCcvJylcbn1cblxuZnVuY3Rpb24gcGFyc2VQYXRoIChwYXRoKSB7XG4gIHZhciBoYXNoID0gJyc7XG4gIHZhciBxdWVyeSA9ICcnO1xuXG4gIHZhciBoYXNoSW5kZXggPSBwYXRoLmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2hJbmRleCA+PSAwKSB7XG4gICAgaGFzaCA9IHBhdGguc2xpY2UoaGFzaEluZGV4KTtcbiAgICBwYXRoID0gcGF0aC5zbGljZSgwLCBoYXNoSW5kZXgpO1xuICB9XG5cbiAgdmFyIHF1ZXJ5SW5kZXggPSBwYXRoLmluZGV4T2YoJz8nKTtcbiAgaWYgKHF1ZXJ5SW5kZXggPj0gMCkge1xuICAgIHF1ZXJ5ID0gcGF0aC5zbGljZShxdWVyeUluZGV4ICsgMSk7XG4gICAgcGF0aCA9IHBhdGguc2xpY2UoMCwgcXVlcnlJbmRleCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBhdGg6IHBhdGgsXG4gICAgcXVlcnk6IHF1ZXJ5LFxuICAgIGhhc2g6IGhhc2hcbiAgfVxufVxuXG5mdW5jdGlvbiBjbGVhblBhdGggKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGgucmVwbGFjZSgvXFwvKD86XFxzKlxcLykrL2csICcvJylcbn1cblxudmFyIGlzYXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG4vKipcbiAqIEV4cG9zZSBgcGF0aFRvUmVnZXhwYC5cbiAqL1xudmFyIHBhdGhUb1JlZ2V4cF8xID0gcGF0aFRvUmVnZXhwO1xudmFyIHBhcnNlXzEgPSBwYXJzZTtcbnZhciBjb21waWxlXzEgPSBjb21waWxlO1xudmFyIHRva2Vuc1RvRnVuY3Rpb25fMSA9IHRva2Vuc1RvRnVuY3Rpb247XG52YXIgdG9rZW5zVG9SZWdFeHBfMSA9IHRva2Vuc1RvUmVnRXhwO1xuXG4vKipcbiAqIFRoZSBtYWluIHBhdGggbWF0Y2hpbmcgcmVnZXhwIHV0aWxpdHkuXG4gKlxuICogQHR5cGUge1JlZ0V4cH1cbiAqL1xudmFyIFBBVEhfUkVHRVhQID0gbmV3IFJlZ0V4cChbXG4gIC8vIE1hdGNoIGVzY2FwZWQgY2hhcmFjdGVycyB0aGF0IHdvdWxkIG90aGVyd2lzZSBhcHBlYXIgaW4gZnV0dXJlIG1hdGNoZXMuXG4gIC8vIFRoaXMgYWxsb3dzIHRoZSB1c2VyIHRvIGVzY2FwZSBzcGVjaWFsIGNoYXJhY3RlcnMgdGhhdCB3b24ndCB0cmFuc2Zvcm0uXG4gICcoXFxcXFxcXFwuKScsXG4gIC8vIE1hdGNoIEV4cHJlc3Mtc3R5bGUgcGFyYW1ldGVycyBhbmQgdW4tbmFtZWQgcGFyYW1ldGVycyB3aXRoIGEgcHJlZml4XG4gIC8vIGFuZCBvcHRpb25hbCBzdWZmaXhlcy4gTWF0Y2hlcyBhcHBlYXIgYXM6XG4gIC8vXG4gIC8vIFwiLzp0ZXN0KFxcXFxkKyk/XCIgPT4gW1wiL1wiLCBcInRlc3RcIiwgXCJcXGQrXCIsIHVuZGVmaW5lZCwgXCI/XCIsIHVuZGVmaW5lZF1cbiAgLy8gXCIvcm91dGUoXFxcXGQrKVwiICA9PiBbdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgXCJcXGQrXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkXVxuICAvLyBcIi8qXCIgICAgICAgICAgICA9PiBbXCIvXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgXCIqXCJdXG4gICcoW1xcXFwvLl0pPyg/Oig/OlxcXFw6KFxcXFx3KykoPzpcXFxcKCgoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpXSkrKVxcXFwpKT98XFxcXCgoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKV0pKylcXFxcKSkoWysqP10pP3woXFxcXCopKSdcbl0uam9pbignfCcpLCAnZycpO1xuXG4vKipcbiAqIFBhcnNlIGEgc3RyaW5nIGZvciB0aGUgcmF3IHRva2Vucy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICBzdHJcbiAqIEBwYXJhbSAge09iamVjdD19IG9wdGlvbnNcbiAqIEByZXR1cm4geyFBcnJheX1cbiAqL1xuZnVuY3Rpb24gcGFyc2UgKHN0ciwgb3B0aW9ucykge1xuICB2YXIgdG9rZW5zID0gW107XG4gIHZhciBrZXkgPSAwO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgcGF0aCA9ICcnO1xuICB2YXIgZGVmYXVsdERlbGltaXRlciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5kZWxpbWl0ZXIgfHwgJy8nO1xuICB2YXIgcmVzO1xuXG4gIHdoaWxlICgocmVzID0gUEFUSF9SRUdFWFAuZXhlYyhzdHIpKSAhPSBudWxsKSB7XG4gICAgdmFyIG0gPSByZXNbMF07XG4gICAgdmFyIGVzY2FwZWQgPSByZXNbMV07XG4gICAgdmFyIG9mZnNldCA9IHJlcy5pbmRleDtcbiAgICBwYXRoICs9IHN0ci5zbGljZShpbmRleCwgb2Zmc2V0KTtcbiAgICBpbmRleCA9IG9mZnNldCArIG0ubGVuZ3RoO1xuXG4gICAgLy8gSWdub3JlIGFscmVhZHkgZXNjYXBlZCBzZXF1ZW5jZXMuXG4gICAgaWYgKGVzY2FwZWQpIHtcbiAgICAgIHBhdGggKz0gZXNjYXBlZFsxXTtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgdmFyIG5leHQgPSBzdHJbaW5kZXhdO1xuICAgIHZhciBwcmVmaXggPSByZXNbMl07XG4gICAgdmFyIG5hbWUgPSByZXNbM107XG4gICAgdmFyIGNhcHR1cmUgPSByZXNbNF07XG4gICAgdmFyIGdyb3VwID0gcmVzWzVdO1xuICAgIHZhciBtb2RpZmllciA9IHJlc1s2XTtcbiAgICB2YXIgYXN0ZXJpc2sgPSByZXNbN107XG5cbiAgICAvLyBQdXNoIHRoZSBjdXJyZW50IHBhdGggb250byB0aGUgdG9rZW5zLlxuICAgIGlmIChwYXRoKSB7XG4gICAgICB0b2tlbnMucHVzaChwYXRoKTtcbiAgICAgIHBhdGggPSAnJztcbiAgICB9XG5cbiAgICB2YXIgcGFydGlhbCA9IHByZWZpeCAhPSBudWxsICYmIG5leHQgIT0gbnVsbCAmJiBuZXh0ICE9PSBwcmVmaXg7XG4gICAgdmFyIHJlcGVhdCA9IG1vZGlmaWVyID09PSAnKycgfHwgbW9kaWZpZXIgPT09ICcqJztcbiAgICB2YXIgb3B0aW9uYWwgPSBtb2RpZmllciA9PT0gJz8nIHx8IG1vZGlmaWVyID09PSAnKic7XG4gICAgdmFyIGRlbGltaXRlciA9IHJlc1syXSB8fCBkZWZhdWx0RGVsaW1pdGVyO1xuICAgIHZhciBwYXR0ZXJuID0gY2FwdHVyZSB8fCBncm91cDtcblxuICAgIHRva2Vucy5wdXNoKHtcbiAgICAgIG5hbWU6IG5hbWUgfHwga2V5KyssXG4gICAgICBwcmVmaXg6IHByZWZpeCB8fCAnJyxcbiAgICAgIGRlbGltaXRlcjogZGVsaW1pdGVyLFxuICAgICAgb3B0aW9uYWw6IG9wdGlvbmFsLFxuICAgICAgcmVwZWF0OiByZXBlYXQsXG4gICAgICBwYXJ0aWFsOiBwYXJ0aWFsLFxuICAgICAgYXN0ZXJpc2s6ICEhYXN0ZXJpc2ssXG4gICAgICBwYXR0ZXJuOiBwYXR0ZXJuID8gZXNjYXBlR3JvdXAocGF0dGVybikgOiAoYXN0ZXJpc2sgPyAnLionIDogJ1teJyArIGVzY2FwZVN0cmluZyhkZWxpbWl0ZXIpICsgJ10rPycpXG4gICAgfSk7XG4gIH1cblxuICAvLyBNYXRjaCBhbnkgY2hhcmFjdGVycyBzdGlsbCByZW1haW5pbmcuXG4gIGlmIChpbmRleCA8IHN0ci5sZW5ndGgpIHtcbiAgICBwYXRoICs9IHN0ci5zdWJzdHIoaW5kZXgpO1xuICB9XG5cbiAgLy8gSWYgdGhlIHBhdGggZXhpc3RzLCBwdXNoIGl0IG9udG8gdGhlIGVuZC5cbiAgaWYgKHBhdGgpIHtcbiAgICB0b2tlbnMucHVzaChwYXRoKTtcbiAgfVxuXG4gIHJldHVybiB0b2tlbnNcbn1cblxuLyoqXG4gKiBDb21waWxlIGEgc3RyaW5nIHRvIGEgdGVtcGxhdGUgZnVuY3Rpb24gZm9yIHRoZSBwYXRoLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gICAgICAgICAgICAgc3RyXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSAgICAgICAgICAgIG9wdGlvbnNcbiAqIEByZXR1cm4geyFmdW5jdGlvbihPYmplY3Q9LCBPYmplY3Q9KX1cbiAqL1xuZnVuY3Rpb24gY29tcGlsZSAoc3RyLCBvcHRpb25zKSB7XG4gIHJldHVybiB0b2tlbnNUb0Z1bmN0aW9uKHBhcnNlKHN0ciwgb3B0aW9ucyksIG9wdGlvbnMpXG59XG5cbi8qKlxuICogUHJldHRpZXIgZW5jb2Rpbmcgb2YgVVJJIHBhdGggc2VnbWVudHMuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlbmNvZGVVUklDb21wb25lbnRQcmV0dHkgKHN0cikge1xuICByZXR1cm4gZW5jb2RlVVJJKHN0cikucmVwbGFjZSgvW1xcLz8jXS9nLCBmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiAnJScgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKClcbiAgfSlcbn1cblxuLyoqXG4gKiBFbmNvZGUgdGhlIGFzdGVyaXNrIHBhcmFtZXRlci4gU2ltaWxhciB0byBgcHJldHR5YCwgYnV0IGFsbG93cyBzbGFzaGVzLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ31cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZW5jb2RlQXN0ZXJpc2sgKHN0cikge1xuICByZXR1cm4gZW5jb2RlVVJJKHN0cikucmVwbGFjZSgvWz8jXS9nLCBmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiAnJScgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKClcbiAgfSlcbn1cblxuLyoqXG4gKiBFeHBvc2UgYSBtZXRob2QgZm9yIHRyYW5zZm9ybWluZyB0b2tlbnMgaW50byB0aGUgcGF0aCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gdG9rZW5zVG9GdW5jdGlvbiAodG9rZW5zLCBvcHRpb25zKSB7XG4gIC8vIENvbXBpbGUgYWxsIHRoZSB0b2tlbnMgaW50byByZWdleHBzLlxuICB2YXIgbWF0Y2hlcyA9IG5ldyBBcnJheSh0b2tlbnMubGVuZ3RoKTtcblxuICAvLyBDb21waWxlIGFsbCB0aGUgcGF0dGVybnMgYmVmb3JlIGNvbXBpbGF0aW9uLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0eXBlb2YgdG9rZW5zW2ldID09PSAnb2JqZWN0Jykge1xuICAgICAgbWF0Y2hlc1tpXSA9IG5ldyBSZWdFeHAoJ14oPzonICsgdG9rZW5zW2ldLnBhdHRlcm4gKyAnKSQnLCBmbGFncyhvcHRpb25zKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChvYmosIG9wdHMpIHtcbiAgICB2YXIgcGF0aCA9ICcnO1xuICAgIHZhciBkYXRhID0gb2JqIHx8IHt9O1xuICAgIHZhciBvcHRpb25zID0gb3B0cyB8fCB7fTtcbiAgICB2YXIgZW5jb2RlID0gb3B0aW9ucy5wcmV0dHkgPyBlbmNvZGVVUklDb21wb25lbnRQcmV0dHkgOiBlbmNvZGVVUklDb21wb25lbnQ7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICBwYXRoICs9IHRva2VuO1xuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZSA9IGRhdGFbdG9rZW4ubmFtZV07XG4gICAgICB2YXIgc2VnbWVudDtcblxuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgaWYgKHRva2VuLm9wdGlvbmFsKSB7XG4gICAgICAgICAgLy8gUHJlcGVuZCBwYXJ0aWFsIHNlZ21lbnQgcHJlZml4ZXMuXG4gICAgICAgICAgaWYgKHRva2VuLnBhcnRpYWwpIHtcbiAgICAgICAgICAgIHBhdGggKz0gdG9rZW4ucHJlZml4O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBiZSBkZWZpbmVkJylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNhcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKCF0b2tlbi5yZXBlYXQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG5vdCByZXBlYXQsIGJ1dCByZWNlaXZlZCBgJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKSArICdgJylcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBpZiAodG9rZW4ub3B0aW9uYWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbm90IGJlIGVtcHR5JylcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbHVlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgc2VnbWVudCA9IGVuY29kZSh2YWx1ZVtqXSk7XG5cbiAgICAgICAgICBpZiAoIW1hdGNoZXNbaV0udGVzdChzZWdtZW50KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYWxsIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbWF0Y2ggXCInICsgdG9rZW4ucGF0dGVybiArICdcIiwgYnV0IHJlY2VpdmVkIGAnICsgSlNPTi5zdHJpbmdpZnkoc2VnbWVudCkgKyAnYCcpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGF0aCArPSAoaiA9PT0gMCA/IHRva2VuLnByZWZpeCA6IHRva2VuLmRlbGltaXRlcikgKyBzZWdtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgc2VnbWVudCA9IHRva2VuLmFzdGVyaXNrID8gZW5jb2RlQXN0ZXJpc2sodmFsdWUpIDogZW5jb2RlKHZhbHVlKTtcblxuICAgICAgaWYgKCFtYXRjaGVzW2ldLnRlc3Qoc2VnbWVudCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBtYXRjaCBcIicgKyB0b2tlbi5wYXR0ZXJuICsgJ1wiLCBidXQgcmVjZWl2ZWQgXCInICsgc2VnbWVudCArICdcIicpXG4gICAgICB9XG5cbiAgICAgIHBhdGggKz0gdG9rZW4ucHJlZml4ICsgc2VnbWVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aFxuICB9XG59XG5cbi8qKlxuICogRXNjYXBlIGEgcmVndWxhciBleHByZXNzaW9uIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlc2NhcGVTdHJpbmcgKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbLisqPz1eIToke30oKVtcXF18XFwvXFxcXF0pL2csICdcXFxcJDEnKVxufVxuXG4vKipcbiAqIEVzY2FwZSB0aGUgY2FwdHVyaW5nIGdyb3VwIGJ5IGVzY2FwaW5nIHNwZWNpYWwgY2hhcmFjdGVycyBhbmQgbWVhbmluZy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGdyb3VwXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVzY2FwZUdyb3VwIChncm91cCkge1xuICByZXR1cm4gZ3JvdXAucmVwbGFjZSgvKFs9ITokXFwvKCldKS9nLCAnXFxcXCQxJylcbn1cblxuLyoqXG4gKiBBdHRhY2ggdGhlIGtleXMgYXMgYSBwcm9wZXJ0eSBvZiB0aGUgcmVnZXhwLlxuICpcbiAqIEBwYXJhbSAgeyFSZWdFeHB9IHJlXG4gKiBAcGFyYW0gIHtBcnJheX0gICBrZXlzXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiBhdHRhY2hLZXlzIChyZSwga2V5cykge1xuICByZS5rZXlzID0ga2V5cztcbiAgcmV0dXJuIHJlXG59XG5cbi8qKlxuICogR2V0IHRoZSBmbGFncyBmb3IgYSByZWdleHAgZnJvbSB0aGUgb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZmxhZ3MgKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMgJiYgb3B0aW9ucy5zZW5zaXRpdmUgPyAnJyA6ICdpJ1xufVxuXG4vKipcbiAqIFB1bGwgb3V0IGtleXMgZnJvbSBhIHJlZ2V4cC5cbiAqXG4gKiBAcGFyYW0gIHshUmVnRXhwfSBwYXRoXG4gKiBAcGFyYW0gIHshQXJyYXl9ICBrZXlzXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiByZWdleHBUb1JlZ2V4cCAocGF0aCwga2V5cykge1xuICAvLyBVc2UgYSBuZWdhdGl2ZSBsb29rYWhlYWQgdG8gbWF0Y2ggb25seSBjYXB0dXJpbmcgZ3JvdXBzLlxuICB2YXIgZ3JvdXBzID0gcGF0aC5zb3VyY2UubWF0Y2goL1xcKCg/IVxcPykvZyk7XG5cbiAgaWYgKGdyb3Vwcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXlzLnB1c2goe1xuICAgICAgICBuYW1lOiBpLFxuICAgICAgICBwcmVmaXg6IG51bGwsXG4gICAgICAgIGRlbGltaXRlcjogbnVsbCxcbiAgICAgICAgb3B0aW9uYWw6IGZhbHNlLFxuICAgICAgICByZXBlYXQ6IGZhbHNlLFxuICAgICAgICBwYXJ0aWFsOiBmYWxzZSxcbiAgICAgICAgYXN0ZXJpc2s6IGZhbHNlLFxuICAgICAgICBwYXR0ZXJuOiBudWxsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYXR0YWNoS2V5cyhwYXRoLCBrZXlzKVxufVxuXG4vKipcbiAqIFRyYW5zZm9ybSBhbiBhcnJheSBpbnRvIGEgcmVnZXhwLlxuICpcbiAqIEBwYXJhbSAgeyFBcnJheX0gIHBhdGhcbiAqIEBwYXJhbSAge0FycmF5fSAgIGtleXNcbiAqIEBwYXJhbSAgeyFPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIGFycmF5VG9SZWdleHAgKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgdmFyIHBhcnRzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgcGFydHMucHVzaChwYXRoVG9SZWdleHAocGF0aFtpXSwga2V5cywgb3B0aW9ucykuc291cmNlKTtcbiAgfVxuXG4gIHZhciByZWdleHAgPSBuZXcgUmVnRXhwKCcoPzonICsgcGFydHMuam9pbignfCcpICsgJyknLCBmbGFncyhvcHRpb25zKSk7XG5cbiAgcmV0dXJuIGF0dGFjaEtleXMocmVnZXhwLCBrZXlzKVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIHBhdGggcmVnZXhwIGZyb20gc3RyaW5nIGlucHV0LlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gIHBhdGhcbiAqIEBwYXJhbSAgeyFBcnJheX0gIGtleXNcbiAqIEBwYXJhbSAgeyFPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1RvUmVnZXhwIChwYXRoLCBrZXlzLCBvcHRpb25zKSB7XG4gIHJldHVybiB0b2tlbnNUb1JlZ0V4cChwYXJzZShwYXRoLCBvcHRpb25zKSwga2V5cywgb3B0aW9ucylcbn1cblxuLyoqXG4gKiBFeHBvc2UgYSBmdW5jdGlvbiBmb3IgdGFraW5nIHRva2VucyBhbmQgcmV0dXJuaW5nIGEgUmVnRXhwLlxuICpcbiAqIEBwYXJhbSAgeyFBcnJheX0gICAgICAgICAgdG9rZW5zXG4gKiBAcGFyYW0gIHsoQXJyYXl8T2JqZWN0KT19IGtleXNcbiAqIEBwYXJhbSAge09iamVjdD19ICAgICAgICAgb3B0aW9uc1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gdG9rZW5zVG9SZWdFeHAgKHRva2Vucywga2V5cywgb3B0aW9ucykge1xuICBpZiAoIWlzYXJyYXkoa2V5cykpIHtcbiAgICBvcHRpb25zID0gLyoqIEB0eXBlIHshT2JqZWN0fSAqLyAoa2V5cyB8fCBvcHRpb25zKTtcbiAgICBrZXlzID0gW107XG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgc3RyaWN0ID0gb3B0aW9ucy5zdHJpY3Q7XG4gIHZhciBlbmQgPSBvcHRpb25zLmVuZCAhPT0gZmFsc2U7XG4gIHZhciByb3V0ZSA9ICcnO1xuXG4gIC8vIEl0ZXJhdGUgb3ZlciB0aGUgdG9rZW5zIGFuZCBjcmVhdGUgb3VyIHJlZ2V4cCBzdHJpbmcuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJvdXRlICs9IGVzY2FwZVN0cmluZyh0b2tlbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwcmVmaXggPSBlc2NhcGVTdHJpbmcodG9rZW4ucHJlZml4KTtcbiAgICAgIHZhciBjYXB0dXJlID0gJyg/OicgKyB0b2tlbi5wYXR0ZXJuICsgJyknO1xuXG4gICAgICBrZXlzLnB1c2godG9rZW4pO1xuXG4gICAgICBpZiAodG9rZW4ucmVwZWF0KSB7XG4gICAgICAgIGNhcHR1cmUgKz0gJyg/OicgKyBwcmVmaXggKyBjYXB0dXJlICsgJykqJztcbiAgICAgIH1cblxuICAgICAgaWYgKHRva2VuLm9wdGlvbmFsKSB7XG4gICAgICAgIGlmICghdG9rZW4ucGFydGlhbCkge1xuICAgICAgICAgIGNhcHR1cmUgPSAnKD86JyArIHByZWZpeCArICcoJyArIGNhcHR1cmUgKyAnKSk/JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYXB0dXJlID0gcHJlZml4ICsgJygnICsgY2FwdHVyZSArICcpPyc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhcHR1cmUgPSBwcmVmaXggKyAnKCcgKyBjYXB0dXJlICsgJyknO1xuICAgICAgfVxuXG4gICAgICByb3V0ZSArPSBjYXB0dXJlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBkZWxpbWl0ZXIgPSBlc2NhcGVTdHJpbmcob3B0aW9ucy5kZWxpbWl0ZXIgfHwgJy8nKTtcbiAgdmFyIGVuZHNXaXRoRGVsaW1pdGVyID0gcm91dGUuc2xpY2UoLWRlbGltaXRlci5sZW5ndGgpID09PSBkZWxpbWl0ZXI7XG5cbiAgLy8gSW4gbm9uLXN0cmljdCBtb2RlIHdlIGFsbG93IGEgc2xhc2ggYXQgdGhlIGVuZCBvZiBtYXRjaC4gSWYgdGhlIHBhdGggdG9cbiAgLy8gbWF0Y2ggYWxyZWFkeSBlbmRzIHdpdGggYSBzbGFzaCwgd2UgcmVtb3ZlIGl0IGZvciBjb25zaXN0ZW5jeS4gVGhlIHNsYXNoXG4gIC8vIGlzIHZhbGlkIGF0IHRoZSBlbmQgb2YgYSBwYXRoIG1hdGNoLCBub3QgaW4gdGhlIG1pZGRsZS4gVGhpcyBpcyBpbXBvcnRhbnRcbiAgLy8gaW4gbm9uLWVuZGluZyBtb2RlLCB3aGVyZSBcIi90ZXN0L1wiIHNob3VsZG4ndCBtYXRjaCBcIi90ZXN0Ly9yb3V0ZVwiLlxuICBpZiAoIXN0cmljdCkge1xuICAgIHJvdXRlID0gKGVuZHNXaXRoRGVsaW1pdGVyID8gcm91dGUuc2xpY2UoMCwgLWRlbGltaXRlci5sZW5ndGgpIDogcm91dGUpICsgJyg/OicgKyBkZWxpbWl0ZXIgKyAnKD89JCkpPyc7XG4gIH1cblxuICBpZiAoZW5kKSB7XG4gICAgcm91dGUgKz0gJyQnO1xuICB9IGVsc2Uge1xuICAgIC8vIEluIG5vbi1lbmRpbmcgbW9kZSwgd2UgbmVlZCB0aGUgY2FwdHVyaW5nIGdyb3VwcyB0byBtYXRjaCBhcyBtdWNoIGFzXG4gICAgLy8gcG9zc2libGUgYnkgdXNpbmcgYSBwb3NpdGl2ZSBsb29rYWhlYWQgdG8gdGhlIGVuZCBvciBuZXh0IHBhdGggc2VnbWVudC5cbiAgICByb3V0ZSArPSBzdHJpY3QgJiYgZW5kc1dpdGhEZWxpbWl0ZXIgPyAnJyA6ICcoPz0nICsgZGVsaW1pdGVyICsgJ3wkKSc7XG4gIH1cblxuICByZXR1cm4gYXR0YWNoS2V5cyhuZXcgUmVnRXhwKCdeJyArIHJvdXRlLCBmbGFncyhvcHRpb25zKSksIGtleXMpXG59XG5cbi8qKlxuICogTm9ybWFsaXplIHRoZSBnaXZlbiBwYXRoIHN0cmluZywgcmV0dXJuaW5nIGEgcmVndWxhciBleHByZXNzaW9uLlxuICpcbiAqIEFuIGVtcHR5IGFycmF5IGNhbiBiZSBwYXNzZWQgaW4gZm9yIHRoZSBrZXlzLCB3aGljaCB3aWxsIGhvbGQgdGhlXG4gKiBwbGFjZWhvbGRlciBrZXkgZGVzY3JpcHRpb25zLiBGb3IgZXhhbXBsZSwgdXNpbmcgYC91c2VyLzppZGAsIGBrZXlzYCB3aWxsXG4gKiBjb250YWluIGBbeyBuYW1lOiAnaWQnLCBkZWxpbWl0ZXI6ICcvJywgb3B0aW9uYWw6IGZhbHNlLCByZXBlYXQ6IGZhbHNlIH1dYC5cbiAqXG4gKiBAcGFyYW0gIHsoc3RyaW5nfFJlZ0V4cHxBcnJheSl9IHBhdGhcbiAqIEBwYXJhbSAgeyhBcnJheXxPYmplY3QpPX0gICAgICAga2V5c1xuICogQHBhcmFtICB7T2JqZWN0PX0gICAgICAgICAgICAgICBvcHRpb25zXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiBwYXRoVG9SZWdleHAgKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgaWYgKCFpc2FycmF5KGtleXMpKSB7XG4gICAgb3B0aW9ucyA9IC8qKiBAdHlwZSB7IU9iamVjdH0gKi8gKGtleXMgfHwgb3B0aW9ucyk7XG4gICAga2V5cyA9IFtdO1xuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgaWYgKHBhdGggaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gcmVnZXhwVG9SZWdleHAocGF0aCwgLyoqIEB0eXBlIHshQXJyYXl9ICovIChrZXlzKSlcbiAgfVxuXG4gIGlmIChpc2FycmF5KHBhdGgpKSB7XG4gICAgcmV0dXJuIGFycmF5VG9SZWdleHAoLyoqIEB0eXBlIHshQXJyYXl9ICovIChwYXRoKSwgLyoqIEB0eXBlIHshQXJyYXl9ICovIChrZXlzKSwgb3B0aW9ucylcbiAgfVxuXG4gIHJldHVybiBzdHJpbmdUb1JlZ2V4cCgvKiogQHR5cGUge3N0cmluZ30gKi8gKHBhdGgpLCAvKiogQHR5cGUgeyFBcnJheX0gKi8gKGtleXMpLCBvcHRpb25zKVxufVxucGF0aFRvUmVnZXhwXzEucGFyc2UgPSBwYXJzZV8xO1xucGF0aFRvUmVnZXhwXzEuY29tcGlsZSA9IGNvbXBpbGVfMTtcbnBhdGhUb1JlZ2V4cF8xLnRva2Vuc1RvRnVuY3Rpb24gPSB0b2tlbnNUb0Z1bmN0aW9uXzE7XG5wYXRoVG9SZWdleHBfMS50b2tlbnNUb1JlZ0V4cCA9IHRva2Vuc1RvUmVnRXhwXzE7XG5cbi8qICAqL1xuXG4vLyAkZmxvdy1kaXNhYmxlLWxpbmVcbnZhciByZWdleHBDb21waWxlQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5mdW5jdGlvbiBmaWxsUGFyYW1zIChcbiAgcGF0aCxcbiAgcGFyYW1zLFxuICByb3V0ZU1zZ1xuKSB7XG4gIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgdHJ5IHtcbiAgICB2YXIgZmlsbGVyID1cbiAgICAgIHJlZ2V4cENvbXBpbGVDYWNoZVtwYXRoXSB8fFxuICAgICAgKHJlZ2V4cENvbXBpbGVDYWNoZVtwYXRoXSA9IHBhdGhUb1JlZ2V4cF8xLmNvbXBpbGUocGF0aCkpO1xuXG4gICAgLy8gRml4ICMyNTA1IHJlc29sdmluZyBhc3RlcmlzayByb3V0ZXMgeyBuYW1lOiAnbm90LWZvdW5kJywgcGFyYW1zOiB7IHBhdGhNYXRjaDogJy9ub3QtZm91bmQnIH19XG4gICAgLy8gYW5kIGZpeCAjMzEwNiBzbyB0aGF0IHlvdSBjYW4gd29yayB3aXRoIGxvY2F0aW9uIGRlc2NyaXB0b3Igb2JqZWN0IGhhdmluZyBwYXJhbXMucGF0aE1hdGNoIGVxdWFsIHRvIGVtcHR5IHN0cmluZ1xuICAgIGlmICh0eXBlb2YgcGFyYW1zLnBhdGhNYXRjaCA9PT0gJ3N0cmluZycpIHsgcGFyYW1zWzBdID0gcGFyYW1zLnBhdGhNYXRjaDsgfVxuXG4gICAgcmV0dXJuIGZpbGxlcihwYXJhbXMsIHsgcHJldHR5OiB0cnVlIH0pXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gRml4ICMzMDcyIG5vIHdhcm4gaWYgYHBhdGhNYXRjaGAgaXMgc3RyaW5nXG4gICAgICB3YXJuKHR5cGVvZiBwYXJhbXMucGF0aE1hdGNoID09PSAnc3RyaW5nJywgKFwibWlzc2luZyBwYXJhbSBmb3IgXCIgKyByb3V0ZU1zZyArIFwiOiBcIiArIChlLm1lc3NhZ2UpKSk7XG4gICAgfVxuICAgIHJldHVybiAnJ1xuICB9IGZpbmFsbHkge1xuICAgIC8vIGRlbGV0ZSB0aGUgMCBpZiBpdCB3YXMgYWRkZWRcbiAgICBkZWxldGUgcGFyYW1zWzBdO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBub3JtYWxpemVMb2NhdGlvbiAoXG4gIHJhdyxcbiAgY3VycmVudCxcbiAgYXBwZW5kLFxuICByb3V0ZXJcbikge1xuICB2YXIgbmV4dCA9IHR5cGVvZiByYXcgPT09ICdzdHJpbmcnID8geyBwYXRoOiByYXcgfSA6IHJhdztcbiAgLy8gbmFtZWQgdGFyZ2V0XG4gIGlmIChuZXh0Ll9ub3JtYWxpemVkKSB7XG4gICAgcmV0dXJuIG5leHRcbiAgfSBlbHNlIGlmIChuZXh0Lm5hbWUpIHtcbiAgICBuZXh0ID0gZXh0ZW5kKHt9LCByYXcpO1xuICAgIHZhciBwYXJhbXMgPSBuZXh0LnBhcmFtcztcbiAgICBpZiAocGFyYW1zICYmIHR5cGVvZiBwYXJhbXMgPT09ICdvYmplY3QnKSB7XG4gICAgICBuZXh0LnBhcmFtcyA9IGV4dGVuZCh7fSwgcGFyYW1zKTtcbiAgICB9XG4gICAgcmV0dXJuIG5leHRcbiAgfVxuXG4gIC8vIHJlbGF0aXZlIHBhcmFtc1xuICBpZiAoIW5leHQucGF0aCAmJiBuZXh0LnBhcmFtcyAmJiBjdXJyZW50KSB7XG4gICAgbmV4dCA9IGV4dGVuZCh7fSwgbmV4dCk7XG4gICAgbmV4dC5fbm9ybWFsaXplZCA9IHRydWU7XG4gICAgdmFyIHBhcmFtcyQxID0gZXh0ZW5kKGV4dGVuZCh7fSwgY3VycmVudC5wYXJhbXMpLCBuZXh0LnBhcmFtcyk7XG4gICAgaWYgKGN1cnJlbnQubmFtZSkge1xuICAgICAgbmV4dC5uYW1lID0gY3VycmVudC5uYW1lO1xuICAgICAgbmV4dC5wYXJhbXMgPSBwYXJhbXMkMTtcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnQubWF0Y2hlZC5sZW5ndGgpIHtcbiAgICAgIHZhciByYXdQYXRoID0gY3VycmVudC5tYXRjaGVkW2N1cnJlbnQubWF0Y2hlZC5sZW5ndGggLSAxXS5wYXRoO1xuICAgICAgbmV4dC5wYXRoID0gZmlsbFBhcmFtcyhyYXdQYXRoLCBwYXJhbXMkMSwgKFwicGF0aCBcIiArIChjdXJyZW50LnBhdGgpKSk7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuKGZhbHNlLCBcInJlbGF0aXZlIHBhcmFtcyBuYXZpZ2F0aW9uIHJlcXVpcmVzIGEgY3VycmVudCByb3V0ZS5cIik7XG4gICAgfVxuICAgIHJldHVybiBuZXh0XG4gIH1cblxuICB2YXIgcGFyc2VkUGF0aCA9IHBhcnNlUGF0aChuZXh0LnBhdGggfHwgJycpO1xuICB2YXIgYmFzZVBhdGggPSAoY3VycmVudCAmJiBjdXJyZW50LnBhdGgpIHx8ICcvJztcbiAgdmFyIHBhdGggPSBwYXJzZWRQYXRoLnBhdGhcbiAgICA/IHJlc29sdmVQYXRoKHBhcnNlZFBhdGgucGF0aCwgYmFzZVBhdGgsIGFwcGVuZCB8fCBuZXh0LmFwcGVuZClcbiAgICA6IGJhc2VQYXRoO1xuXG4gIHZhciBxdWVyeSA9IHJlc29sdmVRdWVyeShcbiAgICBwYXJzZWRQYXRoLnF1ZXJ5LFxuICAgIG5leHQucXVlcnksXG4gICAgcm91dGVyICYmIHJvdXRlci5vcHRpb25zLnBhcnNlUXVlcnlcbiAgKTtcblxuICB2YXIgaGFzaCA9IG5leHQuaGFzaCB8fCBwYXJzZWRQYXRoLmhhc2g7XG4gIGlmIChoYXNoICYmIGhhc2guY2hhckF0KDApICE9PSAnIycpIHtcbiAgICBoYXNoID0gXCIjXCIgKyBoYXNoO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBfbm9ybWFsaXplZDogdHJ1ZSxcbiAgICBwYXRoOiBwYXRoLFxuICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICBoYXNoOiBoYXNoXG4gIH1cbn1cblxuLyogICovXG5cbi8vIHdvcmsgYXJvdW5kIHdlaXJkIGZsb3cgYnVnXG52YXIgdG9UeXBlcyA9IFtTdHJpbmcsIE9iamVjdF07XG52YXIgZXZlbnRUeXBlcyA9IFtTdHJpbmcsIEFycmF5XTtcblxudmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7fTtcblxudmFyIHdhcm5lZEN1c3RvbVNsb3Q7XG52YXIgd2FybmVkVGFnUHJvcDtcbnZhciB3YXJuZWRFdmVudFByb3A7XG5cbnZhciBMaW5rID0ge1xuICBuYW1lOiAnUm91dGVyTGluaycsXG4gIHByb3BzOiB7XG4gICAgdG86IHtcbiAgICAgIHR5cGU6IHRvVHlwZXMsXG4gICAgICByZXF1aXJlZDogdHJ1ZVxuICAgIH0sXG4gICAgdGFnOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnYSdcbiAgICB9LFxuICAgIGN1c3RvbTogQm9vbGVhbixcbiAgICBleGFjdDogQm9vbGVhbixcbiAgICBleGFjdFBhdGg6IEJvb2xlYW4sXG4gICAgYXBwZW5kOiBCb29sZWFuLFxuICAgIHJlcGxhY2U6IEJvb2xlYW4sXG4gICAgYWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgICBleGFjdEFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gICAgYXJpYUN1cnJlbnRWYWx1ZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ3BhZ2UnXG4gICAgfSxcbiAgICBldmVudDoge1xuICAgICAgdHlwZTogZXZlbnRUeXBlcyxcbiAgICAgIGRlZmF1bHQ6ICdjbGljaydcbiAgICB9XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgcm91dGVyID0gdGhpcy4kcm91dGVyO1xuICAgIHZhciBjdXJyZW50ID0gdGhpcy4kcm91dGU7XG4gICAgdmFyIHJlZiA9IHJvdXRlci5yZXNvbHZlKFxuICAgICAgdGhpcy50byxcbiAgICAgIGN1cnJlbnQsXG4gICAgICB0aGlzLmFwcGVuZFxuICAgICk7XG4gICAgdmFyIGxvY2F0aW9uID0gcmVmLmxvY2F0aW9uO1xuICAgIHZhciByb3V0ZSA9IHJlZi5yb3V0ZTtcbiAgICB2YXIgaHJlZiA9IHJlZi5ocmVmO1xuXG4gICAgdmFyIGNsYXNzZXMgPSB7fTtcbiAgICB2YXIgZ2xvYmFsQWN0aXZlQ2xhc3MgPSByb3V0ZXIub3B0aW9ucy5saW5rQWN0aXZlQ2xhc3M7XG4gICAgdmFyIGdsb2JhbEV4YWN0QWN0aXZlQ2xhc3MgPSByb3V0ZXIub3B0aW9ucy5saW5rRXhhY3RBY3RpdmVDbGFzcztcbiAgICAvLyBTdXBwb3J0IGdsb2JhbCBlbXB0eSBhY3RpdmUgY2xhc3NcbiAgICB2YXIgYWN0aXZlQ2xhc3NGYWxsYmFjayA9XG4gICAgICBnbG9iYWxBY3RpdmVDbGFzcyA9PSBudWxsID8gJ3JvdXRlci1saW5rLWFjdGl2ZScgOiBnbG9iYWxBY3RpdmVDbGFzcztcbiAgICB2YXIgZXhhY3RBY3RpdmVDbGFzc0ZhbGxiYWNrID1cbiAgICAgIGdsb2JhbEV4YWN0QWN0aXZlQ2xhc3MgPT0gbnVsbFxuICAgICAgICA/ICdyb3V0ZXItbGluay1leGFjdC1hY3RpdmUnXG4gICAgICAgIDogZ2xvYmFsRXhhY3RBY3RpdmVDbGFzcztcbiAgICB2YXIgYWN0aXZlQ2xhc3MgPVxuICAgICAgdGhpcy5hY3RpdmVDbGFzcyA9PSBudWxsID8gYWN0aXZlQ2xhc3NGYWxsYmFjayA6IHRoaXMuYWN0aXZlQ2xhc3M7XG4gICAgdmFyIGV4YWN0QWN0aXZlQ2xhc3MgPVxuICAgICAgdGhpcy5leGFjdEFjdGl2ZUNsYXNzID09IG51bGxcbiAgICAgICAgPyBleGFjdEFjdGl2ZUNsYXNzRmFsbGJhY2tcbiAgICAgICAgOiB0aGlzLmV4YWN0QWN0aXZlQ2xhc3M7XG5cbiAgICB2YXIgY29tcGFyZVRhcmdldCA9IHJvdXRlLnJlZGlyZWN0ZWRGcm9tXG4gICAgICA/IGNyZWF0ZVJvdXRlKG51bGwsIG5vcm1hbGl6ZUxvY2F0aW9uKHJvdXRlLnJlZGlyZWN0ZWRGcm9tKSwgbnVsbCwgcm91dGVyKVxuICAgICAgOiByb3V0ZTtcblxuICAgIGNsYXNzZXNbZXhhY3RBY3RpdmVDbGFzc10gPSBpc1NhbWVSb3V0ZShjdXJyZW50LCBjb21wYXJlVGFyZ2V0LCB0aGlzLmV4YWN0UGF0aCk7XG4gICAgY2xhc3Nlc1thY3RpdmVDbGFzc10gPSB0aGlzLmV4YWN0IHx8IHRoaXMuZXhhY3RQYXRoXG4gICAgICA/IGNsYXNzZXNbZXhhY3RBY3RpdmVDbGFzc11cbiAgICAgIDogaXNJbmNsdWRlZFJvdXRlKGN1cnJlbnQsIGNvbXBhcmVUYXJnZXQpO1xuXG4gICAgdmFyIGFyaWFDdXJyZW50VmFsdWUgPSBjbGFzc2VzW2V4YWN0QWN0aXZlQ2xhc3NdID8gdGhpcy5hcmlhQ3VycmVudFZhbHVlIDogbnVsbDtcblxuICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChndWFyZEV2ZW50KGUpKSB7XG4gICAgICAgIGlmICh0aGlzJDEucmVwbGFjZSkge1xuICAgICAgICAgIHJvdXRlci5yZXBsYWNlKGxvY2F0aW9uLCBub29wKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByb3V0ZXIucHVzaChsb2NhdGlvbiwgbm9vcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIG9uID0geyBjbGljazogZ3VhcmRFdmVudCB9O1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuZXZlbnQpKSB7XG4gICAgICB0aGlzLmV2ZW50LmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgb25bZV0gPSBoYW5kbGVyO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9uW3RoaXMuZXZlbnRdID0gaGFuZGxlcjtcbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IHsgY2xhc3M6IGNsYXNzZXMgfTtcblxuICAgIHZhciBzY29wZWRTbG90ID1cbiAgICAgICF0aGlzLiRzY29wZWRTbG90cy4kaGFzTm9ybWFsICYmXG4gICAgICB0aGlzLiRzY29wZWRTbG90cy5kZWZhdWx0ICYmXG4gICAgICB0aGlzLiRzY29wZWRTbG90cy5kZWZhdWx0KHtcbiAgICAgICAgaHJlZjogaHJlZixcbiAgICAgICAgcm91dGU6IHJvdXRlLFxuICAgICAgICBuYXZpZ2F0ZTogaGFuZGxlcixcbiAgICAgICAgaXNBY3RpdmU6IGNsYXNzZXNbYWN0aXZlQ2xhc3NdLFxuICAgICAgICBpc0V4YWN0QWN0aXZlOiBjbGFzc2VzW2V4YWN0QWN0aXZlQ2xhc3NdXG4gICAgICB9KTtcblxuICAgIGlmIChzY29wZWRTbG90KSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhdGhpcy5jdXN0b20pIHtcbiAgICAgICAgIXdhcm5lZEN1c3RvbVNsb3QgJiYgd2FybihmYWxzZSwgJ0luIFZ1ZSBSb3V0ZXIgNCwgdGhlIHYtc2xvdCBBUEkgd2lsbCBieSBkZWZhdWx0IHdyYXAgaXRzIGNvbnRlbnQgd2l0aCBhbiA8YT4gZWxlbWVudC4gVXNlIHRoZSBjdXN0b20gcHJvcCB0byByZW1vdmUgdGhpcyB3YXJuaW5nOlxcbjxyb3V0ZXItbGluayB2LXNsb3Q9XCJ7IG5hdmlnYXRlLCBocmVmIH1cIiBjdXN0b20+PC9yb3V0ZXItbGluaz5cXG4nKTtcbiAgICAgICAgd2FybmVkQ3VzdG9tU2xvdCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoc2NvcGVkU2xvdC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHNjb3BlZFNsb3RbMF1cbiAgICAgIH0gZWxzZSBpZiAoc2NvcGVkU2xvdC5sZW5ndGggPiAxIHx8ICFzY29wZWRTbG90Lmxlbmd0aCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgIChcIjxyb3V0ZXItbGluaz4gd2l0aCB0bz1cXFwiXCIgKyAodGhpcy50bykgKyBcIlxcXCIgaXMgdHJ5aW5nIHRvIHVzZSBhIHNjb3BlZCBzbG90IGJ1dCBpdCBkaWRuJ3QgcHJvdmlkZSBleGFjdGx5IG9uZSBjaGlsZC4gV3JhcHBpbmcgdGhlIGNvbnRlbnQgd2l0aCBhIHNwYW4gZWxlbWVudC5cIilcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzY29wZWRTbG90Lmxlbmd0aCA9PT0gMCA/IGgoKSA6IGgoJ3NwYW4nLCB7fSwgc2NvcGVkU2xvdClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCd0YWcnIGluIHRoaXMuJG9wdGlvbnMucHJvcHNEYXRhICYmICF3YXJuZWRUYWdQcm9wKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgXCI8cm91dGVyLWxpbms+J3MgdGFnIHByb3AgaXMgZGVwcmVjYXRlZCBhbmQgaGFzIGJlZW4gcmVtb3ZlZCBpbiBWdWUgUm91dGVyIDQuIFVzZSB0aGUgdi1zbG90IEFQSSB0byByZW1vdmUgdGhpcyB3YXJuaW5nOiBodHRwczovL25leHQucm91dGVyLnZ1ZWpzLm9yZy9ndWlkZS9taWdyYXRpb24vI3JlbW92YWwtb2YtZXZlbnQtYW5kLXRhZy1wcm9wcy1pbi1yb3V0ZXItbGluay5cIlxuICAgICAgICApO1xuICAgICAgICB3YXJuZWRUYWdQcm9wID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICgnZXZlbnQnIGluIHRoaXMuJG9wdGlvbnMucHJvcHNEYXRhICYmICF3YXJuZWRFdmVudFByb3ApIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICBcIjxyb3V0ZXItbGluaz4ncyBldmVudCBwcm9wIGlzIGRlcHJlY2F0ZWQgYW5kIGhhcyBiZWVuIHJlbW92ZWQgaW4gVnVlIFJvdXRlciA0LiBVc2UgdGhlIHYtc2xvdCBBUEkgdG8gcmVtb3ZlIHRoaXMgd2FybmluZzogaHR0cHM6Ly9uZXh0LnJvdXRlci52dWVqcy5vcmcvZ3VpZGUvbWlncmF0aW9uLyNyZW1vdmFsLW9mLWV2ZW50LWFuZC10YWctcHJvcHMtaW4tcm91dGVyLWxpbmsuXCJcbiAgICAgICAgKTtcbiAgICAgICAgd2FybmVkRXZlbnRQcm9wID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy50YWcgPT09ICdhJykge1xuICAgICAgZGF0YS5vbiA9IG9uO1xuICAgICAgZGF0YS5hdHRycyA9IHsgaHJlZjogaHJlZiwgJ2FyaWEtY3VycmVudCc6IGFyaWFDdXJyZW50VmFsdWUgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZmluZCB0aGUgZmlyc3QgPGE+IGNoaWxkIGFuZCBhcHBseSBsaXN0ZW5lciBhbmQgaHJlZlxuICAgICAgdmFyIGEgPSBmaW5kQW5jaG9yKHRoaXMuJHNsb3RzLmRlZmF1bHQpO1xuICAgICAgaWYgKGEpIHtcbiAgICAgICAgLy8gaW4gY2FzZSB0aGUgPGE+IGlzIGEgc3RhdGljIG5vZGVcbiAgICAgICAgYS5pc1N0YXRpYyA9IGZhbHNlO1xuICAgICAgICB2YXIgYURhdGEgPSAoYS5kYXRhID0gZXh0ZW5kKHt9LCBhLmRhdGEpKTtcbiAgICAgICAgYURhdGEub24gPSBhRGF0YS5vbiB8fCB7fTtcbiAgICAgICAgLy8gdHJhbnNmb3JtIGV4aXN0aW5nIGV2ZW50cyBpbiBib3RoIG9iamVjdHMgaW50byBhcnJheXMgc28gd2UgY2FuIHB1c2ggbGF0ZXJcbiAgICAgICAgZm9yICh2YXIgZXZlbnQgaW4gYURhdGEub24pIHtcbiAgICAgICAgICB2YXIgaGFuZGxlciQxID0gYURhdGEub25bZXZlbnRdO1xuICAgICAgICAgIGlmIChldmVudCBpbiBvbikge1xuICAgICAgICAgICAgYURhdGEub25bZXZlbnRdID0gQXJyYXkuaXNBcnJheShoYW5kbGVyJDEpID8gaGFuZGxlciQxIDogW2hhbmRsZXIkMV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGFwcGVuZCBuZXcgbGlzdGVuZXJzIGZvciByb3V0ZXItbGlua1xuICAgICAgICBmb3IgKHZhciBldmVudCQxIGluIG9uKSB7XG4gICAgICAgICAgaWYgKGV2ZW50JDEgaW4gYURhdGEub24pIHtcbiAgICAgICAgICAgIC8vIG9uW2V2ZW50XSBpcyBhbHdheXMgYSBmdW5jdGlvblxuICAgICAgICAgICAgYURhdGEub25bZXZlbnQkMV0ucHVzaChvbltldmVudCQxXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFEYXRhLm9uW2V2ZW50JDFdID0gaGFuZGxlcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYUF0dHJzID0gKGEuZGF0YS5hdHRycyA9IGV4dGVuZCh7fSwgYS5kYXRhLmF0dHJzKSk7XG4gICAgICAgIGFBdHRycy5ocmVmID0gaHJlZjtcbiAgICAgICAgYUF0dHJzWydhcmlhLWN1cnJlbnQnXSA9IGFyaWFDdXJyZW50VmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkb2Vzbid0IGhhdmUgPGE+IGNoaWxkLCBhcHBseSBsaXN0ZW5lciB0byBzZWxmXG4gICAgICAgIGRhdGEub24gPSBvbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaCh0aGlzLnRhZywgZGF0YSwgdGhpcy4kc2xvdHMuZGVmYXVsdClcbiAgfVxufTtcblxuZnVuY3Rpb24gZ3VhcmRFdmVudCAoZSkge1xuICAvLyBkb24ndCByZWRpcmVjdCB3aXRoIGNvbnRyb2wga2V5c1xuICBpZiAoZS5tZXRhS2V5IHx8IGUuYWx0S2V5IHx8IGUuY3RybEtleSB8fCBlLnNoaWZ0S2V5KSB7IHJldHVybiB9XG4gIC8vIGRvbid0IHJlZGlyZWN0IHdoZW4gcHJldmVudERlZmF1bHQgY2FsbGVkXG4gIGlmIChlLmRlZmF1bHRQcmV2ZW50ZWQpIHsgcmV0dXJuIH1cbiAgLy8gZG9uJ3QgcmVkaXJlY3Qgb24gcmlnaHQgY2xpY2tcbiAgaWYgKGUuYnV0dG9uICE9PSB1bmRlZmluZWQgJiYgZS5idXR0b24gIT09IDApIHsgcmV0dXJuIH1cbiAgLy8gZG9uJ3QgcmVkaXJlY3QgaWYgYHRhcmdldD1cIl9ibGFua1wiYFxuICBpZiAoZS5jdXJyZW50VGFyZ2V0ICYmIGUuY3VycmVudFRhcmdldC5nZXRBdHRyaWJ1dGUpIHtcbiAgICB2YXIgdGFyZ2V0ID0gZS5jdXJyZW50VGFyZ2V0LmdldEF0dHJpYnV0ZSgndGFyZ2V0Jyk7XG4gICAgaWYgKC9cXGJfYmxhbmtcXGIvaS50ZXN0KHRhcmdldCkpIHsgcmV0dXJuIH1cbiAgfVxuICAvLyB0aGlzIG1heSBiZSBhIFdlZXggZXZlbnQgd2hpY2ggZG9lc24ndCBoYXZlIHRoaXMgbWV0aG9kXG4gIGlmIChlLnByZXZlbnREZWZhdWx0KSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIGZpbmRBbmNob3IgKGNoaWxkcmVuKSB7XG4gIGlmIChjaGlsZHJlbikge1xuICAgIHZhciBjaGlsZDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gJ2EnKSB7XG4gICAgICAgIHJldHVybiBjaGlsZFxuICAgICAgfVxuICAgICAgaWYgKGNoaWxkLmNoaWxkcmVuICYmIChjaGlsZCA9IGZpbmRBbmNob3IoY2hpbGQuY2hpbGRyZW4pKSkge1xuICAgICAgICByZXR1cm4gY2hpbGRcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIF9WdWU7XG5cbmZ1bmN0aW9uIGluc3RhbGwgKFZ1ZSkge1xuICBpZiAoaW5zdGFsbC5pbnN0YWxsZWQgJiYgX1Z1ZSA9PT0gVnVlKSB7IHJldHVybiB9XG4gIGluc3RhbGwuaW5zdGFsbGVkID0gdHJ1ZTtcblxuICBfVnVlID0gVnVlO1xuXG4gIHZhciBpc0RlZiA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiB2ICE9PSB1bmRlZmluZWQ7IH07XG5cbiAgdmFyIHJlZ2lzdGVySW5zdGFuY2UgPSBmdW5jdGlvbiAodm0sIGNhbGxWYWwpIHtcbiAgICB2YXIgaSA9IHZtLiRvcHRpb25zLl9wYXJlbnRWbm9kZTtcbiAgICBpZiAoaXNEZWYoaSkgJiYgaXNEZWYoaSA9IGkuZGF0YSkgJiYgaXNEZWYoaSA9IGkucmVnaXN0ZXJSb3V0ZUluc3RhbmNlKSkge1xuICAgICAgaSh2bSwgY2FsbFZhbCk7XG4gICAgfVxuICB9O1xuXG4gIFZ1ZS5taXhpbih7XG4gICAgYmVmb3JlQ3JlYXRlOiBmdW5jdGlvbiBiZWZvcmVDcmVhdGUgKCkge1xuICAgICAgaWYgKGlzRGVmKHRoaXMuJG9wdGlvbnMucm91dGVyKSkge1xuICAgICAgICB0aGlzLl9yb3V0ZXJSb290ID0gdGhpcztcbiAgICAgICAgdGhpcy5fcm91dGVyID0gdGhpcy4kb3B0aW9ucy5yb3V0ZXI7XG4gICAgICAgIHRoaXMuX3JvdXRlci5pbml0KHRoaXMpO1xuICAgICAgICBWdWUudXRpbC5kZWZpbmVSZWFjdGl2ZSh0aGlzLCAnX3JvdXRlJywgdGhpcy5fcm91dGVyLmhpc3RvcnkuY3VycmVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9yb3V0ZXJSb290ID0gKHRoaXMuJHBhcmVudCAmJiB0aGlzLiRwYXJlbnQuX3JvdXRlclJvb3QpIHx8IHRoaXM7XG4gICAgICB9XG4gICAgICByZWdpc3Rlckluc3RhbmNlKHRoaXMsIHRoaXMpO1xuICAgIH0sXG4gICAgZGVzdHJveWVkOiBmdW5jdGlvbiBkZXN0cm95ZWQgKCkge1xuICAgICAgcmVnaXN0ZXJJbnN0YW5jZSh0aGlzKTtcbiAgICB9XG4gIH0pO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJHJvdXRlcicsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7IHJldHVybiB0aGlzLl9yb3V0ZXJSb290Ll9yb3V0ZXIgfVxuICB9KTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRyb3V0ZScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7IHJldHVybiB0aGlzLl9yb3V0ZXJSb290Ll9yb3V0ZSB9XG4gIH0pO1xuXG4gIFZ1ZS5jb21wb25lbnQoJ1JvdXRlclZpZXcnLCBWaWV3KTtcbiAgVnVlLmNvbXBvbmVudCgnUm91dGVyTGluaycsIExpbmspO1xuXG4gIHZhciBzdHJhdHMgPSBWdWUuY29uZmlnLm9wdGlvbk1lcmdlU3RyYXRlZ2llcztcbiAgLy8gdXNlIHRoZSBzYW1lIGhvb2sgbWVyZ2luZyBzdHJhdGVneSBmb3Igcm91dGUgaG9va3NcbiAgc3RyYXRzLmJlZm9yZVJvdXRlRW50ZXIgPSBzdHJhdHMuYmVmb3JlUm91dGVMZWF2ZSA9IHN0cmF0cy5iZWZvcmVSb3V0ZVVwZGF0ZSA9IHN0cmF0cy5jcmVhdGVkO1xufVxuXG4vKiAgKi9cblxudmFyIGluQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gY3JlYXRlUm91dGVNYXAgKFxuICByb3V0ZXMsXG4gIG9sZFBhdGhMaXN0LFxuICBvbGRQYXRoTWFwLFxuICBvbGROYW1lTWFwLFxuICBwYXJlbnRSb3V0ZVxuKSB7XG4gIC8vIHRoZSBwYXRoIGxpc3QgaXMgdXNlZCB0byBjb250cm9sIHBhdGggbWF0Y2hpbmcgcHJpb3JpdHlcbiAgdmFyIHBhdGhMaXN0ID0gb2xkUGF0aExpc3QgfHwgW107XG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICB2YXIgcGF0aE1hcCA9IG9sZFBhdGhNYXAgfHwgT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIHZhciBuYW1lTWFwID0gb2xkTmFtZU1hcCB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIHJvdXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgIGFkZFJvdXRlUmVjb3JkKHBhdGhMaXN0LCBwYXRoTWFwLCBuYW1lTWFwLCByb3V0ZSwgcGFyZW50Um91dGUpO1xuICB9KTtcblxuICAvLyBlbnN1cmUgd2lsZGNhcmQgcm91dGVzIGFyZSBhbHdheXMgYXQgdGhlIGVuZFxuICBmb3IgKHZhciBpID0gMCwgbCA9IHBhdGhMaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChwYXRoTGlzdFtpXSA9PT0gJyonKSB7XG4gICAgICBwYXRoTGlzdC5wdXNoKHBhdGhMaXN0LnNwbGljZShpLCAxKVswXSk7XG4gICAgICBsLS07XG4gICAgICBpLS07XG4gICAgfVxuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgLy8gd2FybiBpZiByb3V0ZXMgZG8gbm90IGluY2x1ZGUgbGVhZGluZyBzbGFzaGVzXG4gICAgdmFyIGZvdW5kID0gcGF0aExpc3RcbiAgICAvLyBjaGVjayBmb3IgbWlzc2luZyBsZWFkaW5nIHNsYXNoXG4gICAgICAuZmlsdGVyKGZ1bmN0aW9uIChwYXRoKSB7IHJldHVybiBwYXRoICYmIHBhdGguY2hhckF0KDApICE9PSAnKicgJiYgcGF0aC5jaGFyQXQoMCkgIT09ICcvJzsgfSk7XG5cbiAgICBpZiAoZm91bmQubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIHBhdGhOYW1lcyA9IGZvdW5kLm1hcChmdW5jdGlvbiAocGF0aCkgeyByZXR1cm4gKFwiLSBcIiArIHBhdGgpOyB9KS5qb2luKCdcXG4nKTtcbiAgICAgIHdhcm4oZmFsc2UsIChcIk5vbi1uZXN0ZWQgcm91dGVzIG11c3QgaW5jbHVkZSBhIGxlYWRpbmcgc2xhc2ggY2hhcmFjdGVyLiBGaXggdGhlIGZvbGxvd2luZyByb3V0ZXM6IFxcblwiICsgcGF0aE5hbWVzKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwYXRoTGlzdDogcGF0aExpc3QsXG4gICAgcGF0aE1hcDogcGF0aE1hcCxcbiAgICBuYW1lTWFwOiBuYW1lTWFwXG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkUm91dGVSZWNvcmQgKFxuICBwYXRoTGlzdCxcbiAgcGF0aE1hcCxcbiAgbmFtZU1hcCxcbiAgcm91dGUsXG4gIHBhcmVudCxcbiAgbWF0Y2hBc1xuKSB7XG4gIHZhciBwYXRoID0gcm91dGUucGF0aDtcbiAgdmFyIG5hbWUgPSByb3V0ZS5uYW1lO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydChwYXRoICE9IG51bGwsIFwiXFxcInBhdGhcXFwiIGlzIHJlcXVpcmVkIGluIGEgcm91dGUgY29uZmlndXJhdGlvbi5cIik7XG4gICAgYXNzZXJ0KFxuICAgICAgdHlwZW9mIHJvdXRlLmNvbXBvbmVudCAhPT0gJ3N0cmluZycsXG4gICAgICBcInJvdXRlIGNvbmZpZyBcXFwiY29tcG9uZW50XFxcIiBmb3IgcGF0aDogXCIgKyAoU3RyaW5nKFxuICAgICAgICBwYXRoIHx8IG5hbWVcbiAgICAgICkpICsgXCIgY2Fubm90IGJlIGEgXCIgKyBcInN0cmluZyBpZC4gVXNlIGFuIGFjdHVhbCBjb21wb25lbnQgaW5zdGVhZC5cIlxuICAgICk7XG5cbiAgICB3YXJuKFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRyb2wtcmVnZXhcbiAgICAgICEvW15cXHUwMDAwLVxcdTAwN0ZdKy8udGVzdChwYXRoKSxcbiAgICAgIFwiUm91dGUgd2l0aCBwYXRoIFxcXCJcIiArIHBhdGggKyBcIlxcXCIgY29udGFpbnMgdW5lbmNvZGVkIGNoYXJhY3RlcnMsIG1ha2Ugc3VyZSBcIiArXG4gICAgICAgIFwieW91ciBwYXRoIGlzIGNvcnJlY3RseSBlbmNvZGVkIGJlZm9yZSBwYXNzaW5nIGl0IHRvIHRoZSByb3V0ZXIuIFVzZSBcIiArXG4gICAgICAgIFwiZW5jb2RlVVJJIHRvIGVuY29kZSBzdGF0aWMgc2VnbWVudHMgb2YgeW91ciBwYXRoLlwiXG4gICAgKTtcbiAgfVxuXG4gIHZhciBwYXRoVG9SZWdleHBPcHRpb25zID1cbiAgICByb3V0ZS5wYXRoVG9SZWdleHBPcHRpb25zIHx8IHt9O1xuICB2YXIgbm9ybWFsaXplZFBhdGggPSBub3JtYWxpemVQYXRoKHBhdGgsIHBhcmVudCwgcGF0aFRvUmVnZXhwT3B0aW9ucy5zdHJpY3QpO1xuXG4gIGlmICh0eXBlb2Ygcm91dGUuY2FzZVNlbnNpdGl2ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgcGF0aFRvUmVnZXhwT3B0aW9ucy5zZW5zaXRpdmUgPSByb3V0ZS5jYXNlU2Vuc2l0aXZlO1xuICB9XG5cbiAgdmFyIHJlY29yZCA9IHtcbiAgICBwYXRoOiBub3JtYWxpemVkUGF0aCxcbiAgICByZWdleDogY29tcGlsZVJvdXRlUmVnZXgobm9ybWFsaXplZFBhdGgsIHBhdGhUb1JlZ2V4cE9wdGlvbnMpLFxuICAgIGNvbXBvbmVudHM6IHJvdXRlLmNvbXBvbmVudHMgfHwgeyBkZWZhdWx0OiByb3V0ZS5jb21wb25lbnQgfSxcbiAgICBhbGlhczogcm91dGUuYWxpYXNcbiAgICAgID8gdHlwZW9mIHJvdXRlLmFsaWFzID09PSAnc3RyaW5nJ1xuICAgICAgICA/IFtyb3V0ZS5hbGlhc11cbiAgICAgICAgOiByb3V0ZS5hbGlhc1xuICAgICAgOiBbXSxcbiAgICBpbnN0YW5jZXM6IHt9LFxuICAgIGVudGVyZWRDYnM6IHt9LFxuICAgIG5hbWU6IG5hbWUsXG4gICAgcGFyZW50OiBwYXJlbnQsXG4gICAgbWF0Y2hBczogbWF0Y2hBcyxcbiAgICByZWRpcmVjdDogcm91dGUucmVkaXJlY3QsXG4gICAgYmVmb3JlRW50ZXI6IHJvdXRlLmJlZm9yZUVudGVyLFxuICAgIG1ldGE6IHJvdXRlLm1ldGEgfHwge30sXG4gICAgcHJvcHM6XG4gICAgICByb3V0ZS5wcm9wcyA9PSBudWxsXG4gICAgICAgID8ge31cbiAgICAgICAgOiByb3V0ZS5jb21wb25lbnRzXG4gICAgICAgICAgPyByb3V0ZS5wcm9wc1xuICAgICAgICAgIDogeyBkZWZhdWx0OiByb3V0ZS5wcm9wcyB9XG4gIH07XG5cbiAgaWYgKHJvdXRlLmNoaWxkcmVuKSB7XG4gICAgLy8gV2FybiBpZiByb3V0ZSBpcyBuYW1lZCwgZG9lcyBub3QgcmVkaXJlY3QgYW5kIGhhcyBhIGRlZmF1bHQgY2hpbGQgcm91dGUuXG4gICAgLy8gSWYgdXNlcnMgbmF2aWdhdGUgdG8gdGhpcyByb3V0ZSBieSBuYW1lLCB0aGUgZGVmYXVsdCBjaGlsZCB3aWxsXG4gICAgLy8gbm90IGJlIHJlbmRlcmVkIChHSCBJc3N1ZSAjNjI5KVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHJvdXRlLm5hbWUgJiZcbiAgICAgICAgIXJvdXRlLnJlZGlyZWN0ICYmXG4gICAgICAgIHJvdXRlLmNoaWxkcmVuLnNvbWUoZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiAvXlxcLz8kLy50ZXN0KGNoaWxkLnBhdGgpOyB9KVxuICAgICAgKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgXCJOYW1lZCBSb3V0ZSAnXCIgKyAocm91dGUubmFtZSkgKyBcIicgaGFzIGEgZGVmYXVsdCBjaGlsZCByb3V0ZS4gXCIgK1xuICAgICAgICAgICAgXCJXaGVuIG5hdmlnYXRpbmcgdG8gdGhpcyBuYW1lZCByb3V0ZSAoOnRvPVxcXCJ7bmFtZTogJ1wiICsgKHJvdXRlLm5hbWUpICsgXCInfVxcXCIpLCBcIiArXG4gICAgICAgICAgICBcInRoZSBkZWZhdWx0IGNoaWxkIHJvdXRlIHdpbGwgbm90IGJlIHJlbmRlcmVkLiBSZW1vdmUgdGhlIG5hbWUgZnJvbSBcIiArXG4gICAgICAgICAgICBcInRoaXMgcm91dGUgYW5kIHVzZSB0aGUgbmFtZSBvZiB0aGUgZGVmYXVsdCBjaGlsZCByb3V0ZSBmb3IgbmFtZWQgXCIgK1xuICAgICAgICAgICAgXCJsaW5rcyBpbnN0ZWFkLlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJvdXRlLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICB2YXIgY2hpbGRNYXRjaEFzID0gbWF0Y2hBc1xuICAgICAgICA/IGNsZWFuUGF0aCgobWF0Y2hBcyArIFwiL1wiICsgKGNoaWxkLnBhdGgpKSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICBhZGRSb3V0ZVJlY29yZChwYXRoTGlzdCwgcGF0aE1hcCwgbmFtZU1hcCwgY2hpbGQsIHJlY29yZCwgY2hpbGRNYXRjaEFzKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmICghcGF0aE1hcFtyZWNvcmQucGF0aF0pIHtcbiAgICBwYXRoTGlzdC5wdXNoKHJlY29yZC5wYXRoKTtcbiAgICBwYXRoTWFwW3JlY29yZC5wYXRoXSA9IHJlY29yZDtcbiAgfVxuXG4gIGlmIChyb3V0ZS5hbGlhcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGFsaWFzZXMgPSBBcnJheS5pc0FycmF5KHJvdXRlLmFsaWFzKSA/IHJvdXRlLmFsaWFzIDogW3JvdXRlLmFsaWFzXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsaWFzZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBhbGlhcyA9IGFsaWFzZXNbaV07XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBhbGlhcyA9PT0gcGF0aCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIChcIkZvdW5kIGFuIGFsaWFzIHdpdGggdGhlIHNhbWUgdmFsdWUgYXMgdGhlIHBhdGg6IFxcXCJcIiArIHBhdGggKyBcIlxcXCIuIFlvdSBoYXZlIHRvIHJlbW92ZSB0aGF0IGFsaWFzLiBJdCB3aWxsIGJlIGlnbm9yZWQgaW4gZGV2ZWxvcG1lbnQuXCIpXG4gICAgICAgICk7XG4gICAgICAgIC8vIHNraXAgaW4gZGV2IHRvIG1ha2UgaXQgd29ya1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICB2YXIgYWxpYXNSb3V0ZSA9IHtcbiAgICAgICAgcGF0aDogYWxpYXMsXG4gICAgICAgIGNoaWxkcmVuOiByb3V0ZS5jaGlsZHJlblxuICAgICAgfTtcbiAgICAgIGFkZFJvdXRlUmVjb3JkKFxuICAgICAgICBwYXRoTGlzdCxcbiAgICAgICAgcGF0aE1hcCxcbiAgICAgICAgbmFtZU1hcCxcbiAgICAgICAgYWxpYXNSb3V0ZSxcbiAgICAgICAgcGFyZW50LFxuICAgICAgICByZWNvcmQucGF0aCB8fCAnLycgLy8gbWF0Y2hBc1xuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBpZiAobmFtZSkge1xuICAgIGlmICghbmFtZU1hcFtuYW1lXSkge1xuICAgICAgbmFtZU1hcFtuYW1lXSA9IHJlY29yZDtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIW1hdGNoQXMpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBcIkR1cGxpY2F0ZSBuYW1lZCByb3V0ZXMgZGVmaW5pdGlvbjogXCIgK1xuICAgICAgICAgIFwieyBuYW1lOiBcXFwiXCIgKyBuYW1lICsgXCJcXFwiLCBwYXRoOiBcXFwiXCIgKyAocmVjb3JkLnBhdGgpICsgXCJcXFwiIH1cIlxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tcGlsZVJvdXRlUmVnZXggKFxuICBwYXRoLFxuICBwYXRoVG9SZWdleHBPcHRpb25zXG4pIHtcbiAgdmFyIHJlZ2V4ID0gcGF0aFRvUmVnZXhwXzEocGF0aCwgW10sIHBhdGhUb1JlZ2V4cE9wdGlvbnMpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICByZWdleC5rZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgd2FybihcbiAgICAgICAgIWtleXNba2V5Lm5hbWVdLFxuICAgICAgICAoXCJEdXBsaWNhdGUgcGFyYW0ga2V5cyBpbiByb3V0ZSB3aXRoIHBhdGg6IFxcXCJcIiArIHBhdGggKyBcIlxcXCJcIilcbiAgICAgICk7XG4gICAgICBrZXlzW2tleS5uYW1lXSA9IHRydWU7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJlZ2V4XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVBhdGggKFxuICBwYXRoLFxuICBwYXJlbnQsXG4gIHN0cmljdFxuKSB7XG4gIGlmICghc3RyaWN0KSB7IHBhdGggPSBwYXRoLnJlcGxhY2UoL1xcLyQvLCAnJyk7IH1cbiAgaWYgKHBhdGhbMF0gPT09ICcvJykgeyByZXR1cm4gcGF0aCB9XG4gIGlmIChwYXJlbnQgPT0gbnVsbCkgeyByZXR1cm4gcGF0aCB9XG4gIHJldHVybiBjbGVhblBhdGgoKChwYXJlbnQucGF0aCkgKyBcIi9cIiArIHBhdGgpKVxufVxuXG4vKiAgKi9cblxuXG5cbmZ1bmN0aW9uIGNyZWF0ZU1hdGNoZXIgKFxuICByb3V0ZXMsXG4gIHJvdXRlclxuKSB7XG4gIHZhciByZWYgPSBjcmVhdGVSb3V0ZU1hcChyb3V0ZXMpO1xuICB2YXIgcGF0aExpc3QgPSByZWYucGF0aExpc3Q7XG4gIHZhciBwYXRoTWFwID0gcmVmLnBhdGhNYXA7XG4gIHZhciBuYW1lTWFwID0gcmVmLm5hbWVNYXA7XG5cbiAgZnVuY3Rpb24gYWRkUm91dGVzIChyb3V0ZXMpIHtcbiAgICBjcmVhdGVSb3V0ZU1hcChyb3V0ZXMsIHBhdGhMaXN0LCBwYXRoTWFwLCBuYW1lTWFwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFJvdXRlIChwYXJlbnRPclJvdXRlLCByb3V0ZSkge1xuICAgIHZhciBwYXJlbnQgPSAodHlwZW9mIHBhcmVudE9yUm91dGUgIT09ICdvYmplY3QnKSA/IG5hbWVNYXBbcGFyZW50T3JSb3V0ZV0gOiB1bmRlZmluZWQ7XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgY3JlYXRlUm91dGVNYXAoW3JvdXRlIHx8IHBhcmVudE9yUm91dGVdLCBwYXRoTGlzdCwgcGF0aE1hcCwgbmFtZU1hcCwgcGFyZW50KTtcblxuICAgIC8vIGFkZCBhbGlhc2VzIG9mIHBhcmVudFxuICAgIGlmIChwYXJlbnQgJiYgcGFyZW50LmFsaWFzLmxlbmd0aCkge1xuICAgICAgY3JlYXRlUm91dGVNYXAoXG4gICAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZSByb3V0ZSBpcyBkZWZpbmVkIGlmIHBhcmVudCBpc1xuICAgICAgICBwYXJlbnQuYWxpYXMubWFwKGZ1bmN0aW9uIChhbGlhcykgeyByZXR1cm4gKHsgcGF0aDogYWxpYXMsIGNoaWxkcmVuOiBbcm91dGVdIH0pOyB9KSxcbiAgICAgICAgcGF0aExpc3QsXG4gICAgICAgIHBhdGhNYXAsXG4gICAgICAgIG5hbWVNYXAsXG4gICAgICAgIHBhcmVudFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRSb3V0ZXMgKCkge1xuICAgIHJldHVybiBwYXRoTGlzdC5tYXAoZnVuY3Rpb24gKHBhdGgpIHsgcmV0dXJuIHBhdGhNYXBbcGF0aF07IH0pXG4gIH1cblxuICBmdW5jdGlvbiBtYXRjaCAoXG4gICAgcmF3LFxuICAgIGN1cnJlbnRSb3V0ZSxcbiAgICByZWRpcmVjdGVkRnJvbVxuICApIHtcbiAgICB2YXIgbG9jYXRpb24gPSBub3JtYWxpemVMb2NhdGlvbihyYXcsIGN1cnJlbnRSb3V0ZSwgZmFsc2UsIHJvdXRlcik7XG4gICAgdmFyIG5hbWUgPSBsb2NhdGlvbi5uYW1lO1xuXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHZhciByZWNvcmQgPSBuYW1lTWFwW25hbWVdO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FybihyZWNvcmQsIChcIlJvdXRlIHdpdGggbmFtZSAnXCIgKyBuYW1lICsgXCInIGRvZXMgbm90IGV4aXN0XCIpKTtcbiAgICAgIH1cbiAgICAgIGlmICghcmVjb3JkKSB7IHJldHVybiBfY3JlYXRlUm91dGUobnVsbCwgbG9jYXRpb24pIH1cbiAgICAgIHZhciBwYXJhbU5hbWVzID0gcmVjb3JkLnJlZ2V4LmtleXNcbiAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7IHJldHVybiAha2V5Lm9wdGlvbmFsOyB9KVxuICAgICAgICAubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGtleS5uYW1lOyB9KTtcblxuICAgICAgaWYgKHR5cGVvZiBsb2NhdGlvbi5wYXJhbXMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIGxvY2F0aW9uLnBhcmFtcyA9IHt9O1xuICAgICAgfVxuXG4gICAgICBpZiAoY3VycmVudFJvdXRlICYmIHR5cGVvZiBjdXJyZW50Um91dGUucGFyYW1zID09PSAnb2JqZWN0Jykge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gY3VycmVudFJvdXRlLnBhcmFtcykge1xuICAgICAgICAgIGlmICghKGtleSBpbiBsb2NhdGlvbi5wYXJhbXMpICYmIHBhcmFtTmFtZXMuaW5kZXhPZihrZXkpID4gLTEpIHtcbiAgICAgICAgICAgIGxvY2F0aW9uLnBhcmFtc1trZXldID0gY3VycmVudFJvdXRlLnBhcmFtc1trZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsb2NhdGlvbi5wYXRoID0gZmlsbFBhcmFtcyhyZWNvcmQucGF0aCwgbG9jYXRpb24ucGFyYW1zLCAoXCJuYW1lZCByb3V0ZSBcXFwiXCIgKyBuYW1lICsgXCJcXFwiXCIpKTtcbiAgICAgIHJldHVybiBfY3JlYXRlUm91dGUocmVjb3JkLCBsb2NhdGlvbiwgcmVkaXJlY3RlZEZyb20pXG4gICAgfSBlbHNlIGlmIChsb2NhdGlvbi5wYXRoKSB7XG4gICAgICBsb2NhdGlvbi5wYXJhbXMgPSB7fTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHBhdGggPSBwYXRoTGlzdFtpXTtcbiAgICAgICAgdmFyIHJlY29yZCQxID0gcGF0aE1hcFtwYXRoXTtcbiAgICAgICAgaWYgKG1hdGNoUm91dGUocmVjb3JkJDEucmVnZXgsIGxvY2F0aW9uLnBhdGgsIGxvY2F0aW9uLnBhcmFtcykpIHtcbiAgICAgICAgICByZXR1cm4gX2NyZWF0ZVJvdXRlKHJlY29yZCQxLCBsb2NhdGlvbiwgcmVkaXJlY3RlZEZyb20pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gbm8gbWF0Y2hcbiAgICByZXR1cm4gX2NyZWF0ZVJvdXRlKG51bGwsIGxvY2F0aW9uKVxuICB9XG5cbiAgZnVuY3Rpb24gcmVkaXJlY3QgKFxuICAgIHJlY29yZCxcbiAgICBsb2NhdGlvblxuICApIHtcbiAgICB2YXIgb3JpZ2luYWxSZWRpcmVjdCA9IHJlY29yZC5yZWRpcmVjdDtcbiAgICB2YXIgcmVkaXJlY3QgPSB0eXBlb2Ygb3JpZ2luYWxSZWRpcmVjdCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBvcmlnaW5hbFJlZGlyZWN0KGNyZWF0ZVJvdXRlKHJlY29yZCwgbG9jYXRpb24sIG51bGwsIHJvdXRlcikpXG4gICAgICA6IG9yaWdpbmFsUmVkaXJlY3Q7XG5cbiAgICBpZiAodHlwZW9mIHJlZGlyZWN0ID09PSAnc3RyaW5nJykge1xuICAgICAgcmVkaXJlY3QgPSB7IHBhdGg6IHJlZGlyZWN0IH07XG4gICAgfVxuXG4gICAgaWYgKCFyZWRpcmVjdCB8fCB0eXBlb2YgcmVkaXJlY3QgIT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGZhbHNlLCAoXCJpbnZhbGlkIHJlZGlyZWN0IG9wdGlvbjogXCIgKyAoSlNPTi5zdHJpbmdpZnkocmVkaXJlY3QpKSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfY3JlYXRlUm91dGUobnVsbCwgbG9jYXRpb24pXG4gICAgfVxuXG4gICAgdmFyIHJlID0gcmVkaXJlY3Q7XG4gICAgdmFyIG5hbWUgPSByZS5uYW1lO1xuICAgIHZhciBwYXRoID0gcmUucGF0aDtcbiAgICB2YXIgcXVlcnkgPSBsb2NhdGlvbi5xdWVyeTtcbiAgICB2YXIgaGFzaCA9IGxvY2F0aW9uLmhhc2g7XG4gICAgdmFyIHBhcmFtcyA9IGxvY2F0aW9uLnBhcmFtcztcbiAgICBxdWVyeSA9IHJlLmhhc093blByb3BlcnR5KCdxdWVyeScpID8gcmUucXVlcnkgOiBxdWVyeTtcbiAgICBoYXNoID0gcmUuaGFzT3duUHJvcGVydHkoJ2hhc2gnKSA/IHJlLmhhc2ggOiBoYXNoO1xuICAgIHBhcmFtcyA9IHJlLmhhc093blByb3BlcnR5KCdwYXJhbXMnKSA/IHJlLnBhcmFtcyA6IHBhcmFtcztcblxuICAgIGlmIChuYW1lKSB7XG4gICAgICAvLyByZXNvbHZlZCBuYW1lZCBkaXJlY3RcbiAgICAgIHZhciB0YXJnZXRSZWNvcmQgPSBuYW1lTWFwW25hbWVdO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgYXNzZXJ0KHRhcmdldFJlY29yZCwgKFwicmVkaXJlY3QgZmFpbGVkOiBuYW1lZCByb3V0ZSBcXFwiXCIgKyBuYW1lICsgXCJcXFwiIG5vdCBmb3VuZC5cIikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoKHtcbiAgICAgICAgX25vcm1hbGl6ZWQ6IHRydWUsXG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICAgICAgaGFzaDogaGFzaCxcbiAgICAgICAgcGFyYW1zOiBwYXJhbXNcbiAgICAgIH0sIHVuZGVmaW5lZCwgbG9jYXRpb24pXG4gICAgfSBlbHNlIGlmIChwYXRoKSB7XG4gICAgICAvLyAxLiByZXNvbHZlIHJlbGF0aXZlIHJlZGlyZWN0XG4gICAgICB2YXIgcmF3UGF0aCA9IHJlc29sdmVSZWNvcmRQYXRoKHBhdGgsIHJlY29yZCk7XG4gICAgICAvLyAyLiByZXNvbHZlIHBhcmFtc1xuICAgICAgdmFyIHJlc29sdmVkUGF0aCA9IGZpbGxQYXJhbXMocmF3UGF0aCwgcGFyYW1zLCAoXCJyZWRpcmVjdCByb3V0ZSB3aXRoIHBhdGggXFxcIlwiICsgcmF3UGF0aCArIFwiXFxcIlwiKSk7XG4gICAgICAvLyAzLiByZW1hdGNoIHdpdGggZXhpc3RpbmcgcXVlcnkgYW5kIGhhc2hcbiAgICAgIHJldHVybiBtYXRjaCh7XG4gICAgICAgIF9ub3JtYWxpemVkOiB0cnVlLFxuICAgICAgICBwYXRoOiByZXNvbHZlZFBhdGgsXG4gICAgICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICAgICAgaGFzaDogaGFzaFxuICAgICAgfSwgdW5kZWZpbmVkLCBsb2NhdGlvbilcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgd2FybihmYWxzZSwgKFwiaW52YWxpZCByZWRpcmVjdCBvcHRpb246IFwiICsgKEpTT04uc3RyaW5naWZ5KHJlZGlyZWN0KSkpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfY3JlYXRlUm91dGUobnVsbCwgbG9jYXRpb24pXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWxpYXMgKFxuICAgIHJlY29yZCxcbiAgICBsb2NhdGlvbixcbiAgICBtYXRjaEFzXG4gICkge1xuICAgIHZhciBhbGlhc2VkUGF0aCA9IGZpbGxQYXJhbXMobWF0Y2hBcywgbG9jYXRpb24ucGFyYW1zLCAoXCJhbGlhc2VkIHJvdXRlIHdpdGggcGF0aCBcXFwiXCIgKyBtYXRjaEFzICsgXCJcXFwiXCIpKTtcbiAgICB2YXIgYWxpYXNlZE1hdGNoID0gbWF0Y2goe1xuICAgICAgX25vcm1hbGl6ZWQ6IHRydWUsXG4gICAgICBwYXRoOiBhbGlhc2VkUGF0aFxuICAgIH0pO1xuICAgIGlmIChhbGlhc2VkTWF0Y2gpIHtcbiAgICAgIHZhciBtYXRjaGVkID0gYWxpYXNlZE1hdGNoLm1hdGNoZWQ7XG4gICAgICB2YXIgYWxpYXNlZFJlY29yZCA9IG1hdGNoZWRbbWF0Y2hlZC5sZW5ndGggLSAxXTtcbiAgICAgIGxvY2F0aW9uLnBhcmFtcyA9IGFsaWFzZWRNYXRjaC5wYXJhbXM7XG4gICAgICByZXR1cm4gX2NyZWF0ZVJvdXRlKGFsaWFzZWRSZWNvcmQsIGxvY2F0aW9uKVxuICAgIH1cbiAgICByZXR1cm4gX2NyZWF0ZVJvdXRlKG51bGwsIGxvY2F0aW9uKVxuICB9XG5cbiAgZnVuY3Rpb24gX2NyZWF0ZVJvdXRlIChcbiAgICByZWNvcmQsXG4gICAgbG9jYXRpb24sXG4gICAgcmVkaXJlY3RlZEZyb21cbiAgKSB7XG4gICAgaWYgKHJlY29yZCAmJiByZWNvcmQucmVkaXJlY3QpIHtcbiAgICAgIHJldHVybiByZWRpcmVjdChyZWNvcmQsIHJlZGlyZWN0ZWRGcm9tIHx8IGxvY2F0aW9uKVxuICAgIH1cbiAgICBpZiAocmVjb3JkICYmIHJlY29yZC5tYXRjaEFzKSB7XG4gICAgICByZXR1cm4gYWxpYXMocmVjb3JkLCBsb2NhdGlvbiwgcmVjb3JkLm1hdGNoQXMpXG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVSb3V0ZShyZWNvcmQsIGxvY2F0aW9uLCByZWRpcmVjdGVkRnJvbSwgcm91dGVyKVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBtYXRjaDogbWF0Y2gsXG4gICAgYWRkUm91dGU6IGFkZFJvdXRlLFxuICAgIGdldFJvdXRlczogZ2V0Um91dGVzLFxuICAgIGFkZFJvdXRlczogYWRkUm91dGVzXG4gIH1cbn1cblxuZnVuY3Rpb24gbWF0Y2hSb3V0ZSAoXG4gIHJlZ2V4LFxuICBwYXRoLFxuICBwYXJhbXNcbikge1xuICB2YXIgbSA9IHBhdGgubWF0Y2gocmVnZXgpO1xuXG4gIGlmICghbSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYgKCFwYXJhbXMpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDEsIGxlbiA9IG0ubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIga2V5ID0gcmVnZXgua2V5c1tpIC0gMV07XG4gICAgaWYgKGtleSkge1xuICAgICAgLy8gRml4ICMxOTk0OiB1c2luZyAqIHdpdGggcHJvcHM6IHRydWUgZ2VuZXJhdGVzIGEgcGFyYW0gbmFtZWQgMFxuICAgICAgcGFyYW1zW2tleS5uYW1lIHx8ICdwYXRoTWF0Y2gnXSA9IHR5cGVvZiBtW2ldID09PSAnc3RyaW5nJyA/IGRlY29kZShtW2ldKSA6IG1baV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVJlY29yZFBhdGggKHBhdGgsIHJlY29yZCkge1xuICByZXR1cm4gcmVzb2x2ZVBhdGgocGF0aCwgcmVjb3JkLnBhcmVudCA/IHJlY29yZC5wYXJlbnQucGF0aCA6ICcvJywgdHJ1ZSlcbn1cblxuLyogICovXG5cbi8vIHVzZSBVc2VyIFRpbWluZyBhcGkgKGlmIHByZXNlbnQpIGZvciBtb3JlIGFjY3VyYXRlIGtleSBwcmVjaXNpb25cbnZhciBUaW1lID1cbiAgaW5Ccm93c2VyICYmIHdpbmRvdy5wZXJmb3JtYW5jZSAmJiB3aW5kb3cucGVyZm9ybWFuY2Uubm93XG4gICAgPyB3aW5kb3cucGVyZm9ybWFuY2VcbiAgICA6IERhdGU7XG5cbmZ1bmN0aW9uIGdlblN0YXRlS2V5ICgpIHtcbiAgcmV0dXJuIFRpbWUubm93KCkudG9GaXhlZCgzKVxufVxuXG52YXIgX2tleSA9IGdlblN0YXRlS2V5KCk7XG5cbmZ1bmN0aW9uIGdldFN0YXRlS2V5ICgpIHtcbiAgcmV0dXJuIF9rZXlcbn1cblxuZnVuY3Rpb24gc2V0U3RhdGVLZXkgKGtleSkge1xuICByZXR1cm4gKF9rZXkgPSBrZXkpXG59XG5cbi8qICAqL1xuXG52YXIgcG9zaXRpb25TdG9yZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbmZ1bmN0aW9uIHNldHVwU2Nyb2xsICgpIHtcbiAgLy8gUHJldmVudCBicm93c2VyIHNjcm9sbCBiZWhhdmlvciBvbiBIaXN0b3J5IHBvcHN0YXRlXG4gIGlmICgnc2Nyb2xsUmVzdG9yYXRpb24nIGluIHdpbmRvdy5oaXN0b3J5KSB7XG4gICAgd2luZG93Lmhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSAnbWFudWFsJztcbiAgfVxuICAvLyBGaXggZm9yICMxNTg1IGZvciBGaXJlZm94XG4gIC8vIEZpeCBmb3IgIzIxOTUgQWRkIG9wdGlvbmFsIHRoaXJkIGF0dHJpYnV0ZSB0byB3b3JrYXJvdW5kIGEgYnVnIGluIHNhZmFyaSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTgyNjc4XG4gIC8vIEZpeCBmb3IgIzI3NzQgU3VwcG9ydCBmb3IgYXBwcyBsb2FkZWQgZnJvbSBXaW5kb3dzIGZpbGUgc2hhcmVzIG5vdCBtYXBwZWQgdG8gbmV0d29yayBkcml2ZXM6IHJlcGxhY2VkIGxvY2F0aW9uLm9yaWdpbiB3aXRoXG4gIC8vIHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCArICcvLycgKyB3aW5kb3cubG9jYXRpb24uaG9zdFxuICAvLyBsb2NhdGlvbi5ob3N0IGNvbnRhaW5zIHRoZSBwb3J0IGFuZCBsb2NhdGlvbi5ob3N0bmFtZSBkb2Vzbid0XG4gIHZhciBwcm90b2NvbEFuZFBhdGggPSB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgKyAnLy8nICsgd2luZG93LmxvY2F0aW9uLmhvc3Q7XG4gIHZhciBhYnNvbHV0ZVBhdGggPSB3aW5kb3cubG9jYXRpb24uaHJlZi5yZXBsYWNlKHByb3RvY29sQW5kUGF0aCwgJycpO1xuICAvLyBwcmVzZXJ2ZSBleGlzdGluZyBoaXN0b3J5IHN0YXRlIGFzIGl0IGNvdWxkIGJlIG92ZXJyaWRlbiBieSB0aGUgdXNlclxuICB2YXIgc3RhdGVDb3B5ID0gZXh0ZW5kKHt9LCB3aW5kb3cuaGlzdG9yeS5zdGF0ZSk7XG4gIHN0YXRlQ29weS5rZXkgPSBnZXRTdGF0ZUtleSgpO1xuICB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoc3RhdGVDb3B5LCAnJywgYWJzb2x1dGVQYXRoKTtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgaGFuZGxlUG9wU3RhdGUpO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIGhhbmRsZVBvcFN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVTY3JvbGwgKFxuICByb3V0ZXIsXG4gIHRvLFxuICBmcm9tLFxuICBpc1BvcFxuKSB7XG4gIGlmICghcm91dGVyLmFwcCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGJlaGF2aW9yID0gcm91dGVyLm9wdGlvbnMuc2Nyb2xsQmVoYXZpb3I7XG4gIGlmICghYmVoYXZpb3IpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiZWhhdmlvciA9PT0gJ2Z1bmN0aW9uJywgXCJzY3JvbGxCZWhhdmlvciBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICAvLyB3YWl0IHVudGlsIHJlLXJlbmRlciBmaW5pc2hlcyBiZWZvcmUgc2Nyb2xsaW5nXG4gIHJvdXRlci5hcHAuJG5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcG9zaXRpb24gPSBnZXRTY3JvbGxQb3NpdGlvbigpO1xuICAgIHZhciBzaG91bGRTY3JvbGwgPSBiZWhhdmlvci5jYWxsKFxuICAgICAgcm91dGVyLFxuICAgICAgdG8sXG4gICAgICBmcm9tLFxuICAgICAgaXNQb3AgPyBwb3NpdGlvbiA6IG51bGxcbiAgICApO1xuXG4gICAgaWYgKCFzaG91bGRTY3JvbGwpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygc2hvdWxkU2Nyb2xsLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHNob3VsZFNjcm9sbFxuICAgICAgICAudGhlbihmdW5jdGlvbiAoc2hvdWxkU2Nyb2xsKSB7XG4gICAgICAgICAgc2Nyb2xsVG9Qb3NpdGlvbigoc2hvdWxkU2Nyb2xsKSwgcG9zaXRpb24pO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBhc3NlcnQoZmFsc2UsIGVyci50b1N0cmluZygpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY3JvbGxUb1Bvc2l0aW9uKHNob3VsZFNjcm9sbCwgcG9zaXRpb24pO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHNhdmVTY3JvbGxQb3NpdGlvbiAoKSB7XG4gIHZhciBrZXkgPSBnZXRTdGF0ZUtleSgpO1xuICBpZiAoa2V5KSB7XG4gICAgcG9zaXRpb25TdG9yZVtrZXldID0ge1xuICAgICAgeDogd2luZG93LnBhZ2VYT2Zmc2V0LFxuICAgICAgeTogd2luZG93LnBhZ2VZT2Zmc2V0XG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVQb3BTdGF0ZSAoZSkge1xuICBzYXZlU2Nyb2xsUG9zaXRpb24oKTtcbiAgaWYgKGUuc3RhdGUgJiYgZS5zdGF0ZS5rZXkpIHtcbiAgICBzZXRTdGF0ZUtleShlLnN0YXRlLmtleSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U2Nyb2xsUG9zaXRpb24gKCkge1xuICB2YXIga2V5ID0gZ2V0U3RhdGVLZXkoKTtcbiAgaWYgKGtleSkge1xuICAgIHJldHVybiBwb3NpdGlvblN0b3JlW2tleV1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRFbGVtZW50UG9zaXRpb24gKGVsLCBvZmZzZXQpIHtcbiAgdmFyIGRvY0VsID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB2YXIgZG9jUmVjdCA9IGRvY0VsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgZWxSZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHJldHVybiB7XG4gICAgeDogZWxSZWN0LmxlZnQgLSBkb2NSZWN0LmxlZnQgLSBvZmZzZXQueCxcbiAgICB5OiBlbFJlY3QudG9wIC0gZG9jUmVjdC50b3AgLSBvZmZzZXQueVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWRQb3NpdGlvbiAob2JqKSB7XG4gIHJldHVybiBpc051bWJlcihvYmoueCkgfHwgaXNOdW1iZXIob2JqLnkpXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVBvc2l0aW9uIChvYmopIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBpc051bWJlcihvYmoueCkgPyBvYmoueCA6IHdpbmRvdy5wYWdlWE9mZnNldCxcbiAgICB5OiBpc051bWJlcihvYmoueSkgPyBvYmoueSA6IHdpbmRvdy5wYWdlWU9mZnNldFxuICB9XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZU9mZnNldCAob2JqKSB7XG4gIHJldHVybiB7XG4gICAgeDogaXNOdW1iZXIob2JqLngpID8gb2JqLnggOiAwLFxuICAgIHk6IGlzTnVtYmVyKG9iai55KSA/IG9iai55IDogMFxuICB9XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyICh2KSB7XG4gIHJldHVybiB0eXBlb2YgdiA9PT0gJ251bWJlcidcbn1cblxudmFyIGhhc2hTdGFydHNXaXRoTnVtYmVyUkUgPSAvXiNcXGQvO1xuXG5mdW5jdGlvbiBzY3JvbGxUb1Bvc2l0aW9uIChzaG91bGRTY3JvbGwsIHBvc2l0aW9uKSB7XG4gIHZhciBpc09iamVjdCA9IHR5cGVvZiBzaG91bGRTY3JvbGwgPT09ICdvYmplY3QnO1xuICBpZiAoaXNPYmplY3QgJiYgdHlwZW9mIHNob3VsZFNjcm9sbC5zZWxlY3RvciA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBnZXRFbGVtZW50QnlJZCB3b3VsZCBzdGlsbCBmYWlsIGlmIHRoZSBzZWxlY3RvciBjb250YWlucyBhIG1vcmUgY29tcGxpY2F0ZWQgcXVlcnkgbGlrZSAjbWFpbltkYXRhLWF0dHJdXG4gICAgLy8gYnV0IGF0IHRoZSBzYW1lIHRpbWUsIGl0IGRvZXNuJ3QgbWFrZSBtdWNoIHNlbnNlIHRvIHNlbGVjdCBhbiBlbGVtZW50IHdpdGggYW4gaWQgYW5kIGFuIGV4dHJhIHNlbGVjdG9yXG4gICAgdmFyIGVsID0gaGFzaFN0YXJ0c1dpdGhOdW1iZXJSRS50ZXN0KHNob3VsZFNjcm9sbC5zZWxlY3RvcikgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICA/IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHNob3VsZFNjcm9sbC5zZWxlY3Rvci5zbGljZSgxKSkgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICA6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2hvdWxkU2Nyb2xsLnNlbGVjdG9yKTtcblxuICAgIGlmIChlbCkge1xuICAgICAgdmFyIG9mZnNldCA9XG4gICAgICAgIHNob3VsZFNjcm9sbC5vZmZzZXQgJiYgdHlwZW9mIHNob3VsZFNjcm9sbC5vZmZzZXQgPT09ICdvYmplY3QnXG4gICAgICAgICAgPyBzaG91bGRTY3JvbGwub2Zmc2V0XG4gICAgICAgICAgOiB7fTtcbiAgICAgIG9mZnNldCA9IG5vcm1hbGl6ZU9mZnNldChvZmZzZXQpO1xuICAgICAgcG9zaXRpb24gPSBnZXRFbGVtZW50UG9zaXRpb24oZWwsIG9mZnNldCk7XG4gICAgfSBlbHNlIGlmIChpc1ZhbGlkUG9zaXRpb24oc2hvdWxkU2Nyb2xsKSkge1xuICAgICAgcG9zaXRpb24gPSBub3JtYWxpemVQb3NpdGlvbihzaG91bGRTY3JvbGwpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdCAmJiBpc1ZhbGlkUG9zaXRpb24oc2hvdWxkU2Nyb2xsKSkge1xuICAgIHBvc2l0aW9uID0gbm9ybWFsaXplUG9zaXRpb24oc2hvdWxkU2Nyb2xsKTtcbiAgfVxuXG4gIGlmIChwb3NpdGlvbikge1xuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIGlmICgnc2Nyb2xsQmVoYXZpb3InIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSkge1xuICAgICAgd2luZG93LnNjcm9sbFRvKHtcbiAgICAgICAgbGVmdDogcG9zaXRpb24ueCxcbiAgICAgICAgdG9wOiBwb3NpdGlvbi55LFxuICAgICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgICAgYmVoYXZpb3I6IHNob3VsZFNjcm9sbC5iZWhhdmlvclxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpbmRvdy5zY3JvbGxUbyhwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBzdXBwb3J0c1B1c2hTdGF0ZSA9XG4gIGluQnJvd3NlciAmJlxuICAoZnVuY3Rpb24gKCkge1xuICAgIHZhciB1YSA9IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50O1xuXG4gICAgaWYgKFxuICAgICAgKHVhLmluZGV4T2YoJ0FuZHJvaWQgMi4nKSAhPT0gLTEgfHwgdWEuaW5kZXhPZignQW5kcm9pZCA0LjAnKSAhPT0gLTEpICYmXG4gICAgICB1YS5pbmRleE9mKCdNb2JpbGUgU2FmYXJpJykgIT09IC0xICYmXG4gICAgICB1YS5pbmRleE9mKCdDaHJvbWUnKSA9PT0gLTEgJiZcbiAgICAgIHVhLmluZGV4T2YoJ1dpbmRvd3MgUGhvbmUnKSA9PT0gLTFcbiAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHJldHVybiB3aW5kb3cuaGlzdG9yeSAmJiB0eXBlb2Ygd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlID09PSAnZnVuY3Rpb24nXG4gIH0pKCk7XG5cbmZ1bmN0aW9uIHB1c2hTdGF0ZSAodXJsLCByZXBsYWNlKSB7XG4gIHNhdmVTY3JvbGxQb3NpdGlvbigpO1xuICAvLyB0cnkuLi5jYXRjaCB0aGUgcHVzaFN0YXRlIGNhbGwgdG8gZ2V0IGFyb3VuZCBTYWZhcmlcbiAgLy8gRE9NIEV4Y2VwdGlvbiAxOCB3aGVyZSBpdCBsaW1pdHMgdG8gMTAwIHB1c2hTdGF0ZSBjYWxsc1xuICB2YXIgaGlzdG9yeSA9IHdpbmRvdy5oaXN0b3J5O1xuICB0cnkge1xuICAgIGlmIChyZXBsYWNlKSB7XG4gICAgICAvLyBwcmVzZXJ2ZSBleGlzdGluZyBoaXN0b3J5IHN0YXRlIGFzIGl0IGNvdWxkIGJlIG92ZXJyaWRlbiBieSB0aGUgdXNlclxuICAgICAgdmFyIHN0YXRlQ29weSA9IGV4dGVuZCh7fSwgaGlzdG9yeS5zdGF0ZSk7XG4gICAgICBzdGF0ZUNvcHkua2V5ID0gZ2V0U3RhdGVLZXkoKTtcbiAgICAgIGhpc3RvcnkucmVwbGFjZVN0YXRlKHN0YXRlQ29weSwgJycsIHVybCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhpc3RvcnkucHVzaFN0YXRlKHsga2V5OiBzZXRTdGF0ZUtleShnZW5TdGF0ZUtleSgpKSB9LCAnJywgdXJsKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB3aW5kb3cubG9jYXRpb25bcmVwbGFjZSA/ICdyZXBsYWNlJyA6ICdhc3NpZ24nXSh1cmwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VTdGF0ZSAodXJsKSB7XG4gIHB1c2hTdGF0ZSh1cmwsIHRydWUpO1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gcnVuUXVldWUgKHF1ZXVlLCBmbiwgY2IpIHtcbiAgdmFyIHN0ZXAgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPj0gcXVldWUubGVuZ3RoKSB7XG4gICAgICBjYigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocXVldWVbaW5kZXhdKSB7XG4gICAgICAgIGZuKHF1ZXVlW2luZGV4XSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHN0ZXAoaW5kZXggKyAxKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGVwKGluZGV4ICsgMSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBzdGVwKDApO1xufVxuXG4vLyBXaGVuIGNoYW5naW5nIHRoaW5nLCBhbHNvIGVkaXQgcm91dGVyLmQudHNcbnZhciBOYXZpZ2F0aW9uRmFpbHVyZVR5cGUgPSB7XG4gIHJlZGlyZWN0ZWQ6IDIsXG4gIGFib3J0ZWQ6IDQsXG4gIGNhbmNlbGxlZDogOCxcbiAgZHVwbGljYXRlZDogMTZcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZU5hdmlnYXRpb25SZWRpcmVjdGVkRXJyb3IgKGZyb20sIHRvKSB7XG4gIHJldHVybiBjcmVhdGVSb3V0ZXJFcnJvcihcbiAgICBmcm9tLFxuICAgIHRvLFxuICAgIE5hdmlnYXRpb25GYWlsdXJlVHlwZS5yZWRpcmVjdGVkLFxuICAgIChcIlJlZGlyZWN0ZWQgd2hlbiBnb2luZyBmcm9tIFxcXCJcIiArIChmcm9tLmZ1bGxQYXRoKSArIFwiXFxcIiB0byBcXFwiXCIgKyAoc3RyaW5naWZ5Um91dGUoXG4gICAgICB0b1xuICAgICkpICsgXCJcXFwiIHZpYSBhIG5hdmlnYXRpb24gZ3VhcmQuXCIpXG4gIClcbn1cblxuZnVuY3Rpb24gY3JlYXRlTmF2aWdhdGlvbkR1cGxpY2F0ZWRFcnJvciAoZnJvbSwgdG8pIHtcbiAgdmFyIGVycm9yID0gY3JlYXRlUm91dGVyRXJyb3IoXG4gICAgZnJvbSxcbiAgICB0byxcbiAgICBOYXZpZ2F0aW9uRmFpbHVyZVR5cGUuZHVwbGljYXRlZCxcbiAgICAoXCJBdm9pZGVkIHJlZHVuZGFudCBuYXZpZ2F0aW9uIHRvIGN1cnJlbnQgbG9jYXRpb246IFxcXCJcIiArIChmcm9tLmZ1bGxQYXRoKSArIFwiXFxcIi5cIilcbiAgKTtcbiAgLy8gYmFja3dhcmRzIGNvbXBhdGlibGUgd2l0aCB0aGUgZmlyc3QgaW50cm9kdWN0aW9uIG9mIEVycm9yc1xuICBlcnJvci5uYW1lID0gJ05hdmlnYXRpb25EdXBsaWNhdGVkJztcbiAgcmV0dXJuIGVycm9yXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU5hdmlnYXRpb25DYW5jZWxsZWRFcnJvciAoZnJvbSwgdG8pIHtcbiAgcmV0dXJuIGNyZWF0ZVJvdXRlckVycm9yKFxuICAgIGZyb20sXG4gICAgdG8sXG4gICAgTmF2aWdhdGlvbkZhaWx1cmVUeXBlLmNhbmNlbGxlZCxcbiAgICAoXCJOYXZpZ2F0aW9uIGNhbmNlbGxlZCBmcm9tIFxcXCJcIiArIChmcm9tLmZ1bGxQYXRoKSArIFwiXFxcIiB0byBcXFwiXCIgKyAodG8uZnVsbFBhdGgpICsgXCJcXFwiIHdpdGggYSBuZXcgbmF2aWdhdGlvbi5cIilcbiAgKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVOYXZpZ2F0aW9uQWJvcnRlZEVycm9yIChmcm9tLCB0bykge1xuICByZXR1cm4gY3JlYXRlUm91dGVyRXJyb3IoXG4gICAgZnJvbSxcbiAgICB0byxcbiAgICBOYXZpZ2F0aW9uRmFpbHVyZVR5cGUuYWJvcnRlZCxcbiAgICAoXCJOYXZpZ2F0aW9uIGFib3J0ZWQgZnJvbSBcXFwiXCIgKyAoZnJvbS5mdWxsUGF0aCkgKyBcIlxcXCIgdG8gXFxcIlwiICsgKHRvLmZ1bGxQYXRoKSArIFwiXFxcIiB2aWEgYSBuYXZpZ2F0aW9uIGd1YXJkLlwiKVxuICApXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlckVycm9yIChmcm9tLCB0bywgdHlwZSwgbWVzc2FnZSkge1xuICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIGVycm9yLl9pc1JvdXRlciA9IHRydWU7XG4gIGVycm9yLmZyb20gPSBmcm9tO1xuICBlcnJvci50byA9IHRvO1xuICBlcnJvci50eXBlID0gdHlwZTtcblxuICByZXR1cm4gZXJyb3Jcbn1cblxudmFyIHByb3BlcnRpZXNUb0xvZyA9IFsncGFyYW1zJywgJ3F1ZXJ5JywgJ2hhc2gnXTtcblxuZnVuY3Rpb24gc3RyaW5naWZ5Um91dGUgKHRvKSB7XG4gIGlmICh0eXBlb2YgdG8gPT09ICdzdHJpbmcnKSB7IHJldHVybiB0byB9XG4gIGlmICgncGF0aCcgaW4gdG8pIHsgcmV0dXJuIHRvLnBhdGggfVxuICB2YXIgbG9jYXRpb24gPSB7fTtcbiAgcHJvcGVydGllc1RvTG9nLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGlmIChrZXkgaW4gdG8pIHsgbG9jYXRpb25ba2V5XSA9IHRvW2tleV07IH1cbiAgfSk7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShsb2NhdGlvbiwgbnVsbCwgMilcbn1cblxuZnVuY3Rpb24gaXNFcnJvciAoZXJyKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZXJyKS5pbmRleE9mKCdFcnJvcicpID4gLTFcbn1cblxuZnVuY3Rpb24gaXNOYXZpZ2F0aW9uRmFpbHVyZSAoZXJyLCBlcnJvclR5cGUpIHtcbiAgcmV0dXJuIChcbiAgICBpc0Vycm9yKGVycikgJiZcbiAgICBlcnIuX2lzUm91dGVyICYmXG4gICAgKGVycm9yVHlwZSA9PSBudWxsIHx8IGVyci50eXBlID09PSBlcnJvclR5cGUpXG4gIClcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHJlc29sdmVBc3luY0NvbXBvbmVudHMgKG1hdGNoZWQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0bywgZnJvbSwgbmV4dCkge1xuICAgIHZhciBoYXNBc3luYyA9IGZhbHNlO1xuICAgIHZhciBwZW5kaW5nID0gMDtcbiAgICB2YXIgZXJyb3IgPSBudWxsO1xuXG4gICAgZmxhdE1hcENvbXBvbmVudHMobWF0Y2hlZCwgZnVuY3Rpb24gKGRlZiwgXywgbWF0Y2gsIGtleSkge1xuICAgICAgLy8gaWYgaXQncyBhIGZ1bmN0aW9uIGFuZCBkb2Vzbid0IGhhdmUgY2lkIGF0dGFjaGVkLFxuICAgICAgLy8gYXNzdW1lIGl0J3MgYW4gYXN5bmMgY29tcG9uZW50IHJlc29sdmUgZnVuY3Rpb24uXG4gICAgICAvLyB3ZSBhcmUgbm90IHVzaW5nIFZ1ZSdzIGRlZmF1bHQgYXN5bmMgcmVzb2x2aW5nIG1lY2hhbmlzbSBiZWNhdXNlXG4gICAgICAvLyB3ZSB3YW50IHRvIGhhbHQgdGhlIG5hdmlnYXRpb24gdW50aWwgdGhlIGluY29taW5nIGNvbXBvbmVudCBoYXMgYmVlblxuICAgICAgLy8gcmVzb2x2ZWQuXG4gICAgICBpZiAodHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWYuY2lkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaGFzQXN5bmMgPSB0cnVlO1xuICAgICAgICBwZW5kaW5nKys7XG5cbiAgICAgICAgdmFyIHJlc29sdmUgPSBvbmNlKGZ1bmN0aW9uIChyZXNvbHZlZERlZikge1xuICAgICAgICAgIGlmIChpc0VTTW9kdWxlKHJlc29sdmVkRGVmKSkge1xuICAgICAgICAgICAgcmVzb2x2ZWREZWYgPSByZXNvbHZlZERlZi5kZWZhdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBzYXZlIHJlc29sdmVkIG9uIGFzeW5jIGZhY3RvcnkgaW4gY2FzZSBpdCdzIHVzZWQgZWxzZXdoZXJlXG4gICAgICAgICAgZGVmLnJlc29sdmVkID0gdHlwZW9mIHJlc29sdmVkRGVmID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IHJlc29sdmVkRGVmXG4gICAgICAgICAgICA6IF9WdWUuZXh0ZW5kKHJlc29sdmVkRGVmKTtcbiAgICAgICAgICBtYXRjaC5jb21wb25lbnRzW2tleV0gPSByZXNvbHZlZERlZjtcbiAgICAgICAgICBwZW5kaW5nLS07XG4gICAgICAgICAgaWYgKHBlbmRpbmcgPD0gMCkge1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHJlamVjdCA9IG9uY2UoZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgIHZhciBtc2cgPSBcIkZhaWxlZCB0byByZXNvbHZlIGFzeW5jIGNvbXBvbmVudCBcIiArIGtleSArIFwiOiBcIiArIHJlYXNvbjtcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oZmFsc2UsIG1zZyk7XG4gICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgZXJyb3IgPSBpc0Vycm9yKHJlYXNvbilcbiAgICAgICAgICAgICAgPyByZWFzb25cbiAgICAgICAgICAgICAgOiBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgICAgIG5leHQoZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHJlcztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXMgPSBkZWYocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiByZXMudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmVzLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gbmV3IHN5bnRheCBpbiBWdWUgMi4zXG4gICAgICAgICAgICB2YXIgY29tcCA9IHJlcy5jb21wb25lbnQ7XG4gICAgICAgICAgICBpZiAoY29tcCAmJiB0eXBlb2YgY29tcC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIGNvbXAudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKCFoYXNBc3luYykgeyBuZXh0KCk7IH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmbGF0TWFwQ29tcG9uZW50cyAoXG4gIG1hdGNoZWQsXG4gIGZuXG4pIHtcbiAgcmV0dXJuIGZsYXR0ZW4obWF0Y2hlZC5tYXAoZnVuY3Rpb24gKG0pIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMobS5jb21wb25lbnRzKS5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gZm4oXG4gICAgICBtLmNvbXBvbmVudHNba2V5XSxcbiAgICAgIG0uaW5zdGFuY2VzW2tleV0sXG4gICAgICBtLCBrZXlcbiAgICApOyB9KVxuICB9KSlcbn1cblxuZnVuY3Rpb24gZmxhdHRlbiAoYXJyKSB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBhcnIpXG59XG5cbnZhciBoYXNTeW1ib2wgPVxuICB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmXG4gIHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnO1xuXG5mdW5jdGlvbiBpc0VTTW9kdWxlIChvYmopIHtcbiAgcmV0dXJuIG9iai5fX2VzTW9kdWxlIHx8IChoYXNTeW1ib2wgJiYgb2JqW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdNb2R1bGUnKVxufVxuXG4vLyBpbiBXZWJwYWNrIDIsIHJlcXVpcmUuZW5zdXJlIG5vdyBhbHNvIHJldHVybnMgYSBQcm9taXNlXG4vLyBzbyB0aGUgcmVzb2x2ZS9yZWplY3QgZnVuY3Rpb25zIG1heSBnZXQgY2FsbGVkIGFuIGV4dHJhIHRpbWVcbi8vIGlmIHRoZSB1c2VyIHVzZXMgYW4gYXJyb3cgZnVuY3Rpb24gc2hvcnRoYW5kIHRoYXQgaGFwcGVucyB0b1xuLy8gcmV0dXJuIHRoYXQgUHJvbWlzZS5cbmZ1bmN0aW9uIG9uY2UgKGZuKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICBpZiAoY2FsbGVkKSB7IHJldHVybiB9XG4gICAgY2FsbGVkID0gdHJ1ZTtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJncylcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIEhpc3RvcnkgPSBmdW5jdGlvbiBIaXN0b3J5IChyb3V0ZXIsIGJhc2UpIHtcbiAgdGhpcy5yb3V0ZXIgPSByb3V0ZXI7XG4gIHRoaXMuYmFzZSA9IG5vcm1hbGl6ZUJhc2UoYmFzZSk7XG4gIC8vIHN0YXJ0IHdpdGggYSByb3V0ZSBvYmplY3QgdGhhdCBzdGFuZHMgZm9yIFwibm93aGVyZVwiXG4gIHRoaXMuY3VycmVudCA9IFNUQVJUO1xuICB0aGlzLnBlbmRpbmcgPSBudWxsO1xuICB0aGlzLnJlYWR5ID0gZmFsc2U7XG4gIHRoaXMucmVhZHlDYnMgPSBbXTtcbiAgdGhpcy5yZWFkeUVycm9yQ2JzID0gW107XG4gIHRoaXMuZXJyb3JDYnMgPSBbXTtcbiAgdGhpcy5saXN0ZW5lcnMgPSBbXTtcbn07XG5cbkhpc3RvcnkucHJvdG90eXBlLmxpc3RlbiA9IGZ1bmN0aW9uIGxpc3RlbiAoY2IpIHtcbiAgdGhpcy5jYiA9IGNiO1xufTtcblxuSGlzdG9yeS5wcm90b3R5cGUub25SZWFkeSA9IGZ1bmN0aW9uIG9uUmVhZHkgKGNiLCBlcnJvckNiKSB7XG4gIGlmICh0aGlzLnJlYWR5KSB7XG4gICAgY2IoKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnJlYWR5Q2JzLnB1c2goY2IpO1xuICAgIGlmIChlcnJvckNiKSB7XG4gICAgICB0aGlzLnJlYWR5RXJyb3JDYnMucHVzaChlcnJvckNiKTtcbiAgICB9XG4gIH1cbn07XG5cbkhpc3RvcnkucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiBvbkVycm9yIChlcnJvckNiKSB7XG4gIHRoaXMuZXJyb3JDYnMucHVzaChlcnJvckNiKTtcbn07XG5cbkhpc3RvcnkucHJvdG90eXBlLnRyYW5zaXRpb25UbyA9IGZ1bmN0aW9uIHRyYW5zaXRpb25UbyAoXG4gIGxvY2F0aW9uLFxuICBvbkNvbXBsZXRlLFxuICBvbkFib3J0XG4pIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgcm91dGU7XG4gIC8vIGNhdGNoIHJlZGlyZWN0IG9wdGlvbiBodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlLXJvdXRlci9pc3N1ZXMvMzIwMVxuICB0cnkge1xuICAgIHJvdXRlID0gdGhpcy5yb3V0ZXIubWF0Y2gobG9jYXRpb24sIHRoaXMuY3VycmVudCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aGlzLmVycm9yQ2JzLmZvckVhY2goZnVuY3Rpb24gKGNiKSB7XG4gICAgICBjYihlKTtcbiAgICB9KTtcbiAgICAvLyBFeGNlcHRpb24gc2hvdWxkIHN0aWxsIGJlIHRocm93blxuICAgIHRocm93IGVcbiAgfVxuICB2YXIgcHJldiA9IHRoaXMuY3VycmVudDtcbiAgdGhpcy5jb25maXJtVHJhbnNpdGlvbihcbiAgICByb3V0ZSxcbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzJDEudXBkYXRlUm91dGUocm91dGUpO1xuICAgICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlKHJvdXRlKTtcbiAgICAgIHRoaXMkMS5lbnN1cmVVUkwoKTtcbiAgICAgIHRoaXMkMS5yb3V0ZXIuYWZ0ZXJIb29rcy5mb3JFYWNoKGZ1bmN0aW9uIChob29rKSB7XG4gICAgICAgIGhvb2sgJiYgaG9vayhyb3V0ZSwgcHJldik7XG4gICAgICB9KTtcblxuICAgICAgLy8gZmlyZSByZWFkeSBjYnMgb25jZVxuICAgICAgaWYgKCF0aGlzJDEucmVhZHkpIHtcbiAgICAgICAgdGhpcyQxLnJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcyQxLnJlYWR5Q2JzLmZvckVhY2goZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgY2Iocm91dGUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGlmIChvbkFib3J0KSB7XG4gICAgICAgIG9uQWJvcnQoZXJyKTtcbiAgICAgIH1cbiAgICAgIGlmIChlcnIgJiYgIXRoaXMkMS5yZWFkeSkge1xuICAgICAgICAvLyBJbml0aWFsIHJlZGlyZWN0aW9uIHNob3VsZCBub3QgbWFyayB0aGUgaGlzdG9yeSBhcyByZWFkeSB5ZXRcbiAgICAgICAgLy8gYmVjYXVzZSBpdCdzIHRyaWdnZXJlZCBieSB0aGUgcmVkaXJlY3Rpb24gaW5zdGVhZFxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlLXJvdXRlci9pc3N1ZXMvMzIyNVxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlLXJvdXRlci9pc3N1ZXMvMzMzMVxuICAgICAgICBpZiAoIWlzTmF2aWdhdGlvbkZhaWx1cmUoZXJyLCBOYXZpZ2F0aW9uRmFpbHVyZVR5cGUucmVkaXJlY3RlZCkgfHwgcHJldiAhPT0gU1RBUlQpIHtcbiAgICAgICAgICB0aGlzJDEucmVhZHkgPSB0cnVlO1xuICAgICAgICAgIHRoaXMkMS5yZWFkeUVycm9yQ2JzLmZvckVhY2goZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgICBjYihlcnIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICApO1xufTtcblxuSGlzdG9yeS5wcm90b3R5cGUuY29uZmlybVRyYW5zaXRpb24gPSBmdW5jdGlvbiBjb25maXJtVHJhbnNpdGlvbiAocm91dGUsIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgdGhpcy5wZW5kaW5nID0gcm91dGU7XG4gIHZhciBhYm9ydCA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAvLyBjaGFuZ2VkIGFmdGVyIGFkZGluZyBlcnJvcnMgd2l0aFxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUtcm91dGVyL3B1bGwvMzA0NyBiZWZvcmUgdGhhdCBjaGFuZ2UsXG4gICAgLy8gcmVkaXJlY3QgYW5kIGFib3J0ZWQgbmF2aWdhdGlvbiB3b3VsZCBwcm9kdWNlIGFuIGVyciA9PSBudWxsXG4gICAgaWYgKCFpc05hdmlnYXRpb25GYWlsdXJlKGVycikgJiYgaXNFcnJvcihlcnIpKSB7XG4gICAgICBpZiAodGhpcyQxLmVycm9yQ2JzLmxlbmd0aCkge1xuICAgICAgICB0aGlzJDEuZXJyb3JDYnMuZm9yRWFjaChmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICBjYihlcnIpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgd2FybihmYWxzZSwgJ3VuY2F1Z2h0IGVycm9yIGR1cmluZyByb3V0ZSBuYXZpZ2F0aW9uOicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgb25BYm9ydCAmJiBvbkFib3J0KGVycik7XG4gIH07XG4gIHZhciBsYXN0Um91dGVJbmRleCA9IHJvdXRlLm1hdGNoZWQubGVuZ3RoIC0gMTtcbiAgdmFyIGxhc3RDdXJyZW50SW5kZXggPSBjdXJyZW50Lm1hdGNoZWQubGVuZ3RoIC0gMTtcbiAgaWYgKFxuICAgIGlzU2FtZVJvdXRlKHJvdXRlLCBjdXJyZW50KSAmJlxuICAgIC8vIGluIHRoZSBjYXNlIHRoZSByb3V0ZSBtYXAgaGFzIGJlZW4gZHluYW1pY2FsbHkgYXBwZW5kZWQgdG9cbiAgICBsYXN0Um91dGVJbmRleCA9PT0gbGFzdEN1cnJlbnRJbmRleCAmJlxuICAgIHJvdXRlLm1hdGNoZWRbbGFzdFJvdXRlSW5kZXhdID09PSBjdXJyZW50Lm1hdGNoZWRbbGFzdEN1cnJlbnRJbmRleF1cbiAgKSB7XG4gICAgdGhpcy5lbnN1cmVVUkwoKTtcbiAgICBpZiAocm91dGUuaGFzaCkge1xuICAgICAgaGFuZGxlU2Nyb2xsKHRoaXMucm91dGVyLCBjdXJyZW50LCByb3V0ZSwgZmFsc2UpO1xuICAgIH1cbiAgICByZXR1cm4gYWJvcnQoY3JlYXRlTmF2aWdhdGlvbkR1cGxpY2F0ZWRFcnJvcihjdXJyZW50LCByb3V0ZSkpXG4gIH1cblxuICB2YXIgcmVmID0gcmVzb2x2ZVF1ZXVlKFxuICAgIHRoaXMuY3VycmVudC5tYXRjaGVkLFxuICAgIHJvdXRlLm1hdGNoZWRcbiAgKTtcbiAgICB2YXIgdXBkYXRlZCA9IHJlZi51cGRhdGVkO1xuICAgIHZhciBkZWFjdGl2YXRlZCA9IHJlZi5kZWFjdGl2YXRlZDtcbiAgICB2YXIgYWN0aXZhdGVkID0gcmVmLmFjdGl2YXRlZDtcblxuICB2YXIgcXVldWUgPSBbXS5jb25jYXQoXG4gICAgLy8gaW4tY29tcG9uZW50IGxlYXZlIGd1YXJkc1xuICAgIGV4dHJhY3RMZWF2ZUd1YXJkcyhkZWFjdGl2YXRlZCksXG4gICAgLy8gZ2xvYmFsIGJlZm9yZSBob29rc1xuICAgIHRoaXMucm91dGVyLmJlZm9yZUhvb2tzLFxuICAgIC8vIGluLWNvbXBvbmVudCB1cGRhdGUgaG9va3NcbiAgICBleHRyYWN0VXBkYXRlSG9va3ModXBkYXRlZCksXG4gICAgLy8gaW4tY29uZmlnIGVudGVyIGd1YXJkc1xuICAgIGFjdGl2YXRlZC5tYXAoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0uYmVmb3JlRW50ZXI7IH0pLFxuICAgIC8vIGFzeW5jIGNvbXBvbmVudHNcbiAgICByZXNvbHZlQXN5bmNDb21wb25lbnRzKGFjdGl2YXRlZClcbiAgKTtcblxuICB2YXIgaXRlcmF0b3IgPSBmdW5jdGlvbiAoaG9vaywgbmV4dCkge1xuICAgIGlmICh0aGlzJDEucGVuZGluZyAhPT0gcm91dGUpIHtcbiAgICAgIHJldHVybiBhYm9ydChjcmVhdGVOYXZpZ2F0aW9uQ2FuY2VsbGVkRXJyb3IoY3VycmVudCwgcm91dGUpKVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgaG9vayhyb3V0ZSwgY3VycmVudCwgZnVuY3Rpb24gKHRvKSB7XG4gICAgICAgIGlmICh0byA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAvLyBuZXh0KGZhbHNlKSAtPiBhYm9ydCBuYXZpZ2F0aW9uLCBlbnN1cmUgY3VycmVudCBVUkxcbiAgICAgICAgICB0aGlzJDEuZW5zdXJlVVJMKHRydWUpO1xuICAgICAgICAgIGFib3J0KGNyZWF0ZU5hdmlnYXRpb25BYm9ydGVkRXJyb3IoY3VycmVudCwgcm91dGUpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0Vycm9yKHRvKSkge1xuICAgICAgICAgIHRoaXMkMS5lbnN1cmVVUkwodHJ1ZSk7XG4gICAgICAgICAgYWJvcnQodG8pO1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIHR5cGVvZiB0byA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgICAodHlwZW9mIHRvID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgKHR5cGVvZiB0by5wYXRoID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdG8ubmFtZSA9PT0gJ3N0cmluZycpKVxuICAgICAgICApIHtcbiAgICAgICAgICAvLyBuZXh0KCcvJykgb3IgbmV4dCh7IHBhdGg6ICcvJyB9KSAtPiByZWRpcmVjdFxuICAgICAgICAgIGFib3J0KGNyZWF0ZU5hdmlnYXRpb25SZWRpcmVjdGVkRXJyb3IoY3VycmVudCwgcm91dGUpKTtcbiAgICAgICAgICBpZiAodHlwZW9mIHRvID09PSAnb2JqZWN0JyAmJiB0by5yZXBsYWNlKSB7XG4gICAgICAgICAgICB0aGlzJDEucmVwbGFjZSh0byk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMkMS5wdXNoKHRvKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY29uZmlybSB0cmFuc2l0aW9uIGFuZCBwYXNzIG9uIHRoZSB2YWx1ZVxuICAgICAgICAgIG5leHQodG8pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBhYm9ydChlKTtcbiAgICB9XG4gIH07XG5cbiAgcnVuUXVldWUocXVldWUsIGl0ZXJhdG9yLCBmdW5jdGlvbiAoKSB7XG4gICAgLy8gd2FpdCB1bnRpbCBhc3luYyBjb21wb25lbnRzIGFyZSByZXNvbHZlZCBiZWZvcmVcbiAgICAvLyBleHRyYWN0aW5nIGluLWNvbXBvbmVudCBlbnRlciBndWFyZHNcbiAgICB2YXIgZW50ZXJHdWFyZHMgPSBleHRyYWN0RW50ZXJHdWFyZHMoYWN0aXZhdGVkKTtcbiAgICB2YXIgcXVldWUgPSBlbnRlckd1YXJkcy5jb25jYXQodGhpcyQxLnJvdXRlci5yZXNvbHZlSG9va3MpO1xuICAgIHJ1blF1ZXVlKHF1ZXVlLCBpdGVyYXRvciwgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHRoaXMkMS5wZW5kaW5nICE9PSByb3V0ZSkge1xuICAgICAgICByZXR1cm4gYWJvcnQoY3JlYXRlTmF2aWdhdGlvbkNhbmNlbGxlZEVycm9yKGN1cnJlbnQsIHJvdXRlKSlcbiAgICAgIH1cbiAgICAgIHRoaXMkMS5wZW5kaW5nID0gbnVsbDtcbiAgICAgIG9uQ29tcGxldGUocm91dGUpO1xuICAgICAgaWYgKHRoaXMkMS5yb3V0ZXIuYXBwKSB7XG4gICAgICAgIHRoaXMkMS5yb3V0ZXIuYXBwLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaGFuZGxlUm91dGVFbnRlcmVkKHJvdXRlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufTtcblxuSGlzdG9yeS5wcm90b3R5cGUudXBkYXRlUm91dGUgPSBmdW5jdGlvbiB1cGRhdGVSb3V0ZSAocm91dGUpIHtcbiAgdGhpcy5jdXJyZW50ID0gcm91dGU7XG4gIHRoaXMuY2IgJiYgdGhpcy5jYihyb3V0ZSk7XG59O1xuXG5IaXN0b3J5LnByb3RvdHlwZS5zZXR1cExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldHVwTGlzdGVuZXJzICgpIHtcbiAgLy8gRGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBpcyBlbXB0eVxufTtcblxuSGlzdG9yeS5wcm90b3R5cGUudGVhcmRvd24gPSBmdW5jdGlvbiB0ZWFyZG93biAoKSB7XG4gIC8vIGNsZWFuIHVwIGV2ZW50IGxpc3RlbmVyc1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlLXJvdXRlci9pc3N1ZXMvMjM0MVxuICB0aGlzLmxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChjbGVhbnVwTGlzdGVuZXIpIHtcbiAgICBjbGVhbnVwTGlzdGVuZXIoKTtcbiAgfSk7XG4gIHRoaXMubGlzdGVuZXJzID0gW107XG5cbiAgLy8gcmVzZXQgY3VycmVudCBoaXN0b3J5IHJvdXRlXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUtcm91dGVyL2lzc3Vlcy8zMjk0XG4gIHRoaXMuY3VycmVudCA9IFNUQVJUO1xuICB0aGlzLnBlbmRpbmcgPSBudWxsO1xufTtcblxuZnVuY3Rpb24gbm9ybWFsaXplQmFzZSAoYmFzZSkge1xuICBpZiAoIWJhc2UpIHtcbiAgICBpZiAoaW5Ccm93c2VyKSB7XG4gICAgICAvLyByZXNwZWN0IDxiYXNlPiB0YWdcbiAgICAgIHZhciBiYXNlRWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdiYXNlJyk7XG4gICAgICBiYXNlID0gKGJhc2VFbCAmJiBiYXNlRWwuZ2V0QXR0cmlidXRlKCdocmVmJykpIHx8ICcvJztcbiAgICAgIC8vIHN0cmlwIGZ1bGwgVVJMIG9yaWdpblxuICAgICAgYmFzZSA9IGJhc2UucmVwbGFjZSgvXmh0dHBzPzpcXC9cXC9bXlxcL10rLywgJycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBiYXNlID0gJy8nO1xuICAgIH1cbiAgfVxuICAvLyBtYWtlIHN1cmUgdGhlcmUncyB0aGUgc3RhcnRpbmcgc2xhc2hcbiAgaWYgKGJhc2UuY2hhckF0KDApICE9PSAnLycpIHtcbiAgICBiYXNlID0gJy8nICsgYmFzZTtcbiAgfVxuICAvLyByZW1vdmUgdHJhaWxpbmcgc2xhc2hcbiAgcmV0dXJuIGJhc2UucmVwbGFjZSgvXFwvJC8sICcnKVxufVxuXG5mdW5jdGlvbiByZXNvbHZlUXVldWUgKFxuICBjdXJyZW50LFxuICBuZXh0XG4pIHtcbiAgdmFyIGk7XG4gIHZhciBtYXggPSBNYXRoLm1heChjdXJyZW50Lmxlbmd0aCwgbmV4dC5sZW5ndGgpO1xuICBmb3IgKGkgPSAwOyBpIDwgbWF4OyBpKyspIHtcbiAgICBpZiAoY3VycmVudFtpXSAhPT0gbmV4dFtpXSkge1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB1cGRhdGVkOiBuZXh0LnNsaWNlKDAsIGkpLFxuICAgIGFjdGl2YXRlZDogbmV4dC5zbGljZShpKSxcbiAgICBkZWFjdGl2YXRlZDogY3VycmVudC5zbGljZShpKVxuICB9XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RHdWFyZHMgKFxuICByZWNvcmRzLFxuICBuYW1lLFxuICBiaW5kLFxuICByZXZlcnNlXG4pIHtcbiAgdmFyIGd1YXJkcyA9IGZsYXRNYXBDb21wb25lbnRzKHJlY29yZHMsIGZ1bmN0aW9uIChkZWYsIGluc3RhbmNlLCBtYXRjaCwga2V5KSB7XG4gICAgdmFyIGd1YXJkID0gZXh0cmFjdEd1YXJkKGRlZiwgbmFtZSk7XG4gICAgaWYgKGd1YXJkKSB7XG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShndWFyZClcbiAgICAgICAgPyBndWFyZC5tYXAoZnVuY3Rpb24gKGd1YXJkKSB7IHJldHVybiBiaW5kKGd1YXJkLCBpbnN0YW5jZSwgbWF0Y2gsIGtleSk7IH0pXG4gICAgICAgIDogYmluZChndWFyZCwgaW5zdGFuY2UsIG1hdGNoLCBrZXkpXG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGZsYXR0ZW4ocmV2ZXJzZSA/IGd1YXJkcy5yZXZlcnNlKCkgOiBndWFyZHMpXG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RHdWFyZCAoXG4gIGRlZixcbiAga2V5XG4pIHtcbiAgaWYgKHR5cGVvZiBkZWYgIT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBleHRlbmQgbm93IHNvIHRoYXQgZ2xvYmFsIG1peGlucyBhcmUgYXBwbGllZC5cbiAgICBkZWYgPSBfVnVlLmV4dGVuZChkZWYpO1xuICB9XG4gIHJldHVybiBkZWYub3B0aW9uc1trZXldXG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RMZWF2ZUd1YXJkcyAoZGVhY3RpdmF0ZWQpIHtcbiAgcmV0dXJuIGV4dHJhY3RHdWFyZHMoZGVhY3RpdmF0ZWQsICdiZWZvcmVSb3V0ZUxlYXZlJywgYmluZEd1YXJkLCB0cnVlKVxufVxuXG5mdW5jdGlvbiBleHRyYWN0VXBkYXRlSG9va3MgKHVwZGF0ZWQpIHtcbiAgcmV0dXJuIGV4dHJhY3RHdWFyZHModXBkYXRlZCwgJ2JlZm9yZVJvdXRlVXBkYXRlJywgYmluZEd1YXJkKVxufVxuXG5mdW5jdGlvbiBiaW5kR3VhcmQgKGd1YXJkLCBpbnN0YW5jZSkge1xuICBpZiAoaW5zdGFuY2UpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gYm91bmRSb3V0ZUd1YXJkICgpIHtcbiAgICAgIHJldHVybiBndWFyZC5hcHBseShpbnN0YW5jZSwgYXJndW1lbnRzKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBleHRyYWN0RW50ZXJHdWFyZHMgKFxuICBhY3RpdmF0ZWRcbikge1xuICByZXR1cm4gZXh0cmFjdEd1YXJkcyhcbiAgICBhY3RpdmF0ZWQsXG4gICAgJ2JlZm9yZVJvdXRlRW50ZXInLFxuICAgIGZ1bmN0aW9uIChndWFyZCwgXywgbWF0Y2gsIGtleSkge1xuICAgICAgcmV0dXJuIGJpbmRFbnRlckd1YXJkKGd1YXJkLCBtYXRjaCwga2V5KVxuICAgIH1cbiAgKVxufVxuXG5mdW5jdGlvbiBiaW5kRW50ZXJHdWFyZCAoXG4gIGd1YXJkLFxuICBtYXRjaCxcbiAga2V5XG4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHJvdXRlRW50ZXJHdWFyZCAodG8sIGZyb20sIG5leHQpIHtcbiAgICByZXR1cm4gZ3VhcmQodG8sIGZyb20sIGZ1bmN0aW9uIChjYikge1xuICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAoIW1hdGNoLmVudGVyZWRDYnNba2V5XSkge1xuICAgICAgICAgIG1hdGNoLmVudGVyZWRDYnNba2V5XSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIG1hdGNoLmVudGVyZWRDYnNba2V5XS5wdXNoKGNiKTtcbiAgICAgIH1cbiAgICAgIG5leHQoY2IpO1xuICAgIH0pXG4gIH1cbn1cblxuLyogICovXG5cbnZhciBIVE1MNUhpc3RvcnkgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChIaXN0b3J5KSB7XG4gIGZ1bmN0aW9uIEhUTUw1SGlzdG9yeSAocm91dGVyLCBiYXNlKSB7XG4gICAgSGlzdG9yeS5jYWxsKHRoaXMsIHJvdXRlciwgYmFzZSk7XG5cbiAgICB0aGlzLl9zdGFydExvY2F0aW9uID0gZ2V0TG9jYXRpb24odGhpcy5iYXNlKTtcbiAgfVxuXG4gIGlmICggSGlzdG9yeSApIEhUTUw1SGlzdG9yeS5fX3Byb3RvX18gPSBIaXN0b3J5O1xuICBIVE1MNUhpc3RvcnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSGlzdG9yeSAmJiBIaXN0b3J5LnByb3RvdHlwZSApO1xuICBIVE1MNUhpc3RvcnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSFRNTDVIaXN0b3J5O1xuXG4gIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUuc2V0dXBMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXR1cExpc3RlbmVycyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5saXN0ZW5lcnMubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIHJvdXRlciA9IHRoaXMucm91dGVyO1xuICAgIHZhciBleHBlY3RTY3JvbGwgPSByb3V0ZXIub3B0aW9ucy5zY3JvbGxCZWhhdmlvcjtcbiAgICB2YXIgc3VwcG9ydHNTY3JvbGwgPSBzdXBwb3J0c1B1c2hTdGF0ZSAmJiBleHBlY3RTY3JvbGw7XG5cbiAgICBpZiAoc3VwcG9ydHNTY3JvbGwpIHtcbiAgICAgIHRoaXMubGlzdGVuZXJzLnB1c2goc2V0dXBTY3JvbGwoKSk7XG4gICAgfVxuXG4gICAgdmFyIGhhbmRsZVJvdXRpbmdFdmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gdGhpcyQxLmN1cnJlbnQ7XG5cbiAgICAgIC8vIEF2b2lkaW5nIGZpcnN0IGBwb3BzdGF0ZWAgZXZlbnQgZGlzcGF0Y2hlZCBpbiBzb21lIGJyb3dzZXJzIGJ1dCBmaXJzdFxuICAgICAgLy8gaGlzdG9yeSByb3V0ZSBub3QgdXBkYXRlZCBzaW5jZSBhc3luYyBndWFyZCBhdCB0aGUgc2FtZSB0aW1lLlxuICAgICAgdmFyIGxvY2F0aW9uID0gZ2V0TG9jYXRpb24odGhpcyQxLmJhc2UpO1xuICAgICAgaWYgKHRoaXMkMS5jdXJyZW50ID09PSBTVEFSVCAmJiBsb2NhdGlvbiA9PT0gdGhpcyQxLl9zdGFydExvY2F0aW9uKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICB0aGlzJDEudHJhbnNpdGlvblRvKGxvY2F0aW9uLCBmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgICAgaWYgKHN1cHBvcnRzU2Nyb2xsKSB7XG4gICAgICAgICAgaGFuZGxlU2Nyb2xsKHJvdXRlciwgcm91dGUsIGN1cnJlbnQsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIGhhbmRsZVJvdXRpbmdFdmVudCk7XG4gICAgdGhpcy5saXN0ZW5lcnMucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCBoYW5kbGVSb3V0aW5nRXZlbnQpO1xuICAgIH0pO1xuICB9O1xuXG4gIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUuZ28gPSBmdW5jdGlvbiBnbyAobikge1xuICAgIHdpbmRvdy5oaXN0b3J5LmdvKG4pO1xuICB9O1xuXG4gIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2ggKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgcmVmID0gdGhpcztcbiAgICB2YXIgZnJvbVJvdXRlID0gcmVmLmN1cnJlbnQ7XG4gICAgdGhpcy50cmFuc2l0aW9uVG8obG9jYXRpb24sIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgcHVzaFN0YXRlKGNsZWFuUGF0aCh0aGlzJDEuYmFzZSArIHJvdXRlLmZ1bGxQYXRoKSk7XG4gICAgICBoYW5kbGVTY3JvbGwodGhpcyQxLnJvdXRlciwgcm91dGUsIGZyb21Sb3V0ZSwgZmFsc2UpO1xuICAgICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlKHJvdXRlKTtcbiAgICB9LCBvbkFib3J0KTtcbiAgfTtcblxuICBIVE1MNUhpc3RvcnkucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHJlZiA9IHRoaXM7XG4gICAgdmFyIGZyb21Sb3V0ZSA9IHJlZi5jdXJyZW50O1xuICAgIHRoaXMudHJhbnNpdGlvblRvKGxvY2F0aW9uLCBmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgIHJlcGxhY2VTdGF0ZShjbGVhblBhdGgodGhpcyQxLmJhc2UgKyByb3V0ZS5mdWxsUGF0aCkpO1xuICAgICAgaGFuZGxlU2Nyb2xsKHRoaXMkMS5yb3V0ZXIsIHJvdXRlLCBmcm9tUm91dGUsIGZhbHNlKTtcbiAgICAgIG9uQ29tcGxldGUgJiYgb25Db21wbGV0ZShyb3V0ZSk7XG4gICAgfSwgb25BYm9ydCk7XG4gIH07XG5cbiAgSFRNTDVIaXN0b3J5LnByb3RvdHlwZS5lbnN1cmVVUkwgPSBmdW5jdGlvbiBlbnN1cmVVUkwgKHB1c2gpIHtcbiAgICBpZiAoZ2V0TG9jYXRpb24odGhpcy5iYXNlKSAhPT0gdGhpcy5jdXJyZW50LmZ1bGxQYXRoKSB7XG4gICAgICB2YXIgY3VycmVudCA9IGNsZWFuUGF0aCh0aGlzLmJhc2UgKyB0aGlzLmN1cnJlbnQuZnVsbFBhdGgpO1xuICAgICAgcHVzaCA/IHB1c2hTdGF0ZShjdXJyZW50KSA6IHJlcGxhY2VTdGF0ZShjdXJyZW50KTtcbiAgICB9XG4gIH07XG5cbiAgSFRNTDVIaXN0b3J5LnByb3RvdHlwZS5nZXRDdXJyZW50TG9jYXRpb24gPSBmdW5jdGlvbiBnZXRDdXJyZW50TG9jYXRpb24gKCkge1xuICAgIHJldHVybiBnZXRMb2NhdGlvbih0aGlzLmJhc2UpXG4gIH07XG5cbiAgcmV0dXJuIEhUTUw1SGlzdG9yeTtcbn0oSGlzdG9yeSkpO1xuXG5mdW5jdGlvbiBnZXRMb2NhdGlvbiAoYmFzZSkge1xuICB2YXIgcGF0aCA9IHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZTtcbiAgdmFyIHBhdGhMb3dlckNhc2UgPSBwYXRoLnRvTG93ZXJDYXNlKCk7XG4gIHZhciBiYXNlTG93ZXJDYXNlID0gYmFzZS50b0xvd2VyQ2FzZSgpO1xuICAvLyBiYXNlPVwiL2FcIiBzaG91bGRuJ3QgdHVybiBwYXRoPVwiL2FwcFwiIGludG8gXCIvYS9wcFwiXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUtcm91dGVyL2lzc3Vlcy8zNTU1XG4gIC8vIHNvIHdlIGVuc3VyZSB0aGUgdHJhaWxpbmcgc2xhc2ggaW4gdGhlIGJhc2VcbiAgaWYgKGJhc2UgJiYgKChwYXRoTG93ZXJDYXNlID09PSBiYXNlTG93ZXJDYXNlKSB8fFxuICAgIChwYXRoTG93ZXJDYXNlLmluZGV4T2YoY2xlYW5QYXRoKGJhc2VMb3dlckNhc2UgKyAnLycpKSA9PT0gMCkpKSB7XG4gICAgcGF0aCA9IHBhdGguc2xpY2UoYmFzZS5sZW5ndGgpO1xuICB9XG4gIHJldHVybiAocGF0aCB8fCAnLycpICsgd2luZG93LmxvY2F0aW9uLnNlYXJjaCArIHdpbmRvdy5sb2NhdGlvbi5oYXNoXG59XG5cbi8qICAqL1xuXG52YXIgSGFzaEhpc3RvcnkgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChIaXN0b3J5KSB7XG4gIGZ1bmN0aW9uIEhhc2hIaXN0b3J5IChyb3V0ZXIsIGJhc2UsIGZhbGxiYWNrKSB7XG4gICAgSGlzdG9yeS5jYWxsKHRoaXMsIHJvdXRlciwgYmFzZSk7XG4gICAgLy8gY2hlY2sgaGlzdG9yeSBmYWxsYmFjayBkZWVwbGlua2luZ1xuICAgIGlmIChmYWxsYmFjayAmJiBjaGVja0ZhbGxiYWNrKHRoaXMuYmFzZSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBlbnN1cmVTbGFzaCgpO1xuICB9XG5cbiAgaWYgKCBIaXN0b3J5ICkgSGFzaEhpc3RvcnkuX19wcm90b19fID0gSGlzdG9yeTtcbiAgSGFzaEhpc3RvcnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSGlzdG9yeSAmJiBIaXN0b3J5LnByb3RvdHlwZSApO1xuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBIYXNoSGlzdG9yeTtcblxuICAvLyB0aGlzIGlzIGRlbGF5ZWQgdW50aWwgdGhlIGFwcCBtb3VudHNcbiAgLy8gdG8gYXZvaWQgdGhlIGhhc2hjaGFuZ2UgbGlzdGVuZXIgYmVpbmcgZmlyZWQgdG9vIGVhcmx5XG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5zZXR1cExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldHVwTGlzdGVuZXJzICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmICh0aGlzLmxpc3RlbmVycy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgcm91dGVyID0gdGhpcy5yb3V0ZXI7XG4gICAgdmFyIGV4cGVjdFNjcm9sbCA9IHJvdXRlci5vcHRpb25zLnNjcm9sbEJlaGF2aW9yO1xuICAgIHZhciBzdXBwb3J0c1Njcm9sbCA9IHN1cHBvcnRzUHVzaFN0YXRlICYmIGV4cGVjdFNjcm9sbDtcblxuICAgIGlmIChzdXBwb3J0c1Njcm9sbCkge1xuICAgICAgdGhpcy5saXN0ZW5lcnMucHVzaChzZXR1cFNjcm9sbCgpKTtcbiAgICB9XG5cbiAgICB2YXIgaGFuZGxlUm91dGluZ0V2ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzJDEuY3VycmVudDtcbiAgICAgIGlmICghZW5zdXJlU2xhc2goKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHRoaXMkMS50cmFuc2l0aW9uVG8oZ2V0SGFzaCgpLCBmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgICAgaWYgKHN1cHBvcnRzU2Nyb2xsKSB7XG4gICAgICAgICAgaGFuZGxlU2Nyb2xsKHRoaXMkMS5yb3V0ZXIsIHJvdXRlLCBjdXJyZW50LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN1cHBvcnRzUHVzaFN0YXRlKSB7XG4gICAgICAgICAgcmVwbGFjZUhhc2gocm91dGUuZnVsbFBhdGgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHZhciBldmVudFR5cGUgPSBzdXBwb3J0c1B1c2hTdGF0ZSA/ICdwb3BzdGF0ZScgOiAnaGFzaGNoYW5nZSc7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICBldmVudFR5cGUsXG4gICAgICBoYW5kbGVSb3V0aW5nRXZlbnRcbiAgICApO1xuICAgIHRoaXMubGlzdGVuZXJzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBoYW5kbGVSb3V0aW5nRXZlbnQpO1xuICAgIH0pO1xuICB9O1xuXG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCAobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciByZWYgPSB0aGlzO1xuICAgIHZhciBmcm9tUm91dGUgPSByZWYuY3VycmVudDtcbiAgICB0aGlzLnRyYW5zaXRpb25UbyhcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICAgIHB1c2hIYXNoKHJvdXRlLmZ1bGxQYXRoKTtcbiAgICAgICAgaGFuZGxlU2Nyb2xsKHRoaXMkMS5yb3V0ZXIsIHJvdXRlLCBmcm9tUm91dGUsIGZhbHNlKTtcbiAgICAgICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlKHJvdXRlKTtcbiAgICAgIH0sXG4gICAgICBvbkFib3J0XG4gICAgKTtcbiAgfTtcblxuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UgKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgcmVmID0gdGhpcztcbiAgICB2YXIgZnJvbVJvdXRlID0gcmVmLmN1cnJlbnQ7XG4gICAgdGhpcy50cmFuc2l0aW9uVG8oXG4gICAgICBsb2NhdGlvbixcbiAgICAgIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgICByZXBsYWNlSGFzaChyb3V0ZS5mdWxsUGF0aCk7XG4gICAgICAgIGhhbmRsZVNjcm9sbCh0aGlzJDEucm91dGVyLCByb3V0ZSwgZnJvbVJvdXRlLCBmYWxzZSk7XG4gICAgICAgIG9uQ29tcGxldGUgJiYgb25Db21wbGV0ZShyb3V0ZSk7XG4gICAgICB9LFxuICAgICAgb25BYm9ydFxuICAgICk7XG4gIH07XG5cbiAgSGFzaEhpc3RvcnkucHJvdG90eXBlLmdvID0gZnVuY3Rpb24gZ28gKG4pIHtcbiAgICB3aW5kb3cuaGlzdG9yeS5nbyhuKTtcbiAgfTtcblxuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUuZW5zdXJlVVJMID0gZnVuY3Rpb24gZW5zdXJlVVJMIChwdXNoKSB7XG4gICAgdmFyIGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQuZnVsbFBhdGg7XG4gICAgaWYgKGdldEhhc2goKSAhPT0gY3VycmVudCkge1xuICAgICAgcHVzaCA/IHB1c2hIYXNoKGN1cnJlbnQpIDogcmVwbGFjZUhhc2goY3VycmVudCk7XG4gICAgfVxuICB9O1xuXG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5nZXRDdXJyZW50TG9jYXRpb24gPSBmdW5jdGlvbiBnZXRDdXJyZW50TG9jYXRpb24gKCkge1xuICAgIHJldHVybiBnZXRIYXNoKClcbiAgfTtcblxuICByZXR1cm4gSGFzaEhpc3Rvcnk7XG59KEhpc3RvcnkpKTtcblxuZnVuY3Rpb24gY2hlY2tGYWxsYmFjayAoYmFzZSkge1xuICB2YXIgbG9jYXRpb24gPSBnZXRMb2NhdGlvbihiYXNlKTtcbiAgaWYgKCEvXlxcLyMvLnRlc3QobG9jYXRpb24pKSB7XG4gICAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UoY2xlYW5QYXRoKGJhc2UgKyAnLyMnICsgbG9jYXRpb24pKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG59XG5cbmZ1bmN0aW9uIGVuc3VyZVNsYXNoICgpIHtcbiAgdmFyIHBhdGggPSBnZXRIYXNoKCk7XG4gIGlmIChwYXRoLmNoYXJBdCgwKSA9PT0gJy8nKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXBsYWNlSGFzaCgnLycgKyBwYXRoKTtcbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGdldEhhc2ggKCkge1xuICAvLyBXZSBjYW4ndCB1c2Ugd2luZG93LmxvY2F0aW9uLmhhc2ggaGVyZSBiZWNhdXNlIGl0J3Mgbm90XG4gIC8vIGNvbnNpc3RlbnQgYWNyb3NzIGJyb3dzZXJzIC0gRmlyZWZveCB3aWxsIHByZS1kZWNvZGUgaXQhXG4gIHZhciBocmVmID0gd2luZG93LmxvY2F0aW9uLmhyZWY7XG4gIHZhciBpbmRleCA9IGhyZWYuaW5kZXhPZignIycpO1xuICAvLyBlbXB0eSBwYXRoXG4gIGlmIChpbmRleCA8IDApIHsgcmV0dXJuICcnIH1cblxuICBocmVmID0gaHJlZi5zbGljZShpbmRleCArIDEpO1xuXG4gIHJldHVybiBocmVmXG59XG5cbmZ1bmN0aW9uIGdldFVybCAocGF0aCkge1xuICB2YXIgaHJlZiA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICB2YXIgaSA9IGhyZWYuaW5kZXhPZignIycpO1xuICB2YXIgYmFzZSA9IGkgPj0gMCA/IGhyZWYuc2xpY2UoMCwgaSkgOiBocmVmO1xuICByZXR1cm4gKGJhc2UgKyBcIiNcIiArIHBhdGgpXG59XG5cbmZ1bmN0aW9uIHB1c2hIYXNoIChwYXRoKSB7XG4gIGlmIChzdXBwb3J0c1B1c2hTdGF0ZSkge1xuICAgIHB1c2hTdGF0ZShnZXRVcmwocGF0aCkpO1xuICB9IGVsc2Uge1xuICAgIHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gcGF0aDtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXBsYWNlSGFzaCAocGF0aCkge1xuICBpZiAoc3VwcG9ydHNQdXNoU3RhdGUpIHtcbiAgICByZXBsYWNlU3RhdGUoZ2V0VXJsKHBhdGgpKTtcbiAgfSBlbHNlIHtcbiAgICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZShnZXRVcmwocGF0aCkpO1xuICB9XG59XG5cbi8qICAqL1xuXG52YXIgQWJzdHJhY3RIaXN0b3J5ID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoSGlzdG9yeSkge1xuICBmdW5jdGlvbiBBYnN0cmFjdEhpc3RvcnkgKHJvdXRlciwgYmFzZSkge1xuICAgIEhpc3RvcnkuY2FsbCh0aGlzLCByb3V0ZXIsIGJhc2UpO1xuICAgIHRoaXMuc3RhY2sgPSBbXTtcbiAgICB0aGlzLmluZGV4ID0gLTE7XG4gIH1cblxuICBpZiAoIEhpc3RvcnkgKSBBYnN0cmFjdEhpc3RvcnkuX19wcm90b19fID0gSGlzdG9yeTtcbiAgQWJzdHJhY3RIaXN0b3J5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEhpc3RvcnkgJiYgSGlzdG9yeS5wcm90b3R5cGUgKTtcbiAgQWJzdHJhY3RIaXN0b3J5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFic3RyYWN0SGlzdG9yeTtcblxuICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdGhpcy50cmFuc2l0aW9uVG8oXG4gICAgICBsb2NhdGlvbixcbiAgICAgIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgICB0aGlzJDEuc3RhY2sgPSB0aGlzJDEuc3RhY2suc2xpY2UoMCwgdGhpcyQxLmluZGV4ICsgMSkuY29uY2F0KHJvdXRlKTtcbiAgICAgICAgdGhpcyQxLmluZGV4Kys7XG4gICAgICAgIG9uQ29tcGxldGUgJiYgb25Db21wbGV0ZShyb3V0ZSk7XG4gICAgICB9LFxuICAgICAgb25BYm9ydFxuICAgICk7XG4gIH07XG5cbiAgQWJzdHJhY3RIaXN0b3J5LnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZSAobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHRoaXMudHJhbnNpdGlvblRvKFxuICAgICAgbG9jYXRpb24sXG4gICAgICBmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgICAgdGhpcyQxLnN0YWNrID0gdGhpcyQxLnN0YWNrLnNsaWNlKDAsIHRoaXMkMS5pbmRleCkuY29uY2F0KHJvdXRlKTtcbiAgICAgICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlKHJvdXRlKTtcbiAgICAgIH0sXG4gICAgICBvbkFib3J0XG4gICAgKTtcbiAgfTtcblxuICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlLmdvID0gZnVuY3Rpb24gZ28gKG4pIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciB0YXJnZXRJbmRleCA9IHRoaXMuaW5kZXggKyBuO1xuICAgIGlmICh0YXJnZXRJbmRleCA8IDAgfHwgdGFyZ2V0SW5kZXggPj0gdGhpcy5zdGFjay5sZW5ndGgpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgcm91dGUgPSB0aGlzLnN0YWNrW3RhcmdldEluZGV4XTtcbiAgICB0aGlzLmNvbmZpcm1UcmFuc2l0aW9uKFxuICAgICAgcm91dGUsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcmV2ID0gdGhpcyQxLmN1cnJlbnQ7XG4gICAgICAgIHRoaXMkMS5pbmRleCA9IHRhcmdldEluZGV4O1xuICAgICAgICB0aGlzJDEudXBkYXRlUm91dGUocm91dGUpO1xuICAgICAgICB0aGlzJDEucm91dGVyLmFmdGVySG9va3MuZm9yRWFjaChmdW5jdGlvbiAoaG9vaykge1xuICAgICAgICAgIGhvb2sgJiYgaG9vayhyb3V0ZSwgcHJldik7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKGlzTmF2aWdhdGlvbkZhaWx1cmUoZXJyLCBOYXZpZ2F0aW9uRmFpbHVyZVR5cGUuZHVwbGljYXRlZCkpIHtcbiAgICAgICAgICB0aGlzJDEuaW5kZXggPSB0YXJnZXRJbmRleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG4gIH07XG5cbiAgQWJzdHJhY3RIaXN0b3J5LnByb3RvdHlwZS5nZXRDdXJyZW50TG9jYXRpb24gPSBmdW5jdGlvbiBnZXRDdXJyZW50TG9jYXRpb24gKCkge1xuICAgIHZhciBjdXJyZW50ID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiBjdXJyZW50ID8gY3VycmVudC5mdWxsUGF0aCA6ICcvJ1xuICB9O1xuXG4gIEFic3RyYWN0SGlzdG9yeS5wcm90b3R5cGUuZW5zdXJlVVJMID0gZnVuY3Rpb24gZW5zdXJlVVJMICgpIHtcbiAgICAvLyBub29wXG4gIH07XG5cbiAgcmV0dXJuIEFic3RyYWN0SGlzdG9yeTtcbn0oSGlzdG9yeSkpO1xuXG4vKiAgKi9cblxudmFyIFZ1ZVJvdXRlciA9IGZ1bmN0aW9uIFZ1ZVJvdXRlciAob3B0aW9ucykge1xuICBpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHdhcm4odGhpcyBpbnN0YW5jZW9mIFZ1ZVJvdXRlciwgXCJSb3V0ZXIgbXVzdCBiZSBjYWxsZWQgd2l0aCB0aGUgbmV3IG9wZXJhdG9yLlwiKTtcbiAgfVxuICB0aGlzLmFwcCA9IG51bGw7XG4gIHRoaXMuYXBwcyA9IFtdO1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB0aGlzLmJlZm9yZUhvb2tzID0gW107XG4gIHRoaXMucmVzb2x2ZUhvb2tzID0gW107XG4gIHRoaXMuYWZ0ZXJIb29rcyA9IFtdO1xuICB0aGlzLm1hdGNoZXIgPSBjcmVhdGVNYXRjaGVyKG9wdGlvbnMucm91dGVzIHx8IFtdLCB0aGlzKTtcblxuICB2YXIgbW9kZSA9IG9wdGlvbnMubW9kZSB8fCAnaGFzaCc7XG4gIHRoaXMuZmFsbGJhY2sgPVxuICAgIG1vZGUgPT09ICdoaXN0b3J5JyAmJiAhc3VwcG9ydHNQdXNoU3RhdGUgJiYgb3B0aW9ucy5mYWxsYmFjayAhPT0gZmFsc2U7XG4gIGlmICh0aGlzLmZhbGxiYWNrKSB7XG4gICAgbW9kZSA9ICdoYXNoJztcbiAgfVxuICBpZiAoIWluQnJvd3Nlcikge1xuICAgIG1vZGUgPSAnYWJzdHJhY3QnO1xuICB9XG4gIHRoaXMubW9kZSA9IG1vZGU7XG5cbiAgc3dpdGNoIChtb2RlKSB7XG4gICAgY2FzZSAnaGlzdG9yeSc6XG4gICAgICB0aGlzLmhpc3RvcnkgPSBuZXcgSFRNTDVIaXN0b3J5KHRoaXMsIG9wdGlvbnMuYmFzZSk7XG4gICAgICBicmVha1xuICAgIGNhc2UgJ2hhc2gnOlxuICAgICAgdGhpcy5oaXN0b3J5ID0gbmV3IEhhc2hIaXN0b3J5KHRoaXMsIG9wdGlvbnMuYmFzZSwgdGhpcy5mYWxsYmFjayk7XG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Fic3RyYWN0JzpcbiAgICAgIHRoaXMuaGlzdG9yeSA9IG5ldyBBYnN0cmFjdEhpc3RvcnkodGhpcywgb3B0aW9ucy5iYXNlKTtcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGFzc2VydChmYWxzZSwgKFwiaW52YWxpZCBtb2RlOiBcIiArIG1vZGUpKTtcbiAgICAgIH1cbiAgfVxufTtcblxudmFyIHByb3RvdHlwZUFjY2Vzc29ycyA9IHsgY3VycmVudFJvdXRlOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbiBtYXRjaCAocmF3LCBjdXJyZW50LCByZWRpcmVjdGVkRnJvbSkge1xuICByZXR1cm4gdGhpcy5tYXRjaGVyLm1hdGNoKHJhdywgY3VycmVudCwgcmVkaXJlY3RlZEZyb20pXG59O1xuXG5wcm90b3R5cGVBY2Nlc3NvcnMuY3VycmVudFJvdXRlLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuaGlzdG9yeSAmJiB0aGlzLmhpc3RvcnkuY3VycmVudFxufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gaW5pdCAoYXBwIC8qIFZ1ZSBjb21wb25lbnQgaW5zdGFuY2UgKi8pIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgYXNzZXJ0KFxuICAgICAgaW5zdGFsbC5pbnN0YWxsZWQsXG4gICAgICBcIm5vdCBpbnN0YWxsZWQuIE1ha2Ugc3VyZSB0byBjYWxsIGBWdWUudXNlKFZ1ZVJvdXRlcilgIFwiICtcbiAgICAgICAgXCJiZWZvcmUgY3JlYXRpbmcgcm9vdCBpbnN0YW5jZS5cIlxuICAgICk7XG5cbiAgdGhpcy5hcHBzLnB1c2goYXBwKTtcblxuICAvLyBzZXQgdXAgYXBwIGRlc3Ryb3llZCBoYW5kbGVyXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUtcm91dGVyL2lzc3Vlcy8yNjM5XG4gIGFwcC4kb25jZSgnaG9vazpkZXN0cm95ZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgLy8gY2xlYW4gb3V0IGFwcCBmcm9tIHRoaXMuYXBwcyBhcnJheSBvbmNlIGRlc3Ryb3llZFxuICAgIHZhciBpbmRleCA9IHRoaXMkMS5hcHBzLmluZGV4T2YoYXBwKTtcbiAgICBpZiAoaW5kZXggPiAtMSkgeyB0aGlzJDEuYXBwcy5zcGxpY2UoaW5kZXgsIDEpOyB9XG4gICAgLy8gZW5zdXJlIHdlIHN0aWxsIGhhdmUgYSBtYWluIGFwcCBvciBudWxsIGlmIG5vIGFwcHNcbiAgICAvLyB3ZSBkbyBub3QgcmVsZWFzZSB0aGUgcm91dGVyIHNvIGl0IGNhbiBiZSByZXVzZWRcbiAgICBpZiAodGhpcyQxLmFwcCA9PT0gYXBwKSB7IHRoaXMkMS5hcHAgPSB0aGlzJDEuYXBwc1swXSB8fCBudWxsOyB9XG5cbiAgICBpZiAoIXRoaXMkMS5hcHApIHsgdGhpcyQxLmhpc3RvcnkudGVhcmRvd24oKTsgfVxuICB9KTtcblxuICAvLyBtYWluIGFwcCBwcmV2aW91c2x5IGluaXRpYWxpemVkXG4gIC8vIHJldHVybiBhcyB3ZSBkb24ndCBuZWVkIHRvIHNldCB1cCBuZXcgaGlzdG9yeSBsaXN0ZW5lclxuICBpZiAodGhpcy5hcHApIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHRoaXMuYXBwID0gYXBwO1xuXG4gIHZhciBoaXN0b3J5ID0gdGhpcy5oaXN0b3J5O1xuXG4gIGlmIChoaXN0b3J5IGluc3RhbmNlb2YgSFRNTDVIaXN0b3J5IHx8IGhpc3RvcnkgaW5zdGFuY2VvZiBIYXNoSGlzdG9yeSkge1xuICAgIHZhciBoYW5kbGVJbml0aWFsU2Nyb2xsID0gZnVuY3Rpb24gKHJvdXRlT3JFcnJvcikge1xuICAgICAgdmFyIGZyb20gPSBoaXN0b3J5LmN1cnJlbnQ7XG4gICAgICB2YXIgZXhwZWN0U2Nyb2xsID0gdGhpcyQxLm9wdGlvbnMuc2Nyb2xsQmVoYXZpb3I7XG4gICAgICB2YXIgc3VwcG9ydHNTY3JvbGwgPSBzdXBwb3J0c1B1c2hTdGF0ZSAmJiBleHBlY3RTY3JvbGw7XG5cbiAgICAgIGlmIChzdXBwb3J0c1Njcm9sbCAmJiAnZnVsbFBhdGgnIGluIHJvdXRlT3JFcnJvcikge1xuICAgICAgICBoYW5kbGVTY3JvbGwodGhpcyQxLCByb3V0ZU9yRXJyb3IsIGZyb20sIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBzZXR1cExpc3RlbmVycyA9IGZ1bmN0aW9uIChyb3V0ZU9yRXJyb3IpIHtcbiAgICAgIGhpc3Rvcnkuc2V0dXBMaXN0ZW5lcnMoKTtcbiAgICAgIGhhbmRsZUluaXRpYWxTY3JvbGwocm91dGVPckVycm9yKTtcbiAgICB9O1xuICAgIGhpc3RvcnkudHJhbnNpdGlvblRvKFxuICAgICAgaGlzdG9yeS5nZXRDdXJyZW50TG9jYXRpb24oKSxcbiAgICAgIHNldHVwTGlzdGVuZXJzLFxuICAgICAgc2V0dXBMaXN0ZW5lcnNcbiAgICApO1xuICB9XG5cbiAgaGlzdG9yeS5saXN0ZW4oZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgdGhpcyQxLmFwcHMuZm9yRWFjaChmdW5jdGlvbiAoYXBwKSB7XG4gICAgICBhcHAuX3JvdXRlID0gcm91dGU7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5iZWZvcmVFYWNoID0gZnVuY3Rpb24gYmVmb3JlRWFjaCAoZm4pIHtcbiAgcmV0dXJuIHJlZ2lzdGVySG9vayh0aGlzLmJlZm9yZUhvb2tzLCBmbilcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUuYmVmb3JlUmVzb2x2ZSA9IGZ1bmN0aW9uIGJlZm9yZVJlc29sdmUgKGZuKSB7XG4gIHJldHVybiByZWdpc3Rlckhvb2sodGhpcy5yZXNvbHZlSG9va3MsIGZuKVxufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5hZnRlckVhY2ggPSBmdW5jdGlvbiBhZnRlckVhY2ggKGZuKSB7XG4gIHJldHVybiByZWdpc3Rlckhvb2sodGhpcy5hZnRlckhvb2tzLCBmbilcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUub25SZWFkeSA9IGZ1bmN0aW9uIG9uUmVhZHkgKGNiLCBlcnJvckNiKSB7XG4gIHRoaXMuaGlzdG9yeS5vblJlYWR5KGNiLCBlcnJvckNiKTtcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIG9uRXJyb3IgKGVycm9yQ2IpIHtcbiAgdGhpcy5oaXN0b3J5Lm9uRXJyb3IoZXJyb3JDYik7XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICBpZiAoIW9uQ29tcGxldGUgJiYgIW9uQWJvcnQgJiYgdHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHRoaXMkMS5oaXN0b3J5LnB1c2gobG9jYXRpb24sIHJlc29sdmUsIHJlamVjdCk7XG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmhpc3RvcnkucHVzaChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCk7XG4gIH1cbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UgKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIGlmICghb25Db21wbGV0ZSAmJiAhb25BYm9ydCAmJiB0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdGhpcyQxLmhpc3RvcnkucmVwbGFjZShsb2NhdGlvbiwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIHRoaXMuaGlzdG9yeS5yZXBsYWNlKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KTtcbiAgfVxufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5nbyA9IGZ1bmN0aW9uIGdvIChuKSB7XG4gIHRoaXMuaGlzdG9yeS5nbyhuKTtcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUuYmFjayA9IGZ1bmN0aW9uIGJhY2sgKCkge1xuICB0aGlzLmdvKC0xKTtcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUuZm9yd2FyZCA9IGZ1bmN0aW9uIGZvcndhcmQgKCkge1xuICB0aGlzLmdvKDEpO1xufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5nZXRNYXRjaGVkQ29tcG9uZW50cyA9IGZ1bmN0aW9uIGdldE1hdGNoZWRDb21wb25lbnRzICh0bykge1xuICB2YXIgcm91dGUgPSB0b1xuICAgID8gdG8ubWF0Y2hlZFxuICAgICAgPyB0b1xuICAgICAgOiB0aGlzLnJlc29sdmUodG8pLnJvdXRlXG4gICAgOiB0aGlzLmN1cnJlbnRSb3V0ZTtcbiAgaWYgKCFyb3V0ZSkge1xuICAgIHJldHVybiBbXVxuICB9XG4gIHJldHVybiBbXS5jb25jYXQuYXBwbHkoXG4gICAgW10sXG4gICAgcm91dGUubWF0Y2hlZC5tYXAoZnVuY3Rpb24gKG0pIHtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyhtLmNvbXBvbmVudHMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBtLmNvbXBvbmVudHNba2V5XVxuICAgICAgfSlcbiAgICB9KVxuICApXG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiByZXNvbHZlIChcbiAgdG8sXG4gIGN1cnJlbnQsXG4gIGFwcGVuZFxuKSB7XG4gIGN1cnJlbnQgPSBjdXJyZW50IHx8IHRoaXMuaGlzdG9yeS5jdXJyZW50O1xuICB2YXIgbG9jYXRpb24gPSBub3JtYWxpemVMb2NhdGlvbih0bywgY3VycmVudCwgYXBwZW5kLCB0aGlzKTtcbiAgdmFyIHJvdXRlID0gdGhpcy5tYXRjaChsb2NhdGlvbiwgY3VycmVudCk7XG4gIHZhciBmdWxsUGF0aCA9IHJvdXRlLnJlZGlyZWN0ZWRGcm9tIHx8IHJvdXRlLmZ1bGxQYXRoO1xuICB2YXIgYmFzZSA9IHRoaXMuaGlzdG9yeS5iYXNlO1xuICB2YXIgaHJlZiA9IGNyZWF0ZUhyZWYoYmFzZSwgZnVsbFBhdGgsIHRoaXMubW9kZSk7XG4gIHJldHVybiB7XG4gICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgIHJvdXRlOiByb3V0ZSxcbiAgICBocmVmOiBocmVmLFxuICAgIC8vIGZvciBiYWNrd2FyZHMgY29tcGF0XG4gICAgbm9ybWFsaXplZFRvOiBsb2NhdGlvbixcbiAgICByZXNvbHZlZDogcm91dGVcbiAgfVxufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5nZXRSb3V0ZXMgPSBmdW5jdGlvbiBnZXRSb3V0ZXMgKCkge1xuICByZXR1cm4gdGhpcy5tYXRjaGVyLmdldFJvdXRlcygpXG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLmFkZFJvdXRlID0gZnVuY3Rpb24gYWRkUm91dGUgKHBhcmVudE9yUm91dGUsIHJvdXRlKSB7XG4gIHRoaXMubWF0Y2hlci5hZGRSb3V0ZShwYXJlbnRPclJvdXRlLCByb3V0ZSk7XG4gIGlmICh0aGlzLmhpc3RvcnkuY3VycmVudCAhPT0gU1RBUlQpIHtcbiAgICB0aGlzLmhpc3RvcnkudHJhbnNpdGlvblRvKHRoaXMuaGlzdG9yeS5nZXRDdXJyZW50TG9jYXRpb24oKSk7XG4gIH1cbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUuYWRkUm91dGVzID0gZnVuY3Rpb24gYWRkUm91dGVzIChyb3V0ZXMpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB3YXJuKGZhbHNlLCAncm91dGVyLmFkZFJvdXRlcygpIGlzIGRlcHJlY2F0ZWQgYW5kIGhhcyBiZWVuIHJlbW92ZWQgaW4gVnVlIFJvdXRlciA0LiBVc2Ugcm91dGVyLmFkZFJvdXRlKCkgaW5zdGVhZC4nKTtcbiAgfVxuICB0aGlzLm1hdGNoZXIuYWRkUm91dGVzKHJvdXRlcyk7XG4gIGlmICh0aGlzLmhpc3RvcnkuY3VycmVudCAhPT0gU1RBUlQpIHtcbiAgICB0aGlzLmhpc3RvcnkudHJhbnNpdGlvblRvKHRoaXMuaGlzdG9yeS5nZXRDdXJyZW50TG9jYXRpb24oKSk7XG4gIH1cbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBWdWVSb3V0ZXIucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcblxuZnVuY3Rpb24gcmVnaXN0ZXJIb29rIChsaXN0LCBmbikge1xuICBsaXN0LnB1c2goZm4pO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpID0gbGlzdC5pbmRleE9mKGZuKTtcbiAgICBpZiAoaSA+IC0xKSB7IGxpc3Quc3BsaWNlKGksIDEpOyB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlSHJlZiAoYmFzZSwgZnVsbFBhdGgsIG1vZGUpIHtcbiAgdmFyIHBhdGggPSBtb2RlID09PSAnaGFzaCcgPyAnIycgKyBmdWxsUGF0aCA6IGZ1bGxQYXRoO1xuICByZXR1cm4gYmFzZSA/IGNsZWFuUGF0aChiYXNlICsgJy8nICsgcGF0aCkgOiBwYXRoXG59XG5cblZ1ZVJvdXRlci5pbnN0YWxsID0gaW5zdGFsbDtcblZ1ZVJvdXRlci52ZXJzaW9uID0gJzMuNS40JztcblZ1ZVJvdXRlci5pc05hdmlnYXRpb25GYWlsdXJlID0gaXNOYXZpZ2F0aW9uRmFpbHVyZTtcblZ1ZVJvdXRlci5OYXZpZ2F0aW9uRmFpbHVyZVR5cGUgPSBOYXZpZ2F0aW9uRmFpbHVyZVR5cGU7XG5WdWVSb3V0ZXIuU1RBUlRfTE9DQVRJT04gPSBTVEFSVDtcblxuaWYgKGluQnJvd3NlciAmJiB3aW5kb3cuVnVlKSB7XG4gIHdpbmRvdy5WdWUudXNlKFZ1ZVJvdXRlcik7XG59XG5cbmV4cG9ydCBkZWZhdWx0IFZ1ZVJvdXRlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/vue-router/dist/vue-router.esm.js\n");

/***/ }),

/***/ "./node_modules/vue/dist/vue.esm.js":
/*!******************************************!*\
  !*** ./node_modules/vue/dist/vue.esm.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EffectScope\": () => (/* binding */ EffectScope),\n/* harmony export */   \"computed\": () => (/* binding */ computed),\n/* harmony export */   \"customRef\": () => (/* binding */ customRef),\n/* harmony export */   \"default\": () => (/* binding */ Vue),\n/* harmony export */   \"defineAsyncComponent\": () => (/* binding */ defineAsyncComponent),\n/* harmony export */   \"defineComponent\": () => (/* binding */ defineComponent),\n/* harmony export */   \"del\": () => (/* binding */ del),\n/* harmony export */   \"effectScope\": () => (/* binding */ effectScope),\n/* harmony export */   \"getCurrentInstance\": () => (/* binding */ getCurrentInstance),\n/* harmony export */   \"getCurrentScope\": () => (/* binding */ getCurrentScope),\n/* harmony export */   \"h\": () => (/* binding */ h),\n/* harmony export */   \"inject\": () => (/* binding */ inject),\n/* harmony export */   \"isProxy\": () => (/* binding */ isProxy),\n/* harmony export */   \"isReactive\": () => (/* binding */ isReactive),\n/* harmony export */   \"isReadonly\": () => (/* binding */ isReadonly),\n/* harmony export */   \"isRef\": () => (/* binding */ isRef),\n/* harmony export */   \"isShallow\": () => (/* binding */ isShallow),\n/* harmony export */   \"markRaw\": () => (/* binding */ markRaw),\n/* harmony export */   \"mergeDefaults\": () => (/* binding */ mergeDefaults),\n/* harmony export */   \"nextTick\": () => (/* binding */ nextTick),\n/* harmony export */   \"onActivated\": () => (/* binding */ onActivated),\n/* harmony export */   \"onBeforeMount\": () => (/* binding */ onBeforeMount),\n/* harmony export */   \"onBeforeUnmount\": () => (/* binding */ onBeforeUnmount),\n/* harmony export */   \"onBeforeUpdate\": () => (/* binding */ onBeforeUpdate),\n/* harmony export */   \"onDeactivated\": () => (/* binding */ onDeactivated),\n/* harmony export */   \"onErrorCaptured\": () => (/* binding */ onErrorCaptured),\n/* harmony export */   \"onMounted\": () => (/* binding */ onMounted),\n/* harmony export */   \"onRenderTracked\": () => (/* binding */ onRenderTracked),\n/* harmony export */   \"onRenderTriggered\": () => (/* binding */ onRenderTriggered),\n/* harmony export */   \"onScopeDispose\": () => (/* binding */ onScopeDispose),\n/* harmony export */   \"onServerPrefetch\": () => (/* binding */ onServerPrefetch),\n/* harmony export */   \"onUnmounted\": () => (/* binding */ onUnmounted),\n/* harmony export */   \"onUpdated\": () => (/* binding */ onUpdated),\n/* harmony export */   \"provide\": () => (/* binding */ provide),\n/* harmony export */   \"proxyRefs\": () => (/* binding */ proxyRefs),\n/* harmony export */   \"reactive\": () => (/* binding */ reactive),\n/* harmony export */   \"readonly\": () => (/* binding */ readonly),\n/* harmony export */   \"ref\": () => (/* binding */ ref$1),\n/* harmony export */   \"set\": () => (/* binding */ set),\n/* harmony export */   \"shallowReactive\": () => (/* binding */ shallowReactive),\n/* harmony export */   \"shallowReadonly\": () => (/* binding */ shallowReadonly),\n/* harmony export */   \"shallowRef\": () => (/* binding */ shallowRef),\n/* harmony export */   \"toRaw\": () => (/* binding */ toRaw),\n/* harmony export */   \"toRef\": () => (/* binding */ toRef),\n/* harmony export */   \"toRefs\": () => (/* binding */ toRefs),\n/* harmony export */   \"triggerRef\": () => (/* binding */ triggerRef),\n/* harmony export */   \"unref\": () => (/* binding */ unref),\n/* harmony export */   \"useAttrs\": () => (/* binding */ useAttrs),\n/* harmony export */   \"useCssModule\": () => (/* binding */ useCssModule),\n/* harmony export */   \"useCssVars\": () => (/* binding */ useCssVars),\n/* harmony export */   \"useListeners\": () => (/* binding */ useListeners),\n/* harmony export */   \"useSlots\": () => (/* binding */ useSlots),\n/* harmony export */   \"version\": () => (/* binding */ version),\n/* harmony export */   \"watch\": () => (/* binding */ watch),\n/* harmony export */   \"watchEffect\": () => (/* binding */ watchEffect),\n/* harmony export */   \"watchPostEffect\": () => (/* binding */ watchPostEffect),\n/* harmony export */   \"watchSyncEffect\": () => (/* binding */ watchSyncEffect)\n/* harmony export */ });\n/*!\n * Vue.js v2.7.8\n * (c) 2014-2022 Evan You\n * Released under the MIT License.\n */\nvar emptyObject = Object.freeze({});\r\nvar isArray = Array.isArray;\r\n// These helpers produce better VM code in JS engines due to their\r\n// explicitness and function inlining.\r\nfunction isUndef(v) {\r\n    return v === undefined || v === null;\r\n}\r\nfunction isDef(v) {\r\n    return v !== undefined && v !== null;\r\n}\r\nfunction isTrue(v) {\r\n    return v === true;\r\n}\r\nfunction isFalse(v) {\r\n    return v === false;\r\n}\r\n/**\r\n * Check if value is primitive.\r\n */\r\nfunction isPrimitive(value) {\r\n    return (typeof value === 'string' ||\r\n        typeof value === 'number' ||\r\n        // $flow-disable-line\r\n        typeof value === 'symbol' ||\r\n        typeof value === 'boolean');\r\n}\r\nfunction isFunction(value) {\r\n    return typeof value === 'function';\r\n}\r\n/**\r\n * Quick object check - this is primarily used to tell\r\n * objects from primitive values when we know the value\r\n * is a JSON-compliant type.\r\n */\r\nfunction isObject(obj) {\r\n    return obj !== null && typeof obj === 'object';\r\n}\r\n/**\r\n * Get the raw type string of a value, e.g., [object Object].\r\n */\r\nvar _toString = Object.prototype.toString;\r\nfunction toRawType(value) {\r\n    return _toString.call(value).slice(8, -1);\r\n}\r\n/**\r\n * Strict object type check. Only returns true\r\n * for plain JavaScript objects.\r\n */\r\nfunction isPlainObject(obj) {\r\n    return _toString.call(obj) === '[object Object]';\r\n}\r\nfunction isRegExp(v) {\r\n    return _toString.call(v) === '[object RegExp]';\r\n}\r\n/**\r\n * Check if val is a valid array index.\r\n */\r\nfunction isValidArrayIndex(val) {\r\n    var n = parseFloat(String(val));\r\n    return n >= 0 && Math.floor(n) === n && isFinite(val);\r\n}\r\nfunction isPromise(val) {\r\n    return (isDef(val) &&\r\n        typeof val.then === 'function' &&\r\n        typeof val.catch === 'function');\r\n}\r\n/**\r\n * Convert a value to a string that is actually rendered.\r\n */\r\nfunction toString(val) {\r\n    return val == null\r\n        ? ''\r\n        : Array.isArray(val) || (isPlainObject(val) && val.toString === _toString)\r\n            ? JSON.stringify(val, null, 2)\r\n            : String(val);\r\n}\r\n/**\r\n * Convert an input value to a number for persistence.\r\n * If the conversion fails, return original string.\r\n */\r\nfunction toNumber(val) {\r\n    var n = parseFloat(val);\r\n    return isNaN(n) ? val : n;\r\n}\r\n/**\r\n * Make a map and return a function for checking if a key\r\n * is in that map.\r\n */\r\nfunction makeMap(str, expectsLowerCase) {\r\n    var map = Object.create(null);\r\n    var list = str.split(',');\r\n    for (var i = 0; i < list.length; i++) {\r\n        map[list[i]] = true;\r\n    }\r\n    return expectsLowerCase ? function (val) { return map[val.toLowerCase()]; } : function (val) { return map[val]; };\r\n}\r\n/**\r\n * Check if a tag is a built-in tag.\r\n */\r\nvar isBuiltInTag = makeMap('slot,component', true);\r\n/**\r\n * Check if an attribute is a reserved attribute.\r\n */\r\nvar isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');\r\n/**\r\n * Remove an item from an array.\r\n */\r\nfunction remove$2(arr, item) {\r\n    if (arr.length) {\r\n        var index = arr.indexOf(item);\r\n        if (index > -1) {\r\n            return arr.splice(index, 1);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Check whether an object has the property.\r\n */\r\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\r\nfunction hasOwn(obj, key) {\r\n    return hasOwnProperty.call(obj, key);\r\n}\r\n/**\r\n * Create a cached version of a pure function.\r\n */\r\nfunction cached(fn) {\r\n    var cache = Object.create(null);\r\n    return function cachedFn(str) {\r\n        var hit = cache[str];\r\n        return hit || (cache[str] = fn(str));\r\n    };\r\n}\r\n/**\r\n * Camelize a hyphen-delimited string.\r\n */\r\nvar camelizeRE = /-(\\w)/g;\r\nvar camelize = cached(function (str) {\r\n    return str.replace(camelizeRE, function (_, c) { return (c ? c.toUpperCase() : ''); });\r\n});\r\n/**\r\n * Capitalize a string.\r\n */\r\nvar capitalize = cached(function (str) {\r\n    return str.charAt(0).toUpperCase() + str.slice(1);\r\n});\r\n/**\r\n * Hyphenate a camelCase string.\r\n */\r\nvar hyphenateRE = /\\B([A-Z])/g;\r\nvar hyphenate = cached(function (str) {\r\n    return str.replace(hyphenateRE, '-$1').toLowerCase();\r\n});\r\n/**\r\n * Simple bind polyfill for environments that do not support it,\r\n * e.g., PhantomJS 1.x. Technically, we don't need this anymore\r\n * since native bind is now performant enough in most browsers.\r\n * But removing it would mean breaking code that was able to run in\r\n * PhantomJS 1.x, so this must be kept for backward compatibility.\r\n */\r\n/* istanbul ignore next */\r\nfunction polyfillBind(fn, ctx) {\r\n    function boundFn(a) {\r\n        var l = arguments.length;\r\n        return l\r\n            ? l > 1\r\n                ? fn.apply(ctx, arguments)\r\n                : fn.call(ctx, a)\r\n            : fn.call(ctx);\r\n    }\r\n    boundFn._length = fn.length;\r\n    return boundFn;\r\n}\r\nfunction nativeBind(fn, ctx) {\r\n    return fn.bind(ctx);\r\n}\r\n// @ts-expect-error bind cannot be `undefined`\r\nvar bind$1 = Function.prototype.bind ? nativeBind : polyfillBind;\r\n/**\r\n * Convert an Array-like object to a real Array.\r\n */\r\nfunction toArray(list, start) {\r\n    start = start || 0;\r\n    var i = list.length - start;\r\n    var ret = new Array(i);\r\n    while (i--) {\r\n        ret[i] = list[i + start];\r\n    }\r\n    return ret;\r\n}\r\n/**\r\n * Mix properties into target object.\r\n */\r\nfunction extend(to, _from) {\r\n    for (var key in _from) {\r\n        to[key] = _from[key];\r\n    }\r\n    return to;\r\n}\r\n/**\r\n * Merge an Array of Objects into a single Object.\r\n */\r\nfunction toObject(arr) {\r\n    var res = {};\r\n    for (var i = 0; i < arr.length; i++) {\r\n        if (arr[i]) {\r\n            extend(res, arr[i]);\r\n        }\r\n    }\r\n    return res;\r\n}\r\n/* eslint-disable no-unused-vars */\r\n/**\r\n * Perform no operation.\r\n * Stubbing args to make Flow happy without leaving useless transpiled code\r\n * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).\r\n */\r\nfunction noop(a, b, c) { }\r\n/**\r\n * Always return false.\r\n */\r\nvar no = function (a, b, c) { return false; };\r\n/* eslint-enable no-unused-vars */\r\n/**\r\n * Return the same value.\r\n */\r\nvar identity = function (_) { return _; };\r\n/**\r\n * Generate a string containing static keys from compiler modules.\r\n */\r\nfunction genStaticKeys$1(modules) {\r\n    return modules\r\n        .reduce(function (keys, m) {\r\n        return keys.concat(m.staticKeys || []);\r\n    }, [])\r\n        .join(',');\r\n}\r\n/**\r\n * Check if two values are loosely equal - that is,\r\n * if they are plain objects, do they have the same shape?\r\n */\r\nfunction looseEqual(a, b) {\r\n    if (a === b)\r\n        return true;\r\n    var isObjectA = isObject(a);\r\n    var isObjectB = isObject(b);\r\n    if (isObjectA && isObjectB) {\r\n        try {\r\n            var isArrayA = Array.isArray(a);\r\n            var isArrayB = Array.isArray(b);\r\n            if (isArrayA && isArrayB) {\r\n                return (a.length === b.length &&\r\n                    a.every(function (e, i) {\r\n                        return looseEqual(e, b[i]);\r\n                    }));\r\n            }\r\n            else if (a instanceof Date && b instanceof Date) {\r\n                return a.getTime() === b.getTime();\r\n            }\r\n            else if (!isArrayA && !isArrayB) {\r\n                var keysA = Object.keys(a);\r\n                var keysB = Object.keys(b);\r\n                return (keysA.length === keysB.length &&\r\n                    keysA.every(function (key) {\r\n                        return looseEqual(a[key], b[key]);\r\n                    }));\r\n            }\r\n            else {\r\n                /* istanbul ignore next */\r\n                return false;\r\n            }\r\n        }\r\n        catch (e) {\r\n            /* istanbul ignore next */\r\n            return false;\r\n        }\r\n    }\r\n    else if (!isObjectA && !isObjectB) {\r\n        return String(a) === String(b);\r\n    }\r\n    else {\r\n        return false;\r\n    }\r\n}\r\n/**\r\n * Return the first index at which a loosely equal value can be\r\n * found in the array (if value is a plain object, the array must\r\n * contain an object of the same shape), or -1 if it is not present.\r\n */\r\nfunction looseIndexOf(arr, val) {\r\n    for (var i = 0; i < arr.length; i++) {\r\n        if (looseEqual(arr[i], val))\r\n            return i;\r\n    }\r\n    return -1;\r\n}\r\n/**\r\n * Ensure a function is called only once.\r\n */\r\nfunction once(fn) {\r\n    var called = false;\r\n    return function () {\r\n        if (!called) {\r\n            called = true;\r\n            fn.apply(this, arguments);\r\n        }\r\n    };\r\n}\r\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#polyfill\r\nfunction hasChanged(x, y) {\r\n    if (x === y) {\r\n        return x === 0 && 1 / x !== 1 / y;\r\n    }\r\n    else {\r\n        return x === x || y === y;\r\n    }\r\n}\n\nvar SSR_ATTR = 'data-server-rendered';\r\nvar ASSET_TYPES = ['component', 'directive', 'filter'];\r\nvar LIFECYCLE_HOOKS = [\r\n    'beforeCreate',\r\n    'created',\r\n    'beforeMount',\r\n    'mounted',\r\n    'beforeUpdate',\r\n    'updated',\r\n    'beforeDestroy',\r\n    'destroyed',\r\n    'activated',\r\n    'deactivated',\r\n    'errorCaptured',\r\n    'serverPrefetch',\r\n    'renderTracked',\r\n    'renderTriggered'\r\n];\n\nvar config = {\r\n    /**\r\n     * Option merge strategies (used in core/util/options)\r\n     */\r\n    // $flow-disable-line\r\n    optionMergeStrategies: Object.create(null),\r\n    /**\r\n     * Whether to suppress warnings.\r\n     */\r\n    silent: false,\r\n    /**\r\n     * Show production mode tip message on boot?\r\n     */\r\n    productionTip: \"development\" !== 'production',\r\n    /**\r\n     * Whether to enable devtools\r\n     */\r\n    devtools: \"development\" !== 'production',\r\n    /**\r\n     * Whether to record perf\r\n     */\r\n    performance: false,\r\n    /**\r\n     * Error handler for watcher errors\r\n     */\r\n    errorHandler: null,\r\n    /**\r\n     * Warn handler for watcher warns\r\n     */\r\n    warnHandler: null,\r\n    /**\r\n     * Ignore certain custom elements\r\n     */\r\n    ignoredElements: [],\r\n    /**\r\n     * Custom user key aliases for v-on\r\n     */\r\n    // $flow-disable-line\r\n    keyCodes: Object.create(null),\r\n    /**\r\n     * Check if a tag is reserved so that it cannot be registered as a\r\n     * component. This is platform-dependent and may be overwritten.\r\n     */\r\n    isReservedTag: no,\r\n    /**\r\n     * Check if an attribute is reserved so that it cannot be used as a component\r\n     * prop. This is platform-dependent and may be overwritten.\r\n     */\r\n    isReservedAttr: no,\r\n    /**\r\n     * Check if a tag is an unknown element.\r\n     * Platform-dependent.\r\n     */\r\n    isUnknownElement: no,\r\n    /**\r\n     * Get the namespace of an element\r\n     */\r\n    getTagNamespace: noop,\r\n    /**\r\n     * Parse the real tag name for the specific platform.\r\n     */\r\n    parsePlatformTagName: identity,\r\n    /**\r\n     * Check if an attribute must be bound using property, e.g. value\r\n     * Platform-dependent.\r\n     */\r\n    mustUseProp: no,\r\n    /**\r\n     * Perform updates asynchronously. Intended to be used by Vue Test Utils\r\n     * This will significantly reduce performance if set to false.\r\n     */\r\n    async: true,\r\n    /**\r\n     * Exposed for legacy reasons\r\n     */\r\n    _lifecycleHooks: LIFECYCLE_HOOKS\r\n};\n\n/**\r\n * unicode letters used for parsing html tags, component names and property paths.\r\n * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname\r\n * skipping \\u10000-\\uEFFFF due to it freezing up PhantomJS\r\n */\r\nvar unicodeRegExp = /a-zA-Z\\u00B7\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u203F-\\u2040\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD/;\r\n/**\r\n * Check if a string starts with $ or _\r\n */\r\nfunction isReserved(str) {\r\n    var c = (str + '').charCodeAt(0);\r\n    return c === 0x24 || c === 0x5f;\r\n}\r\n/**\r\n * Define a property.\r\n */\r\nfunction def(obj, key, val, enumerable) {\r\n    Object.defineProperty(obj, key, {\r\n        value: val,\r\n        enumerable: !!enumerable,\r\n        writable: true,\r\n        configurable: true\r\n    });\r\n}\r\n/**\r\n * Parse simple path.\r\n */\r\nvar bailRE = new RegExp(\"[^\".concat(unicodeRegExp.source, \".$_\\\\d]\"));\r\nfunction parsePath(path) {\r\n    if (bailRE.test(path)) {\r\n        return;\r\n    }\r\n    var segments = path.split('.');\r\n    return function (obj) {\r\n        for (var i = 0; i < segments.length; i++) {\r\n            if (!obj)\r\n                return;\r\n            obj = obj[segments[i]];\r\n        }\r\n        return obj;\r\n    };\r\n}\n\n// can we use __proto__?\r\nvar hasProto = '__proto__' in {};\r\n// Browser environment sniffing\r\nvar inBrowser = typeof window !== 'undefined';\r\nvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\r\nvar isIE = UA && /msie|trident/.test(UA);\r\nvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\r\nvar isEdge = UA && UA.indexOf('edge/') > 0;\r\nUA && UA.indexOf('android') > 0;\r\nvar isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);\r\nUA && /chrome\\/\\d+/.test(UA) && !isEdge;\r\nUA && /phantomjs/.test(UA);\r\nvar isFF = UA && UA.match(/firefox\\/(\\d+)/);\r\n// Firefox has a \"watch\" function on Object.prototype...\r\n// @ts-expect-error firebox support\r\nvar nativeWatch = {}.watch;\r\nvar supportsPassive = false;\r\nif (inBrowser) {\r\n    try {\r\n        var opts = {};\r\n        Object.defineProperty(opts, 'passive', {\r\n            get: function () {\r\n                /* istanbul ignore next */\r\n                supportsPassive = true;\r\n            }\r\n        }); // https://github.com/facebook/flow/issues/285\r\n        window.addEventListener('test-passive', null, opts);\r\n    }\r\n    catch (e) { }\r\n}\r\n// this needs to be lazy-evaled because vue may be required before\r\n// vue-server-renderer can set VUE_ENV\r\nvar _isServer;\r\nvar isServerRendering = function () {\r\n    if (_isServer === undefined) {\r\n        /* istanbul ignore if */\r\n        if (!inBrowser && typeof __webpack_require__.g !== 'undefined') {\r\n            // detect presence of vue-server-renderer and avoid\r\n            // Webpack shimming the process\r\n            _isServer =\r\n                __webpack_require__.g['process'] && __webpack_require__.g['process'].env.VUE_ENV === 'server';\r\n        }\r\n        else {\r\n            _isServer = false;\r\n        }\r\n    }\r\n    return _isServer;\r\n};\r\n// detect devtools\r\nvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\r\n/* istanbul ignore next */\r\nfunction isNative(Ctor) {\r\n    return typeof Ctor === 'function' && /native code/.test(Ctor.toString());\r\n}\r\nvar hasSymbol = typeof Symbol !== 'undefined' &&\r\n    isNative(Symbol) &&\r\n    typeof Reflect !== 'undefined' &&\r\n    isNative(Reflect.ownKeys);\r\nvar _Set; // $flow-disable-line\r\n/* istanbul ignore if */ if (typeof Set !== 'undefined' && isNative(Set)) {\r\n    // use native Set when available.\r\n    _Set = Set;\r\n}\r\nelse {\r\n    // a non-standard Set polyfill that only works with primitive keys.\r\n    _Set = /** @class */ (function () {\r\n        function Set() {\r\n            this.set = Object.create(null);\r\n        }\r\n        Set.prototype.has = function (key) {\r\n            return this.set[key] === true;\r\n        };\r\n        Set.prototype.add = function (key) {\r\n            this.set[key] = true;\r\n        };\r\n        Set.prototype.clear = function () {\r\n            this.set = Object.create(null);\r\n        };\r\n        return Set;\r\n    }());\r\n}\n\nvar currentInstance = null;\r\n/**\r\n * This is exposed for compatibility with v3 (e.g. some functions in VueUse\r\n * relies on it). Do not use this internally, just use `currentInstance`.\r\n *\r\n * @internal this function needs manual type declaration because it relies\r\n * on previously manually authored types from Vue 2\r\n */\r\nfunction getCurrentInstance() {\r\n    return currentInstance && { proxy: currentInstance };\r\n}\r\n/**\r\n * @internal\r\n */\r\nfunction setCurrentInstance(vm) {\r\n    if (vm === void 0) { vm = null; }\r\n    if (!vm)\r\n        currentInstance && currentInstance._scope.off();\r\n    currentInstance = vm;\r\n    vm && vm._scope.on();\r\n}\n\n/**\r\n * @internal\r\n */\r\nvar VNode = /** @class */ (function () {\r\n    function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {\r\n        this.tag = tag;\r\n        this.data = data;\r\n        this.children = children;\r\n        this.text = text;\r\n        this.elm = elm;\r\n        this.ns = undefined;\r\n        this.context = context;\r\n        this.fnContext = undefined;\r\n        this.fnOptions = undefined;\r\n        this.fnScopeId = undefined;\r\n        this.key = data && data.key;\r\n        this.componentOptions = componentOptions;\r\n        this.componentInstance = undefined;\r\n        this.parent = undefined;\r\n        this.raw = false;\r\n        this.isStatic = false;\r\n        this.isRootInsert = true;\r\n        this.isComment = false;\r\n        this.isCloned = false;\r\n        this.isOnce = false;\r\n        this.asyncFactory = asyncFactory;\r\n        this.asyncMeta = undefined;\r\n        this.isAsyncPlaceholder = false;\r\n    }\r\n    Object.defineProperty(VNode.prototype, \"child\", {\r\n        // DEPRECATED: alias for componentInstance for backwards compat.\r\n        /* istanbul ignore next */\r\n        get: function () {\r\n            return this.componentInstance;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    return VNode;\r\n}());\r\nvar createEmptyVNode = function (text) {\r\n    if (text === void 0) { text = ''; }\r\n    var node = new VNode();\r\n    node.text = text;\r\n    node.isComment = true;\r\n    return node;\r\n};\r\nfunction createTextVNode(val) {\r\n    return new VNode(undefined, undefined, undefined, String(val));\r\n}\r\n// optimized shallow clone\r\n// used for static nodes and slot nodes because they may be reused across\r\n// multiple renders, cloning them avoids errors when DOM manipulations rely\r\n// on their elm reference.\r\nfunction cloneVNode(vnode) {\r\n    var cloned = new VNode(vnode.tag, vnode.data, \r\n    // #7975\r\n    // clone children array to avoid mutating original in case of cloning\r\n    // a child.\r\n    vnode.children && vnode.children.slice(), vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);\r\n    cloned.ns = vnode.ns;\r\n    cloned.isStatic = vnode.isStatic;\r\n    cloned.key = vnode.key;\r\n    cloned.isComment = vnode.isComment;\r\n    cloned.fnContext = vnode.fnContext;\r\n    cloned.fnOptions = vnode.fnOptions;\r\n    cloned.fnScopeId = vnode.fnScopeId;\r\n    cloned.asyncMeta = vnode.asyncMeta;\r\n    cloned.isCloned = true;\r\n    return cloned;\r\n}\n\n/* not type checking this file because flow doesn't play well with Proxy */\r\nvar initProxy;\r\nif (true) {\r\n    var allowedGlobals_1 = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' +\r\n        'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +\r\n        'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,' +\r\n        'require' // for Webpack/Browserify\r\n    );\r\n    var warnNonPresent_1 = function (target, key) {\r\n        warn$2(\"Property or method \\\"\".concat(key, \"\\\" is not defined on the instance but \") +\r\n            'referenced during render. Make sure that this property is reactive, ' +\r\n            'either in the data option, or for class-based components, by ' +\r\n            'initializing the property. ' +\r\n            'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.', target);\r\n    };\r\n    var warnReservedPrefix_1 = function (target, key) {\r\n        warn$2(\"Property \\\"\".concat(key, \"\\\" must be accessed with \\\"$data.\").concat(key, \"\\\" because \") +\r\n            'properties starting with \"$\" or \"_\" are not proxied in the Vue instance to ' +\r\n            'prevent conflicts with Vue internals. ' +\r\n            'See: https://vuejs.org/v2/api/#data', target);\r\n    };\r\n    var hasProxy_1 = typeof Proxy !== 'undefined' && isNative(Proxy);\r\n    if (hasProxy_1) {\r\n        var isBuiltInModifier_1 = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');\r\n        config.keyCodes = new Proxy(config.keyCodes, {\r\n            set: function (target, key, value) {\r\n                if (isBuiltInModifier_1(key)) {\r\n                    warn$2(\"Avoid overwriting built-in modifier in config.keyCodes: .\".concat(key));\r\n                    return false;\r\n                }\r\n                else {\r\n                    target[key] = value;\r\n                    return true;\r\n                }\r\n            }\r\n        });\r\n    }\r\n    var hasHandler_1 = {\r\n        has: function (target, key) {\r\n            var has = key in target;\r\n            var isAllowed = allowedGlobals_1(key) ||\r\n                (typeof key === 'string' &&\r\n                    key.charAt(0) === '_' &&\r\n                    !(key in target.$data));\r\n            if (!has && !isAllowed) {\r\n                if (key in target.$data)\r\n                    warnReservedPrefix_1(target, key);\r\n                else\r\n                    warnNonPresent_1(target, key);\r\n            }\r\n            return has || !isAllowed;\r\n        }\r\n    };\r\n    var getHandler_1 = {\r\n        get: function (target, key) {\r\n            if (typeof key === 'string' && !(key in target)) {\r\n                if (key in target.$data)\r\n                    warnReservedPrefix_1(target, key);\r\n                else\r\n                    warnNonPresent_1(target, key);\r\n            }\r\n            return target[key];\r\n        }\r\n    };\r\n    initProxy = function initProxy(vm) {\r\n        if (hasProxy_1) {\r\n            // determine which proxy handler to use\r\n            var options = vm.$options;\r\n            var handlers = options.render && options.render._withStripped ? getHandler_1 : hasHandler_1;\r\n            vm._renderProxy = new Proxy(vm, handlers);\r\n        }\r\n        else {\r\n            vm._renderProxy = vm;\r\n        }\r\n    };\r\n}\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\n\nvar uid$2 = 0;\r\n/**\r\n * A dep is an observable that can have multiple\r\n * directives subscribing to it.\r\n * @internal\r\n */\r\nvar Dep = /** @class */ (function () {\r\n    function Dep() {\r\n        this.id = uid$2++;\r\n        this.subs = [];\r\n    }\r\n    Dep.prototype.addSub = function (sub) {\r\n        this.subs.push(sub);\r\n    };\r\n    Dep.prototype.removeSub = function (sub) {\r\n        remove$2(this.subs, sub);\r\n    };\r\n    Dep.prototype.depend = function (info) {\r\n        if (Dep.target) {\r\n            Dep.target.addDep(this);\r\n            if ( true && info && Dep.target.onTrack) {\r\n                Dep.target.onTrack(__assign({ effect: Dep.target }, info));\r\n            }\r\n        }\r\n    };\r\n    Dep.prototype.notify = function (info) {\r\n        // stabilize the subscriber list first\r\n        var subs = this.subs.slice();\r\n        if ( true && !config.async) {\r\n            // subs aren't sorted in scheduler if not running async\r\n            // we need to sort them now to make sure they fire in correct\r\n            // order\r\n            subs.sort(function (a, b) { return a.id - b.id; });\r\n        }\r\n        for (var i = 0, l = subs.length; i < l; i++) {\r\n            if ( true && info) {\r\n                var sub = subs[i];\r\n                sub.onTrigger &&\r\n                    sub.onTrigger(__assign({ effect: subs[i] }, info));\r\n            }\r\n            subs[i].update();\r\n        }\r\n    };\r\n    return Dep;\r\n}());\r\n// The current target watcher being evaluated.\r\n// This is globally unique because only one watcher\r\n// can be evaluated at a time.\r\nDep.target = null;\r\nvar targetStack = [];\r\nfunction pushTarget(target) {\r\n    targetStack.push(target);\r\n    Dep.target = target;\r\n}\r\nfunction popTarget() {\r\n    targetStack.pop();\r\n    Dep.target = targetStack[targetStack.length - 1];\r\n}\n\n/*\r\n * not type checking this file because flow doesn't play well with\r\n * dynamically accessing methods on Array prototype\r\n */\r\nvar arrayProto = Array.prototype;\r\nvar arrayMethods = Object.create(arrayProto);\r\nvar methodsToPatch = [\r\n    'push',\r\n    'pop',\r\n    'shift',\r\n    'unshift',\r\n    'splice',\r\n    'sort',\r\n    'reverse'\r\n];\r\n/**\r\n * Intercept mutating methods and emit events\r\n */\r\nmethodsToPatch.forEach(function (method) {\r\n    // cache original method\r\n    var original = arrayProto[method];\r\n    def(arrayMethods, method, function mutator() {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        var result = original.apply(this, args);\r\n        var ob = this.__ob__;\r\n        var inserted;\r\n        switch (method) {\r\n            case 'push':\r\n            case 'unshift':\r\n                inserted = args;\r\n                break;\r\n            case 'splice':\r\n                inserted = args.slice(2);\r\n                break;\r\n        }\r\n        if (inserted)\r\n            ob.observeArray(inserted);\r\n        // notify change\r\n        if (true) {\r\n            ob.dep.notify({\r\n                type: \"array mutation\" /* TriggerOpTypes.ARRAY_MUTATION */,\r\n                target: this,\r\n                key: method\r\n            });\r\n        }\r\n        else {}\r\n        return result;\r\n    });\r\n});\n\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\r\nvar NO_INIITIAL_VALUE = {};\r\n/**\r\n * In some cases we may want to disable observation inside a component's\r\n * update computation.\r\n */\r\nvar shouldObserve = true;\r\nfunction toggleObserving(value) {\r\n    shouldObserve = value;\r\n}\r\n// ssr mock dep\r\nvar mockDep = {\r\n    notify: noop,\r\n    depend: noop,\r\n    addSub: noop,\r\n    removeSub: noop\r\n};\r\n/**\r\n * Observer class that is attached to each observed\r\n * object. Once attached, the observer converts the target\r\n * object's property keys into getter/setters that\r\n * collect dependencies and dispatch updates.\r\n */\r\nvar Observer = /** @class */ (function () {\r\n    function Observer(value, shallow, mock) {\r\n        if (shallow === void 0) { shallow = false; }\r\n        if (mock === void 0) { mock = false; }\r\n        this.value = value;\r\n        this.shallow = shallow;\r\n        this.mock = mock;\r\n        // this.value = value\r\n        this.dep = mock ? mockDep : new Dep();\r\n        this.vmCount = 0;\r\n        def(value, '__ob__', this);\r\n        if (isArray(value)) {\r\n            if (!mock) {\r\n                if (hasProto) {\r\n                    value.__proto__ = arrayMethods;\r\n                    /* eslint-enable no-proto */\r\n                }\r\n                else {\r\n                    for (var i = 0, l = arrayKeys.length; i < l; i++) {\r\n                        var key = arrayKeys[i];\r\n                        def(value, key, arrayMethods[key]);\r\n                    }\r\n                }\r\n            }\r\n            if (!shallow) {\r\n                this.observeArray(value);\r\n            }\r\n        }\r\n        else {\r\n            /**\r\n             * Walk through all properties and convert them into\r\n             * getter/setters. This method should only be called when\r\n             * value type is Object.\r\n             */\r\n            var keys = Object.keys(value);\r\n            for (var i = 0; i < keys.length; i++) {\r\n                var key = keys[i];\r\n                defineReactive(value, key, NO_INIITIAL_VALUE, undefined, shallow, mock);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Observe a list of Array items.\r\n     */\r\n    Observer.prototype.observeArray = function (value) {\r\n        for (var i = 0, l = value.length; i < l; i++) {\r\n            observe(value[i], false, this.mock);\r\n        }\r\n    };\r\n    return Observer;\r\n}());\r\n// helpers\r\n/**\r\n * Attempt to create an observer instance for a value,\r\n * returns the new observer if successfully observed,\r\n * or the existing observer if the value already has one.\r\n */\r\nfunction observe(value, shallow, ssrMockReactivity) {\r\n    if (!isObject(value) || isRef(value) || value instanceof VNode) {\r\n        return;\r\n    }\r\n    var ob;\r\n    if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\r\n        ob = value.__ob__;\r\n    }\r\n    else if (shouldObserve &&\r\n        (ssrMockReactivity || !isServerRendering()) &&\r\n        (isArray(value) || isPlainObject(value)) &&\r\n        Object.isExtensible(value) &&\r\n        !value.__v_skip /* ReactiveFlags.SKIP */) {\r\n        ob = new Observer(value, shallow, ssrMockReactivity);\r\n    }\r\n    return ob;\r\n}\r\n/**\r\n * Define a reactive property on an Object.\r\n */\r\nfunction defineReactive(obj, key, val, customSetter, shallow, mock) {\r\n    var dep = new Dep();\r\n    var property = Object.getOwnPropertyDescriptor(obj, key);\r\n    if (property && property.configurable === false) {\r\n        return;\r\n    }\r\n    // cater for pre-defined getter/setters\r\n    var getter = property && property.get;\r\n    var setter = property && property.set;\r\n    if ((!getter || setter) &&\r\n        (val === NO_INIITIAL_VALUE || arguments.length === 2)) {\r\n        val = obj[key];\r\n    }\r\n    var childOb = !shallow && observe(val, false, mock);\r\n    Object.defineProperty(obj, key, {\r\n        enumerable: true,\r\n        configurable: true,\r\n        get: function reactiveGetter() {\r\n            var value = getter ? getter.call(obj) : val;\r\n            if (Dep.target) {\r\n                if (true) {\r\n                    dep.depend({\r\n                        target: obj,\r\n                        type: \"get\" /* TrackOpTypes.GET */,\r\n                        key: key\r\n                    });\r\n                }\r\n                else {}\r\n                if (childOb) {\r\n                    childOb.dep.depend();\r\n                    if (isArray(value)) {\r\n                        dependArray(value);\r\n                    }\r\n                }\r\n            }\r\n            return isRef(value) && !shallow ? value.value : value;\r\n        },\r\n        set: function reactiveSetter(newVal) {\r\n            var value = getter ? getter.call(obj) : val;\r\n            if (!hasChanged(value, newVal)) {\r\n                return;\r\n            }\r\n            if ( true && customSetter) {\r\n                customSetter();\r\n            }\r\n            if (setter) {\r\n                setter.call(obj, newVal);\r\n            }\r\n            else if (getter) {\r\n                // #7981: for accessor properties without setter\r\n                return;\r\n            }\r\n            else if (!shallow && isRef(value) && !isRef(newVal)) {\r\n                value.value = newVal;\r\n                return;\r\n            }\r\n            else {\r\n                val = newVal;\r\n            }\r\n            childOb = !shallow && observe(newVal, false, mock);\r\n            if (true) {\r\n                dep.notify({\r\n                    type: \"set\" /* TriggerOpTypes.SET */,\r\n                    target: obj,\r\n                    key: key,\r\n                    newValue: newVal,\r\n                    oldValue: value\r\n                });\r\n            }\r\n            else {}\r\n        }\r\n    });\r\n    return dep;\r\n}\r\nfunction set(target, key, val) {\r\n    if ( true && (isUndef(target) || isPrimitive(target))) {\r\n        warn$2(\"Cannot set reactive property on undefined, null, or primitive value: \".concat(target));\r\n    }\r\n    if (isReadonly(target)) {\r\n         true && warn$2(\"Set operation on key \\\"\".concat(key, \"\\\" failed: target is readonly.\"));\r\n        return;\r\n    }\r\n    var ob = target.__ob__;\r\n    if (isArray(target) && isValidArrayIndex(key)) {\r\n        target.length = Math.max(target.length, key);\r\n        target.splice(key, 1, val);\r\n        // when mocking for SSR, array methods are not hijacked\r\n        if (ob && !ob.shallow && ob.mock) {\r\n            observe(val, false, true);\r\n        }\r\n        return val;\r\n    }\r\n    if (key in target && !(key in Object.prototype)) {\r\n        target[key] = val;\r\n        return val;\r\n    }\r\n    if (target._isVue || (ob && ob.vmCount)) {\r\n         true &&\r\n            warn$2('Avoid adding reactive properties to a Vue instance or its root $data ' +\r\n                'at runtime - declare it upfront in the data option.');\r\n        return val;\r\n    }\r\n    if (!ob) {\r\n        target[key] = val;\r\n        return val;\r\n    }\r\n    defineReactive(ob.value, key, val, undefined, ob.shallow, ob.mock);\r\n    if (true) {\r\n        ob.dep.notify({\r\n            type: \"add\" /* TriggerOpTypes.ADD */,\r\n            target: target,\r\n            key: key,\r\n            newValue: val,\r\n            oldValue: undefined\r\n        });\r\n    }\r\n    else {}\r\n    return val;\r\n}\r\nfunction del(target, key) {\r\n    if ( true && (isUndef(target) || isPrimitive(target))) {\r\n        warn$2(\"Cannot delete reactive property on undefined, null, or primitive value: \".concat(target));\r\n    }\r\n    if (isArray(target) && isValidArrayIndex(key)) {\r\n        target.splice(key, 1);\r\n        return;\r\n    }\r\n    var ob = target.__ob__;\r\n    if (target._isVue || (ob && ob.vmCount)) {\r\n         true &&\r\n            warn$2('Avoid deleting properties on a Vue instance or its root $data ' +\r\n                '- just set it to null.');\r\n        return;\r\n    }\r\n    if (isReadonly(target)) {\r\n         true &&\r\n            warn$2(\"Delete operation on key \\\"\".concat(key, \"\\\" failed: target is readonly.\"));\r\n        return;\r\n    }\r\n    if (!hasOwn(target, key)) {\r\n        return;\r\n    }\r\n    delete target[key];\r\n    if (!ob) {\r\n        return;\r\n    }\r\n    if (true) {\r\n        ob.dep.notify({\r\n            type: \"delete\" /* TriggerOpTypes.DELETE */,\r\n            target: target,\r\n            key: key\r\n        });\r\n    }\r\n    else {}\r\n}\r\n/**\r\n * Collect dependencies on array elements when the array is touched, since\r\n * we cannot intercept array element access like property getters.\r\n */\r\nfunction dependArray(value) {\r\n    for (var e = void 0, i = 0, l = value.length; i < l; i++) {\r\n        e = value[i];\r\n        if (e && e.__ob__) {\r\n            e.__ob__.dep.depend();\r\n        }\r\n        if (isArray(e)) {\r\n            dependArray(e);\r\n        }\r\n    }\r\n}\n\nfunction reactive(target) {\r\n    makeReactive(target, false);\r\n    return target;\r\n}\r\n/**\r\n * Return a shallowly-reactive copy of the original object, where only the root\r\n * level properties are reactive. It also does not auto-unwrap refs (even at the\r\n * root level).\r\n */\r\nfunction shallowReactive(target) {\r\n    makeReactive(target, true);\r\n    def(target, \"__v_isShallow\" /* ReactiveFlags.IS_SHALLOW */, true);\r\n    return target;\r\n}\r\nfunction makeReactive(target, shallow) {\r\n    // if trying to observe a readonly proxy, return the readonly version.\r\n    if (!isReadonly(target)) {\r\n        if (true) {\r\n            if (isArray(target)) {\r\n                warn$2(\"Avoid using Array as root value for \".concat(shallow ? \"shallowReactive()\" : \"reactive()\", \" as it cannot be tracked in watch() or watchEffect(). Use \").concat(shallow ? \"shallowRef()\" : \"ref()\", \" instead. This is a Vue-2-only limitation.\"));\r\n            }\r\n            var existingOb = target && target.__ob__;\r\n            if (existingOb && existingOb.shallow !== shallow) {\r\n                warn$2(\"Target is already a \".concat(existingOb.shallow ? \"\" : \"non-\", \"shallow reactive object, and cannot be converted to \").concat(shallow ? \"\" : \"non-\", \"shallow.\"));\r\n            }\r\n        }\r\n        var ob = observe(target, shallow, isServerRendering() /* ssr mock reactivity */);\r\n        if ( true && !ob) {\r\n            if (target == null || isPrimitive(target)) {\r\n                warn$2(\"value cannot be made reactive: \".concat(String(target)));\r\n            }\r\n            if (isCollectionType(target)) {\r\n                warn$2(\"Vue 2 does not support reactive collection types such as Map or Set.\");\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction isReactive(value) {\r\n    if (isReadonly(value)) {\r\n        return isReactive(value[\"__v_raw\" /* ReactiveFlags.RAW */]);\r\n    }\r\n    return !!(value && value.__ob__);\r\n}\r\nfunction isShallow(value) {\r\n    return !!(value && value.__v_isShallow);\r\n}\r\nfunction isReadonly(value) {\r\n    return !!(value && value.__v_isReadonly);\r\n}\r\nfunction isProxy(value) {\r\n    return isReactive(value) || isReadonly(value);\r\n}\r\nfunction toRaw(observed) {\r\n    var raw = observed && observed[\"__v_raw\" /* ReactiveFlags.RAW */];\r\n    return raw ? toRaw(raw) : observed;\r\n}\r\nfunction markRaw(value) {\r\n    def(value, \"__v_skip\" /* ReactiveFlags.SKIP */, true);\r\n    return value;\r\n}\r\n/**\r\n * @internal\r\n */\r\nfunction isCollectionType(value) {\r\n    var type = toRawType(value);\r\n    return (type === 'Map' || type === 'WeakMap' || type === 'Set' || type === 'WeakSet');\r\n}\n\n/**\r\n * @internal\r\n */\r\nvar RefFlag = \"__v_isRef\";\r\nfunction isRef(r) {\r\n    return !!(r && r.__v_isRef === true);\r\n}\r\nfunction ref$1(value) {\r\n    return createRef(value, false);\r\n}\r\nfunction shallowRef(value) {\r\n    return createRef(value, true);\r\n}\r\nfunction createRef(rawValue, shallow) {\r\n    if (isRef(rawValue)) {\r\n        return rawValue;\r\n    }\r\n    var ref = {};\r\n    def(ref, RefFlag, true);\r\n    def(ref, \"__v_isShallow\" /* ReactiveFlags.IS_SHALLOW */, shallow);\r\n    def(ref, 'dep', defineReactive(ref, 'value', rawValue, null, shallow, isServerRendering()));\r\n    return ref;\r\n}\r\nfunction triggerRef(ref) {\r\n    if ( true && !ref.dep) {\r\n        warn$2(\"received object is not a triggerable ref.\");\r\n    }\r\n    if (true) {\r\n        ref.dep &&\r\n            ref.dep.notify({\r\n                type: \"set\" /* TriggerOpTypes.SET */,\r\n                target: ref,\r\n                key: 'value'\r\n            });\r\n    }\r\n    else {}\r\n}\r\nfunction unref(ref) {\r\n    return isRef(ref) ? ref.value : ref;\r\n}\r\nfunction proxyRefs(objectWithRefs) {\r\n    if (isReactive(objectWithRefs)) {\r\n        return objectWithRefs;\r\n    }\r\n    var proxy = {};\r\n    var keys = Object.keys(objectWithRefs);\r\n    for (var i = 0; i < keys.length; i++) {\r\n        proxyWithRefUnwrap(proxy, objectWithRefs, keys[i]);\r\n    }\r\n    return proxy;\r\n}\r\nfunction proxyWithRefUnwrap(target, source, key) {\r\n    Object.defineProperty(target, key, {\r\n        enumerable: true,\r\n        configurable: true,\r\n        get: function () {\r\n            var val = source[key];\r\n            if (isRef(val)) {\r\n                return val.value;\r\n            }\r\n            else {\r\n                var ob = val && val.__ob__;\r\n                if (ob)\r\n                    ob.dep.depend();\r\n                return val;\r\n            }\r\n        },\r\n        set: function (value) {\r\n            var oldValue = source[key];\r\n            if (isRef(oldValue) && !isRef(value)) {\r\n                oldValue.value = value;\r\n            }\r\n            else {\r\n                source[key] = value;\r\n            }\r\n        }\r\n    });\r\n}\r\nfunction customRef(factory) {\r\n    var dep = new Dep();\r\n    var _a = factory(function () {\r\n        if (true) {\r\n            dep.depend({\r\n                target: ref,\r\n                type: \"get\" /* TrackOpTypes.GET */,\r\n                key: 'value'\r\n            });\r\n        }\r\n        else {}\r\n    }, function () {\r\n        if (true) {\r\n            dep.notify({\r\n                target: ref,\r\n                type: \"set\" /* TriggerOpTypes.SET */,\r\n                key: 'value'\r\n            });\r\n        }\r\n        else {}\r\n    }), get = _a.get, set = _a.set;\r\n    var ref = {\r\n        get value() {\r\n            return get();\r\n        },\r\n        set value(newVal) {\r\n            set(newVal);\r\n        }\r\n    };\r\n    def(ref, RefFlag, true);\r\n    return ref;\r\n}\r\nfunction toRefs(object) {\r\n    if ( true && !isReactive(object)) {\r\n        warn$2(\"toRefs() expects a reactive object but received a plain one.\");\r\n    }\r\n    var ret = isArray(object) ? new Array(object.length) : {};\r\n    for (var key in object) {\r\n        ret[key] = toRef(object, key);\r\n    }\r\n    return ret;\r\n}\r\nfunction toRef(object, key, defaultValue) {\r\n    var val = object[key];\r\n    if (isRef(val)) {\r\n        return val;\r\n    }\r\n    var ref = {\r\n        get value() {\r\n            var val = object[key];\r\n            return val === undefined ? defaultValue : val;\r\n        },\r\n        set value(newVal) {\r\n            object[key] = newVal;\r\n        }\r\n    };\r\n    def(ref, RefFlag, true);\r\n    return ref;\r\n}\n\nvar rawToReadonlyFlag = \"__v_rawToReadonly\";\r\nvar rawToShallowReadonlyFlag = \"__v_rawToShallowReadonly\";\r\nfunction readonly(target) {\r\n    return createReadonly(target, false);\r\n}\r\nfunction createReadonly(target, shallow) {\r\n    if (!isPlainObject(target)) {\r\n        if (true) {\r\n            if (isArray(target)) {\r\n                warn$2(\"Vue 2 does not support readonly arrays.\");\r\n            }\r\n            else if (isCollectionType(target)) {\r\n                warn$2(\"Vue 2 does not support readonly collection types such as Map or Set.\");\r\n            }\r\n            else {\r\n                warn$2(\"value cannot be made readonly: \".concat(typeof target));\r\n            }\r\n        }\r\n        return target;\r\n    }\r\n    // already a readonly object\r\n    if (isReadonly(target)) {\r\n        return target;\r\n    }\r\n    // already has a readonly proxy\r\n    var existingFlag = shallow ? rawToShallowReadonlyFlag : rawToReadonlyFlag;\r\n    var existingProxy = target[existingFlag];\r\n    if (existingProxy) {\r\n        return existingProxy;\r\n    }\r\n    var proxy = Object.create(Object.getPrototypeOf(target));\r\n    def(target, existingFlag, proxy);\r\n    def(proxy, \"__v_isReadonly\" /* ReactiveFlags.IS_READONLY */, true);\r\n    def(proxy, \"__v_raw\" /* ReactiveFlags.RAW */, target);\r\n    if (isRef(target)) {\r\n        def(proxy, RefFlag, true);\r\n    }\r\n    if (shallow || isShallow(target)) {\r\n        def(proxy, \"__v_isShallow\" /* ReactiveFlags.IS_SHALLOW */, true);\r\n    }\r\n    var keys = Object.keys(target);\r\n    for (var i = 0; i < keys.length; i++) {\r\n        defineReadonlyProperty(proxy, target, keys[i], shallow);\r\n    }\r\n    return proxy;\r\n}\r\nfunction defineReadonlyProperty(proxy, target, key, shallow) {\r\n    Object.defineProperty(proxy, key, {\r\n        enumerable: true,\r\n        configurable: true,\r\n        get: function () {\r\n            var val = target[key];\r\n            return shallow || !isPlainObject(val) ? val : readonly(val);\r\n        },\r\n        set: function () {\r\n             true &&\r\n                warn$2(\"Set operation on key \\\"\".concat(key, \"\\\" failed: target is readonly.\"));\r\n        }\r\n    });\r\n}\r\n/**\r\n * Returns a reactive-copy of the original object, where only the root level\r\n * properties are readonly, and does NOT unwrap refs nor recursively convert\r\n * returned properties.\r\n * This is used for creating the props proxy object for stateful components.\r\n */\r\nfunction shallowReadonly(target) {\r\n    return createReadonly(target, true);\r\n}\n\nfunction computed(getterOrOptions, debugOptions) {\r\n    var getter;\r\n    var setter;\r\n    var onlyGetter = isFunction(getterOrOptions);\r\n    if (onlyGetter) {\r\n        getter = getterOrOptions;\r\n        setter =  true\r\n            ? function () {\r\n                warn$2('Write operation failed: computed value is readonly');\r\n            }\r\n            : 0;\r\n    }\r\n    else {\r\n        getter = getterOrOptions.get;\r\n        setter = getterOrOptions.set;\r\n    }\r\n    var watcher = isServerRendering()\r\n        ? null\r\n        : new Watcher(currentInstance, getter, noop, { lazy: true });\r\n    if ( true && watcher && debugOptions) {\r\n        watcher.onTrack = debugOptions.onTrack;\r\n        watcher.onTrigger = debugOptions.onTrigger;\r\n    }\r\n    var ref = {\r\n        // some libs rely on the presence effect for checking computed refs\r\n        // from normal refs, but the implementation doesn't matter\r\n        effect: watcher,\r\n        get value() {\r\n            if (watcher) {\r\n                if (watcher.dirty) {\r\n                    watcher.evaluate();\r\n                }\r\n                if (Dep.target) {\r\n                    if ( true && Dep.target.onTrack) {\r\n                        Dep.target.onTrack({\r\n                            effect: Dep.target,\r\n                            target: ref,\r\n                            type: \"get\" /* TrackOpTypes.GET */,\r\n                            key: 'value'\r\n                        });\r\n                    }\r\n                    watcher.depend();\r\n                }\r\n                return watcher.value;\r\n            }\r\n            else {\r\n                return getter();\r\n            }\r\n        },\r\n        set value(newVal) {\r\n            setter(newVal);\r\n        }\r\n    };\r\n    def(ref, RefFlag, true);\r\n    def(ref, \"__v_isReadonly\" /* ReactiveFlags.IS_READONLY */, onlyGetter);\r\n    return ref;\r\n}\n\nvar mark;\r\nvar measure;\r\nif (true) {\r\n    var perf_1 = inBrowser && window.performance;\r\n    /* istanbul ignore if */\r\n    if (perf_1 &&\r\n        // @ts-ignore\r\n        perf_1.mark &&\r\n        // @ts-ignore\r\n        perf_1.measure &&\r\n        // @ts-ignore\r\n        perf_1.clearMarks &&\r\n        // @ts-ignore\r\n        perf_1.clearMeasures) {\r\n        mark = function (tag) { return perf_1.mark(tag); };\r\n        measure = function (name, startTag, endTag) {\r\n            perf_1.measure(name, startTag, endTag);\r\n            perf_1.clearMarks(startTag);\r\n            perf_1.clearMarks(endTag);\r\n            // perf.clearMeasures(name)\r\n        };\r\n    }\r\n}\n\nvar normalizeEvent = cached(function (name) {\r\n    var passive = name.charAt(0) === '&';\r\n    name = passive ? name.slice(1) : name;\r\n    var once = name.charAt(0) === '~'; // Prefixed last, checked first\r\n    name = once ? name.slice(1) : name;\r\n    var capture = name.charAt(0) === '!';\r\n    name = capture ? name.slice(1) : name;\r\n    return {\r\n        name: name,\r\n        once: once,\r\n        capture: capture,\r\n        passive: passive\r\n    };\r\n});\r\nfunction createFnInvoker(fns, vm) {\r\n    function invoker() {\r\n        var fns = invoker.fns;\r\n        if (isArray(fns)) {\r\n            var cloned = fns.slice();\r\n            for (var i = 0; i < cloned.length; i++) {\r\n                invokeWithErrorHandling(cloned[i], null, arguments, vm, \"v-on handler\");\r\n            }\r\n        }\r\n        else {\r\n            // return handler return value for single handlers\r\n            return invokeWithErrorHandling(fns, null, arguments, vm, \"v-on handler\");\r\n        }\r\n    }\r\n    invoker.fns = fns;\r\n    return invoker;\r\n}\r\nfunction updateListeners(on, oldOn, add, remove, createOnceHandler, vm) {\r\n    var name, cur, old, event;\r\n    for (name in on) {\r\n        cur = on[name];\r\n        old = oldOn[name];\r\n        event = normalizeEvent(name);\r\n        if (isUndef(cur)) {\r\n             true &&\r\n                warn$2(\"Invalid handler for event \\\"\".concat(event.name, \"\\\": got \") + String(cur), vm);\r\n        }\r\n        else if (isUndef(old)) {\r\n            if (isUndef(cur.fns)) {\r\n                cur = on[name] = createFnInvoker(cur, vm);\r\n            }\r\n            if (isTrue(event.once)) {\r\n                cur = on[name] = createOnceHandler(event.name, cur, event.capture);\r\n            }\r\n            add(event.name, cur, event.capture, event.passive, event.params);\r\n        }\r\n        else if (cur !== old) {\r\n            old.fns = cur;\r\n            on[name] = old;\r\n        }\r\n    }\r\n    for (name in oldOn) {\r\n        if (isUndef(on[name])) {\r\n            event = normalizeEvent(name);\r\n            remove(event.name, oldOn[name], event.capture);\r\n        }\r\n    }\r\n}\n\nfunction mergeVNodeHook(def, hookKey, hook) {\r\n    if (def instanceof VNode) {\r\n        def = def.data.hook || (def.data.hook = {});\r\n    }\r\n    var invoker;\r\n    var oldHook = def[hookKey];\r\n    function wrappedHook() {\r\n        hook.apply(this, arguments);\r\n        // important: remove merged hook to ensure it's called only once\r\n        // and prevent memory leak\r\n        remove$2(invoker.fns, wrappedHook);\r\n    }\r\n    if (isUndef(oldHook)) {\r\n        // no existing hook\r\n        invoker = createFnInvoker([wrappedHook]);\r\n    }\r\n    else {\r\n        /* istanbul ignore if */\r\n        if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {\r\n            // already a merged invoker\r\n            invoker = oldHook;\r\n            invoker.fns.push(wrappedHook);\r\n        }\r\n        else {\r\n            // existing plain hook\r\n            invoker = createFnInvoker([oldHook, wrappedHook]);\r\n        }\r\n    }\r\n    invoker.merged = true;\r\n    def[hookKey] = invoker;\r\n}\n\nfunction extractPropsFromVNodeData(data, Ctor, tag) {\r\n    // we are only extracting raw values here.\r\n    // validation and default values are handled in the child\r\n    // component itself.\r\n    var propOptions = Ctor.options.props;\r\n    if (isUndef(propOptions)) {\r\n        return;\r\n    }\r\n    var res = {};\r\n    var attrs = data.attrs, props = data.props;\r\n    if (isDef(attrs) || isDef(props)) {\r\n        for (var key in propOptions) {\r\n            var altKey = hyphenate(key);\r\n            if (true) {\r\n                var keyInLowerCase = key.toLowerCase();\r\n                if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {\r\n                    tip(\"Prop \\\"\".concat(keyInLowerCase, \"\\\" is passed to component \") +\r\n                        \"\".concat(formatComponentName(\r\n                        // @ts-expect-error tag is string\r\n                        tag || Ctor), \", but the declared prop name is\") +\r\n                        \" \\\"\".concat(key, \"\\\". \") +\r\n                        \"Note that HTML attributes are case-insensitive and camelCased \" +\r\n                        \"props need to use their kebab-case equivalents when using in-DOM \" +\r\n                        \"templates. You should probably use \\\"\".concat(altKey, \"\\\" instead of \\\"\").concat(key, \"\\\".\"));\r\n                }\r\n            }\r\n            checkProp(res, props, key, altKey, true) ||\r\n                checkProp(res, attrs, key, altKey, false);\r\n        }\r\n    }\r\n    return res;\r\n}\r\nfunction checkProp(res, hash, key, altKey, preserve) {\r\n    if (isDef(hash)) {\r\n        if (hasOwn(hash, key)) {\r\n            res[key] = hash[key];\r\n            if (!preserve) {\r\n                delete hash[key];\r\n            }\r\n            return true;\r\n        }\r\n        else if (hasOwn(hash, altKey)) {\r\n            res[key] = hash[altKey];\r\n            if (!preserve) {\r\n                delete hash[altKey];\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\n\n// The template compiler attempts to minimize the need for normalization by\r\n// statically analyzing the template at compile time.\r\n//\r\n// For plain HTML markup, normalization can be completely skipped because the\r\n// generated render function is guaranteed to return Array<VNode>. There are\r\n// two cases where extra normalization is needed:\r\n// 1. When the children contains components - because a functional component\r\n// may return an Array instead of a single root. In this case, just a simple\r\n// normalization is needed - if any child is an Array, we flatten the whole\r\n// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\r\n// because functional components already normalize their own children.\r\nfunction simpleNormalizeChildren(children) {\r\n    for (var i = 0; i < children.length; i++) {\r\n        if (isArray(children[i])) {\r\n            return Array.prototype.concat.apply([], children);\r\n        }\r\n    }\r\n    return children;\r\n}\r\n// 2. When the children contains constructs that always generated nested Arrays,\r\n// e.g. <template>, <slot>, v-for, or when the children is provided by user\r\n// with hand-written render functions / JSX. In such cases a full normalization\r\n// is needed to cater to all possible types of children values.\r\nfunction normalizeChildren(children) {\r\n    return isPrimitive(children)\r\n        ? [createTextVNode(children)]\r\n        : isArray(children)\r\n            ? normalizeArrayChildren(children)\r\n            : undefined;\r\n}\r\nfunction isTextNode(node) {\r\n    return isDef(node) && isDef(node.text) && isFalse(node.isComment);\r\n}\r\nfunction normalizeArrayChildren(children, nestedIndex) {\r\n    var res = [];\r\n    var i, c, lastIndex, last;\r\n    for (i = 0; i < children.length; i++) {\r\n        c = children[i];\r\n        if (isUndef(c) || typeof c === 'boolean')\r\n            continue;\r\n        lastIndex = res.length - 1;\r\n        last = res[lastIndex];\r\n        //  nested\r\n        if (isArray(c)) {\r\n            if (c.length > 0) {\r\n                c = normalizeArrayChildren(c, \"\".concat(nestedIndex || '', \"_\").concat(i));\r\n                // merge adjacent text nodes\r\n                if (isTextNode(c[0]) && isTextNode(last)) {\r\n                    res[lastIndex] = createTextVNode(last.text + c[0].text);\r\n                    c.shift();\r\n                }\r\n                res.push.apply(res, c);\r\n            }\r\n        }\r\n        else if (isPrimitive(c)) {\r\n            if (isTextNode(last)) {\r\n                // merge adjacent text nodes\r\n                // this is necessary for SSR hydration because text nodes are\r\n                // essentially merged when rendered to HTML strings\r\n                res[lastIndex] = createTextVNode(last.text + c);\r\n            }\r\n            else if (c !== '') {\r\n                // convert primitive to vnode\r\n                res.push(createTextVNode(c));\r\n            }\r\n        }\r\n        else {\r\n            if (isTextNode(c) && isTextNode(last)) {\r\n                // merge adjacent text nodes\r\n                res[lastIndex] = createTextVNode(last.text + c.text);\r\n            }\r\n            else {\r\n                // default key for nested array children (likely generated by v-for)\r\n                if (isTrue(children._isVList) &&\r\n                    isDef(c.tag) &&\r\n                    isUndef(c.key) &&\r\n                    isDef(nestedIndex)) {\r\n                    c.key = \"__vlist\".concat(nestedIndex, \"_\").concat(i, \"__\");\r\n                }\r\n                res.push(c);\r\n            }\r\n        }\r\n    }\r\n    return res;\r\n}\n\nvar SIMPLE_NORMALIZE = 1;\r\nvar ALWAYS_NORMALIZE = 2;\r\n// wrapper function for providing a more flexible interface\r\n// without getting yelled at by flow\r\nfunction createElement$1(context, tag, data, children, normalizationType, alwaysNormalize) {\r\n    if (isArray(data) || isPrimitive(data)) {\r\n        normalizationType = children;\r\n        children = data;\r\n        data = undefined;\r\n    }\r\n    if (isTrue(alwaysNormalize)) {\r\n        normalizationType = ALWAYS_NORMALIZE;\r\n    }\r\n    return _createElement(context, tag, data, children, normalizationType);\r\n}\r\nfunction _createElement(context, tag, data, children, normalizationType) {\r\n    if (isDef(data) && isDef(data.__ob__)) {\r\n         true &&\r\n            warn$2(\"Avoid using observed data object as vnode data: \".concat(JSON.stringify(data), \"\\n\") + 'Always create fresh vnode data objects in each render!', context);\r\n        return createEmptyVNode();\r\n    }\r\n    // object syntax in v-bind\r\n    if (isDef(data) && isDef(data.is)) {\r\n        tag = data.is;\r\n    }\r\n    if (!tag) {\r\n        // in case of component :is set to falsy value\r\n        return createEmptyVNode();\r\n    }\r\n    // warn against non-primitive key\r\n    if ( true && isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {\r\n        warn$2('Avoid using non-primitive value as key, ' +\r\n            'use string/number value instead.', context);\r\n    }\r\n    // support single function children as default scoped slot\r\n    if (isArray(children) && isFunction(children[0])) {\r\n        data = data || {};\r\n        data.scopedSlots = { default: children[0] };\r\n        children.length = 0;\r\n    }\r\n    if (normalizationType === ALWAYS_NORMALIZE) {\r\n        children = normalizeChildren(children);\r\n    }\r\n    else if (normalizationType === SIMPLE_NORMALIZE) {\r\n        children = simpleNormalizeChildren(children);\r\n    }\r\n    var vnode, ns;\r\n    if (typeof tag === 'string') {\r\n        var Ctor = void 0;\r\n        ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);\r\n        if (config.isReservedTag(tag)) {\r\n            // platform built-in elements\r\n            if ( true &&\r\n                isDef(data) &&\r\n                isDef(data.nativeOn) &&\r\n                data.tag !== 'component') {\r\n                warn$2(\"The .native modifier for v-on is only valid on components but it was used on <\".concat(tag, \">.\"), context);\r\n            }\r\n            vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);\r\n        }\r\n        else if ((!data || !data.pre) &&\r\n            isDef((Ctor = resolveAsset(context.$options, 'components', tag)))) {\r\n            // component\r\n            vnode = createComponent(Ctor, data, context, children, tag);\r\n        }\r\n        else {\r\n            // unknown or unlisted namespaced elements\r\n            // check at runtime because it may get assigned a namespace when its\r\n            // parent normalizes children\r\n            vnode = new VNode(tag, data, children, undefined, undefined, context);\r\n        }\r\n    }\r\n    else {\r\n        // direct component options / constructor\r\n        vnode = createComponent(tag, data, context, children);\r\n    }\r\n    if (isArray(vnode)) {\r\n        return vnode;\r\n    }\r\n    else if (isDef(vnode)) {\r\n        if (isDef(ns))\r\n            applyNS(vnode, ns);\r\n        if (isDef(data))\r\n            registerDeepBindings(data);\r\n        return vnode;\r\n    }\r\n    else {\r\n        return createEmptyVNode();\r\n    }\r\n}\r\nfunction applyNS(vnode, ns, force) {\r\n    vnode.ns = ns;\r\n    if (vnode.tag === 'foreignObject') {\r\n        // use default namespace inside foreignObject\r\n        ns = undefined;\r\n        force = true;\r\n    }\r\n    if (isDef(vnode.children)) {\r\n        for (var i = 0, l = vnode.children.length; i < l; i++) {\r\n            var child = vnode.children[i];\r\n            if (isDef(child.tag) &&\r\n                (isUndef(child.ns) || (isTrue(force) && child.tag !== 'svg'))) {\r\n                applyNS(child, ns, force);\r\n            }\r\n        }\r\n    }\r\n}\r\n// ref #5318\r\n// necessary to ensure parent re-render when deep bindings like :style and\r\n// :class are used on slot nodes\r\nfunction registerDeepBindings(data) {\r\n    if (isObject(data.style)) {\r\n        traverse(data.style);\r\n    }\r\n    if (isObject(data.class)) {\r\n        traverse(data.class);\r\n    }\r\n}\n\n/**\r\n * Runtime helper for rendering v-for lists.\r\n */\r\nfunction renderList(val, render) {\r\n    var ret = null, i, l, keys, key;\r\n    if (isArray(val) || typeof val === 'string') {\r\n        ret = new Array(val.length);\r\n        for (i = 0, l = val.length; i < l; i++) {\r\n            ret[i] = render(val[i], i);\r\n        }\r\n    }\r\n    else if (typeof val === 'number') {\r\n        ret = new Array(val);\r\n        for (i = 0; i < val; i++) {\r\n            ret[i] = render(i + 1, i);\r\n        }\r\n    }\r\n    else if (isObject(val)) {\r\n        if (hasSymbol && val[Symbol.iterator]) {\r\n            ret = [];\r\n            var iterator = val[Symbol.iterator]();\r\n            var result = iterator.next();\r\n            while (!result.done) {\r\n                ret.push(render(result.value, ret.length));\r\n                result = iterator.next();\r\n            }\r\n        }\r\n        else {\r\n            keys = Object.keys(val);\r\n            ret = new Array(keys.length);\r\n            for (i = 0, l = keys.length; i < l; i++) {\r\n                key = keys[i];\r\n                ret[i] = render(val[key], key, i);\r\n            }\r\n        }\r\n    }\r\n    if (!isDef(ret)) {\r\n        ret = [];\r\n    }\r\n    ret._isVList = true;\r\n    return ret;\r\n}\n\n/**\r\n * Runtime helper for rendering <slot>\r\n */\r\nfunction renderSlot(name, fallbackRender, props, bindObject) {\r\n    var scopedSlotFn = this.$scopedSlots[name];\r\n    var nodes;\r\n    if (scopedSlotFn) {\r\n        // scoped slot\r\n        props = props || {};\r\n        if (bindObject) {\r\n            if ( true && !isObject(bindObject)) {\r\n                warn$2('slot v-bind without argument expects an Object', this);\r\n            }\r\n            props = extend(extend({}, bindObject), props);\r\n        }\r\n        nodes =\r\n            scopedSlotFn(props) ||\r\n                (isFunction(fallbackRender) ? fallbackRender() : fallbackRender);\r\n    }\r\n    else {\r\n        nodes =\r\n            this.$slots[name] ||\r\n                (isFunction(fallbackRender) ? fallbackRender() : fallbackRender);\r\n    }\r\n    var target = props && props.slot;\r\n    if (target) {\r\n        return this.$createElement('template', { slot: target }, nodes);\r\n    }\r\n    else {\r\n        return nodes;\r\n    }\r\n}\n\n/**\r\n * Runtime helper for resolving filters\r\n */\r\nfunction resolveFilter(id) {\r\n    return resolveAsset(this.$options, 'filters', id, true) || identity;\r\n}\n\nfunction isKeyNotMatch(expect, actual) {\r\n    if (isArray(expect)) {\r\n        return expect.indexOf(actual) === -1;\r\n    }\r\n    else {\r\n        return expect !== actual;\r\n    }\r\n}\r\n/**\r\n * Runtime helper for checking keyCodes from config.\r\n * exposed as Vue.prototype._k\r\n * passing in eventKeyName as last argument separately for backwards compat\r\n */\r\nfunction checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {\r\n    var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;\r\n    if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {\r\n        return isKeyNotMatch(builtInKeyName, eventKeyName);\r\n    }\r\n    else if (mappedKeyCode) {\r\n        return isKeyNotMatch(mappedKeyCode, eventKeyCode);\r\n    }\r\n    else if (eventKeyName) {\r\n        return hyphenate(eventKeyName) !== key;\r\n    }\r\n    return eventKeyCode === undefined;\r\n}\n\n/**\r\n * Runtime helper for merging v-bind=\"object\" into a VNode's data.\r\n */\r\nfunction bindObjectProps(data, tag, value, asProp, isSync) {\r\n    if (value) {\r\n        if (!isObject(value)) {\r\n             true &&\r\n                warn$2('v-bind without argument expects an Object or Array value', this);\r\n        }\r\n        else {\r\n            if (isArray(value)) {\r\n                value = toObject(value);\r\n            }\r\n            var hash = void 0;\r\n            var _loop_1 = function (key) {\r\n                if (key === 'class' || key === 'style' || isReservedAttribute(key)) {\r\n                    hash = data;\r\n                }\r\n                else {\r\n                    var type = data.attrs && data.attrs.type;\r\n                    hash =\r\n                        asProp || config.mustUseProp(tag, type, key)\r\n                            ? data.domProps || (data.domProps = {})\r\n                            : data.attrs || (data.attrs = {});\r\n                }\r\n                var camelizedKey = camelize(key);\r\n                var hyphenatedKey = hyphenate(key);\r\n                if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {\r\n                    hash[key] = value[key];\r\n                    if (isSync) {\r\n                        var on = data.on || (data.on = {});\r\n                        on[\"update:\".concat(key)] = function ($event) {\r\n                            value[key] = $event;\r\n                        };\r\n                    }\r\n                }\r\n            };\r\n            for (var key in value) {\r\n                _loop_1(key);\r\n            }\r\n        }\r\n    }\r\n    return data;\r\n}\n\n/**\r\n * Runtime helper for rendering static trees.\r\n */\r\nfunction renderStatic(index, isInFor) {\r\n    var cached = this._staticTrees || (this._staticTrees = []);\r\n    var tree = cached[index];\r\n    // if has already-rendered static tree and not inside v-for,\r\n    // we can reuse the same tree.\r\n    if (tree && !isInFor) {\r\n        return tree;\r\n    }\r\n    // otherwise, render a fresh tree.\r\n    tree = cached[index] = this.$options.staticRenderFns[index].call(this._renderProxy, this._c, this // for render fns generated for functional component templates\r\n    );\r\n    markStatic$1(tree, \"__static__\".concat(index), false);\r\n    return tree;\r\n}\r\n/**\r\n * Runtime helper for v-once.\r\n * Effectively it means marking the node as static with a unique key.\r\n */\r\nfunction markOnce(tree, index, key) {\r\n    markStatic$1(tree, \"__once__\".concat(index).concat(key ? \"_\".concat(key) : \"\"), true);\r\n    return tree;\r\n}\r\nfunction markStatic$1(tree, key, isOnce) {\r\n    if (isArray(tree)) {\r\n        for (var i = 0; i < tree.length; i++) {\r\n            if (tree[i] && typeof tree[i] !== 'string') {\r\n                markStaticNode(tree[i], \"\".concat(key, \"_\").concat(i), isOnce);\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        markStaticNode(tree, key, isOnce);\r\n    }\r\n}\r\nfunction markStaticNode(node, key, isOnce) {\r\n    node.isStatic = true;\r\n    node.key = key;\r\n    node.isOnce = isOnce;\r\n}\n\nfunction bindObjectListeners(data, value) {\r\n    if (value) {\r\n        if (!isPlainObject(value)) {\r\n             true && warn$2('v-on without argument expects an Object value', this);\r\n        }\r\n        else {\r\n            var on = (data.on = data.on ? extend({}, data.on) : {});\r\n            for (var key in value) {\r\n                var existing = on[key];\r\n                var ours = value[key];\r\n                on[key] = existing ? [].concat(existing, ours) : ours;\r\n            }\r\n        }\r\n    }\r\n    return data;\r\n}\n\nfunction resolveScopedSlots(fns, res, \r\n// the following are added in 2.6\r\nhasDynamicKeys, contentHashKey) {\r\n    res = res || { $stable: !hasDynamicKeys };\r\n    for (var i = 0; i < fns.length; i++) {\r\n        var slot = fns[i];\r\n        if (isArray(slot)) {\r\n            resolveScopedSlots(slot, res, hasDynamicKeys);\r\n        }\r\n        else if (slot) {\r\n            // marker for reverse proxying v-slot without scope on this.$slots\r\n            // @ts-expect-error\r\n            if (slot.proxy) {\r\n                // @ts-expect-error\r\n                slot.fn.proxy = true;\r\n            }\r\n            res[slot.key] = slot.fn;\r\n        }\r\n    }\r\n    if (contentHashKey) {\r\n        res.$key = contentHashKey;\r\n    }\r\n    return res;\r\n}\n\n// helper to process dynamic keys for dynamic arguments in v-bind and v-on.\r\nfunction bindDynamicKeys(baseObj, values) {\r\n    for (var i = 0; i < values.length; i += 2) {\r\n        var key = values[i];\r\n        if (typeof key === 'string' && key) {\r\n            baseObj[values[i]] = values[i + 1];\r\n        }\r\n        else if ( true && key !== '' && key !== null) {\r\n            // null is a special value for explicitly removing a binding\r\n            warn$2(\"Invalid value for dynamic directive argument (expected string or null): \".concat(key), this);\r\n        }\r\n    }\r\n    return baseObj;\r\n}\r\n// helper to dynamically append modifier runtime markers to event names.\r\n// ensure only append when value is already string, otherwise it will be cast\r\n// to string and cause the type check to miss.\r\nfunction prependModifier(value, symbol) {\r\n    return typeof value === 'string' ? symbol + value : value;\r\n}\n\nfunction installRenderHelpers(target) {\r\n    target._o = markOnce;\r\n    target._n = toNumber;\r\n    target._s = toString;\r\n    target._l = renderList;\r\n    target._t = renderSlot;\r\n    target._q = looseEqual;\r\n    target._i = looseIndexOf;\r\n    target._m = renderStatic;\r\n    target._f = resolveFilter;\r\n    target._k = checkKeyCodes;\r\n    target._b = bindObjectProps;\r\n    target._v = createTextVNode;\r\n    target._e = createEmptyVNode;\r\n    target._u = resolveScopedSlots;\r\n    target._g = bindObjectListeners;\r\n    target._d = bindDynamicKeys;\r\n    target._p = prependModifier;\r\n}\n\n/**\r\n * Runtime helper for resolving raw children VNodes into a slot object.\r\n */\r\nfunction resolveSlots(children, context) {\r\n    if (!children || !children.length) {\r\n        return {};\r\n    }\r\n    var slots = {};\r\n    for (var i = 0, l = children.length; i < l; i++) {\r\n        var child = children[i];\r\n        var data = child.data;\r\n        // remove slot attribute if the node is resolved as a Vue slot node\r\n        if (data && data.attrs && data.attrs.slot) {\r\n            delete data.attrs.slot;\r\n        }\r\n        // named slots should only be respected if the vnode was rendered in the\r\n        // same context.\r\n        if ((child.context === context || child.fnContext === context) &&\r\n            data &&\r\n            data.slot != null) {\r\n            var name_1 = data.slot;\r\n            var slot = slots[name_1] || (slots[name_1] = []);\r\n            if (child.tag === 'template') {\r\n                slot.push.apply(slot, child.children || []);\r\n            }\r\n            else {\r\n                slot.push(child);\r\n            }\r\n        }\r\n        else {\r\n            (slots.default || (slots.default = [])).push(child);\r\n        }\r\n    }\r\n    // ignore slots that contains only whitespace\r\n    for (var name_2 in slots) {\r\n        if (slots[name_2].every(isWhitespace)) {\r\n            delete slots[name_2];\r\n        }\r\n    }\r\n    return slots;\r\n}\r\nfunction isWhitespace(node) {\r\n    return (node.isComment && !node.asyncFactory) || node.text === ' ';\r\n}\n\nfunction isAsyncPlaceholder(node) {\r\n    // @ts-expect-error not really boolean type\r\n    return node.isComment && node.asyncFactory;\r\n}\n\nfunction normalizeScopedSlots(ownerVm, scopedSlots, normalSlots, prevScopedSlots) {\r\n    var res;\r\n    var hasNormalSlots = Object.keys(normalSlots).length > 0;\r\n    var isStable = scopedSlots ? !!scopedSlots.$stable : !hasNormalSlots;\r\n    var key = scopedSlots && scopedSlots.$key;\r\n    if (!scopedSlots) {\r\n        res = {};\r\n    }\r\n    else if (scopedSlots._normalized) {\r\n        // fast path 1: child component re-render only, parent did not change\r\n        return scopedSlots._normalized;\r\n    }\r\n    else if (isStable &&\r\n        prevScopedSlots &&\r\n        prevScopedSlots !== emptyObject &&\r\n        key === prevScopedSlots.$key &&\r\n        !hasNormalSlots &&\r\n        !prevScopedSlots.$hasNormal) {\r\n        // fast path 2: stable scoped slots w/ no normal slots to proxy,\r\n        // only need to normalize once\r\n        return prevScopedSlots;\r\n    }\r\n    else {\r\n        res = {};\r\n        for (var key_1 in scopedSlots) {\r\n            if (scopedSlots[key_1] && key_1[0] !== '$') {\r\n                res[key_1] = normalizeScopedSlot(ownerVm, normalSlots, key_1, scopedSlots[key_1]);\r\n            }\r\n        }\r\n    }\r\n    // expose normal slots on scopedSlots\r\n    for (var key_2 in normalSlots) {\r\n        if (!(key_2 in res)) {\r\n            res[key_2] = proxyNormalSlot(normalSlots, key_2);\r\n        }\r\n    }\r\n    // avoriaz seems to mock a non-extensible $scopedSlots object\r\n    // and when that is passed down this would cause an error\r\n    if (scopedSlots && Object.isExtensible(scopedSlots)) {\r\n        scopedSlots._normalized = res;\r\n    }\r\n    def(res, '$stable', isStable);\r\n    def(res, '$key', key);\r\n    def(res, '$hasNormal', hasNormalSlots);\r\n    return res;\r\n}\r\nfunction normalizeScopedSlot(vm, normalSlots, key, fn) {\r\n    var normalized = function () {\r\n        var cur = currentInstance;\r\n        setCurrentInstance(vm);\r\n        var res = arguments.length ? fn.apply(null, arguments) : fn({});\r\n        res =\r\n            res && typeof res === 'object' && !isArray(res)\r\n                ? [res] // single vnode\r\n                : normalizeChildren(res);\r\n        var vnode = res && res[0];\r\n        setCurrentInstance(cur);\r\n        return res &&\r\n            (!vnode ||\r\n                (res.length === 1 && vnode.isComment && !isAsyncPlaceholder(vnode))) // #9658, #10391\r\n            ? undefined\r\n            : res;\r\n    };\r\n    // this is a slot using the new v-slot syntax without scope. although it is\r\n    // compiled as a scoped slot, render fn users would expect it to be present\r\n    // on this.$slots because the usage is semantically a normal slot.\r\n    if (fn.proxy) {\r\n        Object.defineProperty(normalSlots, key, {\r\n            get: normalized,\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n    }\r\n    return normalized;\r\n}\r\nfunction proxyNormalSlot(slots, key) {\r\n    return function () { return slots[key]; };\r\n}\n\nfunction initSetup(vm) {\r\n    var options = vm.$options;\r\n    var setup = options.setup;\r\n    if (setup) {\r\n        var ctx = (vm._setupContext = createSetupContext(vm));\r\n        setCurrentInstance(vm);\r\n        pushTarget();\r\n        var setupResult = invokeWithErrorHandling(setup, null, [vm._props || shallowReactive({}), ctx], vm, \"setup\");\r\n        popTarget();\r\n        setCurrentInstance();\r\n        if (isFunction(setupResult)) {\r\n            // render function\r\n            // @ts-ignore\r\n            options.render = setupResult;\r\n        }\r\n        else if (isObject(setupResult)) {\r\n            // bindings\r\n            if ( true && setupResult instanceof VNode) {\r\n                warn$2(\"setup() should not return VNodes directly - \" +\r\n                    \"return a render function instead.\");\r\n            }\r\n            vm._setupState = setupResult;\r\n            // __sfc indicates compiled bindings from <script setup>\r\n            if (!setupResult.__sfc) {\r\n                for (var key in setupResult) {\r\n                    if (!isReserved(key)) {\r\n                        proxyWithRefUnwrap(vm, setupResult, key);\r\n                    }\r\n                    else if (true) {\r\n                        warn$2(\"Avoid using variables that start with _ or $ in setup().\");\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // exposed for compiled render fn\r\n                var proxy = (vm._setupProxy = {});\r\n                for (var key in setupResult) {\r\n                    if (key !== '__sfc') {\r\n                        proxyWithRefUnwrap(proxy, setupResult, key);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else if ( true && setupResult !== undefined) {\r\n            warn$2(\"setup() should return an object. Received: \".concat(setupResult === null ? 'null' : typeof setupResult));\r\n        }\r\n    }\r\n}\r\nfunction createSetupContext(vm) {\r\n    var exposeCalled = false;\r\n    return {\r\n        get attrs() {\r\n            if (!vm._attrsProxy) {\r\n                var proxy = (vm._attrsProxy = {});\r\n                def(proxy, '_v_attr_proxy', true);\r\n                syncSetupProxy(proxy, vm.$attrs, emptyObject, vm, '$attrs');\r\n            }\r\n            return vm._attrsProxy;\r\n        },\r\n        get listeners() {\r\n            if (!vm._listenersProxy) {\r\n                var proxy = (vm._listenersProxy = {});\r\n                syncSetupProxy(proxy, vm.$listeners, emptyObject, vm, '$listeners');\r\n            }\r\n            return vm._listenersProxy;\r\n        },\r\n        get slots() {\r\n            return initSlotsProxy(vm);\r\n        },\r\n        emit: bind$1(vm.$emit, vm),\r\n        expose: function (exposed) {\r\n            if (true) {\r\n                if (exposeCalled) {\r\n                    warn$2(\"expose() should be called only once per setup().\", vm);\r\n                }\r\n                exposeCalled = true;\r\n            }\r\n            if (exposed) {\r\n                Object.keys(exposed).forEach(function (key) {\r\n                    return proxyWithRefUnwrap(vm, exposed, key);\r\n                });\r\n            }\r\n        }\r\n    };\r\n}\r\nfunction syncSetupProxy(to, from, prev, instance, type) {\r\n    var changed = false;\r\n    for (var key in from) {\r\n        if (!(key in to)) {\r\n            changed = true;\r\n            defineProxyAttr(to, key, instance, type);\r\n        }\r\n        else if (from[key] !== prev[key]) {\r\n            changed = true;\r\n        }\r\n    }\r\n    for (var key in to) {\r\n        if (!(key in from)) {\r\n            changed = true;\r\n            delete to[key];\r\n        }\r\n    }\r\n    return changed;\r\n}\r\nfunction defineProxyAttr(proxy, key, instance, type) {\r\n    Object.defineProperty(proxy, key, {\r\n        enumerable: true,\r\n        configurable: true,\r\n        get: function () {\r\n            return instance[type][key];\r\n        }\r\n    });\r\n}\r\nfunction initSlotsProxy(vm) {\r\n    if (!vm._slotsProxy) {\r\n        syncSetupSlots((vm._slotsProxy = {}), vm.$scopedSlots);\r\n    }\r\n    return vm._slotsProxy;\r\n}\r\nfunction syncSetupSlots(to, from) {\r\n    for (var key in from) {\r\n        to[key] = from[key];\r\n    }\r\n    for (var key in to) {\r\n        if (!(key in from)) {\r\n            delete to[key];\r\n        }\r\n    }\r\n}\r\n/**\r\n * @internal use manual type def because public setup context type relies on\r\n * legacy VNode types\r\n */\r\nfunction useSlots() {\r\n    return getContext().slots;\r\n}\r\n/**\r\n * @internal use manual type def because public setup context type relies on\r\n * legacy VNode types\r\n */\r\nfunction useAttrs() {\r\n    return getContext().attrs;\r\n}\r\n/**\r\n * Vue 2 only\r\n * @internal use manual type def because public setup context type relies on\r\n * legacy VNode types\r\n */\r\nfunction useListeners() {\r\n    return getContext().listeners;\r\n}\r\nfunction getContext() {\r\n    if ( true && !currentInstance) {\r\n        warn$2(\"useContext() called without active instance.\");\r\n    }\r\n    var vm = currentInstance;\r\n    return vm._setupContext || (vm._setupContext = createSetupContext(vm));\r\n}\r\n/**\r\n * Runtime helper for merging default declarations. Imported by compiled code\r\n * only.\r\n * @internal\r\n */\r\nfunction mergeDefaults(raw, defaults) {\r\n    var props = isArray(raw)\r\n        ? raw.reduce(function (normalized, p) { return ((normalized[p] = {}), normalized); }, {})\r\n        : raw;\r\n    for (var key in defaults) {\r\n        var opt = props[key];\r\n        if (opt) {\r\n            if (isArray(opt) || isFunction(opt)) {\r\n                props[key] = { type: opt, default: defaults[key] };\r\n            }\r\n            else {\r\n                opt.default = defaults[key];\r\n            }\r\n        }\r\n        else if (opt === null) {\r\n            props[key] = { default: defaults[key] };\r\n        }\r\n        else if (true) {\r\n            warn$2(\"props default key \\\"\".concat(key, \"\\\" has no corresponding declaration.\"));\r\n        }\r\n    }\r\n    return props;\r\n}\n\nfunction initRender(vm) {\r\n    vm._vnode = null; // the root of the child tree\r\n    vm._staticTrees = null; // v-once cached trees\r\n    var options = vm.$options;\r\n    var parentVnode = (vm.$vnode = options._parentVnode); // the placeholder node in parent tree\r\n    var renderContext = parentVnode && parentVnode.context;\r\n    vm.$slots = resolveSlots(options._renderChildren, renderContext);\r\n    vm.$scopedSlots = parentVnode\r\n        ? normalizeScopedSlots(vm.$parent, parentVnode.data.scopedSlots, vm.$slots)\r\n        : emptyObject;\r\n    // bind the createElement fn to this instance\r\n    // so that we get proper render context inside it.\r\n    // args order: tag, data, children, normalizationType, alwaysNormalize\r\n    // internal version is used by render functions compiled from templates\r\n    // @ts-expect-error\r\n    vm._c = function (a, b, c, d) { return createElement$1(vm, a, b, c, d, false); };\r\n    // normalization is always applied for the public version, used in\r\n    // user-written render functions.\r\n    // @ts-expect-error\r\n    vm.$createElement = function (a, b, c, d) { return createElement$1(vm, a, b, c, d, true); };\r\n    // $attrs & $listeners are exposed for easier HOC creation.\r\n    // they need to be reactive so that HOCs using them are always updated\r\n    var parentData = parentVnode && parentVnode.data;\r\n    /* istanbul ignore else */\r\n    if (true) {\r\n        defineReactive(vm, '$attrs', (parentData && parentData.attrs) || emptyObject, function () {\r\n            !isUpdatingChildComponent && warn$2(\"$attrs is readonly.\", vm);\r\n        }, true);\r\n        defineReactive(vm, '$listeners', options._parentListeners || emptyObject, function () {\r\n            !isUpdatingChildComponent && warn$2(\"$listeners is readonly.\", vm);\r\n        }, true);\r\n    }\r\n    else {}\r\n}\r\nvar currentRenderingInstance = null;\r\nfunction renderMixin(Vue) {\r\n    // install runtime convenience helpers\r\n    installRenderHelpers(Vue.prototype);\r\n    Vue.prototype.$nextTick = function (fn) {\r\n        return nextTick(fn, this);\r\n    };\r\n    Vue.prototype._render = function () {\r\n        var vm = this;\r\n        var _a = vm.$options, render = _a.render, _parentVnode = _a._parentVnode;\r\n        if (_parentVnode && vm._isMounted) {\r\n            vm.$scopedSlots = normalizeScopedSlots(vm.$parent, _parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots);\r\n            if (vm._slotsProxy) {\r\n                syncSetupSlots(vm._slotsProxy, vm.$scopedSlots);\r\n            }\r\n        }\r\n        // set parent vnode. this allows render functions to have access\r\n        // to the data on the placeholder node.\r\n        vm.$vnode = _parentVnode;\r\n        // render self\r\n        var vnode;\r\n        try {\r\n            // There's no need to maintain a stack because all render fns are called\r\n            // separately from one another. Nested component's render fns are called\r\n            // when parent component is patched.\r\n            setCurrentInstance(vm);\r\n            currentRenderingInstance = vm;\r\n            vnode = render.call(vm._renderProxy, vm.$createElement);\r\n        }\r\n        catch (e) {\r\n            handleError(e, vm, \"render\");\r\n            // return error render result,\r\n            // or previous vnode to prevent render error causing blank component\r\n            /* istanbul ignore else */\r\n            if ( true && vm.$options.renderError) {\r\n                try {\r\n                    vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);\r\n                }\r\n                catch (e) {\r\n                    handleError(e, vm, \"renderError\");\r\n                    vnode = vm._vnode;\r\n                }\r\n            }\r\n            else {\r\n                vnode = vm._vnode;\r\n            }\r\n        }\r\n        finally {\r\n            currentRenderingInstance = null;\r\n            setCurrentInstance();\r\n        }\r\n        // if the returned array contains only a single node, allow it\r\n        if (isArray(vnode) && vnode.length === 1) {\r\n            vnode = vnode[0];\r\n        }\r\n        // return empty vnode in case the render function errored out\r\n        if (!(vnode instanceof VNode)) {\r\n            if ( true && isArray(vnode)) {\r\n                warn$2('Multiple root nodes returned from render function. Render function ' +\r\n                    'should return a single root node.', vm);\r\n            }\r\n            vnode = createEmptyVNode();\r\n        }\r\n        // set parent\r\n        vnode.parent = _parentVnode;\r\n        return vnode;\r\n    };\r\n}\n\nfunction ensureCtor(comp, base) {\r\n    if (comp.__esModule || (hasSymbol && comp[Symbol.toStringTag] === 'Module')) {\r\n        comp = comp.default;\r\n    }\r\n    return isObject(comp) ? base.extend(comp) : comp;\r\n}\r\nfunction createAsyncPlaceholder(factory, data, context, children, tag) {\r\n    var node = createEmptyVNode();\r\n    node.asyncFactory = factory;\r\n    node.asyncMeta = { data: data, context: context, children: children, tag: tag };\r\n    return node;\r\n}\r\nfunction resolveAsyncComponent(factory, baseCtor) {\r\n    if (isTrue(factory.error) && isDef(factory.errorComp)) {\r\n        return factory.errorComp;\r\n    }\r\n    if (isDef(factory.resolved)) {\r\n        return factory.resolved;\r\n    }\r\n    var owner = currentRenderingInstance;\r\n    if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {\r\n        // already pending\r\n        factory.owners.push(owner);\r\n    }\r\n    if (isTrue(factory.loading) && isDef(factory.loadingComp)) {\r\n        return factory.loadingComp;\r\n    }\r\n    if (owner && !isDef(factory.owners)) {\r\n        var owners_1 = (factory.owners = [owner]);\r\n        var sync_1 = true;\r\n        var timerLoading_1 = null;\r\n        var timerTimeout_1 = null;\r\n        owner.$on('hook:destroyed', function () { return remove$2(owners_1, owner); });\r\n        var forceRender_1 = function (renderCompleted) {\r\n            for (var i = 0, l = owners_1.length; i < l; i++) {\r\n                owners_1[i].$forceUpdate();\r\n            }\r\n            if (renderCompleted) {\r\n                owners_1.length = 0;\r\n                if (timerLoading_1 !== null) {\r\n                    clearTimeout(timerLoading_1);\r\n                    timerLoading_1 = null;\r\n                }\r\n                if (timerTimeout_1 !== null) {\r\n                    clearTimeout(timerTimeout_1);\r\n                    timerTimeout_1 = null;\r\n                }\r\n            }\r\n        };\r\n        var resolve = once(function (res) {\r\n            // cache resolved\r\n            factory.resolved = ensureCtor(res, baseCtor);\r\n            // invoke callbacks only if this is not a synchronous resolve\r\n            // (async resolves are shimmed as synchronous during SSR)\r\n            if (!sync_1) {\r\n                forceRender_1(true);\r\n            }\r\n            else {\r\n                owners_1.length = 0;\r\n            }\r\n        });\r\n        var reject_1 = once(function (reason) {\r\n             true &&\r\n                warn$2(\"Failed to resolve async component: \".concat(String(factory)) +\r\n                    (reason ? \"\\nReason: \".concat(reason) : ''));\r\n            if (isDef(factory.errorComp)) {\r\n                factory.error = true;\r\n                forceRender_1(true);\r\n            }\r\n        });\r\n        var res_1 = factory(resolve, reject_1);\r\n        if (isObject(res_1)) {\r\n            if (isPromise(res_1)) {\r\n                // () => Promise\r\n                if (isUndef(factory.resolved)) {\r\n                    res_1.then(resolve, reject_1);\r\n                }\r\n            }\r\n            else if (isPromise(res_1.component)) {\r\n                res_1.component.then(resolve, reject_1);\r\n                if (isDef(res_1.error)) {\r\n                    factory.errorComp = ensureCtor(res_1.error, baseCtor);\r\n                }\r\n                if (isDef(res_1.loading)) {\r\n                    factory.loadingComp = ensureCtor(res_1.loading, baseCtor);\r\n                    if (res_1.delay === 0) {\r\n                        factory.loading = true;\r\n                    }\r\n                    else {\r\n                        // @ts-expect-error NodeJS timeout type\r\n                        timerLoading_1 = setTimeout(function () {\r\n                            timerLoading_1 = null;\r\n                            if (isUndef(factory.resolved) && isUndef(factory.error)) {\r\n                                factory.loading = true;\r\n                                forceRender_1(false);\r\n                            }\r\n                        }, res_1.delay || 200);\r\n                    }\r\n                }\r\n                if (isDef(res_1.timeout)) {\r\n                    // @ts-expect-error NodeJS timeout type\r\n                    timerTimeout_1 = setTimeout(function () {\r\n                        timerTimeout_1 = null;\r\n                        if (isUndef(factory.resolved)) {\r\n                            reject_1( true ? \"timeout (\".concat(res_1.timeout, \"ms)\") : 0);\r\n                        }\r\n                    }, res_1.timeout);\r\n                }\r\n            }\r\n        }\r\n        sync_1 = false;\r\n        // return in case resolved synchronously\r\n        return factory.loading ? factory.loadingComp : factory.resolved;\r\n    }\r\n}\n\nfunction getFirstComponentChild(children) {\r\n    if (isArray(children)) {\r\n        for (var i = 0; i < children.length; i++) {\r\n            var c = children[i];\r\n            if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {\r\n                return c;\r\n            }\r\n        }\r\n    }\r\n}\n\nfunction initEvents(vm) {\r\n    vm._events = Object.create(null);\r\n    vm._hasHookEvent = false;\r\n    // init parent attached events\r\n    var listeners = vm.$options._parentListeners;\r\n    if (listeners) {\r\n        updateComponentListeners(vm, listeners);\r\n    }\r\n}\r\nvar target$1;\r\nfunction add$1(event, fn) {\r\n    target$1.$on(event, fn);\r\n}\r\nfunction remove$1(event, fn) {\r\n    target$1.$off(event, fn);\r\n}\r\nfunction createOnceHandler$1(event, fn) {\r\n    var _target = target$1;\r\n    return function onceHandler() {\r\n        var res = fn.apply(null, arguments);\r\n        if (res !== null) {\r\n            _target.$off(event, onceHandler);\r\n        }\r\n    };\r\n}\r\nfunction updateComponentListeners(vm, listeners, oldListeners) {\r\n    target$1 = vm;\r\n    updateListeners(listeners, oldListeners || {}, add$1, remove$1, createOnceHandler$1, vm);\r\n    target$1 = undefined;\r\n}\r\nfunction eventsMixin(Vue) {\r\n    var hookRE = /^hook:/;\r\n    Vue.prototype.$on = function (event, fn) {\r\n        var vm = this;\r\n        if (isArray(event)) {\r\n            for (var i = 0, l = event.length; i < l; i++) {\r\n                vm.$on(event[i], fn);\r\n            }\r\n        }\r\n        else {\r\n            (vm._events[event] || (vm._events[event] = [])).push(fn);\r\n            // optimize hook:event cost by using a boolean flag marked at registration\r\n            // instead of a hash lookup\r\n            if (hookRE.test(event)) {\r\n                vm._hasHookEvent = true;\r\n            }\r\n        }\r\n        return vm;\r\n    };\r\n    Vue.prototype.$once = function (event, fn) {\r\n        var vm = this;\r\n        function on() {\r\n            vm.$off(event, on);\r\n            fn.apply(vm, arguments);\r\n        }\r\n        on.fn = fn;\r\n        vm.$on(event, on);\r\n        return vm;\r\n    };\r\n    Vue.prototype.$off = function (event, fn) {\r\n        var vm = this;\r\n        // all\r\n        if (!arguments.length) {\r\n            vm._events = Object.create(null);\r\n            return vm;\r\n        }\r\n        // array of events\r\n        if (isArray(event)) {\r\n            for (var i_1 = 0, l = event.length; i_1 < l; i_1++) {\r\n                vm.$off(event[i_1], fn);\r\n            }\r\n            return vm;\r\n        }\r\n        // specific event\r\n        var cbs = vm._events[event];\r\n        if (!cbs) {\r\n            return vm;\r\n        }\r\n        if (!fn) {\r\n            vm._events[event] = null;\r\n            return vm;\r\n        }\r\n        // specific handler\r\n        var cb;\r\n        var i = cbs.length;\r\n        while (i--) {\r\n            cb = cbs[i];\r\n            if (cb === fn || cb.fn === fn) {\r\n                cbs.splice(i, 1);\r\n                break;\r\n            }\r\n        }\r\n        return vm;\r\n    };\r\n    Vue.prototype.$emit = function (event) {\r\n        var vm = this;\r\n        if (true) {\r\n            var lowerCaseEvent = event.toLowerCase();\r\n            if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\r\n                tip(\"Event \\\"\".concat(lowerCaseEvent, \"\\\" is emitted in component \") +\r\n                    \"\".concat(formatComponentName(vm), \" but the handler is registered for \\\"\").concat(event, \"\\\". \") +\r\n                    \"Note that HTML attributes are case-insensitive and you cannot use \" +\r\n                    \"v-on to listen to camelCase events when using in-DOM templates. \" +\r\n                    \"You should probably use \\\"\".concat(hyphenate(event), \"\\\" instead of \\\"\").concat(event, \"\\\".\"));\r\n            }\r\n        }\r\n        var cbs = vm._events[event];\r\n        if (cbs) {\r\n            cbs = cbs.length > 1 ? toArray(cbs) : cbs;\r\n            var args = toArray(arguments, 1);\r\n            var info = \"event handler for \\\"\".concat(event, \"\\\"\");\r\n            for (var i = 0, l = cbs.length; i < l; i++) {\r\n                invokeWithErrorHandling(cbs[i], vm, args, vm, info);\r\n            }\r\n        }\r\n        return vm;\r\n    };\r\n}\n\nvar activeInstance = null;\r\nvar isUpdatingChildComponent = false;\r\nfunction setActiveInstance(vm) {\r\n    var prevActiveInstance = activeInstance;\r\n    activeInstance = vm;\r\n    return function () {\r\n        activeInstance = prevActiveInstance;\r\n    };\r\n}\r\nfunction initLifecycle(vm) {\r\n    var options = vm.$options;\r\n    // locate first non-abstract parent\r\n    var parent = options.parent;\r\n    if (parent && !options.abstract) {\r\n        while (parent.$options.abstract && parent.$parent) {\r\n            parent = parent.$parent;\r\n        }\r\n        parent.$children.push(vm);\r\n    }\r\n    vm.$parent = parent;\r\n    vm.$root = parent ? parent.$root : vm;\r\n    vm.$children = [];\r\n    vm.$refs = {};\r\n    vm._provided = parent ? parent._provided : Object.create(null);\r\n    vm._watcher = null;\r\n    vm._inactive = null;\r\n    vm._directInactive = false;\r\n    vm._isMounted = false;\r\n    vm._isDestroyed = false;\r\n    vm._isBeingDestroyed = false;\r\n}\r\nfunction lifecycleMixin(Vue) {\r\n    Vue.prototype._update = function (vnode, hydrating) {\r\n        var vm = this;\r\n        var prevEl = vm.$el;\r\n        var prevVnode = vm._vnode;\r\n        var restoreActiveInstance = setActiveInstance(vm);\r\n        vm._vnode = vnode;\r\n        // Vue.prototype.__patch__ is injected in entry points\r\n        // based on the rendering backend used.\r\n        if (!prevVnode) {\r\n            // initial render\r\n            vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */);\r\n        }\r\n        else {\r\n            // updates\r\n            vm.$el = vm.__patch__(prevVnode, vnode);\r\n        }\r\n        restoreActiveInstance();\r\n        // update __vue__ reference\r\n        if (prevEl) {\r\n            prevEl.__vue__ = null;\r\n        }\r\n        if (vm.$el) {\r\n            vm.$el.__vue__ = vm;\r\n        }\r\n        // if parent is an HOC, update its $el as well\r\n        if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\r\n            vm.$parent.$el = vm.$el;\r\n        }\r\n        // updated hook is called by the scheduler to ensure that children are\r\n        // updated in a parent's updated hook.\r\n    };\r\n    Vue.prototype.$forceUpdate = function () {\r\n        var vm = this;\r\n        if (vm._watcher) {\r\n            vm._watcher.update();\r\n        }\r\n    };\r\n    Vue.prototype.$destroy = function () {\r\n        var vm = this;\r\n        if (vm._isBeingDestroyed) {\r\n            return;\r\n        }\r\n        callHook$1(vm, 'beforeDestroy');\r\n        vm._isBeingDestroyed = true;\r\n        // remove self from parent\r\n        var parent = vm.$parent;\r\n        if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\r\n            remove$2(parent.$children, vm);\r\n        }\r\n        // teardown scope. this includes both the render watcher and other\r\n        // watchers created\r\n        vm._scope.stop();\r\n        // remove reference from data ob\r\n        // frozen object may not have observer.\r\n        if (vm._data.__ob__) {\r\n            vm._data.__ob__.vmCount--;\r\n        }\r\n        // call the last hook...\r\n        vm._isDestroyed = true;\r\n        // invoke destroy hooks on current rendered tree\r\n        vm.__patch__(vm._vnode, null);\r\n        // fire destroyed hook\r\n        callHook$1(vm, 'destroyed');\r\n        // turn off all instance listeners.\r\n        vm.$off();\r\n        // remove __vue__ reference\r\n        if (vm.$el) {\r\n            vm.$el.__vue__ = null;\r\n        }\r\n        // release circular reference (#6759)\r\n        if (vm.$vnode) {\r\n            vm.$vnode.parent = null;\r\n        }\r\n    };\r\n}\r\nfunction mountComponent(vm, el, hydrating) {\r\n    vm.$el = el;\r\n    if (!vm.$options.render) {\r\n        // @ts-expect-error invalid type\r\n        vm.$options.render = createEmptyVNode;\r\n        if (true) {\r\n            /* istanbul ignore if */\r\n            if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||\r\n                vm.$options.el ||\r\n                el) {\r\n                warn$2('You are using the runtime-only build of Vue where the template ' +\r\n                    'compiler is not available. Either pre-compile the templates into ' +\r\n                    'render functions, or use the compiler-included build.', vm);\r\n            }\r\n            else {\r\n                warn$2('Failed to mount component: template or render function not defined.', vm);\r\n            }\r\n        }\r\n    }\r\n    callHook$1(vm, 'beforeMount');\r\n    var updateComponent;\r\n    /* istanbul ignore if */\r\n    if ( true && config.performance && mark) {\r\n        updateComponent = function () {\r\n            var name = vm._name;\r\n            var id = vm._uid;\r\n            var startTag = \"vue-perf-start:\".concat(id);\r\n            var endTag = \"vue-perf-end:\".concat(id);\r\n            mark(startTag);\r\n            var vnode = vm._render();\r\n            mark(endTag);\r\n            measure(\"vue \".concat(name, \" render\"), startTag, endTag);\r\n            mark(startTag);\r\n            vm._update(vnode, hydrating);\r\n            mark(endTag);\r\n            measure(\"vue \".concat(name, \" patch\"), startTag, endTag);\r\n        };\r\n    }\r\n    else {\r\n        updateComponent = function () {\r\n            vm._update(vm._render(), hydrating);\r\n        };\r\n    }\r\n    var watcherOptions = {\r\n        before: function () {\r\n            if (vm._isMounted && !vm._isDestroyed) {\r\n                callHook$1(vm, 'beforeUpdate');\r\n            }\r\n        }\r\n    };\r\n    if (true) {\r\n        watcherOptions.onTrack = function (e) { return callHook$1(vm, 'renderTracked', [e]); };\r\n        watcherOptions.onTrigger = function (e) { return callHook$1(vm, 'renderTriggered', [e]); };\r\n    }\r\n    // we set this to vm._watcher inside the watcher's constructor\r\n    // since the watcher's initial patch may call $forceUpdate (e.g. inside child\r\n    // component's mounted hook), which relies on vm._watcher being already defined\r\n    new Watcher(vm, updateComponent, noop, watcherOptions, true /* isRenderWatcher */);\r\n    hydrating = false;\r\n    // flush buffer for flush: \"pre\" watchers queued in setup()\r\n    var preWatchers = vm._preWatchers;\r\n    if (preWatchers) {\r\n        for (var i = 0; i < preWatchers.length; i++) {\r\n            preWatchers[i].run();\r\n        }\r\n    }\r\n    // manually mounted instance, call mounted on self\r\n    // mounted is called for render-created child components in its inserted hook\r\n    if (vm.$vnode == null) {\r\n        vm._isMounted = true;\r\n        callHook$1(vm, 'mounted');\r\n    }\r\n    return vm;\r\n}\r\nfunction updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {\r\n    if (true) {\r\n        isUpdatingChildComponent = true;\r\n    }\r\n    // determine whether component has slot children\r\n    // we need to do this before overwriting $options._renderChildren.\r\n    // check if there are dynamic scopedSlots (hand-written or compiled but with\r\n    // dynamic slot names). Static scoped slots compiled from template has the\r\n    // \"$stable\" marker.\r\n    var newScopedSlots = parentVnode.data.scopedSlots;\r\n    var oldScopedSlots = vm.$scopedSlots;\r\n    var hasDynamicScopedSlot = !!((newScopedSlots && !newScopedSlots.$stable) ||\r\n        (oldScopedSlots !== emptyObject && !oldScopedSlots.$stable) ||\r\n        (newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key) ||\r\n        (!newScopedSlots && vm.$scopedSlots.$key));\r\n    // Any static slot children from the parent may have changed during parent's\r\n    // update. Dynamic scoped slots may also have changed. In such cases, a forced\r\n    // update is necessary to ensure correctness.\r\n    var needsForceUpdate = !!(renderChildren || // has new static slots\r\n        vm.$options._renderChildren || // has old static slots\r\n        hasDynamicScopedSlot);\r\n    var prevVNode = vm.$vnode;\r\n    vm.$options._parentVnode = parentVnode;\r\n    vm.$vnode = parentVnode; // update vm's placeholder node without re-render\r\n    if (vm._vnode) {\r\n        // update child tree's parent\r\n        vm._vnode.parent = parentVnode;\r\n    }\r\n    vm.$options._renderChildren = renderChildren;\r\n    // update $attrs and $listeners hash\r\n    // these are also reactive so they may trigger child update if the child\r\n    // used them during render\r\n    var attrs = parentVnode.data.attrs || emptyObject;\r\n    if (vm._attrsProxy) {\r\n        // force update if attrs are accessed and has changed since it may be\r\n        // passed to a child component.\r\n        if (syncSetupProxy(vm._attrsProxy, attrs, (prevVNode.data && prevVNode.data.attrs) || emptyObject, vm, '$attrs')) {\r\n            needsForceUpdate = true;\r\n        }\r\n    }\r\n    vm.$attrs = attrs;\r\n    // update listeners\r\n    listeners = listeners || emptyObject;\r\n    var prevListeners = vm.$options._parentListeners;\r\n    if (vm._listenersProxy) {\r\n        syncSetupProxy(vm._listenersProxy, listeners, prevListeners || emptyObject, vm, '$listeners');\r\n    }\r\n    vm.$listeners = vm.$options._parentListeners = listeners;\r\n    updateComponentListeners(vm, listeners, prevListeners);\r\n    // update props\r\n    if (propsData && vm.$options.props) {\r\n        toggleObserving(false);\r\n        var props = vm._props;\r\n        var propKeys = vm.$options._propKeys || [];\r\n        for (var i = 0; i < propKeys.length; i++) {\r\n            var key = propKeys[i];\r\n            var propOptions = vm.$options.props; // wtf flow?\r\n            props[key] = validateProp(key, propOptions, propsData, vm);\r\n        }\r\n        toggleObserving(true);\r\n        // keep a copy of raw propsData\r\n        vm.$options.propsData = propsData;\r\n    }\r\n    // resolve slots + force update if has children\r\n    if (needsForceUpdate) {\r\n        vm.$slots = resolveSlots(renderChildren, parentVnode.context);\r\n        vm.$forceUpdate();\r\n    }\r\n    if (true) {\r\n        isUpdatingChildComponent = false;\r\n    }\r\n}\r\nfunction isInInactiveTree(vm) {\r\n    while (vm && (vm = vm.$parent)) {\r\n        if (vm._inactive)\r\n            return true;\r\n    }\r\n    return false;\r\n}\r\nfunction activateChildComponent(vm, direct) {\r\n    if (direct) {\r\n        vm._directInactive = false;\r\n        if (isInInactiveTree(vm)) {\r\n            return;\r\n        }\r\n    }\r\n    else if (vm._directInactive) {\r\n        return;\r\n    }\r\n    if (vm._inactive || vm._inactive === null) {\r\n        vm._inactive = false;\r\n        for (var i = 0; i < vm.$children.length; i++) {\r\n            activateChildComponent(vm.$children[i]);\r\n        }\r\n        callHook$1(vm, 'activated');\r\n    }\r\n}\r\nfunction deactivateChildComponent(vm, direct) {\r\n    if (direct) {\r\n        vm._directInactive = true;\r\n        if (isInInactiveTree(vm)) {\r\n            return;\r\n        }\r\n    }\r\n    if (!vm._inactive) {\r\n        vm._inactive = true;\r\n        for (var i = 0; i < vm.$children.length; i++) {\r\n            deactivateChildComponent(vm.$children[i]);\r\n        }\r\n        callHook$1(vm, 'deactivated');\r\n    }\r\n}\r\nfunction callHook$1(vm, hook, args, setContext) {\r\n    if (setContext === void 0) { setContext = true; }\r\n    // #7573 disable dep collection when invoking lifecycle hooks\r\n    pushTarget();\r\n    var prev = currentInstance;\r\n    setContext && setCurrentInstance(vm);\r\n    var handlers = vm.$options[hook];\r\n    var info = \"\".concat(hook, \" hook\");\r\n    if (handlers) {\r\n        for (var i = 0, j = handlers.length; i < j; i++) {\r\n            invokeWithErrorHandling(handlers[i], vm, args || null, vm, info);\r\n        }\r\n    }\r\n    if (vm._hasHookEvent) {\r\n        vm.$emit('hook:' + hook);\r\n    }\r\n    setContext && setCurrentInstance(prev);\r\n    popTarget();\r\n}\n\nvar MAX_UPDATE_COUNT = 100;\r\nvar queue = [];\r\nvar activatedChildren = [];\r\nvar has = {};\r\nvar circular = {};\r\nvar waiting = false;\r\nvar flushing = false;\r\nvar index$1 = 0;\r\n/**\r\n * Reset the scheduler's state.\r\n */\r\nfunction resetSchedulerState() {\r\n    index$1 = queue.length = activatedChildren.length = 0;\r\n    has = {};\r\n    if (true) {\r\n        circular = {};\r\n    }\r\n    waiting = flushing = false;\r\n}\r\n// Async edge case #6566 requires saving the timestamp when event listeners are\r\n// attached. However, calling performance.now() has a perf overhead especially\r\n// if the page has thousands of event listeners. Instead, we take a timestamp\r\n// every time the scheduler flushes and use that for all event listeners\r\n// attached during that flush.\r\nvar currentFlushTimestamp = 0;\r\n// Async edge case fix requires storing an event listener's attach timestamp.\r\nvar getNow = Date.now;\r\n// Determine what event timestamp the browser is using. Annoyingly, the\r\n// timestamp can either be hi-res (relative to page load) or low-res\r\n// (relative to UNIX epoch), so in order to compare time we have to use the\r\n// same timestamp type when saving the flush timestamp.\r\n// All IE versions use low-res event timestamps, and have problematic clock\r\n// implementations (#9632)\r\nif (inBrowser && !isIE) {\r\n    var performance_1 = window.performance;\r\n    if (performance_1 &&\r\n        typeof performance_1.now === 'function' &&\r\n        getNow() > document.createEvent('Event').timeStamp) {\r\n        // if the event timestamp, although evaluated AFTER the Date.now(), is\r\n        // smaller than it, it means the event is using a hi-res timestamp,\r\n        // and we need to use the hi-res version for event listener timestamps as\r\n        // well.\r\n        getNow = function () { return performance_1.now(); };\r\n    }\r\n}\r\nvar sortCompareFn = function (a, b) {\r\n    if (a.post) {\r\n        if (!b.post)\r\n            return 1;\r\n    }\r\n    else if (b.post) {\r\n        return -1;\r\n    }\r\n    return a.id - b.id;\r\n};\r\n/**\r\n * Flush both queues and run the watchers.\r\n */\r\nfunction flushSchedulerQueue() {\r\n    currentFlushTimestamp = getNow();\r\n    flushing = true;\r\n    var watcher, id;\r\n    // Sort queue before flush.\r\n    // This ensures that:\r\n    // 1. Components are updated from parent to child. (because parent is always\r\n    //    created before the child)\r\n    // 2. A component's user watchers are run before its render watcher (because\r\n    //    user watchers are created before the render watcher)\r\n    // 3. If a component is destroyed during a parent component's watcher run,\r\n    //    its watchers can be skipped.\r\n    queue.sort(sortCompareFn);\r\n    // do not cache length because more watchers might be pushed\r\n    // as we run existing watchers\r\n    for (index$1 = 0; index$1 < queue.length; index$1++) {\r\n        watcher = queue[index$1];\r\n        if (watcher.before) {\r\n            watcher.before();\r\n        }\r\n        id = watcher.id;\r\n        has[id] = null;\r\n        watcher.run();\r\n        // in dev build, check and stop circular updates.\r\n        if ( true && has[id] != null) {\r\n            circular[id] = (circular[id] || 0) + 1;\r\n            if (circular[id] > MAX_UPDATE_COUNT) {\r\n                warn$2('You may have an infinite update loop ' +\r\n                    (watcher.user\r\n                        ? \"in watcher with expression \\\"\".concat(watcher.expression, \"\\\"\")\r\n                        : \"in a component render function.\"), watcher.vm);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    // keep copies of post queues before resetting state\r\n    var activatedQueue = activatedChildren.slice();\r\n    var updatedQueue = queue.slice();\r\n    resetSchedulerState();\r\n    // call component updated and activated hooks\r\n    callActivatedHooks(activatedQueue);\r\n    callUpdatedHooks(updatedQueue);\r\n    // devtool hook\r\n    /* istanbul ignore if */\r\n    if (devtools && config.devtools) {\r\n        devtools.emit('flush');\r\n    }\r\n}\r\nfunction callUpdatedHooks(queue) {\r\n    var i = queue.length;\r\n    while (i--) {\r\n        var watcher = queue[i];\r\n        var vm = watcher.vm;\r\n        if (vm && vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {\r\n            callHook$1(vm, 'updated');\r\n        }\r\n    }\r\n}\r\n/**\r\n * Queue a kept-alive component that was activated during patch.\r\n * The queue will be processed after the entire tree has been patched.\r\n */\r\nfunction queueActivatedComponent(vm) {\r\n    // setting _inactive to false here so that a render function can\r\n    // rely on checking whether it's in an inactive tree (e.g. router-view)\r\n    vm._inactive = false;\r\n    activatedChildren.push(vm);\r\n}\r\nfunction callActivatedHooks(queue) {\r\n    for (var i = 0; i < queue.length; i++) {\r\n        queue[i]._inactive = true;\r\n        activateChildComponent(queue[i], true /* true */);\r\n    }\r\n}\r\n/**\r\n * Push a watcher into the watcher queue.\r\n * Jobs with duplicate IDs will be skipped unless it's\r\n * pushed when the queue is being flushed.\r\n */\r\nfunction queueWatcher(watcher) {\r\n    var id = watcher.id;\r\n    if (has[id] != null) {\r\n        return;\r\n    }\r\n    if (watcher === Dep.target && watcher.noRecurse) {\r\n        return;\r\n    }\r\n    has[id] = true;\r\n    if (!flushing) {\r\n        queue.push(watcher);\r\n    }\r\n    else {\r\n        // if already flushing, splice the watcher based on its id\r\n        // if already past its id, it will be run next immediately.\r\n        var i = queue.length - 1;\r\n        while (i > index$1 && queue[i].id > watcher.id) {\r\n            i--;\r\n        }\r\n        queue.splice(i + 1, 0, watcher);\r\n    }\r\n    // queue the flush\r\n    if (!waiting) {\r\n        waiting = true;\r\n        if ( true && !config.async) {\r\n            flushSchedulerQueue();\r\n            return;\r\n        }\r\n        nextTick(flushSchedulerQueue);\r\n    }\r\n}\n\nvar WATCHER = \"watcher\";\r\nvar WATCHER_CB = \"\".concat(WATCHER, \" callback\");\r\nvar WATCHER_GETTER = \"\".concat(WATCHER, \" getter\");\r\nvar WATCHER_CLEANUP = \"\".concat(WATCHER, \" cleanup\");\r\n// Simple effect.\r\nfunction watchEffect(effect, options) {\r\n    return doWatch(effect, null, options);\r\n}\r\nfunction watchPostEffect(effect, options) {\r\n    return doWatch(effect, null, ( true\r\n        ? __assign(__assign({}, options), { flush: 'post' }) : 0));\r\n}\r\nfunction watchSyncEffect(effect, options) {\r\n    return doWatch(effect, null, ( true\r\n        ? __assign(__assign({}, options), { flush: 'sync' }) : 0));\r\n}\r\n// initial value for watchers to trigger on undefined initial values\r\nvar INITIAL_WATCHER_VALUE = {};\r\n// implementation\r\nfunction watch(source, cb, options) {\r\n    if ( true && typeof cb !== 'function') {\r\n        warn$2(\"`watch(fn, options?)` signature has been moved to a separate API. \" +\r\n            \"Use `watchEffect(fn, options?)` instead. `watch` now only \" +\r\n            \"supports `watch(source, cb, options?) signature.\");\r\n    }\r\n    return doWatch(source, cb, options);\r\n}\r\nfunction doWatch(source, cb, _a) {\r\n    var _b = _a === void 0 ? emptyObject : _a, immediate = _b.immediate, deep = _b.deep, _c = _b.flush, flush = _c === void 0 ? 'pre' : _c, onTrack = _b.onTrack, onTrigger = _b.onTrigger;\r\n    if ( true && !cb) {\r\n        if (immediate !== undefined) {\r\n            warn$2(\"watch() \\\"immediate\\\" option is only respected when using the \" +\r\n                \"watch(source, callback, options?) signature.\");\r\n        }\r\n        if (deep !== undefined) {\r\n            warn$2(\"watch() \\\"deep\\\" option is only respected when using the \" +\r\n                \"watch(source, callback, options?) signature.\");\r\n        }\r\n    }\r\n    var warnInvalidSource = function (s) {\r\n        warn$2(\"Invalid watch source: \".concat(s, \". A watch source can only be a getter/effect \") +\r\n            \"function, a ref, a reactive object, or an array of these types.\");\r\n    };\r\n    var instance = currentInstance;\r\n    var call = function (fn, type, args) {\r\n        if (args === void 0) { args = null; }\r\n        return invokeWithErrorHandling(fn, null, args, instance, type);\r\n    };\r\n    var getter;\r\n    var forceTrigger = false;\r\n    var isMultiSource = false;\r\n    if (isRef(source)) {\r\n        getter = function () { return source.value; };\r\n        forceTrigger = isShallow(source);\r\n    }\r\n    else if (isReactive(source)) {\r\n        getter = function () {\r\n            source.__ob__.dep.depend();\r\n            return source;\r\n        };\r\n        deep = true;\r\n    }\r\n    else if (isArray(source)) {\r\n        isMultiSource = true;\r\n        forceTrigger = source.some(function (s) { return isReactive(s) || isShallow(s); });\r\n        getter = function () {\r\n            return source.map(function (s) {\r\n                if (isRef(s)) {\r\n                    return s.value;\r\n                }\r\n                else if (isReactive(s)) {\r\n                    return traverse(s);\r\n                }\r\n                else if (isFunction(s)) {\r\n                    return call(s, WATCHER_GETTER);\r\n                }\r\n                else {\r\n                     true && warnInvalidSource(s);\r\n                }\r\n            });\r\n        };\r\n    }\r\n    else if (isFunction(source)) {\r\n        if (cb) {\r\n            // getter with cb\r\n            getter = function () { return call(source, WATCHER_GETTER); };\r\n        }\r\n        else {\r\n            // no cb -> simple effect\r\n            getter = function () {\r\n                if (instance && instance._isDestroyed) {\r\n                    return;\r\n                }\r\n                if (cleanup) {\r\n                    cleanup();\r\n                }\r\n                return call(source, WATCHER, [onCleanup]);\r\n            };\r\n        }\r\n    }\r\n    else {\r\n        getter = noop;\r\n         true && warnInvalidSource(source);\r\n    }\r\n    if (cb && deep) {\r\n        var baseGetter_1 = getter;\r\n        getter = function () { return traverse(baseGetter_1()); };\r\n    }\r\n    var cleanup;\r\n    var onCleanup = function (fn) {\r\n        cleanup = watcher.onStop = function () {\r\n            call(fn, WATCHER_CLEANUP);\r\n        };\r\n    };\r\n    // in SSR there is no need to setup an actual effect, and it should be noop\r\n    // unless it's eager\r\n    if (isServerRendering()) {\r\n        // we will also not call the invalidate callback (+ runner is not set up)\r\n        onCleanup = noop;\r\n        if (!cb) {\r\n            getter();\r\n        }\r\n        else if (immediate) {\r\n            call(cb, WATCHER_CB, [\r\n                getter(),\r\n                isMultiSource ? [] : undefined,\r\n                onCleanup\r\n            ]);\r\n        }\r\n        return noop;\r\n    }\r\n    var watcher = new Watcher(currentInstance, getter, noop, {\r\n        lazy: true\r\n    });\r\n    watcher.noRecurse = !cb;\r\n    var oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;\r\n    // overwrite default run\r\n    watcher.run = function () {\r\n        if (!watcher.active &&\r\n            !(flush === 'pre' && instance && instance._isBeingDestroyed)) {\r\n            return;\r\n        }\r\n        if (cb) {\r\n            // watch(source, cb)\r\n            var newValue = watcher.get();\r\n            if (deep ||\r\n                forceTrigger ||\r\n                (isMultiSource\r\n                    ? newValue.some(function (v, i) {\r\n                        return hasChanged(v, oldValue[i]);\r\n                    })\r\n                    : hasChanged(newValue, oldValue))) {\r\n                // cleanup before running cb again\r\n                if (cleanup) {\r\n                    cleanup();\r\n                }\r\n                call(cb, WATCHER_CB, [\r\n                    newValue,\r\n                    // pass undefined as the old value when it's changed for the first time\r\n                    oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue,\r\n                    onCleanup\r\n                ]);\r\n                oldValue = newValue;\r\n            }\r\n        }\r\n        else {\r\n            // watchEffect\r\n            watcher.get();\r\n        }\r\n    };\r\n    if (flush === 'sync') {\r\n        watcher.update = watcher.run;\r\n    }\r\n    else if (flush === 'post') {\r\n        watcher.post = true;\r\n        watcher.update = function () { return queueWatcher(watcher); };\r\n    }\r\n    else {\r\n        // pre\r\n        watcher.update = function () {\r\n            if (instance && instance === currentInstance && !instance._isMounted) {\r\n                // pre-watcher triggered before\r\n                var buffer = instance._preWatchers || (instance._preWatchers = []);\r\n                if (buffer.indexOf(watcher) < 0)\r\n                    buffer.push(watcher);\r\n            }\r\n            else {\r\n                queueWatcher(watcher);\r\n            }\r\n        };\r\n    }\r\n    if (true) {\r\n        watcher.onTrack = onTrack;\r\n        watcher.onTrigger = onTrigger;\r\n    }\r\n    // initial run\r\n    if (cb) {\r\n        if (immediate) {\r\n            watcher.run();\r\n        }\r\n        else {\r\n            oldValue = watcher.get();\r\n        }\r\n    }\r\n    else if (flush === 'post' && instance) {\r\n        instance.$once('hook:mounted', function () { return watcher.get(); });\r\n    }\r\n    else {\r\n        watcher.get();\r\n    }\r\n    return function () {\r\n        watcher.teardown();\r\n    };\r\n}\n\nvar activeEffectScope;\r\nvar EffectScope = /** @class */ (function () {\r\n    function EffectScope(detached) {\r\n        if (detached === void 0) { detached = false; }\r\n        /**\r\n         * @internal\r\n         */\r\n        this.active = true;\r\n        /**\r\n         * @internal\r\n         */\r\n        this.effects = [];\r\n        /**\r\n         * @internal\r\n         */\r\n        this.cleanups = [];\r\n        if (!detached && activeEffectScope) {\r\n            this.parent = activeEffectScope;\r\n            this.index =\r\n                (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;\r\n        }\r\n    }\r\n    EffectScope.prototype.run = function (fn) {\r\n        if (this.active) {\r\n            var currentEffectScope = activeEffectScope;\r\n            try {\r\n                activeEffectScope = this;\r\n                return fn();\r\n            }\r\n            finally {\r\n                activeEffectScope = currentEffectScope;\r\n            }\r\n        }\r\n        else if (true) {\r\n            warn$2(\"cannot run an inactive effect scope.\");\r\n        }\r\n    };\r\n    /**\r\n     * This should only be called on non-detached scopes\r\n     * @internal\r\n     */\r\n    EffectScope.prototype.on = function () {\r\n        activeEffectScope = this;\r\n    };\r\n    /**\r\n     * This should only be called on non-detached scopes\r\n     * @internal\r\n     */\r\n    EffectScope.prototype.off = function () {\r\n        activeEffectScope = this.parent;\r\n    };\r\n    EffectScope.prototype.stop = function (fromParent) {\r\n        if (this.active) {\r\n            var i = void 0, l = void 0;\r\n            for (i = 0, l = this.effects.length; i < l; i++) {\r\n                this.effects[i].teardown();\r\n            }\r\n            for (i = 0, l = this.cleanups.length; i < l; i++) {\r\n                this.cleanups[i]();\r\n            }\r\n            if (this.scopes) {\r\n                for (i = 0, l = this.scopes.length; i < l; i++) {\r\n                    this.scopes[i].stop(true);\r\n                }\r\n            }\r\n            // nested scope, dereference from parent to avoid memory leaks\r\n            if (this.parent && !fromParent) {\r\n                // optimized O(1) removal\r\n                var last = this.parent.scopes.pop();\r\n                if (last && last !== this) {\r\n                    this.parent.scopes[this.index] = last;\r\n                    last.index = this.index;\r\n                }\r\n            }\r\n            this.active = false;\r\n        }\r\n    };\r\n    return EffectScope;\r\n}());\r\nfunction effectScope(detached) {\r\n    return new EffectScope(detached);\r\n}\r\n/**\r\n * @internal\r\n */\r\nfunction recordEffectScope(effect, scope) {\r\n    if (scope === void 0) { scope = activeEffectScope; }\r\n    if (scope && scope.active) {\r\n        scope.effects.push(effect);\r\n    }\r\n}\r\nfunction getCurrentScope() {\r\n    return activeEffectScope;\r\n}\r\nfunction onScopeDispose(fn) {\r\n    if (activeEffectScope) {\r\n        activeEffectScope.cleanups.push(fn);\r\n    }\r\n    else if (true) {\r\n        warn$2(\"onScopeDispose() is called when there is no active effect scope\" +\r\n            \" to be associated with.\");\r\n    }\r\n}\n\nfunction provide(key, value) {\r\n    if (!currentInstance) {\r\n        if (true) {\r\n            warn$2(\"provide() can only be used inside setup().\");\r\n        }\r\n    }\r\n    else {\r\n        // TS doesn't allow symbol as index type\r\n        resolveProvided(currentInstance)[key] = value;\r\n    }\r\n}\r\nfunction resolveProvided(vm) {\r\n    // by default an instance inherits its parent's provides object\r\n    // but when it needs to provide values of its own, it creates its\r\n    // own provides object using parent provides object as prototype.\r\n    // this way in `inject` we can simply look up injections from direct\r\n    // parent and let the prototype chain do the work.\r\n    var existing = vm._provided;\r\n    var parentProvides = vm.$parent && vm.$parent._provided;\r\n    if (parentProvides === existing) {\r\n        return (vm._provided = Object.create(parentProvides));\r\n    }\r\n    else {\r\n        return existing;\r\n    }\r\n}\r\nfunction inject(key, defaultValue, treatDefaultAsFactory) {\r\n    if (treatDefaultAsFactory === void 0) { treatDefaultAsFactory = false; }\r\n    // fallback to `currentRenderingInstance` so that this can be called in\r\n    // a functional component\r\n    var instance = currentInstance;\r\n    if (instance) {\r\n        // #2400\r\n        // to support `app.use` plugins,\r\n        // fallback to appContext's `provides` if the instance is at root\r\n        var provides = instance.$parent && instance.$parent._provided;\r\n        if (provides && key in provides) {\r\n            // TS doesn't allow symbol as index type\r\n            return provides[key];\r\n        }\r\n        else if (arguments.length > 1) {\r\n            return treatDefaultAsFactory && isFunction(defaultValue)\r\n                ? defaultValue.call(instance)\r\n                : defaultValue;\r\n        }\r\n        else if (true) {\r\n            warn$2(\"injection \\\"\".concat(String(key), \"\\\" not found.\"));\r\n        }\r\n    }\r\n    else if (true) {\r\n        warn$2(\"inject() can only be used inside setup() or functional components.\");\r\n    }\r\n}\n\n/**\r\n * @internal this function needs manual public type declaration because it relies\r\n * on previously manually authored types from Vue 2\r\n */\r\nfunction h(type, props, children) {\r\n    if (!currentInstance) {\r\n         true &&\r\n            warn$2(\"globally imported h() can only be invoked when there is an active \" +\r\n                \"component instance, e.g. synchronously in a component's render or setup function.\");\r\n    }\r\n    return createElement$1(currentInstance, type, props, children, 2, true);\r\n}\n\nfunction handleError(err, vm, info) {\r\n    // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.\r\n    // See: https://github.com/vuejs/vuex/issues/1505\r\n    pushTarget();\r\n    try {\r\n        if (vm) {\r\n            var cur = vm;\r\n            while ((cur = cur.$parent)) {\r\n                var hooks = cur.$options.errorCaptured;\r\n                if (hooks) {\r\n                    for (var i = 0; i < hooks.length; i++) {\r\n                        try {\r\n                            var capture = hooks[i].call(cur, err, vm, info) === false;\r\n                            if (capture)\r\n                                return;\r\n                        }\r\n                        catch (e) {\r\n                            globalHandleError(e, cur, 'errorCaptured hook');\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        globalHandleError(err, vm, info);\r\n    }\r\n    finally {\r\n        popTarget();\r\n    }\r\n}\r\nfunction invokeWithErrorHandling(handler, context, args, vm, info) {\r\n    var res;\r\n    try {\r\n        res = args ? handler.apply(context, args) : handler.call(context);\r\n        if (res && !res._isVue && isPromise(res) && !res._handled) {\r\n            res.catch(function (e) { return handleError(e, vm, info + \" (Promise/async)\"); });\r\n            res._handled = true;\r\n        }\r\n    }\r\n    catch (e) {\r\n        handleError(e, vm, info);\r\n    }\r\n    return res;\r\n}\r\nfunction globalHandleError(err, vm, info) {\r\n    if (config.errorHandler) {\r\n        try {\r\n            return config.errorHandler.call(null, err, vm, info);\r\n        }\r\n        catch (e) {\r\n            // if the user intentionally throws the original error in the handler,\r\n            // do not log it twice\r\n            if (e !== err) {\r\n                logError(e, null, 'config.errorHandler');\r\n            }\r\n        }\r\n    }\r\n    logError(err, vm, info);\r\n}\r\nfunction logError(err, vm, info) {\r\n    if (true) {\r\n        warn$2(\"Error in \".concat(info, \": \\\"\").concat(err.toString(), \"\\\"\"), vm);\r\n    }\r\n    /* istanbul ignore else */\r\n    if (inBrowser && typeof console !== 'undefined') {\r\n        console.error(err);\r\n    }\r\n    else {\r\n        throw err;\r\n    }\r\n}\n\n/* globals MutationObserver */\r\nvar isUsingMicroTask = false;\r\nvar callbacks = [];\r\nvar pending = false;\r\nfunction flushCallbacks() {\r\n    pending = false;\r\n    var copies = callbacks.slice(0);\r\n    callbacks.length = 0;\r\n    for (var i = 0; i < copies.length; i++) {\r\n        copies[i]();\r\n    }\r\n}\r\n// Here we have async deferring wrappers using microtasks.\r\n// In 2.5 we used (macro) tasks (in combination with microtasks).\r\n// However, it has subtle problems when state is changed right before repaint\r\n// (e.g. #6813, out-in transitions).\r\n// Also, using (macro) tasks in event handler would cause some weird behaviors\r\n// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).\r\n// So we now use microtasks everywhere, again.\r\n// A major drawback of this tradeoff is that there are some scenarios\r\n// where microtasks have too high a priority and fire in between supposedly\r\n// sequential events (e.g. #4521, #6690, which have workarounds)\r\n// or even between bubbling of the same event (#6566).\r\nvar timerFunc;\r\n// The nextTick behavior leverages the microtask queue, which can be accessed\r\n// via either native Promise.then or MutationObserver.\r\n// MutationObserver has wider support, however it is seriously bugged in\r\n// UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\r\n// completely stops working after triggering a few times... so, if native\r\n// Promise is available, we will use it:\r\n/* istanbul ignore next, $flow-disable-line */\r\nif (typeof Promise !== 'undefined' && isNative(Promise)) {\r\n    var p_1 = Promise.resolve();\r\n    timerFunc = function () {\r\n        p_1.then(flushCallbacks);\r\n        // In problematic UIWebViews, Promise.then doesn't completely break, but\r\n        // it can get stuck in a weird state where callbacks are pushed into the\r\n        // microtask queue but the queue isn't being flushed, until the browser\r\n        // needs to do some other work, e.g. handle a timer. Therefore we can\r\n        // \"force\" the microtask queue to be flushed by adding an empty timer.\r\n        if (isIOS)\r\n            setTimeout(noop);\r\n    };\r\n    isUsingMicroTask = true;\r\n}\r\nelse if (!isIE &&\r\n    typeof MutationObserver !== 'undefined' &&\r\n    (isNative(MutationObserver) ||\r\n        // PhantomJS and iOS 7.x\r\n        MutationObserver.toString() === '[object MutationObserverConstructor]')) {\r\n    // Use MutationObserver where native Promise is not available,\r\n    // e.g. PhantomJS, iOS7, Android 4.4\r\n    // (#6466 MutationObserver is unreliable in IE11)\r\n    var counter_1 = 1;\r\n    var observer = new MutationObserver(flushCallbacks);\r\n    var textNode_1 = document.createTextNode(String(counter_1));\r\n    observer.observe(textNode_1, {\r\n        characterData: true\r\n    });\r\n    timerFunc = function () {\r\n        counter_1 = (counter_1 + 1) % 2;\r\n        textNode_1.data = String(counter_1);\r\n    };\r\n    isUsingMicroTask = true;\r\n}\r\nelse if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {\r\n    // Fallback to setImmediate.\r\n    // Technically it leverages the (macro) task queue,\r\n    // but it is still a better choice than setTimeout.\r\n    timerFunc = function () {\r\n        setImmediate(flushCallbacks);\r\n    };\r\n}\r\nelse {\r\n    // Fallback to setTimeout.\r\n    timerFunc = function () {\r\n        setTimeout(flushCallbacks, 0);\r\n    };\r\n}\r\n/**\r\n * @internal\r\n */\r\nfunction nextTick(cb, ctx) {\r\n    var _resolve;\r\n    callbacks.push(function () {\r\n        if (cb) {\r\n            try {\r\n                cb.call(ctx);\r\n            }\r\n            catch (e) {\r\n                handleError(e, ctx, 'nextTick');\r\n            }\r\n        }\r\n        else if (_resolve) {\r\n            _resolve(ctx);\r\n        }\r\n    });\r\n    if (!pending) {\r\n        pending = true;\r\n        timerFunc();\r\n    }\r\n    // $flow-disable-line\r\n    if (!cb && typeof Promise !== 'undefined') {\r\n        return new Promise(function (resolve) {\r\n            _resolve = resolve;\r\n        });\r\n    }\r\n}\n\nfunction useCssModule(name) {\r\n    if (name === void 0) { name = '$style'; }\r\n    /* istanbul ignore else */\r\n    {\r\n        if (!currentInstance) {\r\n             true && warn$2(\"useCssModule must be called inside setup()\");\r\n            return emptyObject;\r\n        }\r\n        var mod = currentInstance[name];\r\n        if (!mod) {\r\n             true &&\r\n                warn$2(\"Current instance does not have CSS module named \\\"\".concat(name, \"\\\".\"));\r\n            return emptyObject;\r\n        }\r\n        return mod;\r\n    }\r\n}\n\n/**\r\n * Runtime helper for SFC's CSS variable injection feature.\r\n * @private\r\n */\r\nfunction useCssVars(getter) {\r\n    if (!inBrowser && !false)\r\n        return;\r\n    var instance = currentInstance;\r\n    if (!instance) {\r\n         true &&\r\n            warn$2(\"useCssVars is called without current active component instance.\");\r\n        return;\r\n    }\r\n    watchPostEffect(function () {\r\n        var el = instance.$el;\r\n        var vars = getter(instance, instance._setupProxy);\r\n        if (el && el.nodeType === 1) {\r\n            var style = el.style;\r\n            for (var key in vars) {\r\n                style.setProperty(\"--\".concat(key), vars[key]);\r\n            }\r\n        }\r\n    });\r\n}\n\n/**\r\n * v3-compatible async component API.\r\n * @internal the type is manually declared in <root>/types/v3-define-async-component.d.ts\r\n * because it relies on existing manual types\r\n */\r\nfunction defineAsyncComponent(source) {\r\n    if (isFunction(source)) {\r\n        source = { loader: source };\r\n    }\r\n    var loader = source.loader, loadingComponent = source.loadingComponent, errorComponent = source.errorComponent, _a = source.delay, delay = _a === void 0 ? 200 : _a, timeout = source.timeout, // undefined = never times out\r\n    _b = source.suspensible, // undefined = never times out\r\n    suspensible = _b === void 0 ? false : _b, // in Vue 3 default is true\r\n    userOnError = source.onError;\r\n    if ( true && suspensible) {\r\n        warn$2(\"The suspensiblbe option for async components is not supported in Vue2. It is ignored.\");\r\n    }\r\n    var pendingRequest = null;\r\n    var retries = 0;\r\n    var retry = function () {\r\n        retries++;\r\n        pendingRequest = null;\r\n        return load();\r\n    };\r\n    var load = function () {\r\n        var thisRequest;\r\n        return (pendingRequest ||\r\n            (thisRequest = pendingRequest =\r\n                loader()\r\n                    .catch(function (err) {\r\n                    err = err instanceof Error ? err : new Error(String(err));\r\n                    if (userOnError) {\r\n                        return new Promise(function (resolve, reject) {\r\n                            var userRetry = function () { return resolve(retry()); };\r\n                            var userFail = function () { return reject(err); };\r\n                            userOnError(err, userRetry, userFail, retries + 1);\r\n                        });\r\n                    }\r\n                    else {\r\n                        throw err;\r\n                    }\r\n                })\r\n                    .then(function (comp) {\r\n                    if (thisRequest !== pendingRequest && pendingRequest) {\r\n                        return pendingRequest;\r\n                    }\r\n                    if ( true && !comp) {\r\n                        warn$2(\"Async component loader resolved to undefined. \" +\r\n                            \"If you are using retry(), make sure to return its return value.\");\r\n                    }\r\n                    // interop module default\r\n                    if (comp &&\r\n                        (comp.__esModule || comp[Symbol.toStringTag] === 'Module')) {\r\n                        comp = comp.default;\r\n                    }\r\n                    if ( true && comp && !isObject(comp) && !isFunction(comp)) {\r\n                        throw new Error(\"Invalid async component load result: \".concat(comp));\r\n                    }\r\n                    return comp;\r\n                })));\r\n    };\r\n    return function () {\r\n        var component = load();\r\n        return {\r\n            component: component,\r\n            delay: delay,\r\n            timeout: timeout,\r\n            error: errorComponent,\r\n            loading: loadingComponent\r\n        };\r\n    };\r\n}\n\nfunction createLifeCycle(hookName) {\r\n    return function (fn, target) {\r\n        if (target === void 0) { target = currentInstance; }\r\n        if (!target) {\r\n             true &&\r\n                warn$2(\"\".concat(formatName(hookName), \" is called when there is no active component instance to be \") +\r\n                    \"associated with. \" +\r\n                    \"Lifecycle injection APIs can only be used during execution of setup().\");\r\n            return;\r\n        }\r\n        return injectHook(target, hookName, fn);\r\n    };\r\n}\r\nfunction formatName(name) {\r\n    if (name === 'beforeDestroy') {\r\n        name = 'beforeUnmount';\r\n    }\r\n    else if (name === 'destroyed') {\r\n        name = 'unmounted';\r\n    }\r\n    return \"on\".concat(name[0].toUpperCase() + name.slice(1));\r\n}\r\nfunction injectHook(instance, hookName, fn) {\r\n    var options = instance.$options;\r\n    options[hookName] = mergeLifecycleHook(options[hookName], fn);\r\n}\r\nvar onBeforeMount = createLifeCycle('beforeMount');\r\nvar onMounted = createLifeCycle('mounted');\r\nvar onBeforeUpdate = createLifeCycle('beforeUpdate');\r\nvar onUpdated = createLifeCycle('updated');\r\nvar onBeforeUnmount = createLifeCycle('beforeDestroy');\r\nvar onUnmounted = createLifeCycle('destroyed');\r\nvar onErrorCaptured = createLifeCycle('errorCaptured');\r\nvar onActivated = createLifeCycle('activated');\r\nvar onDeactivated = createLifeCycle('deactivated');\r\nvar onServerPrefetch = createLifeCycle('serverPrefetch');\r\nvar onRenderTracked = createLifeCycle('renderTracked');\r\nvar onRenderTriggered = createLifeCycle('renderTriggered');\n\n/**\r\n * Note: also update dist/vue.runtime.mjs when adding new exports to this file.\r\n */\r\nvar version = '2.7.8';\r\n/**\r\n * @internal type is manually declared in <root>/types/v3-define-component.d.ts\r\n */\r\nfunction defineComponent(options) {\r\n    return options;\r\n}\n\nvar seenObjects = new _Set();\r\n/**\r\n * Recursively traverse an object to evoke all converted\r\n * getters, so that every nested property inside the object\r\n * is collected as a \"deep\" dependency.\r\n */\r\nfunction traverse(val) {\r\n    _traverse(val, seenObjects);\r\n    seenObjects.clear();\r\n    return val;\r\n}\r\nfunction _traverse(val, seen) {\r\n    var i, keys;\r\n    var isA = isArray(val);\r\n    if ((!isA && !isObject(val)) ||\r\n        Object.isFrozen(val) ||\r\n        val instanceof VNode) {\r\n        return;\r\n    }\r\n    if (val.__ob__) {\r\n        var depId = val.__ob__.dep.id;\r\n        if (seen.has(depId)) {\r\n            return;\r\n        }\r\n        seen.add(depId);\r\n    }\r\n    if (isA) {\r\n        i = val.length;\r\n        while (i--)\r\n            _traverse(val[i], seen);\r\n    }\r\n    else if (isRef(val)) {\r\n        _traverse(val.value, seen);\r\n    }\r\n    else {\r\n        keys = Object.keys(val);\r\n        i = keys.length;\r\n        while (i--)\r\n            _traverse(val[keys[i]], seen);\r\n    }\r\n}\n\nvar uid$1 = 0;\r\n/**\r\n * A watcher parses an expression, collects dependencies,\r\n * and fires callback when the expression value changes.\r\n * This is used for both the $watch() api and directives.\r\n * @internal\r\n */\r\nvar Watcher = /** @class */ (function () {\r\n    function Watcher(vm, expOrFn, cb, options, isRenderWatcher) {\r\n        recordEffectScope(this, activeEffectScope || (vm ? vm._scope : undefined));\r\n        if ((this.vm = vm)) {\r\n            if (isRenderWatcher) {\r\n                vm._watcher = this;\r\n            }\r\n        }\r\n        // options\r\n        if (options) {\r\n            this.deep = !!options.deep;\r\n            this.user = !!options.user;\r\n            this.lazy = !!options.lazy;\r\n            this.sync = !!options.sync;\r\n            this.before = options.before;\r\n            if (true) {\r\n                this.onTrack = options.onTrack;\r\n                this.onTrigger = options.onTrigger;\r\n            }\r\n        }\r\n        else {\r\n            this.deep = this.user = this.lazy = this.sync = false;\r\n        }\r\n        this.cb = cb;\r\n        this.id = ++uid$1; // uid for batching\r\n        this.active = true;\r\n        this.post = false;\r\n        this.dirty = this.lazy; // for lazy watchers\r\n        this.deps = [];\r\n        this.newDeps = [];\r\n        this.depIds = new _Set();\r\n        this.newDepIds = new _Set();\r\n        this.expression =  true ? expOrFn.toString() : 0;\r\n        // parse expression for getter\r\n        if (isFunction(expOrFn)) {\r\n            this.getter = expOrFn;\r\n        }\r\n        else {\r\n            this.getter = parsePath(expOrFn);\r\n            if (!this.getter) {\r\n                this.getter = noop;\r\n                 true &&\r\n                    warn$2(\"Failed watching path: \\\"\".concat(expOrFn, \"\\\" \") +\r\n                        'Watcher only accepts simple dot-delimited paths. ' +\r\n                        'For full control, use a function instead.', vm);\r\n            }\r\n        }\r\n        this.value = this.lazy ? undefined : this.get();\r\n    }\r\n    /**\r\n     * Evaluate the getter, and re-collect dependencies.\r\n     */\r\n    Watcher.prototype.get = function () {\r\n        pushTarget(this);\r\n        var value;\r\n        var vm = this.vm;\r\n        try {\r\n            value = this.getter.call(vm, vm);\r\n        }\r\n        catch (e) {\r\n            if (this.user) {\r\n                handleError(e, vm, \"getter for watcher \\\"\".concat(this.expression, \"\\\"\"));\r\n            }\r\n            else {\r\n                throw e;\r\n            }\r\n        }\r\n        finally {\r\n            // \"touch\" every property so they are all tracked as\r\n            // dependencies for deep watching\r\n            if (this.deep) {\r\n                traverse(value);\r\n            }\r\n            popTarget();\r\n            this.cleanupDeps();\r\n        }\r\n        return value;\r\n    };\r\n    /**\r\n     * Add a dependency to this directive.\r\n     */\r\n    Watcher.prototype.addDep = function (dep) {\r\n        var id = dep.id;\r\n        if (!this.newDepIds.has(id)) {\r\n            this.newDepIds.add(id);\r\n            this.newDeps.push(dep);\r\n            if (!this.depIds.has(id)) {\r\n                dep.addSub(this);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Clean up for dependency collection.\r\n     */\r\n    Watcher.prototype.cleanupDeps = function () {\r\n        var i = this.deps.length;\r\n        while (i--) {\r\n            var dep = this.deps[i];\r\n            if (!this.newDepIds.has(dep.id)) {\r\n                dep.removeSub(this);\r\n            }\r\n        }\r\n        var tmp = this.depIds;\r\n        this.depIds = this.newDepIds;\r\n        this.newDepIds = tmp;\r\n        this.newDepIds.clear();\r\n        tmp = this.deps;\r\n        this.deps = this.newDeps;\r\n        this.newDeps = tmp;\r\n        this.newDeps.length = 0;\r\n    };\r\n    /**\r\n     * Subscriber interface.\r\n     * Will be called when a dependency changes.\r\n     */\r\n    Watcher.prototype.update = function () {\r\n        /* istanbul ignore else */\r\n        if (this.lazy) {\r\n            this.dirty = true;\r\n        }\r\n        else if (this.sync) {\r\n            this.run();\r\n        }\r\n        else {\r\n            queueWatcher(this);\r\n        }\r\n    };\r\n    /**\r\n     * Scheduler job interface.\r\n     * Will be called by the scheduler.\r\n     */\r\n    Watcher.prototype.run = function () {\r\n        if (this.active) {\r\n            var value = this.get();\r\n            if (value !== this.value ||\r\n                // Deep watchers and watchers on Object/Arrays should fire even\r\n                // when the value is the same, because the value may\r\n                // have mutated.\r\n                isObject(value) ||\r\n                this.deep) {\r\n                // set new value\r\n                var oldValue = this.value;\r\n                this.value = value;\r\n                if (this.user) {\r\n                    var info = \"callback for watcher \\\"\".concat(this.expression, \"\\\"\");\r\n                    invokeWithErrorHandling(this.cb, this.vm, [value, oldValue], this.vm, info);\r\n                }\r\n                else {\r\n                    this.cb.call(this.vm, value, oldValue);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Evaluate the value of the watcher.\r\n     * This only gets called for lazy watchers.\r\n     */\r\n    Watcher.prototype.evaluate = function () {\r\n        this.value = this.get();\r\n        this.dirty = false;\r\n    };\r\n    /**\r\n     * Depend on all deps collected by this watcher.\r\n     */\r\n    Watcher.prototype.depend = function () {\r\n        var i = this.deps.length;\r\n        while (i--) {\r\n            this.deps[i].depend();\r\n        }\r\n    };\r\n    /**\r\n     * Remove self from all dependencies' subscriber list.\r\n     */\r\n    Watcher.prototype.teardown = function () {\r\n        if (this.vm && !this.vm._isBeingDestroyed) {\r\n            remove$2(this.vm._scope.effects, this);\r\n        }\r\n        if (this.active) {\r\n            var i = this.deps.length;\r\n            while (i--) {\r\n                this.deps[i].removeSub(this);\r\n            }\r\n            this.active = false;\r\n            if (this.onStop) {\r\n                this.onStop();\r\n            }\r\n        }\r\n    };\r\n    return Watcher;\r\n}());\n\nvar sharedPropertyDefinition = {\r\n    enumerable: true,\r\n    configurable: true,\r\n    get: noop,\r\n    set: noop\r\n};\r\nfunction proxy(target, sourceKey, key) {\r\n    sharedPropertyDefinition.get = function proxyGetter() {\r\n        return this[sourceKey][key];\r\n    };\r\n    sharedPropertyDefinition.set = function proxySetter(val) {\r\n        this[sourceKey][key] = val;\r\n    };\r\n    Object.defineProperty(target, key, sharedPropertyDefinition);\r\n}\r\nfunction initState(vm) {\r\n    var opts = vm.$options;\r\n    if (opts.props)\r\n        initProps$1(vm, opts.props);\r\n    // Composition API\r\n    initSetup(vm);\r\n    if (opts.methods)\r\n        initMethods(vm, opts.methods);\r\n    if (opts.data) {\r\n        initData(vm);\r\n    }\r\n    else {\r\n        var ob = observe((vm._data = {}));\r\n        ob && ob.vmCount++;\r\n    }\r\n    if (opts.computed)\r\n        initComputed$1(vm, opts.computed);\r\n    if (opts.watch && opts.watch !== nativeWatch) {\r\n        initWatch(vm, opts.watch);\r\n    }\r\n}\r\nfunction initProps$1(vm, propsOptions) {\r\n    var propsData = vm.$options.propsData || {};\r\n    var props = (vm._props = shallowReactive({}));\r\n    // cache prop keys so that future props updates can iterate using Array\r\n    // instead of dynamic object key enumeration.\r\n    var keys = (vm.$options._propKeys = []);\r\n    var isRoot = !vm.$parent;\r\n    // root instance props should be converted\r\n    if (!isRoot) {\r\n        toggleObserving(false);\r\n    }\r\n    var _loop_1 = function (key) {\r\n        keys.push(key);\r\n        var value = validateProp(key, propsOptions, propsData, vm);\r\n        /* istanbul ignore else */\r\n        if (true) {\r\n            var hyphenatedKey = hyphenate(key);\r\n            if (isReservedAttribute(hyphenatedKey) ||\r\n                config.isReservedAttr(hyphenatedKey)) {\r\n                warn$2(\"\\\"\".concat(hyphenatedKey, \"\\\" is a reserved attribute and cannot be used as component prop.\"), vm);\r\n            }\r\n            defineReactive(props, key, value, function () {\r\n                if (!isRoot && !isUpdatingChildComponent) {\r\n                    warn$2(\"Avoid mutating a prop directly since the value will be \" +\r\n                        \"overwritten whenever the parent component re-renders. \" +\r\n                        \"Instead, use a data or computed property based on the prop's \" +\r\n                        \"value. Prop being mutated: \\\"\".concat(key, \"\\\"\"), vm);\r\n                }\r\n            });\r\n        }\r\n        else {}\r\n        // static props are already proxied on the component's prototype\r\n        // during Vue.extend(). We only need to proxy props defined at\r\n        // instantiation here.\r\n        if (!(key in vm)) {\r\n            proxy(vm, \"_props\", key);\r\n        }\r\n    };\r\n    for (var key in propsOptions) {\r\n        _loop_1(key);\r\n    }\r\n    toggleObserving(true);\r\n}\r\nfunction initData(vm) {\r\n    var data = vm.$options.data;\r\n    data = vm._data = isFunction(data) ? getData(data, vm) : data || {};\r\n    if (!isPlainObject(data)) {\r\n        data = {};\r\n         true &&\r\n            warn$2('data functions should return an object:\\n' +\r\n                'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);\r\n    }\r\n    // proxy data on instance\r\n    var keys = Object.keys(data);\r\n    var props = vm.$options.props;\r\n    var methods = vm.$options.methods;\r\n    var i = keys.length;\r\n    while (i--) {\r\n        var key = keys[i];\r\n        if (true) {\r\n            if (methods && hasOwn(methods, key)) {\r\n                warn$2(\"Method \\\"\".concat(key, \"\\\" has already been defined as a data property.\"), vm);\r\n            }\r\n        }\r\n        if (props && hasOwn(props, key)) {\r\n             true &&\r\n                warn$2(\"The data property \\\"\".concat(key, \"\\\" is already declared as a prop. \") +\r\n                    \"Use prop default value instead.\", vm);\r\n        }\r\n        else if (!isReserved(key)) {\r\n            proxy(vm, \"_data\", key);\r\n        }\r\n    }\r\n    // observe data\r\n    var ob = observe(data);\r\n    ob && ob.vmCount++;\r\n}\r\nfunction getData(data, vm) {\r\n    // #7573 disable dep collection when invoking data getters\r\n    pushTarget();\r\n    try {\r\n        return data.call(vm, vm);\r\n    }\r\n    catch (e) {\r\n        handleError(e, vm, \"data()\");\r\n        return {};\r\n    }\r\n    finally {\r\n        popTarget();\r\n    }\r\n}\r\nvar computedWatcherOptions = { lazy: true };\r\nfunction initComputed$1(vm, computed) {\r\n    // $flow-disable-line\r\n    var watchers = (vm._computedWatchers = Object.create(null));\r\n    // computed properties are just getters during SSR\r\n    var isSSR = isServerRendering();\r\n    for (var key in computed) {\r\n        var userDef = computed[key];\r\n        var getter = isFunction(userDef) ? userDef : userDef.get;\r\n        if ( true && getter == null) {\r\n            warn$2(\"Getter is missing for computed property \\\"\".concat(key, \"\\\".\"), vm);\r\n        }\r\n        if (!isSSR) {\r\n            // create internal watcher for the computed property.\r\n            watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);\r\n        }\r\n        // component-defined computed properties are already defined on the\r\n        // component prototype. We only need to define computed properties defined\r\n        // at instantiation here.\r\n        if (!(key in vm)) {\r\n            defineComputed(vm, key, userDef);\r\n        }\r\n        else if (true) {\r\n            if (key in vm.$data) {\r\n                warn$2(\"The computed property \\\"\".concat(key, \"\\\" is already defined in data.\"), vm);\r\n            }\r\n            else if (vm.$options.props && key in vm.$options.props) {\r\n                warn$2(\"The computed property \\\"\".concat(key, \"\\\" is already defined as a prop.\"), vm);\r\n            }\r\n            else if (vm.$options.methods && key in vm.$options.methods) {\r\n                warn$2(\"The computed property \\\"\".concat(key, \"\\\" is already defined as a method.\"), vm);\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction defineComputed(target, key, userDef) {\r\n    var shouldCache = !isServerRendering();\r\n    if (isFunction(userDef)) {\r\n        sharedPropertyDefinition.get = shouldCache\r\n            ? createComputedGetter(key)\r\n            : createGetterInvoker(userDef);\r\n        sharedPropertyDefinition.set = noop;\r\n    }\r\n    else {\r\n        sharedPropertyDefinition.get = userDef.get\r\n            ? shouldCache && userDef.cache !== false\r\n                ? createComputedGetter(key)\r\n                : createGetterInvoker(userDef.get)\r\n            : noop;\r\n        sharedPropertyDefinition.set = userDef.set || noop;\r\n    }\r\n    if ( true && sharedPropertyDefinition.set === noop) {\r\n        sharedPropertyDefinition.set = function () {\r\n            warn$2(\"Computed property \\\"\".concat(key, \"\\\" was assigned to but it has no setter.\"), this);\r\n        };\r\n    }\r\n    Object.defineProperty(target, key, sharedPropertyDefinition);\r\n}\r\nfunction createComputedGetter(key) {\r\n    return function computedGetter() {\r\n        var watcher = this._computedWatchers && this._computedWatchers[key];\r\n        if (watcher) {\r\n            if (watcher.dirty) {\r\n                watcher.evaluate();\r\n            }\r\n            if (Dep.target) {\r\n                if ( true && Dep.target.onTrack) {\r\n                    Dep.target.onTrack({\r\n                        effect: Dep.target,\r\n                        target: this,\r\n                        type: \"get\" /* TrackOpTypes.GET */,\r\n                        key: key\r\n                    });\r\n                }\r\n                watcher.depend();\r\n            }\r\n            return watcher.value;\r\n        }\r\n    };\r\n}\r\nfunction createGetterInvoker(fn) {\r\n    return function computedGetter() {\r\n        return fn.call(this, this);\r\n    };\r\n}\r\nfunction initMethods(vm, methods) {\r\n    var props = vm.$options.props;\r\n    for (var key in methods) {\r\n        if (true) {\r\n            if (typeof methods[key] !== 'function') {\r\n                warn$2(\"Method \\\"\".concat(key, \"\\\" has type \\\"\").concat(typeof methods[key], \"\\\" in the component definition. \") +\r\n                    \"Did you reference the function correctly?\", vm);\r\n            }\r\n            if (props && hasOwn(props, key)) {\r\n                warn$2(\"Method \\\"\".concat(key, \"\\\" has already been defined as a prop.\"), vm);\r\n            }\r\n            if (key in vm && isReserved(key)) {\r\n                warn$2(\"Method \\\"\".concat(key, \"\\\" conflicts with an existing Vue instance method. \") +\r\n                    \"Avoid defining component methods that start with _ or $.\");\r\n            }\r\n        }\r\n        vm[key] = typeof methods[key] !== 'function' ? noop : bind$1(methods[key], vm);\r\n    }\r\n}\r\nfunction initWatch(vm, watch) {\r\n    for (var key in watch) {\r\n        var handler = watch[key];\r\n        if (isArray(handler)) {\r\n            for (var i = 0; i < handler.length; i++) {\r\n                createWatcher(vm, key, handler[i]);\r\n            }\r\n        }\r\n        else {\r\n            createWatcher(vm, key, handler);\r\n        }\r\n    }\r\n}\r\nfunction createWatcher(vm, expOrFn, handler, options) {\r\n    if (isPlainObject(handler)) {\r\n        options = handler;\r\n        handler = handler.handler;\r\n    }\r\n    if (typeof handler === 'string') {\r\n        handler = vm[handler];\r\n    }\r\n    return vm.$watch(expOrFn, handler, options);\r\n}\r\nfunction stateMixin(Vue) {\r\n    // flow somehow has problems with directly declared definition object\r\n    // when using Object.defineProperty, so we have to procedurally build up\r\n    // the object here.\r\n    var dataDef = {};\r\n    dataDef.get = function () {\r\n        return this._data;\r\n    };\r\n    var propsDef = {};\r\n    propsDef.get = function () {\r\n        return this._props;\r\n    };\r\n    if (true) {\r\n        dataDef.set = function () {\r\n            warn$2('Avoid replacing instance root $data. ' +\r\n                'Use nested data properties instead.', this);\r\n        };\r\n        propsDef.set = function () {\r\n            warn$2(\"$props is readonly.\", this);\r\n        };\r\n    }\r\n    Object.defineProperty(Vue.prototype, '$data', dataDef);\r\n    Object.defineProperty(Vue.prototype, '$props', propsDef);\r\n    Vue.prototype.$set = set;\r\n    Vue.prototype.$delete = del;\r\n    Vue.prototype.$watch = function (expOrFn, cb, options) {\r\n        var vm = this;\r\n        if (isPlainObject(cb)) {\r\n            return createWatcher(vm, expOrFn, cb, options);\r\n        }\r\n        options = options || {};\r\n        options.user = true;\r\n        var watcher = new Watcher(vm, expOrFn, cb, options);\r\n        if (options.immediate) {\r\n            var info = \"callback for immediate watcher \\\"\".concat(watcher.expression, \"\\\"\");\r\n            pushTarget();\r\n            invokeWithErrorHandling(cb, vm, [watcher.value], vm, info);\r\n            popTarget();\r\n        }\r\n        return function unwatchFn() {\r\n            watcher.teardown();\r\n        };\r\n    };\r\n}\n\nfunction initProvide(vm) {\r\n    var provideOption = vm.$options.provide;\r\n    if (provideOption) {\r\n        var provided = isFunction(provideOption)\r\n            ? provideOption.call(vm)\r\n            : provideOption;\r\n        if (!isObject(provided)) {\r\n            return;\r\n        }\r\n        var source = resolveProvided(vm);\r\n        // IE9 doesn't support Object.getOwnPropertyDescriptors so we have to\r\n        // iterate the keys ourselves.\r\n        var keys = hasSymbol ? Reflect.ownKeys(provided) : Object.keys(provided);\r\n        for (var i = 0; i < keys.length; i++) {\r\n            var key = keys[i];\r\n            Object.defineProperty(source, key, Object.getOwnPropertyDescriptor(provided, key));\r\n        }\r\n    }\r\n}\r\nfunction initInjections(vm) {\r\n    var result = resolveInject(vm.$options.inject, vm);\r\n    if (result) {\r\n        toggleObserving(false);\r\n        Object.keys(result).forEach(function (key) {\r\n            /* istanbul ignore else */\r\n            if (true) {\r\n                defineReactive(vm, key, result[key], function () {\r\n                    warn$2(\"Avoid mutating an injected value directly since the changes will be \" +\r\n                        \"overwritten whenever the provided component re-renders. \" +\r\n                        \"injection being mutated: \\\"\".concat(key, \"\\\"\"), vm);\r\n                });\r\n            }\r\n            else {}\r\n        });\r\n        toggleObserving(true);\r\n    }\r\n}\r\nfunction resolveInject(inject, vm) {\r\n    if (inject) {\r\n        // inject is :any because flow is not smart enough to figure out cached\r\n        var result = Object.create(null);\r\n        var keys = hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);\r\n        for (var i = 0; i < keys.length; i++) {\r\n            var key = keys[i];\r\n            // #6574 in case the inject object is observed...\r\n            if (key === '__ob__')\r\n                continue;\r\n            var provideKey = inject[key].from;\r\n            if (provideKey in vm._provided) {\r\n                result[key] = vm._provided[provideKey];\r\n            }\r\n            else if ('default' in inject[key]) {\r\n                var provideDefault = inject[key].default;\r\n                result[key] = isFunction(provideDefault)\r\n                    ? provideDefault.call(vm)\r\n                    : provideDefault;\r\n            }\r\n            else if (true) {\r\n                warn$2(\"Injection \\\"\".concat(key, \"\\\" not found\"), vm);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\n\nvar uid = 0;\r\nfunction initMixin$1(Vue) {\r\n    Vue.prototype._init = function (options) {\r\n        var vm = this;\r\n        // a uid\r\n        vm._uid = uid++;\r\n        var startTag, endTag;\r\n        /* istanbul ignore if */\r\n        if ( true && config.performance && mark) {\r\n            startTag = \"vue-perf-start:\".concat(vm._uid);\r\n            endTag = \"vue-perf-end:\".concat(vm._uid);\r\n            mark(startTag);\r\n        }\r\n        // a flag to mark this as a Vue instance without having to do instanceof\r\n        // check\r\n        vm._isVue = true;\r\n        // avoid instances from being observed\r\n        vm.__v_skip = true;\r\n        // effect scope\r\n        vm._scope = new EffectScope(true /* detached */);\r\n        // merge options\r\n        if (options && options._isComponent) {\r\n            // optimize internal component instantiation\r\n            // since dynamic options merging is pretty slow, and none of the\r\n            // internal component options needs special treatment.\r\n            initInternalComponent(vm, options);\r\n        }\r\n        else {\r\n            vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);\r\n        }\r\n        /* istanbul ignore else */\r\n        if (true) {\r\n            initProxy(vm);\r\n        }\r\n        else {}\r\n        // expose real self\r\n        vm._self = vm;\r\n        initLifecycle(vm);\r\n        initEvents(vm);\r\n        initRender(vm);\r\n        callHook$1(vm, 'beforeCreate', undefined, false /* setContext */);\r\n        initInjections(vm); // resolve injections before data/props\r\n        initState(vm);\r\n        initProvide(vm); // resolve provide after data/props\r\n        callHook$1(vm, 'created');\r\n        /* istanbul ignore if */\r\n        if ( true && config.performance && mark) {\r\n            vm._name = formatComponentName(vm, false);\r\n            mark(endTag);\r\n            measure(\"vue \".concat(vm._name, \" init\"), startTag, endTag);\r\n        }\r\n        if (vm.$options.el) {\r\n            vm.$mount(vm.$options.el);\r\n        }\r\n    };\r\n}\r\nfunction initInternalComponent(vm, options) {\r\n    var opts = (vm.$options = Object.create(vm.constructor.options));\r\n    // doing this because it's faster than dynamic enumeration.\r\n    var parentVnode = options._parentVnode;\r\n    opts.parent = options.parent;\r\n    opts._parentVnode = parentVnode;\r\n    var vnodeComponentOptions = parentVnode.componentOptions;\r\n    opts.propsData = vnodeComponentOptions.propsData;\r\n    opts._parentListeners = vnodeComponentOptions.listeners;\r\n    opts._renderChildren = vnodeComponentOptions.children;\r\n    opts._componentTag = vnodeComponentOptions.tag;\r\n    if (options.render) {\r\n        opts.render = options.render;\r\n        opts.staticRenderFns = options.staticRenderFns;\r\n    }\r\n}\r\nfunction resolveConstructorOptions(Ctor) {\r\n    var options = Ctor.options;\r\n    if (Ctor.super) {\r\n        var superOptions = resolveConstructorOptions(Ctor.super);\r\n        var cachedSuperOptions = Ctor.superOptions;\r\n        if (superOptions !== cachedSuperOptions) {\r\n            // super option changed,\r\n            // need to resolve new options.\r\n            Ctor.superOptions = superOptions;\r\n            // check if there are any late-modified/attached options (#4976)\r\n            var modifiedOptions = resolveModifiedOptions(Ctor);\r\n            // update base extend options\r\n            if (modifiedOptions) {\r\n                extend(Ctor.extendOptions, modifiedOptions);\r\n            }\r\n            options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\r\n            if (options.name) {\r\n                options.components[options.name] = Ctor;\r\n            }\r\n        }\r\n    }\r\n    return options;\r\n}\r\nfunction resolveModifiedOptions(Ctor) {\r\n    var modified;\r\n    var latest = Ctor.options;\r\n    var sealed = Ctor.sealedOptions;\r\n    for (var key in latest) {\r\n        if (latest[key] !== sealed[key]) {\r\n            if (!modified)\r\n                modified = {};\r\n            modified[key] = latest[key];\r\n        }\r\n    }\r\n    return modified;\r\n}\n\nfunction FunctionalRenderContext(data, props, children, parent, Ctor) {\r\n    var _this = this;\r\n    var options = Ctor.options;\r\n    // ensure the createElement function in functional components\r\n    // gets a unique context - this is necessary for correct named slot check\r\n    var contextVm;\r\n    if (hasOwn(parent, '_uid')) {\r\n        contextVm = Object.create(parent);\r\n        contextVm._original = parent;\r\n    }\r\n    else {\r\n        // the context vm passed in is a functional context as well.\r\n        // in this case we want to make sure we are able to get a hold to the\r\n        // real context instance.\r\n        contextVm = parent;\r\n        // @ts-ignore\r\n        parent = parent._original;\r\n    }\r\n    var isCompiled = isTrue(options._compiled);\r\n    var needNormalization = !isCompiled;\r\n    this.data = data;\r\n    this.props = props;\r\n    this.children = children;\r\n    this.parent = parent;\r\n    this.listeners = data.on || emptyObject;\r\n    this.injections = resolveInject(options.inject, parent);\r\n    this.slots = function () {\r\n        if (!_this.$slots) {\r\n            normalizeScopedSlots(parent, data.scopedSlots, (_this.$slots = resolveSlots(children, parent)));\r\n        }\r\n        return _this.$slots;\r\n    };\r\n    Object.defineProperty(this, 'scopedSlots', {\r\n        enumerable: true,\r\n        get: function () {\r\n            return normalizeScopedSlots(parent, data.scopedSlots, this.slots());\r\n        }\r\n    });\r\n    // support for compiled functional template\r\n    if (isCompiled) {\r\n        // exposing $options for renderStatic()\r\n        this.$options = options;\r\n        // pre-resolve slots for renderSlot()\r\n        this.$slots = this.slots();\r\n        this.$scopedSlots = normalizeScopedSlots(parent, data.scopedSlots, this.$slots);\r\n    }\r\n    if (options._scopeId) {\r\n        this._c = function (a, b, c, d) {\r\n            var vnode = createElement$1(contextVm, a, b, c, d, needNormalization);\r\n            if (vnode && !isArray(vnode)) {\r\n                vnode.fnScopeId = options._scopeId;\r\n                vnode.fnContext = parent;\r\n            }\r\n            return vnode;\r\n        };\r\n    }\r\n    else {\r\n        this._c = function (a, b, c, d) {\r\n            return createElement$1(contextVm, a, b, c, d, needNormalization);\r\n        };\r\n    }\r\n}\r\ninstallRenderHelpers(FunctionalRenderContext.prototype);\r\nfunction createFunctionalComponent(Ctor, propsData, data, contextVm, children) {\r\n    var options = Ctor.options;\r\n    var props = {};\r\n    var propOptions = options.props;\r\n    if (isDef(propOptions)) {\r\n        for (var key in propOptions) {\r\n            props[key] = validateProp(key, propOptions, propsData || emptyObject);\r\n        }\r\n    }\r\n    else {\r\n        if (isDef(data.attrs))\r\n            mergeProps(props, data.attrs);\r\n        if (isDef(data.props))\r\n            mergeProps(props, data.props);\r\n    }\r\n    var renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);\r\n    var vnode = options.render.call(null, renderContext._c, renderContext);\r\n    if (vnode instanceof VNode) {\r\n        return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext);\r\n    }\r\n    else if (isArray(vnode)) {\r\n        var vnodes = normalizeChildren(vnode) || [];\r\n        var res = new Array(vnodes.length);\r\n        for (var i = 0; i < vnodes.length; i++) {\r\n            res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);\r\n        }\r\n        return res;\r\n    }\r\n}\r\nfunction cloneAndMarkFunctionalResult(vnode, data, contextVm, options, renderContext) {\r\n    // #7817 clone node before setting fnContext, otherwise if the node is reused\r\n    // (e.g. it was from a cached normal slot) the fnContext causes named slots\r\n    // that should not be matched to match.\r\n    var clone = cloneVNode(vnode);\r\n    clone.fnContext = contextVm;\r\n    clone.fnOptions = options;\r\n    if (true) {\r\n        (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext =\r\n            renderContext;\r\n    }\r\n    if (data.slot) {\r\n        (clone.data || (clone.data = {})).slot = data.slot;\r\n    }\r\n    return clone;\r\n}\r\nfunction mergeProps(to, from) {\r\n    for (var key in from) {\r\n        to[camelize(key)] = from[key];\r\n    }\r\n}\n\nfunction getComponentName(options) {\r\n    return options.name || options.__name || options._componentTag;\r\n}\r\n// inline hooks to be invoked on component VNodes during patch\r\nvar componentVNodeHooks = {\r\n    init: function (vnode, hydrating) {\r\n        if (vnode.componentInstance &&\r\n            !vnode.componentInstance._isDestroyed &&\r\n            vnode.data.keepAlive) {\r\n            // kept-alive components, treat as a patch\r\n            var mountedNode = vnode; // work around flow\r\n            componentVNodeHooks.prepatch(mountedNode, mountedNode);\r\n        }\r\n        else {\r\n            var child = (vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance));\r\n            child.$mount(hydrating ? vnode.elm : undefined, hydrating);\r\n        }\r\n    },\r\n    prepatch: function (oldVnode, vnode) {\r\n        var options = vnode.componentOptions;\r\n        var child = (vnode.componentInstance = oldVnode.componentInstance);\r\n        updateChildComponent(child, options.propsData, // updated props\r\n        options.listeners, // updated listeners\r\n        vnode, // new parent vnode\r\n        options.children // new children\r\n        );\r\n    },\r\n    insert: function (vnode) {\r\n        var context = vnode.context, componentInstance = vnode.componentInstance;\r\n        if (!componentInstance._isMounted) {\r\n            componentInstance._isMounted = true;\r\n            callHook$1(componentInstance, 'mounted');\r\n        }\r\n        if (vnode.data.keepAlive) {\r\n            if (context._isMounted) {\r\n                // vue-router#1212\r\n                // During updates, a kept-alive component's child components may\r\n                // change, so directly walking the tree here may call activated hooks\r\n                // on incorrect children. Instead we push them into a queue which will\r\n                // be processed after the whole patch process ended.\r\n                queueActivatedComponent(componentInstance);\r\n            }\r\n            else {\r\n                activateChildComponent(componentInstance, true /* direct */);\r\n            }\r\n        }\r\n    },\r\n    destroy: function (vnode) {\r\n        var componentInstance = vnode.componentInstance;\r\n        if (!componentInstance._isDestroyed) {\r\n            if (!vnode.data.keepAlive) {\r\n                componentInstance.$destroy();\r\n            }\r\n            else {\r\n                deactivateChildComponent(componentInstance, true /* direct */);\r\n            }\r\n        }\r\n    }\r\n};\r\nvar hooksToMerge = Object.keys(componentVNodeHooks);\r\nfunction createComponent(Ctor, data, context, children, tag) {\r\n    if (isUndef(Ctor)) {\r\n        return;\r\n    }\r\n    var baseCtor = context.$options._base;\r\n    // plain options object: turn it into a constructor\r\n    if (isObject(Ctor)) {\r\n        Ctor = baseCtor.extend(Ctor);\r\n    }\r\n    // if at this stage it's not a constructor or an async component factory,\r\n    // reject.\r\n    if (typeof Ctor !== 'function') {\r\n        if (true) {\r\n            warn$2(\"Invalid Component definition: \".concat(String(Ctor)), context);\r\n        }\r\n        return;\r\n    }\r\n    // async component\r\n    var asyncFactory;\r\n    // @ts-expect-error\r\n    if (isUndef(Ctor.cid)) {\r\n        asyncFactory = Ctor;\r\n        Ctor = resolveAsyncComponent(asyncFactory, baseCtor);\r\n        if (Ctor === undefined) {\r\n            // return a placeholder node for async component, which is rendered\r\n            // as a comment node but preserves all the raw information for the node.\r\n            // the information will be used for async server-rendering and hydration.\r\n            return createAsyncPlaceholder(asyncFactory, data, context, children, tag);\r\n        }\r\n    }\r\n    data = data || {};\r\n    // resolve constructor options in case global mixins are applied after\r\n    // component constructor creation\r\n    resolveConstructorOptions(Ctor);\r\n    // transform component v-model data into props & events\r\n    if (isDef(data.model)) {\r\n        // @ts-expect-error\r\n        transformModel(Ctor.options, data);\r\n    }\r\n    // extract props\r\n    // @ts-expect-error\r\n    var propsData = extractPropsFromVNodeData(data, Ctor, tag);\r\n    // functional component\r\n    // @ts-expect-error\r\n    if (isTrue(Ctor.options.functional)) {\r\n        return createFunctionalComponent(Ctor, propsData, data, context, children);\r\n    }\r\n    // extract listeners, since these needs to be treated as\r\n    // child component listeners instead of DOM listeners\r\n    var listeners = data.on;\r\n    // replace with listeners with .native modifier\r\n    // so it gets processed during parent component patch.\r\n    data.on = data.nativeOn;\r\n    // @ts-expect-error\r\n    if (isTrue(Ctor.options.abstract)) {\r\n        // abstract components do not keep anything\r\n        // other than props & listeners & slot\r\n        // work around flow\r\n        var slot = data.slot;\r\n        data = {};\r\n        if (slot) {\r\n            data.slot = slot;\r\n        }\r\n    }\r\n    // install component management hooks onto the placeholder node\r\n    installComponentHooks(data);\r\n    // return a placeholder vnode\r\n    // @ts-expect-error\r\n    var name = getComponentName(Ctor.options) || tag;\r\n    var vnode = new VNode(\r\n    // @ts-expect-error\r\n    \"vue-component-\".concat(Ctor.cid).concat(name ? \"-\".concat(name) : ''), data, undefined, undefined, undefined, context, \r\n    // @ts-expect-error\r\n    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }, asyncFactory);\r\n    return vnode;\r\n}\r\nfunction createComponentInstanceForVnode(\r\n// we know it's MountedComponentVNode but flow doesn't\r\nvnode, \r\n// activeInstance in lifecycle state\r\nparent) {\r\n    var options = {\r\n        _isComponent: true,\r\n        _parentVnode: vnode,\r\n        parent: parent\r\n    };\r\n    // check inline-template render functions\r\n    var inlineTemplate = vnode.data.inlineTemplate;\r\n    if (isDef(inlineTemplate)) {\r\n        options.render = inlineTemplate.render;\r\n        options.staticRenderFns = inlineTemplate.staticRenderFns;\r\n    }\r\n    return new vnode.componentOptions.Ctor(options);\r\n}\r\nfunction installComponentHooks(data) {\r\n    var hooks = data.hook || (data.hook = {});\r\n    for (var i = 0; i < hooksToMerge.length; i++) {\r\n        var key = hooksToMerge[i];\r\n        var existing = hooks[key];\r\n        var toMerge = componentVNodeHooks[key];\r\n        // @ts-expect-error\r\n        if (existing !== toMerge && !(existing && existing._merged)) {\r\n            hooks[key] = existing ? mergeHook(toMerge, existing) : toMerge;\r\n        }\r\n    }\r\n}\r\nfunction mergeHook(f1, f2) {\r\n    var merged = function (a, b) {\r\n        // flow complains about extra args which is why we use any\r\n        f1(a, b);\r\n        f2(a, b);\r\n    };\r\n    merged._merged = true;\r\n    return merged;\r\n}\r\n// transform component v-model info (value and callback) into\r\n// prop and event handler respectively.\r\nfunction transformModel(options, data) {\r\n    var prop = (options.model && options.model.prop) || 'value';\r\n    var event = (options.model && options.model.event) || 'input';\r\n    (data.attrs || (data.attrs = {}))[prop] = data.model.value;\r\n    var on = data.on || (data.on = {});\r\n    var existing = on[event];\r\n    var callback = data.model.callback;\r\n    if (isDef(existing)) {\r\n        if (isArray(existing)\r\n            ? existing.indexOf(callback) === -1\r\n            : existing !== callback) {\r\n            on[event] = [callback].concat(existing);\r\n        }\r\n    }\r\n    else {\r\n        on[event] = callback;\r\n    }\r\n}\n\nvar warn$2 = noop;\r\nvar tip = noop;\r\nvar generateComponentTrace; // work around flow check\r\nvar formatComponentName;\r\nif (true) {\r\n    var hasConsole_1 = typeof console !== 'undefined';\r\n    var classifyRE_1 = /(?:^|[-_])(\\w)/g;\r\n    var classify_1 = function (str) {\r\n        return str.replace(classifyRE_1, function (c) { return c.toUpperCase(); }).replace(/[-_]/g, '');\r\n    };\r\n    warn$2 = function (msg, vm) {\r\n        if (vm === void 0) { vm = currentInstance; }\r\n        var trace = vm ? generateComponentTrace(vm) : '';\r\n        if (config.warnHandler) {\r\n            config.warnHandler.call(null, msg, vm, trace);\r\n        }\r\n        else if (hasConsole_1 && !config.silent) {\r\n            console.error(\"[Vue warn]: \".concat(msg).concat(trace));\r\n        }\r\n    };\r\n    tip = function (msg, vm) {\r\n        if (hasConsole_1 && !config.silent) {\r\n            console.warn(\"[Vue tip]: \".concat(msg) + (vm ? generateComponentTrace(vm) : ''));\r\n        }\r\n    };\r\n    formatComponentName = function (vm, includeFile) {\r\n        if (vm.$root === vm) {\r\n            return '<Root>';\r\n        }\r\n        var options = isFunction(vm) && vm.cid != null\r\n            ? vm.options\r\n            : vm._isVue\r\n                ? vm.$options || vm.constructor.options\r\n                : vm;\r\n        var name = getComponentName(options);\r\n        var file = options.__file;\r\n        if (!name && file) {\r\n            var match = file.match(/([^/\\\\]+)\\.vue$/);\r\n            name = match && match[1];\r\n        }\r\n        return ((name ? \"<\".concat(classify_1(name), \">\") : \"<Anonymous>\") +\r\n            (file && includeFile !== false ? \" at \".concat(file) : ''));\r\n    };\r\n    var repeat_1 = function (str, n) {\r\n        var res = '';\r\n        while (n) {\r\n            if (n % 2 === 1)\r\n                res += str;\r\n            if (n > 1)\r\n                str += str;\r\n            n >>= 1;\r\n        }\r\n        return res;\r\n    };\r\n    generateComponentTrace = function (vm) {\r\n        if (vm._isVue && vm.$parent) {\r\n            var tree = [];\r\n            var currentRecursiveSequence = 0;\r\n            while (vm) {\r\n                if (tree.length > 0) {\r\n                    var last = tree[tree.length - 1];\r\n                    if (last.constructor === vm.constructor) {\r\n                        currentRecursiveSequence++;\r\n                        vm = vm.$parent;\r\n                        continue;\r\n                    }\r\n                    else if (currentRecursiveSequence > 0) {\r\n                        tree[tree.length - 1] = [last, currentRecursiveSequence];\r\n                        currentRecursiveSequence = 0;\r\n                    }\r\n                }\r\n                tree.push(vm);\r\n                vm = vm.$parent;\r\n            }\r\n            return ('\\n\\nfound in\\n\\n' +\r\n                tree\r\n                    .map(function (vm, i) {\r\n                    return \"\".concat(i === 0 ? '---> ' : repeat_1(' ', 5 + i * 2)).concat(isArray(vm)\r\n                        ? \"\".concat(formatComponentName(vm[0]), \"... (\").concat(vm[1], \" recursive calls)\")\r\n                        : formatComponentName(vm));\r\n                })\r\n                    .join('\\n'));\r\n        }\r\n        else {\r\n            return \"\\n\\n(found in \".concat(formatComponentName(vm), \")\");\r\n        }\r\n    };\r\n}\n\n/**\r\n * Option overwriting strategies are functions that handle\r\n * how to merge a parent option value and a child option\r\n * value into the final value.\r\n */\r\nvar strats = config.optionMergeStrategies;\r\n/**\r\n * Options with restrictions\r\n */\r\nif (true) {\r\n    strats.el = strats.propsData = function (parent, child, vm, key) {\r\n        if (!vm) {\r\n            warn$2(\"option \\\"\".concat(key, \"\\\" can only be used during instance \") +\r\n                'creation with the `new` keyword.');\r\n        }\r\n        return defaultStrat(parent, child);\r\n    };\r\n}\r\n/**\r\n * Helper that recursively merges two data objects together.\r\n */\r\nfunction mergeData(to, from) {\r\n    if (!from)\r\n        return to;\r\n    var key, toVal, fromVal;\r\n    var keys = hasSymbol\r\n        ? Reflect.ownKeys(from)\r\n        : Object.keys(from);\r\n    for (var i = 0; i < keys.length; i++) {\r\n        key = keys[i];\r\n        // in case the object is already observed...\r\n        if (key === '__ob__')\r\n            continue;\r\n        toVal = to[key];\r\n        fromVal = from[key];\r\n        if (!hasOwn(to, key)) {\r\n            set(to, key, fromVal);\r\n        }\r\n        else if (toVal !== fromVal &&\r\n            isPlainObject(toVal) &&\r\n            isPlainObject(fromVal)) {\r\n            mergeData(toVal, fromVal);\r\n        }\r\n    }\r\n    return to;\r\n}\r\n/**\r\n * Data\r\n */\r\nfunction mergeDataOrFn(parentVal, childVal, vm) {\r\n    if (!vm) {\r\n        // in a Vue.extend merge, both should be functions\r\n        if (!childVal) {\r\n            return parentVal;\r\n        }\r\n        if (!parentVal) {\r\n            return childVal;\r\n        }\r\n        // when parentVal & childVal are both present,\r\n        // we need to return a function that returns the\r\n        // merged result of both functions... no need to\r\n        // check if parentVal is a function here because\r\n        // it has to be a function to pass previous merges.\r\n        return function mergedDataFn() {\r\n            return mergeData(isFunction(childVal) ? childVal.call(this, this) : childVal, isFunction(parentVal) ? parentVal.call(this, this) : parentVal);\r\n        };\r\n    }\r\n    else {\r\n        return function mergedInstanceDataFn() {\r\n            // instance merge\r\n            var instanceData = isFunction(childVal)\r\n                ? childVal.call(vm, vm)\r\n                : childVal;\r\n            var defaultData = isFunction(parentVal)\r\n                ? parentVal.call(vm, vm)\r\n                : parentVal;\r\n            if (instanceData) {\r\n                return mergeData(instanceData, defaultData);\r\n            }\r\n            else {\r\n                return defaultData;\r\n            }\r\n        };\r\n    }\r\n}\r\nstrats.data = function (parentVal, childVal, vm) {\r\n    if (!vm) {\r\n        if (childVal && typeof childVal !== 'function') {\r\n             true &&\r\n                warn$2('The \"data\" option should be a function ' +\r\n                    'that returns a per-instance value in component ' +\r\n                    'definitions.', vm);\r\n            return parentVal;\r\n        }\r\n        return mergeDataOrFn(parentVal, childVal);\r\n    }\r\n    return mergeDataOrFn(parentVal, childVal, vm);\r\n};\r\n/**\r\n * Hooks and props are merged as arrays.\r\n */\r\nfunction mergeLifecycleHook(parentVal, childVal) {\r\n    var res = childVal\r\n        ? parentVal\r\n            ? parentVal.concat(childVal)\r\n            : isArray(childVal)\r\n                ? childVal\r\n                : [childVal]\r\n        : parentVal;\r\n    return res ? dedupeHooks(res) : res;\r\n}\r\nfunction dedupeHooks(hooks) {\r\n    var res = [];\r\n    for (var i = 0; i < hooks.length; i++) {\r\n        if (res.indexOf(hooks[i]) === -1) {\r\n            res.push(hooks[i]);\r\n        }\r\n    }\r\n    return res;\r\n}\r\nLIFECYCLE_HOOKS.forEach(function (hook) {\r\n    strats[hook] = mergeLifecycleHook;\r\n});\r\n/**\r\n * Assets\r\n *\r\n * When a vm is present (instance creation), we need to do\r\n * a three-way merge between constructor options, instance\r\n * options and parent options.\r\n */\r\nfunction mergeAssets(parentVal, childVal, vm, key) {\r\n    var res = Object.create(parentVal || null);\r\n    if (childVal) {\r\n         true && assertObjectType(key, childVal, vm);\r\n        return extend(res, childVal);\r\n    }\r\n    else {\r\n        return res;\r\n    }\r\n}\r\nASSET_TYPES.forEach(function (type) {\r\n    strats[type + 's'] = mergeAssets;\r\n});\r\n/**\r\n * Watchers.\r\n *\r\n * Watchers hashes should not overwrite one\r\n * another, so we merge them as arrays.\r\n */\r\nstrats.watch = function (parentVal, childVal, vm, key) {\r\n    // work around Firefox's Object.prototype.watch...\r\n    //@ts-expect-error work around\r\n    if (parentVal === nativeWatch)\r\n        parentVal = undefined;\r\n    //@ts-expect-error work around\r\n    if (childVal === nativeWatch)\r\n        childVal = undefined;\r\n    /* istanbul ignore if */\r\n    if (!childVal)\r\n        return Object.create(parentVal || null);\r\n    if (true) {\r\n        assertObjectType(key, childVal, vm);\r\n    }\r\n    if (!parentVal)\r\n        return childVal;\r\n    var ret = {};\r\n    extend(ret, parentVal);\r\n    for (var key_1 in childVal) {\r\n        var parent_1 = ret[key_1];\r\n        var child = childVal[key_1];\r\n        if (parent_1 && !isArray(parent_1)) {\r\n            parent_1 = [parent_1];\r\n        }\r\n        ret[key_1] = parent_1 ? parent_1.concat(child) : isArray(child) ? child : [child];\r\n    }\r\n    return ret;\r\n};\r\n/**\r\n * Other object hashes.\r\n */\r\nstrats.props =\r\n    strats.methods =\r\n        strats.inject =\r\n            strats.computed =\r\n                function (parentVal, childVal, vm, key) {\r\n                    if (childVal && \"development\" !== 'production') {\r\n                        assertObjectType(key, childVal, vm);\r\n                    }\r\n                    if (!parentVal)\r\n                        return childVal;\r\n                    var ret = Object.create(null);\r\n                    extend(ret, parentVal);\r\n                    if (childVal)\r\n                        extend(ret, childVal);\r\n                    return ret;\r\n                };\r\nstrats.provide = mergeDataOrFn;\r\n/**\r\n * Default strategy.\r\n */\r\nvar defaultStrat = function (parentVal, childVal) {\r\n    return childVal === undefined ? parentVal : childVal;\r\n};\r\n/**\r\n * Validate component names\r\n */\r\nfunction checkComponents(options) {\r\n    for (var key in options.components) {\r\n        validateComponentName(key);\r\n    }\r\n}\r\nfunction validateComponentName(name) {\r\n    if (!new RegExp(\"^[a-zA-Z][\\\\-\\\\.0-9_\".concat(unicodeRegExp.source, \"]*$\")).test(name)) {\r\n        warn$2('Invalid component name: \"' +\r\n            name +\r\n            '\". Component names ' +\r\n            'should conform to valid custom element name in html5 specification.');\r\n    }\r\n    if (isBuiltInTag(name) || config.isReservedTag(name)) {\r\n        warn$2('Do not use built-in or reserved HTML elements as component ' +\r\n            'id: ' +\r\n            name);\r\n    }\r\n}\r\n/**\r\n * Ensure all props option syntax are normalized into the\r\n * Object-based format.\r\n */\r\nfunction normalizeProps(options, vm) {\r\n    var props = options.props;\r\n    if (!props)\r\n        return;\r\n    var res = {};\r\n    var i, val, name;\r\n    if (isArray(props)) {\r\n        i = props.length;\r\n        while (i--) {\r\n            val = props[i];\r\n            if (typeof val === 'string') {\r\n                name = camelize(val);\r\n                res[name] = { type: null };\r\n            }\r\n            else if (true) {\r\n                warn$2('props must be strings when using array syntax.');\r\n            }\r\n        }\r\n    }\r\n    else if (isPlainObject(props)) {\r\n        for (var key in props) {\r\n            val = props[key];\r\n            name = camelize(key);\r\n            res[name] = isPlainObject(val) ? val : { type: val };\r\n        }\r\n    }\r\n    else if (true) {\r\n        warn$2(\"Invalid value for option \\\"props\\\": expected an Array or an Object, \" +\r\n            \"but got \".concat(toRawType(props), \".\"), vm);\r\n    }\r\n    options.props = res;\r\n}\r\n/**\r\n * Normalize all injections into Object-based format\r\n */\r\nfunction normalizeInject(options, vm) {\r\n    var inject = options.inject;\r\n    if (!inject)\r\n        return;\r\n    var normalized = (options.inject = {});\r\n    if (isArray(inject)) {\r\n        for (var i = 0; i < inject.length; i++) {\r\n            normalized[inject[i]] = { from: inject[i] };\r\n        }\r\n    }\r\n    else if (isPlainObject(inject)) {\r\n        for (var key in inject) {\r\n            var val = inject[key];\r\n            normalized[key] = isPlainObject(val)\r\n                ? extend({ from: key }, val)\r\n                : { from: val };\r\n        }\r\n    }\r\n    else if (true) {\r\n        warn$2(\"Invalid value for option \\\"inject\\\": expected an Array or an Object, \" +\r\n            \"but got \".concat(toRawType(inject), \".\"), vm);\r\n    }\r\n}\r\n/**\r\n * Normalize raw function directives into object format.\r\n */\r\nfunction normalizeDirectives$1(options) {\r\n    var dirs = options.directives;\r\n    if (dirs) {\r\n        for (var key in dirs) {\r\n            var def = dirs[key];\r\n            if (isFunction(def)) {\r\n                dirs[key] = { bind: def, update: def };\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction assertObjectType(name, value, vm) {\r\n    if (!isPlainObject(value)) {\r\n        warn$2(\"Invalid value for option \\\"\".concat(name, \"\\\": expected an Object, \") +\r\n            \"but got \".concat(toRawType(value), \".\"), vm);\r\n    }\r\n}\r\n/**\r\n * Merge two option objects into a new one.\r\n * Core utility used in both instantiation and inheritance.\r\n */\r\nfunction mergeOptions(parent, child, vm) {\r\n    if (true) {\r\n        checkComponents(child);\r\n    }\r\n    if (isFunction(child)) {\r\n        // @ts-expect-error\r\n        child = child.options;\r\n    }\r\n    normalizeProps(child, vm);\r\n    normalizeInject(child, vm);\r\n    normalizeDirectives$1(child);\r\n    // Apply extends and mixins on the child options,\r\n    // but only if it is a raw options object that isn't\r\n    // the result of another mergeOptions call.\r\n    // Only merged options has the _base property.\r\n    if (!child._base) {\r\n        if (child.extends) {\r\n            parent = mergeOptions(parent, child.extends, vm);\r\n        }\r\n        if (child.mixins) {\r\n            for (var i = 0, l = child.mixins.length; i < l; i++) {\r\n                parent = mergeOptions(parent, child.mixins[i], vm);\r\n            }\r\n        }\r\n    }\r\n    var options = {};\r\n    var key;\r\n    for (key in parent) {\r\n        mergeField(key);\r\n    }\r\n    for (key in child) {\r\n        if (!hasOwn(parent, key)) {\r\n            mergeField(key);\r\n        }\r\n    }\r\n    function mergeField(key) {\r\n        var strat = strats[key] || defaultStrat;\r\n        options[key] = strat(parent[key], child[key], vm, key);\r\n    }\r\n    return options;\r\n}\r\n/**\r\n * Resolve an asset.\r\n * This function is used because child instances need access\r\n * to assets defined in its ancestor chain.\r\n */\r\nfunction resolveAsset(options, type, id, warnMissing) {\r\n    /* istanbul ignore if */\r\n    if (typeof id !== 'string') {\r\n        return;\r\n    }\r\n    var assets = options[type];\r\n    // check local registration variations first\r\n    if (hasOwn(assets, id))\r\n        return assets[id];\r\n    var camelizedId = camelize(id);\r\n    if (hasOwn(assets, camelizedId))\r\n        return assets[camelizedId];\r\n    var PascalCaseId = capitalize(camelizedId);\r\n    if (hasOwn(assets, PascalCaseId))\r\n        return assets[PascalCaseId];\r\n    // fallback to prototype chain\r\n    var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\r\n    if ( true && warnMissing && !res) {\r\n        warn$2('Failed to resolve ' + type.slice(0, -1) + ': ' + id);\r\n    }\r\n    return res;\r\n}\n\nfunction validateProp(key, propOptions, propsData, vm) {\r\n    var prop = propOptions[key];\r\n    var absent = !hasOwn(propsData, key);\r\n    var value = propsData[key];\r\n    // boolean casting\r\n    var booleanIndex = getTypeIndex(Boolean, prop.type);\r\n    if (booleanIndex > -1) {\r\n        if (absent && !hasOwn(prop, 'default')) {\r\n            value = false;\r\n        }\r\n        else if (value === '' || value === hyphenate(key)) {\r\n            // only cast empty string / same name to boolean if\r\n            // boolean has higher priority\r\n            var stringIndex = getTypeIndex(String, prop.type);\r\n            if (stringIndex < 0 || booleanIndex < stringIndex) {\r\n                value = true;\r\n            }\r\n        }\r\n    }\r\n    // check default value\r\n    if (value === undefined) {\r\n        value = getPropDefaultValue(vm, prop, key);\r\n        // since the default value is a fresh copy,\r\n        // make sure to observe it.\r\n        var prevShouldObserve = shouldObserve;\r\n        toggleObserving(true);\r\n        observe(value);\r\n        toggleObserving(prevShouldObserve);\r\n    }\r\n    if (true) {\r\n        assertProp(prop, key, value, vm, absent);\r\n    }\r\n    return value;\r\n}\r\n/**\r\n * Get the default value of a prop.\r\n */\r\nfunction getPropDefaultValue(vm, prop, key) {\r\n    // no default, return undefined\r\n    if (!hasOwn(prop, 'default')) {\r\n        return undefined;\r\n    }\r\n    var def = prop.default;\r\n    // warn against non-factory defaults for Object & Array\r\n    if ( true && isObject(def)) {\r\n        warn$2('Invalid default value for prop \"' +\r\n            key +\r\n            '\": ' +\r\n            'Props with type Object/Array must use a factory function ' +\r\n            'to return the default value.', vm);\r\n    }\r\n    // the raw prop value was also undefined from previous render,\r\n    // return previous default value to avoid unnecessary watcher trigger\r\n    if (vm &&\r\n        vm.$options.propsData &&\r\n        vm.$options.propsData[key] === undefined &&\r\n        vm._props[key] !== undefined) {\r\n        return vm._props[key];\r\n    }\r\n    // call factory function for non-Function types\r\n    // a value is Function if its prototype is function even across different execution context\r\n    return isFunction(def) && getType(prop.type) !== 'Function'\r\n        ? def.call(vm)\r\n        : def;\r\n}\r\n/**\r\n * Assert whether a prop is valid.\r\n */\r\nfunction assertProp(prop, name, value, vm, absent) {\r\n    if (prop.required && absent) {\r\n        warn$2('Missing required prop: \"' + name + '\"', vm);\r\n        return;\r\n    }\r\n    if (value == null && !prop.required) {\r\n        return;\r\n    }\r\n    var type = prop.type;\r\n    var valid = !type || type === true;\r\n    var expectedTypes = [];\r\n    if (type) {\r\n        if (!isArray(type)) {\r\n            type = [type];\r\n        }\r\n        for (var i = 0; i < type.length && !valid; i++) {\r\n            var assertedType = assertType(value, type[i], vm);\r\n            expectedTypes.push(assertedType.expectedType || '');\r\n            valid = assertedType.valid;\r\n        }\r\n    }\r\n    var haveExpectedTypes = expectedTypes.some(function (t) { return t; });\r\n    if (!valid && haveExpectedTypes) {\r\n        warn$2(getInvalidTypeMessage(name, value, expectedTypes), vm);\r\n        return;\r\n    }\r\n    var validator = prop.validator;\r\n    if (validator) {\r\n        if (!validator(value)) {\r\n            warn$2('Invalid prop: custom validator check failed for prop \"' + name + '\".', vm);\r\n        }\r\n    }\r\n}\r\nvar simpleCheckRE = /^(String|Number|Boolean|Function|Symbol|BigInt)$/;\r\nfunction assertType(value, type, vm) {\r\n    var valid;\r\n    var expectedType = getType(type);\r\n    if (simpleCheckRE.test(expectedType)) {\r\n        var t = typeof value;\r\n        valid = t === expectedType.toLowerCase();\r\n        // for primitive wrapper objects\r\n        if (!valid && t === 'object') {\r\n            valid = value instanceof type;\r\n        }\r\n    }\r\n    else if (expectedType === 'Object') {\r\n        valid = isPlainObject(value);\r\n    }\r\n    else if (expectedType === 'Array') {\r\n        valid = isArray(value);\r\n    }\r\n    else {\r\n        try {\r\n            valid = value instanceof type;\r\n        }\r\n        catch (e) {\r\n            warn$2('Invalid prop type: \"' + String(type) + '\" is not a constructor', vm);\r\n            valid = false;\r\n        }\r\n    }\r\n    return {\r\n        valid: valid,\r\n        expectedType: expectedType\r\n    };\r\n}\r\nvar functionTypeCheckRE = /^\\s*function (\\w+)/;\r\n/**\r\n * Use function string name to check built-in types,\r\n * because a simple equality check will fail when running\r\n * across different vms / iframes.\r\n */\r\nfunction getType(fn) {\r\n    var match = fn && fn.toString().match(functionTypeCheckRE);\r\n    return match ? match[1] : '';\r\n}\r\nfunction isSameType(a, b) {\r\n    return getType(a) === getType(b);\r\n}\r\nfunction getTypeIndex(type, expectedTypes) {\r\n    if (!isArray(expectedTypes)) {\r\n        return isSameType(expectedTypes, type) ? 0 : -1;\r\n    }\r\n    for (var i = 0, len = expectedTypes.length; i < len; i++) {\r\n        if (isSameType(expectedTypes[i], type)) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}\r\nfunction getInvalidTypeMessage(name, value, expectedTypes) {\r\n    var message = \"Invalid prop: type check failed for prop \\\"\".concat(name, \"\\\".\") +\r\n        \" Expected \".concat(expectedTypes.map(capitalize).join(', '));\r\n    var expectedType = expectedTypes[0];\r\n    var receivedType = toRawType(value);\r\n    // check if we need to specify expected value\r\n    if (expectedTypes.length === 1 &&\r\n        isExplicable(expectedType) &&\r\n        isExplicable(typeof value) &&\r\n        !isBoolean(expectedType, receivedType)) {\r\n        message += \" with value \".concat(styleValue(value, expectedType));\r\n    }\r\n    message += \", got \".concat(receivedType, \" \");\r\n    // check if we need to specify received value\r\n    if (isExplicable(receivedType)) {\r\n        message += \"with value \".concat(styleValue(value, receivedType), \".\");\r\n    }\r\n    return message;\r\n}\r\nfunction styleValue(value, type) {\r\n    if (type === 'String') {\r\n        return \"\\\"\".concat(value, \"\\\"\");\r\n    }\r\n    else if (type === 'Number') {\r\n        return \"\".concat(Number(value));\r\n    }\r\n    else {\r\n        return \"\".concat(value);\r\n    }\r\n}\r\nvar EXPLICABLE_TYPES = ['string', 'number', 'boolean'];\r\nfunction isExplicable(value) {\r\n    return EXPLICABLE_TYPES.some(function (elem) { return value.toLowerCase() === elem; });\r\n}\r\nfunction isBoolean() {\r\n    var args = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        args[_i] = arguments[_i];\r\n    }\r\n    return args.some(function (elem) { return elem.toLowerCase() === 'boolean'; });\r\n}\n\nfunction Vue(options) {\r\n    if ( true && !(this instanceof Vue)) {\r\n        warn$2('Vue is a constructor and should be called with the `new` keyword');\r\n    }\r\n    this._init(options);\r\n}\r\n//@ts-expect-error Vue has function type\r\ninitMixin$1(Vue);\r\n//@ts-expect-error Vue has function type\r\nstateMixin(Vue);\r\n//@ts-expect-error Vue has function type\r\neventsMixin(Vue);\r\n//@ts-expect-error Vue has function type\r\nlifecycleMixin(Vue);\r\n//@ts-expect-error Vue has function type\r\nrenderMixin(Vue);\n\nfunction initUse(Vue) {\r\n    Vue.use = function (plugin) {\r\n        var installedPlugins = this._installedPlugins || (this._installedPlugins = []);\r\n        if (installedPlugins.indexOf(plugin) > -1) {\r\n            return this;\r\n        }\r\n        // additional parameters\r\n        var args = toArray(arguments, 1);\r\n        args.unshift(this);\r\n        if (isFunction(plugin.install)) {\r\n            plugin.install.apply(plugin, args);\r\n        }\r\n        else if (isFunction(plugin)) {\r\n            plugin.apply(null, args);\r\n        }\r\n        installedPlugins.push(plugin);\r\n        return this;\r\n    };\r\n}\n\nfunction initMixin(Vue) {\r\n    Vue.mixin = function (mixin) {\r\n        this.options = mergeOptions(this.options, mixin);\r\n        return this;\r\n    };\r\n}\n\nfunction initExtend(Vue) {\r\n    /**\r\n     * Each instance constructor, including Vue, has a unique\r\n     * cid. This enables us to create wrapped \"child\r\n     * constructors\" for prototypal inheritance and cache them.\r\n     */\r\n    Vue.cid = 0;\r\n    var cid = 1;\r\n    /**\r\n     * Class inheritance\r\n     */\r\n    Vue.extend = function (extendOptions) {\r\n        extendOptions = extendOptions || {};\r\n        var Super = this;\r\n        var SuperId = Super.cid;\r\n        var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\r\n        if (cachedCtors[SuperId]) {\r\n            return cachedCtors[SuperId];\r\n        }\r\n        var name = getComponentName(extendOptions) || getComponentName(Super.options);\r\n        if ( true && name) {\r\n            validateComponentName(name);\r\n        }\r\n        var Sub = function VueComponent(options) {\r\n            this._init(options);\r\n        };\r\n        Sub.prototype = Object.create(Super.prototype);\r\n        Sub.prototype.constructor = Sub;\r\n        Sub.cid = cid++;\r\n        Sub.options = mergeOptions(Super.options, extendOptions);\r\n        Sub['super'] = Super;\r\n        // For props and computed properties, we define the proxy getters on\r\n        // the Vue instances at extension time, on the extended prototype. This\r\n        // avoids Object.defineProperty calls for each instance created.\r\n        if (Sub.options.props) {\r\n            initProps(Sub);\r\n        }\r\n        if (Sub.options.computed) {\r\n            initComputed(Sub);\r\n        }\r\n        // allow further extension/mixin/plugin usage\r\n        Sub.extend = Super.extend;\r\n        Sub.mixin = Super.mixin;\r\n        Sub.use = Super.use;\r\n        // create asset registers, so extended classes\r\n        // can have their private assets too.\r\n        ASSET_TYPES.forEach(function (type) {\r\n            Sub[type] = Super[type];\r\n        });\r\n        // enable recursive self-lookup\r\n        if (name) {\r\n            Sub.options.components[name] = Sub;\r\n        }\r\n        // keep a reference to the super options at extension time.\r\n        // later at instantiation we can check if Super's options have\r\n        // been updated.\r\n        Sub.superOptions = Super.options;\r\n        Sub.extendOptions = extendOptions;\r\n        Sub.sealedOptions = extend({}, Sub.options);\r\n        // cache constructor\r\n        cachedCtors[SuperId] = Sub;\r\n        return Sub;\r\n    };\r\n}\r\nfunction initProps(Comp) {\r\n    var props = Comp.options.props;\r\n    for (var key in props) {\r\n        proxy(Comp.prototype, \"_props\", key);\r\n    }\r\n}\r\nfunction initComputed(Comp) {\r\n    var computed = Comp.options.computed;\r\n    for (var key in computed) {\r\n        defineComputed(Comp.prototype, key, computed[key]);\r\n    }\r\n}\n\nfunction initAssetRegisters(Vue) {\r\n    /**\r\n     * Create asset registration methods.\r\n     */\r\n    ASSET_TYPES.forEach(function (type) {\r\n        // @ts-expect-error function is not exact same type\r\n        Vue[type] = function (id, definition) {\r\n            if (!definition) {\r\n                return this.options[type + 's'][id];\r\n            }\r\n            else {\r\n                /* istanbul ignore if */\r\n                if ( true && type === 'component') {\r\n                    validateComponentName(id);\r\n                }\r\n                if (type === 'component' && isPlainObject(definition)) {\r\n                    // @ts-expect-error\r\n                    definition.name = definition.name || id;\r\n                    definition = this.options._base.extend(definition);\r\n                }\r\n                if (type === 'directive' && isFunction(definition)) {\r\n                    definition = { bind: definition, update: definition };\r\n                }\r\n                this.options[type + 's'][id] = definition;\r\n                return definition;\r\n            }\r\n        };\r\n    });\r\n}\n\nfunction _getComponentName(opts) {\r\n    return opts && (getComponentName(opts.Ctor.options) || opts.tag);\r\n}\r\nfunction matches(pattern, name) {\r\n    if (isArray(pattern)) {\r\n        return pattern.indexOf(name) > -1;\r\n    }\r\n    else if (typeof pattern === 'string') {\r\n        return pattern.split(',').indexOf(name) > -1;\r\n    }\r\n    else if (isRegExp(pattern)) {\r\n        return pattern.test(name);\r\n    }\r\n    /* istanbul ignore next */\r\n    return false;\r\n}\r\nfunction pruneCache(keepAliveInstance, filter) {\r\n    var cache = keepAliveInstance.cache, keys = keepAliveInstance.keys, _vnode = keepAliveInstance._vnode;\r\n    for (var key in cache) {\r\n        var entry = cache[key];\r\n        if (entry) {\r\n            var name_1 = entry.name;\r\n            if (name_1 && !filter(name_1)) {\r\n                pruneCacheEntry(cache, key, keys, _vnode);\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction pruneCacheEntry(cache, key, keys, current) {\r\n    var entry = cache[key];\r\n    if (entry && (!current || entry.tag !== current.tag)) {\r\n        // @ts-expect-error can be undefined\r\n        entry.componentInstance.$destroy();\r\n    }\r\n    cache[key] = null;\r\n    remove$2(keys, key);\r\n}\r\nvar patternTypes = [String, RegExp, Array];\r\n// TODO defineComponent\r\nvar KeepAlive = {\r\n    name: 'keep-alive',\r\n    abstract: true,\r\n    props: {\r\n        include: patternTypes,\r\n        exclude: patternTypes,\r\n        max: [String, Number]\r\n    },\r\n    methods: {\r\n        cacheVNode: function () {\r\n            var _a = this, cache = _a.cache, keys = _a.keys, vnodeToCache = _a.vnodeToCache, keyToCache = _a.keyToCache;\r\n            if (vnodeToCache) {\r\n                var tag = vnodeToCache.tag, componentInstance = vnodeToCache.componentInstance, componentOptions = vnodeToCache.componentOptions;\r\n                cache[keyToCache] = {\r\n                    name: _getComponentName(componentOptions),\r\n                    tag: tag,\r\n                    componentInstance: componentInstance\r\n                };\r\n                keys.push(keyToCache);\r\n                // prune oldest entry\r\n                if (this.max && keys.length > parseInt(this.max)) {\r\n                    pruneCacheEntry(cache, keys[0], keys, this._vnode);\r\n                }\r\n                this.vnodeToCache = null;\r\n            }\r\n        }\r\n    },\r\n    created: function () {\r\n        this.cache = Object.create(null);\r\n        this.keys = [];\r\n    },\r\n    destroyed: function () {\r\n        for (var key in this.cache) {\r\n            pruneCacheEntry(this.cache, key, this.keys);\r\n        }\r\n    },\r\n    mounted: function () {\r\n        var _this = this;\r\n        this.cacheVNode();\r\n        this.$watch('include', function (val) {\r\n            pruneCache(_this, function (name) { return matches(val, name); });\r\n        });\r\n        this.$watch('exclude', function (val) {\r\n            pruneCache(_this, function (name) { return !matches(val, name); });\r\n        });\r\n    },\r\n    updated: function () {\r\n        this.cacheVNode();\r\n    },\r\n    render: function () {\r\n        var slot = this.$slots.default;\r\n        var vnode = getFirstComponentChild(slot);\r\n        var componentOptions = vnode && vnode.componentOptions;\r\n        if (componentOptions) {\r\n            // check pattern\r\n            var name_2 = _getComponentName(componentOptions);\r\n            var _a = this, include = _a.include, exclude = _a.exclude;\r\n            if (\r\n            // not included\r\n            (include && (!name_2 || !matches(include, name_2))) ||\r\n                // excluded\r\n                (exclude && name_2 && matches(exclude, name_2))) {\r\n                return vnode;\r\n            }\r\n            var _b = this, cache = _b.cache, keys = _b.keys;\r\n            var key = vnode.key == null\r\n                ? // same constructor may get registered as different local components\r\n                    // so cid alone is not enough (#3269)\r\n                    componentOptions.Ctor.cid +\r\n                        (componentOptions.tag ? \"::\".concat(componentOptions.tag) : '')\r\n                : vnode.key;\r\n            if (cache[key]) {\r\n                vnode.componentInstance = cache[key].componentInstance;\r\n                // make current key freshest\r\n                remove$2(keys, key);\r\n                keys.push(key);\r\n            }\r\n            else {\r\n                // delay setting the cache until update\r\n                this.vnodeToCache = vnode;\r\n                this.keyToCache = key;\r\n            }\r\n            // @ts-expect-error can vnode.data can be undefined\r\n            vnode.data.keepAlive = true;\r\n        }\r\n        return vnode || (slot && slot[0]);\r\n    }\r\n};\n\nvar builtInComponents = {\r\n    KeepAlive: KeepAlive\r\n};\n\nfunction initGlobalAPI(Vue) {\r\n    // config\r\n    var configDef = {};\r\n    configDef.get = function () { return config; };\r\n    if (true) {\r\n        configDef.set = function () {\r\n            warn$2('Do not replace the Vue.config object, set individual fields instead.');\r\n        };\r\n    }\r\n    Object.defineProperty(Vue, 'config', configDef);\r\n    // exposed util methods.\r\n    // NOTE: these are not considered part of the public API - avoid relying on\r\n    // them unless you are aware of the risk.\r\n    Vue.util = {\r\n        warn: warn$2,\r\n        extend: extend,\r\n        mergeOptions: mergeOptions,\r\n        defineReactive: defineReactive\r\n    };\r\n    Vue.set = set;\r\n    Vue.delete = del;\r\n    Vue.nextTick = nextTick;\r\n    // 2.6 explicit observable API\r\n    Vue.observable = function (obj) {\r\n        observe(obj);\r\n        return obj;\r\n    };\r\n    Vue.options = Object.create(null);\r\n    ASSET_TYPES.forEach(function (type) {\r\n        Vue.options[type + 's'] = Object.create(null);\r\n    });\r\n    // this is used to identify the \"base\" constructor to extend all plain-object\r\n    // components with in Weex's multi-instance scenarios.\r\n    Vue.options._base = Vue;\r\n    extend(Vue.options.components, builtInComponents);\r\n    initUse(Vue);\r\n    initMixin(Vue);\r\n    initExtend(Vue);\r\n    initAssetRegisters(Vue);\r\n}\n\ninitGlobalAPI(Vue);\r\nObject.defineProperty(Vue.prototype, '$isServer', {\r\n    get: isServerRendering\r\n});\r\nObject.defineProperty(Vue.prototype, '$ssrContext', {\r\n    get: function () {\r\n        /* istanbul ignore next */\r\n        return this.$vnode && this.$vnode.ssrContext;\r\n    }\r\n});\r\n// expose FunctionalRenderContext for ssr runtime helper installation\r\nObject.defineProperty(Vue, 'FunctionalRenderContext', {\r\n    value: FunctionalRenderContext\r\n});\r\nVue.version = version;\n\n// these are reserved for web because they are directly compiled away\r\n// during template compilation\r\nvar isReservedAttr = makeMap('style,class');\r\n// attributes that should be using props for binding\r\nvar acceptValue = makeMap('input,textarea,option,select,progress');\r\nvar mustUseProp = function (tag, type, attr) {\r\n    return ((attr === 'value' && acceptValue(tag) && type !== 'button') ||\r\n        (attr === 'selected' && tag === 'option') ||\r\n        (attr === 'checked' && tag === 'input') ||\r\n        (attr === 'muted' && tag === 'video'));\r\n};\r\nvar isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\r\nvar isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');\r\nvar convertEnumeratedValue = function (key, value) {\r\n    return isFalsyAttrValue(value) || value === 'false'\r\n        ? 'false'\r\n        : // allow arbitrary string value for contenteditable\r\n            key === 'contenteditable' && isValidContentEditableValue(value)\r\n                ? value\r\n                : 'true';\r\n};\r\nvar isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +\r\n    'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +\r\n    'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +\r\n    'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +\r\n    'required,reversed,scoped,seamless,selected,sortable,' +\r\n    'truespeed,typemustmatch,visible');\r\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\r\nvar isXlink = function (name) {\r\n    return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';\r\n};\r\nvar getXlinkProp = function (name) {\r\n    return isXlink(name) ? name.slice(6, name.length) : '';\r\n};\r\nvar isFalsyAttrValue = function (val) {\r\n    return val == null || val === false;\r\n};\n\nfunction genClassForVnode(vnode) {\r\n    var data = vnode.data;\r\n    var parentNode = vnode;\r\n    var childNode = vnode;\r\n    while (isDef(childNode.componentInstance)) {\r\n        childNode = childNode.componentInstance._vnode;\r\n        if (childNode && childNode.data) {\r\n            data = mergeClassData(childNode.data, data);\r\n        }\r\n    }\r\n    // @ts-expect-error parentNode.parent not VNodeWithData\r\n    while (isDef((parentNode = parentNode.parent))) {\r\n        if (parentNode && parentNode.data) {\r\n            data = mergeClassData(data, parentNode.data);\r\n        }\r\n    }\r\n    return renderClass(data.staticClass, data.class);\r\n}\r\nfunction mergeClassData(child, parent) {\r\n    return {\r\n        staticClass: concat(child.staticClass, parent.staticClass),\r\n        class: isDef(child.class) ? [child.class, parent.class] : parent.class\r\n    };\r\n}\r\nfunction renderClass(staticClass, dynamicClass) {\r\n    if (isDef(staticClass) || isDef(dynamicClass)) {\r\n        return concat(staticClass, stringifyClass(dynamicClass));\r\n    }\r\n    /* istanbul ignore next */\r\n    return '';\r\n}\r\nfunction concat(a, b) {\r\n    return a ? (b ? a + ' ' + b : a) : b || '';\r\n}\r\nfunction stringifyClass(value) {\r\n    if (Array.isArray(value)) {\r\n        return stringifyArray(value);\r\n    }\r\n    if (isObject(value)) {\r\n        return stringifyObject(value);\r\n    }\r\n    if (typeof value === 'string') {\r\n        return value;\r\n    }\r\n    /* istanbul ignore next */\r\n    return '';\r\n}\r\nfunction stringifyArray(value) {\r\n    var res = '';\r\n    var stringified;\r\n    for (var i = 0, l = value.length; i < l; i++) {\r\n        if (isDef((stringified = stringifyClass(value[i]))) && stringified !== '') {\r\n            if (res)\r\n                res += ' ';\r\n            res += stringified;\r\n        }\r\n    }\r\n    return res;\r\n}\r\nfunction stringifyObject(value) {\r\n    var res = '';\r\n    for (var key in value) {\r\n        if (value[key]) {\r\n            if (res)\r\n                res += ' ';\r\n            res += key;\r\n        }\r\n    }\r\n    return res;\r\n}\n\nvar namespaceMap = {\r\n    svg: 'http://www.w3.org/2000/svg',\r\n    math: 'http://www.w3.org/1998/Math/MathML'\r\n};\r\nvar isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' +\r\n    'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +\r\n    'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +\r\n    'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +\r\n    's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +\r\n    'embed,object,param,source,canvas,script,noscript,del,ins,' +\r\n    'caption,col,colgroup,table,thead,tbody,td,th,tr,' +\r\n    'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +\r\n    'output,progress,select,textarea,' +\r\n    'details,dialog,menu,menuitem,summary,' +\r\n    'content,element,shadow,template,blockquote,iframe,tfoot');\r\n// this map is intentionally selective, only covering SVG elements that may\r\n// contain child elements.\r\nvar isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +\r\n    'foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +\r\n    'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);\r\nvar isPreTag = function (tag) { return tag === 'pre'; };\r\nvar isReservedTag = function (tag) {\r\n    return isHTMLTag(tag) || isSVG(tag);\r\n};\r\nfunction getTagNamespace(tag) {\r\n    if (isSVG(tag)) {\r\n        return 'svg';\r\n    }\r\n    // basic support for MathML\r\n    // note it doesn't support other MathML elements being component roots\r\n    if (tag === 'math') {\r\n        return 'math';\r\n    }\r\n}\r\nvar unknownElementCache = Object.create(null);\r\nfunction isUnknownElement(tag) {\r\n    /* istanbul ignore if */\r\n    if (!inBrowser) {\r\n        return true;\r\n    }\r\n    if (isReservedTag(tag)) {\r\n        return false;\r\n    }\r\n    tag = tag.toLowerCase();\r\n    /* istanbul ignore if */\r\n    if (unknownElementCache[tag] != null) {\r\n        return unknownElementCache[tag];\r\n    }\r\n    var el = document.createElement(tag);\r\n    if (tag.indexOf('-') > -1) {\r\n        // http://stackoverflow.com/a/28210364/1070244\r\n        return (unknownElementCache[tag] =\r\n            el.constructor === window.HTMLUnknownElement ||\r\n                el.constructor === window.HTMLElement);\r\n    }\r\n    else {\r\n        return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()));\r\n    }\r\n}\r\nvar isTextInputType = makeMap('text,number,password,search,email,tel,url');\n\n/**\r\n * Query an element selector if it's not an element already.\r\n */\r\nfunction query(el) {\r\n    if (typeof el === 'string') {\r\n        var selected = document.querySelector(el);\r\n        if (!selected) {\r\n             true && warn$2('Cannot find element: ' + el);\r\n            return document.createElement('div');\r\n        }\r\n        return selected;\r\n    }\r\n    else {\r\n        return el;\r\n    }\r\n}\n\nfunction createElement(tagName, vnode) {\r\n    var elm = document.createElement(tagName);\r\n    if (tagName !== 'select') {\r\n        return elm;\r\n    }\r\n    // false or null will remove the attribute but undefined will not\r\n    if (vnode.data &&\r\n        vnode.data.attrs &&\r\n        vnode.data.attrs.multiple !== undefined) {\r\n        elm.setAttribute('multiple', 'multiple');\r\n    }\r\n    return elm;\r\n}\r\nfunction createElementNS(namespace, tagName) {\r\n    return document.createElementNS(namespaceMap[namespace], tagName);\r\n}\r\nfunction createTextNode(text) {\r\n    return document.createTextNode(text);\r\n}\r\nfunction createComment(text) {\r\n    return document.createComment(text);\r\n}\r\nfunction insertBefore(parentNode, newNode, referenceNode) {\r\n    parentNode.insertBefore(newNode, referenceNode);\r\n}\r\nfunction removeChild(node, child) {\r\n    node.removeChild(child);\r\n}\r\nfunction appendChild(node, child) {\r\n    node.appendChild(child);\r\n}\r\nfunction parentNode(node) {\r\n    return node.parentNode;\r\n}\r\nfunction nextSibling(node) {\r\n    return node.nextSibling;\r\n}\r\nfunction tagName(node) {\r\n    return node.tagName;\r\n}\r\nfunction setTextContent(node, text) {\r\n    node.textContent = text;\r\n}\r\nfunction setStyleScope(node, scopeId) {\r\n    node.setAttribute(scopeId, '');\r\n}\n\nvar nodeOps = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  createElement: createElement,\n  createElementNS: createElementNS,\n  createTextNode: createTextNode,\n  createComment: createComment,\n  insertBefore: insertBefore,\n  removeChild: removeChild,\n  appendChild: appendChild,\n  parentNode: parentNode,\n  nextSibling: nextSibling,\n  tagName: tagName,\n  setTextContent: setTextContent,\n  setStyleScope: setStyleScope\n});\n\nvar ref = {\r\n    create: function (_, vnode) {\r\n        registerRef(vnode);\r\n    },\r\n    update: function (oldVnode, vnode) {\r\n        if (oldVnode.data.ref !== vnode.data.ref) {\r\n            registerRef(oldVnode, true);\r\n            registerRef(vnode);\r\n        }\r\n    },\r\n    destroy: function (vnode) {\r\n        registerRef(vnode, true);\r\n    }\r\n};\r\nfunction registerRef(vnode, isRemoval) {\r\n    var ref = vnode.data.ref;\r\n    if (!isDef(ref))\r\n        return;\r\n    var vm = vnode.context;\r\n    var refValue = vnode.componentInstance || vnode.elm;\r\n    var value = isRemoval ? null : refValue;\r\n    var $refsValue = isRemoval ? undefined : refValue;\r\n    if (isFunction(ref)) {\r\n        invokeWithErrorHandling(ref, vm, [value], vm, \"template ref function\");\r\n        return;\r\n    }\r\n    var isFor = vnode.data.refInFor;\r\n    var _isString = typeof ref === 'string' || typeof ref === 'number';\r\n    var _isRef = isRef(ref);\r\n    var refs = vm.$refs;\r\n    if (_isString || _isRef) {\r\n        if (isFor) {\r\n            var existing = _isString ? refs[ref] : ref.value;\r\n            if (isRemoval) {\r\n                isArray(existing) && remove$2(existing, refValue);\r\n            }\r\n            else {\r\n                if (!isArray(existing)) {\r\n                    if (_isString) {\r\n                        refs[ref] = [refValue];\r\n                        setSetupRef(vm, ref, refs[ref]);\r\n                    }\r\n                    else {\r\n                        ref.value = [refValue];\r\n                    }\r\n                }\r\n                else if (!existing.includes(refValue)) {\r\n                    existing.push(refValue);\r\n                }\r\n            }\r\n        }\r\n        else if (_isString) {\r\n            if (isRemoval && refs[ref] !== refValue) {\r\n                return;\r\n            }\r\n            refs[ref] = $refsValue;\r\n            setSetupRef(vm, ref, value);\r\n        }\r\n        else if (_isRef) {\r\n            if (isRemoval && ref.value !== refValue) {\r\n                return;\r\n            }\r\n            ref.value = value;\r\n        }\r\n        else if (true) {\r\n            warn$2(\"Invalid template ref type: \".concat(typeof ref));\r\n        }\r\n    }\r\n}\r\nfunction setSetupRef(_a, key, val) {\r\n    var _setupState = _a._setupState;\r\n    if (_setupState && hasOwn(_setupState, key)) {\r\n        if (isRef(_setupState[key])) {\r\n            _setupState[key].value = val;\r\n        }\r\n        else {\r\n            _setupState[key] = val;\r\n        }\r\n    }\r\n}\n\n/**\r\n * Virtual DOM patching algorithm based on Snabbdom by\r\n * Simon Friis Vindum (@paldepind)\r\n * Licensed under the MIT License\r\n * https://github.com/paldepind/snabbdom/blob/master/LICENSE\r\n *\r\n * modified by Evan You (@yyx990803)\r\n *\r\n * Not type-checking this because this file is perf-critical and the cost\r\n * of making flow understand it is not worth it.\r\n */\r\nvar emptyNode = new VNode('', {}, []);\r\nvar hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\r\nfunction sameVnode(a, b) {\r\n    return (a.key === b.key &&\r\n        a.asyncFactory === b.asyncFactory &&\r\n        ((a.tag === b.tag &&\r\n            a.isComment === b.isComment &&\r\n            isDef(a.data) === isDef(b.data) &&\r\n            sameInputType(a, b)) ||\r\n            (isTrue(a.isAsyncPlaceholder) && isUndef(b.asyncFactory.error))));\r\n}\r\nfunction sameInputType(a, b) {\r\n    if (a.tag !== 'input')\r\n        return true;\r\n    var i;\r\n    var typeA = isDef((i = a.data)) && isDef((i = i.attrs)) && i.type;\r\n    var typeB = isDef((i = b.data)) && isDef((i = i.attrs)) && i.type;\r\n    return typeA === typeB || (isTextInputType(typeA) && isTextInputType(typeB));\r\n}\r\nfunction createKeyToOldIdx(children, beginIdx, endIdx) {\r\n    var i, key;\r\n    var map = {};\r\n    for (i = beginIdx; i <= endIdx; ++i) {\r\n        key = children[i].key;\r\n        if (isDef(key))\r\n            map[key] = i;\r\n    }\r\n    return map;\r\n}\r\nfunction createPatchFunction(backend) {\r\n    var i, j;\r\n    var cbs = {};\r\n    var modules = backend.modules, nodeOps = backend.nodeOps;\r\n    for (i = 0; i < hooks.length; ++i) {\r\n        cbs[hooks[i]] = [];\r\n        for (j = 0; j < modules.length; ++j) {\r\n            if (isDef(modules[j][hooks[i]])) {\r\n                cbs[hooks[i]].push(modules[j][hooks[i]]);\r\n            }\r\n        }\r\n    }\r\n    function emptyNodeAt(elm) {\r\n        return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);\r\n    }\r\n    function createRmCb(childElm, listeners) {\r\n        function remove() {\r\n            if (--remove.listeners === 0) {\r\n                removeNode(childElm);\r\n            }\r\n        }\r\n        remove.listeners = listeners;\r\n        return remove;\r\n    }\r\n    function removeNode(el) {\r\n        var parent = nodeOps.parentNode(el);\r\n        // element may have already been removed due to v-html / v-text\r\n        if (isDef(parent)) {\r\n            nodeOps.removeChild(parent, el);\r\n        }\r\n    }\r\n    function isUnknownElement(vnode, inVPre) {\r\n        return (!inVPre &&\r\n            !vnode.ns &&\r\n            !(config.ignoredElements.length &&\r\n                config.ignoredElements.some(function (ignore) {\r\n                    return isRegExp(ignore)\r\n                        ? ignore.test(vnode.tag)\r\n                        : ignore === vnode.tag;\r\n                })) &&\r\n            config.isUnknownElement(vnode.tag));\r\n    }\r\n    var creatingElmInVPre = 0;\r\n    function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index) {\r\n        if (isDef(vnode.elm) && isDef(ownerArray)) {\r\n            // This vnode was used in a previous render!\r\n            // now it's used as a new node, overwriting its elm would cause\r\n            // potential patch errors down the road when it's used as an insertion\r\n            // reference node. Instead, we clone the node on-demand before creating\r\n            // associated DOM element for it.\r\n            vnode = ownerArray[index] = cloneVNode(vnode);\r\n        }\r\n        vnode.isRootInsert = !nested; // for transition enter check\r\n        if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\r\n            return;\r\n        }\r\n        var data = vnode.data;\r\n        var children = vnode.children;\r\n        var tag = vnode.tag;\r\n        if (isDef(tag)) {\r\n            if (true) {\r\n                if (data && data.pre) {\r\n                    creatingElmInVPre++;\r\n                }\r\n                if (isUnknownElement(vnode, creatingElmInVPre)) {\r\n                    warn$2('Unknown custom element: <' +\r\n                        tag +\r\n                        '> - did you ' +\r\n                        'register the component correctly? For recursive components, ' +\r\n                        'make sure to provide the \"name\" option.', vnode.context);\r\n                }\r\n            }\r\n            vnode.elm = vnode.ns\r\n                ? nodeOps.createElementNS(vnode.ns, tag)\r\n                : nodeOps.createElement(tag, vnode);\r\n            setScope(vnode);\r\n            createChildren(vnode, children, insertedVnodeQueue);\r\n            if (isDef(data)) {\r\n                invokeCreateHooks(vnode, insertedVnodeQueue);\r\n            }\r\n            insert(parentElm, vnode.elm, refElm);\r\n            if ( true && data && data.pre) {\r\n                creatingElmInVPre--;\r\n            }\r\n        }\r\n        else if (isTrue(vnode.isComment)) {\r\n            vnode.elm = nodeOps.createComment(vnode.text);\r\n            insert(parentElm, vnode.elm, refElm);\r\n        }\r\n        else {\r\n            vnode.elm = nodeOps.createTextNode(vnode.text);\r\n            insert(parentElm, vnode.elm, refElm);\r\n        }\r\n    }\r\n    function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {\r\n        var i = vnode.data;\r\n        if (isDef(i)) {\r\n            var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\r\n            if (isDef((i = i.hook)) && isDef((i = i.init))) {\r\n                i(vnode, false /* hydrating */);\r\n            }\r\n            // after calling the init hook, if the vnode is a child component\r\n            // it should've created a child instance and mounted it. the child\r\n            // component also has set the placeholder vnode's elm.\r\n            // in that case we can just return the element and be done.\r\n            if (isDef(vnode.componentInstance)) {\r\n                initComponent(vnode, insertedVnodeQueue);\r\n                insert(parentElm, vnode.elm, refElm);\r\n                if (isTrue(isReactivated)) {\r\n                    reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\r\n                }\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    function initComponent(vnode, insertedVnodeQueue) {\r\n        if (isDef(vnode.data.pendingInsert)) {\r\n            insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\r\n            vnode.data.pendingInsert = null;\r\n        }\r\n        vnode.elm = vnode.componentInstance.$el;\r\n        if (isPatchable(vnode)) {\r\n            invokeCreateHooks(vnode, insertedVnodeQueue);\r\n            setScope(vnode);\r\n        }\r\n        else {\r\n            // empty component root.\r\n            // skip all element-related modules except for ref (#3455)\r\n            registerRef(vnode);\r\n            // make sure to invoke the insert hook\r\n            insertedVnodeQueue.push(vnode);\r\n        }\r\n    }\r\n    function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {\r\n        var i;\r\n        // hack for #4339: a reactivated component with inner transition\r\n        // does not trigger because the inner node's created hooks are not called\r\n        // again. It's not ideal to involve module-specific logic in here but\r\n        // there doesn't seem to be a better way to do it.\r\n        var innerNode = vnode;\r\n        while (innerNode.componentInstance) {\r\n            innerNode = innerNode.componentInstance._vnode;\r\n            if (isDef((i = innerNode.data)) && isDef((i = i.transition))) {\r\n                for (i = 0; i < cbs.activate.length; ++i) {\r\n                    cbs.activate[i](emptyNode, innerNode);\r\n                }\r\n                insertedVnodeQueue.push(innerNode);\r\n                break;\r\n            }\r\n        }\r\n        // unlike a newly created component,\r\n        // a reactivated keep-alive component doesn't insert itself\r\n        insert(parentElm, vnode.elm, refElm);\r\n    }\r\n    function insert(parent, elm, ref) {\r\n        if (isDef(parent)) {\r\n            if (isDef(ref)) {\r\n                if (nodeOps.parentNode(ref) === parent) {\r\n                    nodeOps.insertBefore(parent, elm, ref);\r\n                }\r\n            }\r\n            else {\r\n                nodeOps.appendChild(parent, elm);\r\n            }\r\n        }\r\n    }\r\n    function createChildren(vnode, children, insertedVnodeQueue) {\r\n        if (isArray(children)) {\r\n            if (true) {\r\n                checkDuplicateKeys(children);\r\n            }\r\n            for (var i_1 = 0; i_1 < children.length; ++i_1) {\r\n                createElm(children[i_1], insertedVnodeQueue, vnode.elm, null, true, children, i_1);\r\n            }\r\n        }\r\n        else if (isPrimitive(vnode.text)) {\r\n            nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));\r\n        }\r\n    }\r\n    function isPatchable(vnode) {\r\n        while (vnode.componentInstance) {\r\n            vnode = vnode.componentInstance._vnode;\r\n        }\r\n        return isDef(vnode.tag);\r\n    }\r\n    function invokeCreateHooks(vnode, insertedVnodeQueue) {\r\n        for (var i_2 = 0; i_2 < cbs.create.length; ++i_2) {\r\n            cbs.create[i_2](emptyNode, vnode);\r\n        }\r\n        i = vnode.data.hook; // Reuse variable\r\n        if (isDef(i)) {\r\n            if (isDef(i.create))\r\n                i.create(emptyNode, vnode);\r\n            if (isDef(i.insert))\r\n                insertedVnodeQueue.push(vnode);\r\n        }\r\n    }\r\n    // set scope id attribute for scoped CSS.\r\n    // this is implemented as a special case to avoid the overhead\r\n    // of going through the normal attribute patching process.\r\n    function setScope(vnode) {\r\n        var i;\r\n        if (isDef((i = vnode.fnScopeId))) {\r\n            nodeOps.setStyleScope(vnode.elm, i);\r\n        }\r\n        else {\r\n            var ancestor = vnode;\r\n            while (ancestor) {\r\n                if (isDef((i = ancestor.context)) && isDef((i = i.$options._scopeId))) {\r\n                    nodeOps.setStyleScope(vnode.elm, i);\r\n                }\r\n                ancestor = ancestor.parent;\r\n            }\r\n        }\r\n        // for slot content they should also get the scopeId from the host instance.\r\n        if (isDef((i = activeInstance)) &&\r\n            i !== vnode.context &&\r\n            i !== vnode.fnContext &&\r\n            isDef((i = i.$options._scopeId))) {\r\n            nodeOps.setStyleScope(vnode.elm, i);\r\n        }\r\n    }\r\n    function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\r\n        for (; startIdx <= endIdx; ++startIdx) {\r\n            createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);\r\n        }\r\n    }\r\n    function invokeDestroyHook(vnode) {\r\n        var i, j;\r\n        var data = vnode.data;\r\n        if (isDef(data)) {\r\n            if (isDef((i = data.hook)) && isDef((i = i.destroy)))\r\n                i(vnode);\r\n            for (i = 0; i < cbs.destroy.length; ++i)\r\n                cbs.destroy[i](vnode);\r\n        }\r\n        if (isDef((i = vnode.children))) {\r\n            for (j = 0; j < vnode.children.length; ++j) {\r\n                invokeDestroyHook(vnode.children[j]);\r\n            }\r\n        }\r\n    }\r\n    function removeVnodes(vnodes, startIdx, endIdx) {\r\n        for (; startIdx <= endIdx; ++startIdx) {\r\n            var ch = vnodes[startIdx];\r\n            if (isDef(ch)) {\r\n                if (isDef(ch.tag)) {\r\n                    removeAndInvokeRemoveHook(ch);\r\n                    invokeDestroyHook(ch);\r\n                }\r\n                else {\r\n                    // Text node\r\n                    removeNode(ch.elm);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    function removeAndInvokeRemoveHook(vnode, rm) {\r\n        if (isDef(rm) || isDef(vnode.data)) {\r\n            var i_3;\r\n            var listeners = cbs.remove.length + 1;\r\n            if (isDef(rm)) {\r\n                // we have a recursively passed down rm callback\r\n                // increase the listeners count\r\n                rm.listeners += listeners;\r\n            }\r\n            else {\r\n                // directly removing\r\n                rm = createRmCb(vnode.elm, listeners);\r\n            }\r\n            // recursively invoke hooks on child component root node\r\n            if (isDef((i_3 = vnode.componentInstance)) &&\r\n                isDef((i_3 = i_3._vnode)) &&\r\n                isDef(i_3.data)) {\r\n                removeAndInvokeRemoveHook(i_3, rm);\r\n            }\r\n            for (i_3 = 0; i_3 < cbs.remove.length; ++i_3) {\r\n                cbs.remove[i_3](vnode, rm);\r\n            }\r\n            if (isDef((i_3 = vnode.data.hook)) && isDef((i_3 = i_3.remove))) {\r\n                i_3(vnode, rm);\r\n            }\r\n            else {\r\n                rm();\r\n            }\r\n        }\r\n        else {\r\n            removeNode(vnode.elm);\r\n        }\r\n    }\r\n    function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\r\n        var oldStartIdx = 0;\r\n        var newStartIdx = 0;\r\n        var oldEndIdx = oldCh.length - 1;\r\n        var oldStartVnode = oldCh[0];\r\n        var oldEndVnode = oldCh[oldEndIdx];\r\n        var newEndIdx = newCh.length - 1;\r\n        var newStartVnode = newCh[0];\r\n        var newEndVnode = newCh[newEndIdx];\r\n        var oldKeyToIdx, idxInOld, vnodeToMove, refElm;\r\n        // removeOnly is a special flag used only by <transition-group>\r\n        // to ensure removed elements stay in correct relative positions\r\n        // during leaving transitions\r\n        var canMove = !removeOnly;\r\n        if (true) {\r\n            checkDuplicateKeys(newCh);\r\n        }\r\n        while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\r\n            if (isUndef(oldStartVnode)) {\r\n                oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\r\n            }\r\n            else if (isUndef(oldEndVnode)) {\r\n                oldEndVnode = oldCh[--oldEndIdx];\r\n            }\r\n            else if (sameVnode(oldStartVnode, newStartVnode)) {\r\n                patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\r\n                oldStartVnode = oldCh[++oldStartIdx];\r\n                newStartVnode = newCh[++newStartIdx];\r\n            }\r\n            else if (sameVnode(oldEndVnode, newEndVnode)) {\r\n                patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\r\n                oldEndVnode = oldCh[--oldEndIdx];\r\n                newEndVnode = newCh[--newEndIdx];\r\n            }\r\n            else if (sameVnode(oldStartVnode, newEndVnode)) {\r\n                // Vnode moved right\r\n                patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\r\n                canMove &&\r\n                    nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\r\n                oldStartVnode = oldCh[++oldStartIdx];\r\n                newEndVnode = newCh[--newEndIdx];\r\n            }\r\n            else if (sameVnode(oldEndVnode, newStartVnode)) {\r\n                // Vnode moved left\r\n                patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\r\n                canMove &&\r\n                    nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\r\n                oldEndVnode = oldCh[--oldEndIdx];\r\n                newStartVnode = newCh[++newStartIdx];\r\n            }\r\n            else {\r\n                if (isUndef(oldKeyToIdx))\r\n                    oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\r\n                idxInOld = isDef(newStartVnode.key)\r\n                    ? oldKeyToIdx[newStartVnode.key]\r\n                    : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);\r\n                if (isUndef(idxInOld)) {\r\n                    // New element\r\n                    createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\r\n                }\r\n                else {\r\n                    vnodeToMove = oldCh[idxInOld];\r\n                    if (sameVnode(vnodeToMove, newStartVnode)) {\r\n                        patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\r\n                        oldCh[idxInOld] = undefined;\r\n                        canMove &&\r\n                            nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);\r\n                    }\r\n                    else {\r\n                        // same key but different element. treat as new element\r\n                        createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\r\n                    }\r\n                }\r\n                newStartVnode = newCh[++newStartIdx];\r\n            }\r\n        }\r\n        if (oldStartIdx > oldEndIdx) {\r\n            refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\r\n            addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\r\n        }\r\n        else if (newStartIdx > newEndIdx) {\r\n            removeVnodes(oldCh, oldStartIdx, oldEndIdx);\r\n        }\r\n    }\r\n    function checkDuplicateKeys(children) {\r\n        var seenKeys = {};\r\n        for (var i_4 = 0; i_4 < children.length; i_4++) {\r\n            var vnode = children[i_4];\r\n            var key = vnode.key;\r\n            if (isDef(key)) {\r\n                if (seenKeys[key]) {\r\n                    warn$2(\"Duplicate keys detected: '\".concat(key, \"'. This may cause an update error.\"), vnode.context);\r\n                }\r\n                else {\r\n                    seenKeys[key] = true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    function findIdxInOld(node, oldCh, start, end) {\r\n        for (var i_5 = start; i_5 < end; i_5++) {\r\n            var c = oldCh[i_5];\r\n            if (isDef(c) && sameVnode(node, c))\r\n                return i_5;\r\n        }\r\n    }\r\n    function patchVnode(oldVnode, vnode, insertedVnodeQueue, ownerArray, index, removeOnly) {\r\n        if (oldVnode === vnode) {\r\n            return;\r\n        }\r\n        if (isDef(vnode.elm) && isDef(ownerArray)) {\r\n            // clone reused vnode\r\n            vnode = ownerArray[index] = cloneVNode(vnode);\r\n        }\r\n        var elm = (vnode.elm = oldVnode.elm);\r\n        if (isTrue(oldVnode.isAsyncPlaceholder)) {\r\n            if (isDef(vnode.asyncFactory.resolved)) {\r\n                hydrate(oldVnode.elm, vnode, insertedVnodeQueue);\r\n            }\r\n            else {\r\n                vnode.isAsyncPlaceholder = true;\r\n            }\r\n            return;\r\n        }\r\n        // reuse element for static trees.\r\n        // note we only do this if the vnode is cloned -\r\n        // if the new node is not cloned it means the render functions have been\r\n        // reset by the hot-reload-api and we need to do a proper re-render.\r\n        if (isTrue(vnode.isStatic) &&\r\n            isTrue(oldVnode.isStatic) &&\r\n            vnode.key === oldVnode.key &&\r\n            (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {\r\n            vnode.componentInstance = oldVnode.componentInstance;\r\n            return;\r\n        }\r\n        var i;\r\n        var data = vnode.data;\r\n        if (isDef(data) && isDef((i = data.hook)) && isDef((i = i.prepatch))) {\r\n            i(oldVnode, vnode);\r\n        }\r\n        var oldCh = oldVnode.children;\r\n        var ch = vnode.children;\r\n        if (isDef(data) && isPatchable(vnode)) {\r\n            for (i = 0; i < cbs.update.length; ++i)\r\n                cbs.update[i](oldVnode, vnode);\r\n            if (isDef((i = data.hook)) && isDef((i = i.update)))\r\n                i(oldVnode, vnode);\r\n        }\r\n        if (isUndef(vnode.text)) {\r\n            if (isDef(oldCh) && isDef(ch)) {\r\n                if (oldCh !== ch)\r\n                    updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);\r\n            }\r\n            else if (isDef(ch)) {\r\n                if (true) {\r\n                    checkDuplicateKeys(ch);\r\n                }\r\n                if (isDef(oldVnode.text))\r\n                    nodeOps.setTextContent(elm, '');\r\n                addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\r\n            }\r\n            else if (isDef(oldCh)) {\r\n                removeVnodes(oldCh, 0, oldCh.length - 1);\r\n            }\r\n            else if (isDef(oldVnode.text)) {\r\n                nodeOps.setTextContent(elm, '');\r\n            }\r\n        }\r\n        else if (oldVnode.text !== vnode.text) {\r\n            nodeOps.setTextContent(elm, vnode.text);\r\n        }\r\n        if (isDef(data)) {\r\n            if (isDef((i = data.hook)) && isDef((i = i.postpatch)))\r\n                i(oldVnode, vnode);\r\n        }\r\n    }\r\n    function invokeInsertHook(vnode, queue, initial) {\r\n        // delay insert hooks for component root nodes, invoke them after the\r\n        // element is really inserted\r\n        if (isTrue(initial) && isDef(vnode.parent)) {\r\n            vnode.parent.data.pendingInsert = queue;\r\n        }\r\n        else {\r\n            for (var i_6 = 0; i_6 < queue.length; ++i_6) {\r\n                queue[i_6].data.hook.insert(queue[i_6]);\r\n            }\r\n        }\r\n    }\r\n    var hydrationBailed = false;\r\n    // list of modules that can skip create hook during hydration because they\r\n    // are already rendered on the client or has no need for initialization\r\n    // Note: style is excluded because it relies on initial clone for future\r\n    // deep updates (#7063).\r\n    var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');\r\n    // Note: this is a browser-only function so we can assume elms are DOM nodes.\r\n    function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {\r\n        var i;\r\n        var tag = vnode.tag, data = vnode.data, children = vnode.children;\r\n        inVPre = inVPre || (data && data.pre);\r\n        vnode.elm = elm;\r\n        if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {\r\n            vnode.isAsyncPlaceholder = true;\r\n            return true;\r\n        }\r\n        // assert node match\r\n        if (true) {\r\n            if (!assertNodeMatch(elm, vnode, inVPre)) {\r\n                return false;\r\n            }\r\n        }\r\n        if (isDef(data)) {\r\n            if (isDef((i = data.hook)) && isDef((i = i.init)))\r\n                i(vnode, true /* hydrating */);\r\n            if (isDef((i = vnode.componentInstance))) {\r\n                // child component. it should have hydrated its own tree.\r\n                initComponent(vnode, insertedVnodeQueue);\r\n                return true;\r\n            }\r\n        }\r\n        if (isDef(tag)) {\r\n            if (isDef(children)) {\r\n                // empty element, allow client to pick up and populate children\r\n                if (!elm.hasChildNodes()) {\r\n                    createChildren(vnode, children, insertedVnodeQueue);\r\n                }\r\n                else {\r\n                    // v-html and domProps: innerHTML\r\n                    if (isDef((i = data)) &&\r\n                        isDef((i = i.domProps)) &&\r\n                        isDef((i = i.innerHTML))) {\r\n                        if (i !== elm.innerHTML) {\r\n                            /* istanbul ignore if */\r\n                            if ( true &&\r\n                                typeof console !== 'undefined' &&\r\n                                !hydrationBailed) {\r\n                                hydrationBailed = true;\r\n                                console.warn('Parent: ', elm);\r\n                                console.warn('server innerHTML: ', i);\r\n                                console.warn('client innerHTML: ', elm.innerHTML);\r\n                            }\r\n                            return false;\r\n                        }\r\n                    }\r\n                    else {\r\n                        // iterate and compare children lists\r\n                        var childrenMatch = true;\r\n                        var childNode = elm.firstChild;\r\n                        for (var i_7 = 0; i_7 < children.length; i_7++) {\r\n                            if (!childNode ||\r\n                                !hydrate(childNode, children[i_7], insertedVnodeQueue, inVPre)) {\r\n                                childrenMatch = false;\r\n                                break;\r\n                            }\r\n                            childNode = childNode.nextSibling;\r\n                        }\r\n                        // if childNode is not null, it means the actual childNodes list is\r\n                        // longer than the virtual children list.\r\n                        if (!childrenMatch || childNode) {\r\n                            /* istanbul ignore if */\r\n                            if ( true &&\r\n                                typeof console !== 'undefined' &&\r\n                                !hydrationBailed) {\r\n                                hydrationBailed = true;\r\n                                console.warn('Parent: ', elm);\r\n                                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\r\n                            }\r\n                            return false;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (isDef(data)) {\r\n                var fullInvoke = false;\r\n                for (var key in data) {\r\n                    if (!isRenderedModule(key)) {\r\n                        fullInvoke = true;\r\n                        invokeCreateHooks(vnode, insertedVnodeQueue);\r\n                        break;\r\n                    }\r\n                }\r\n                if (!fullInvoke && data['class']) {\r\n                    // ensure collecting deps for deep class bindings for future updates\r\n                    traverse(data['class']);\r\n                }\r\n            }\r\n        }\r\n        else if (elm.data !== vnode.text) {\r\n            elm.data = vnode.text;\r\n        }\r\n        return true;\r\n    }\r\n    function assertNodeMatch(node, vnode, inVPre) {\r\n        if (isDef(vnode.tag)) {\r\n            return (vnode.tag.indexOf('vue-component') === 0 ||\r\n                (!isUnknownElement(vnode, inVPre) &&\r\n                    vnode.tag.toLowerCase() ===\r\n                        (node.tagName && node.tagName.toLowerCase())));\r\n        }\r\n        else {\r\n            return node.nodeType === (vnode.isComment ? 8 : 3);\r\n        }\r\n    }\r\n    return function patch(oldVnode, vnode, hydrating, removeOnly) {\r\n        if (isUndef(vnode)) {\r\n            if (isDef(oldVnode))\r\n                invokeDestroyHook(oldVnode);\r\n            return;\r\n        }\r\n        var isInitialPatch = false;\r\n        var insertedVnodeQueue = [];\r\n        if (isUndef(oldVnode)) {\r\n            // empty mount (likely as component), create new root element\r\n            isInitialPatch = true;\r\n            createElm(vnode, insertedVnodeQueue);\r\n        }\r\n        else {\r\n            var isRealElement = isDef(oldVnode.nodeType);\r\n            if (!isRealElement && sameVnode(oldVnode, vnode)) {\r\n                // patch existing root node\r\n                patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);\r\n            }\r\n            else {\r\n                if (isRealElement) {\r\n                    // mounting to a real element\r\n                    // check if this is server-rendered content and if we can perform\r\n                    // a successful hydration.\r\n                    if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\r\n                        oldVnode.removeAttribute(SSR_ATTR);\r\n                        hydrating = true;\r\n                    }\r\n                    if (isTrue(hydrating)) {\r\n                        if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\r\n                            invokeInsertHook(vnode, insertedVnodeQueue, true);\r\n                            return oldVnode;\r\n                        }\r\n                        else if (true) {\r\n                            warn$2('The client-side rendered virtual DOM tree is not matching ' +\r\n                                'server-rendered content. This is likely caused by incorrect ' +\r\n                                'HTML markup, for example nesting block-level elements inside ' +\r\n                                '<p>, or missing <tbody>. Bailing hydration and performing ' +\r\n                                'full client-side render.');\r\n                        }\r\n                    }\r\n                    // either not server-rendered, or hydration failed.\r\n                    // create an empty node and replace it\r\n                    oldVnode = emptyNodeAt(oldVnode);\r\n                }\r\n                // replacing existing element\r\n                var oldElm = oldVnode.elm;\r\n                var parentElm = nodeOps.parentNode(oldElm);\r\n                // create new node\r\n                createElm(vnode, insertedVnodeQueue, \r\n                // extremely rare edge case: do not insert if old element is in a\r\n                // leaving transition. Only happens when combining transition +\r\n                // keep-alive + HOCs. (#4590)\r\n                oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm));\r\n                // update parent placeholder node element, recursively\r\n                if (isDef(vnode.parent)) {\r\n                    var ancestor = vnode.parent;\r\n                    var patchable = isPatchable(vnode);\r\n                    while (ancestor) {\r\n                        for (var i_8 = 0; i_8 < cbs.destroy.length; ++i_8) {\r\n                            cbs.destroy[i_8](ancestor);\r\n                        }\r\n                        ancestor.elm = vnode.elm;\r\n                        if (patchable) {\r\n                            for (var i_9 = 0; i_9 < cbs.create.length; ++i_9) {\r\n                                cbs.create[i_9](emptyNode, ancestor);\r\n                            }\r\n                            // #6513\r\n                            // invoke insert hooks that may have been merged by create hooks.\r\n                            // e.g. for directives that uses the \"inserted\" hook.\r\n                            var insert_1 = ancestor.data.hook.insert;\r\n                            if (insert_1.merged) {\r\n                                // start at index 1 to avoid re-invoking component mounted hook\r\n                                for (var i_10 = 1; i_10 < insert_1.fns.length; i_10++) {\r\n                                    insert_1.fns[i_10]();\r\n                                }\r\n                            }\r\n                        }\r\n                        else {\r\n                            registerRef(ancestor);\r\n                        }\r\n                        ancestor = ancestor.parent;\r\n                    }\r\n                }\r\n                // destroy old node\r\n                if (isDef(parentElm)) {\r\n                    removeVnodes([oldVnode], 0, 0);\r\n                }\r\n                else if (isDef(oldVnode.tag)) {\r\n                    invokeDestroyHook(oldVnode);\r\n                }\r\n            }\r\n        }\r\n        invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\r\n        return vnode.elm;\r\n    };\r\n}\n\nvar directives$1 = {\r\n    create: updateDirectives,\r\n    update: updateDirectives,\r\n    destroy: function unbindDirectives(vnode) {\r\n        // @ts-expect-error emptyNode is not VNodeWithData\r\n        updateDirectives(vnode, emptyNode);\r\n    }\r\n};\r\nfunction updateDirectives(oldVnode, vnode) {\r\n    if (oldVnode.data.directives || vnode.data.directives) {\r\n        _update(oldVnode, vnode);\r\n    }\r\n}\r\nfunction _update(oldVnode, vnode) {\r\n    var isCreate = oldVnode === emptyNode;\r\n    var isDestroy = vnode === emptyNode;\r\n    var oldDirs = normalizeDirectives(oldVnode.data.directives, oldVnode.context);\r\n    var newDirs = normalizeDirectives(vnode.data.directives, vnode.context);\r\n    var dirsWithInsert = [];\r\n    var dirsWithPostpatch = [];\r\n    var key, oldDir, dir;\r\n    for (key in newDirs) {\r\n        oldDir = oldDirs[key];\r\n        dir = newDirs[key];\r\n        if (!oldDir) {\r\n            // new directive, bind\r\n            callHook(dir, 'bind', vnode, oldVnode);\r\n            if (dir.def && dir.def.inserted) {\r\n                dirsWithInsert.push(dir);\r\n            }\r\n        }\r\n        else {\r\n            // existing directive, update\r\n            dir.oldValue = oldDir.value;\r\n            dir.oldArg = oldDir.arg;\r\n            callHook(dir, 'update', vnode, oldVnode);\r\n            if (dir.def && dir.def.componentUpdated) {\r\n                dirsWithPostpatch.push(dir);\r\n            }\r\n        }\r\n    }\r\n    if (dirsWithInsert.length) {\r\n        var callInsert = function () {\r\n            for (var i = 0; i < dirsWithInsert.length; i++) {\r\n                callHook(dirsWithInsert[i], 'inserted', vnode, oldVnode);\r\n            }\r\n        };\r\n        if (isCreate) {\r\n            mergeVNodeHook(vnode, 'insert', callInsert);\r\n        }\r\n        else {\r\n            callInsert();\r\n        }\r\n    }\r\n    if (dirsWithPostpatch.length) {\r\n        mergeVNodeHook(vnode, 'postpatch', function () {\r\n            for (var i = 0; i < dirsWithPostpatch.length; i++) {\r\n                callHook(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\r\n            }\r\n        });\r\n    }\r\n    if (!isCreate) {\r\n        for (key in oldDirs) {\r\n            if (!newDirs[key]) {\r\n                // no longer present, unbind\r\n                callHook(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\r\n            }\r\n        }\r\n    }\r\n}\r\nvar emptyModifiers = Object.create(null);\r\nfunction normalizeDirectives(dirs, vm) {\r\n    var res = Object.create(null);\r\n    if (!dirs) {\r\n        // $flow-disable-line\r\n        return res;\r\n    }\r\n    var i, dir;\r\n    for (i = 0; i < dirs.length; i++) {\r\n        dir = dirs[i];\r\n        if (!dir.modifiers) {\r\n            // $flow-disable-line\r\n            dir.modifiers = emptyModifiers;\r\n        }\r\n        res[getRawDirName(dir)] = dir;\r\n        if (vm._setupState && vm._setupState.__sfc) {\r\n            dir.def = dir.def || resolveAsset(vm, '_setupState', 'v-' + dir.name);\r\n        }\r\n        dir.def = dir.def || resolveAsset(vm.$options, 'directives', dir.name, true);\r\n    }\r\n    // $flow-disable-line\r\n    return res;\r\n}\r\nfunction getRawDirName(dir) {\r\n    return (dir.rawName || \"\".concat(dir.name, \".\").concat(Object.keys(dir.modifiers || {}).join('.')));\r\n}\r\nfunction callHook(dir, hook, vnode, oldVnode, isDestroy) {\r\n    var fn = dir.def && dir.def[hook];\r\n    if (fn) {\r\n        try {\r\n            fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\r\n        }\r\n        catch (e) {\r\n            handleError(e, vnode.context, \"directive \".concat(dir.name, \" \").concat(hook, \" hook\"));\r\n        }\r\n    }\r\n}\n\nvar baseModules = [ref, directives$1];\n\nfunction updateAttrs(oldVnode, vnode) {\r\n    var opts = vnode.componentOptions;\r\n    if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {\r\n        return;\r\n    }\r\n    if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {\r\n        return;\r\n    }\r\n    var key, cur, old;\r\n    var elm = vnode.elm;\r\n    var oldAttrs = oldVnode.data.attrs || {};\r\n    var attrs = vnode.data.attrs || {};\r\n    // clone observed objects, as the user probably wants to mutate it\r\n    if (isDef(attrs.__ob__) || isTrue(attrs._v_attr_proxy)) {\r\n        attrs = vnode.data.attrs = extend({}, attrs);\r\n    }\r\n    for (key in attrs) {\r\n        cur = attrs[key];\r\n        old = oldAttrs[key];\r\n        if (old !== cur) {\r\n            setAttr(elm, key, cur, vnode.data.pre);\r\n        }\r\n    }\r\n    // #4391: in IE9, setting type can reset value for input[type=radio]\r\n    // #6666: IE/Edge forces progress value down to 1 before setting a max\r\n    /* istanbul ignore if */\r\n    if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {\r\n        setAttr(elm, 'value', attrs.value);\r\n    }\r\n    for (key in oldAttrs) {\r\n        if (isUndef(attrs[key])) {\r\n            if (isXlink(key)) {\r\n                elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\r\n            }\r\n            else if (!isEnumeratedAttr(key)) {\r\n                elm.removeAttribute(key);\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction setAttr(el, key, value, isInPre) {\r\n    if (isInPre || el.tagName.indexOf('-') > -1) {\r\n        baseSetAttr(el, key, value);\r\n    }\r\n    else if (isBooleanAttr(key)) {\r\n        // set attribute for blank value\r\n        // e.g. <option disabled>Select one</option>\r\n        if (isFalsyAttrValue(value)) {\r\n            el.removeAttribute(key);\r\n        }\r\n        else {\r\n            // technically allowfullscreen is a boolean attribute for <iframe>,\r\n            // but Flash expects a value of \"true\" when used on <embed> tag\r\n            value = key === 'allowfullscreen' && el.tagName === 'EMBED' ? 'true' : key;\r\n            el.setAttribute(key, value);\r\n        }\r\n    }\r\n    else if (isEnumeratedAttr(key)) {\r\n        el.setAttribute(key, convertEnumeratedValue(key, value));\r\n    }\r\n    else if (isXlink(key)) {\r\n        if (isFalsyAttrValue(value)) {\r\n            el.removeAttributeNS(xlinkNS, getXlinkProp(key));\r\n        }\r\n        else {\r\n            el.setAttributeNS(xlinkNS, key, value);\r\n        }\r\n    }\r\n    else {\r\n        baseSetAttr(el, key, value);\r\n    }\r\n}\r\nfunction baseSetAttr(el, key, value) {\r\n    if (isFalsyAttrValue(value)) {\r\n        el.removeAttribute(key);\r\n    }\r\n    else {\r\n        // #7138: IE10 & 11 fires input event when setting placeholder on\r\n        // <textarea>... block the first input event and remove the blocker\r\n        // immediately.\r\n        /* istanbul ignore if */\r\n        if (isIE &&\r\n            !isIE9 &&\r\n            el.tagName === 'TEXTAREA' &&\r\n            key === 'placeholder' &&\r\n            value !== '' &&\r\n            !el.__ieph) {\r\n            var blocker_1 = function (e) {\r\n                e.stopImmediatePropagation();\r\n                el.removeEventListener('input', blocker_1);\r\n            };\r\n            el.addEventListener('input', blocker_1);\r\n            // $flow-disable-line\r\n            el.__ieph = true; /* IE placeholder patched */\r\n        }\r\n        el.setAttribute(key, value);\r\n    }\r\n}\r\nvar attrs = {\r\n    create: updateAttrs,\r\n    update: updateAttrs\r\n};\n\nfunction updateClass(oldVnode, vnode) {\r\n    var el = vnode.elm;\r\n    var data = vnode.data;\r\n    var oldData = oldVnode.data;\r\n    if (isUndef(data.staticClass) &&\r\n        isUndef(data.class) &&\r\n        (isUndef(oldData) ||\r\n            (isUndef(oldData.staticClass) && isUndef(oldData.class)))) {\r\n        return;\r\n    }\r\n    var cls = genClassForVnode(vnode);\r\n    // handle transition classes\r\n    var transitionClass = el._transitionClasses;\r\n    if (isDef(transitionClass)) {\r\n        cls = concat(cls, stringifyClass(transitionClass));\r\n    }\r\n    // set the class\r\n    if (cls !== el._prevClass) {\r\n        el.setAttribute('class', cls);\r\n        el._prevClass = cls;\r\n    }\r\n}\r\nvar klass$1 = {\r\n    create: updateClass,\r\n    update: updateClass\r\n};\n\nvar validDivisionCharRE = /[\\w).+\\-_$\\]]/;\r\nfunction parseFilters(exp) {\r\n    var inSingle = false;\r\n    var inDouble = false;\r\n    var inTemplateString = false;\r\n    var inRegex = false;\r\n    var curly = 0;\r\n    var square = 0;\r\n    var paren = 0;\r\n    var lastFilterIndex = 0;\r\n    var c, prev, i, expression, filters;\r\n    for (i = 0; i < exp.length; i++) {\r\n        prev = c;\r\n        c = exp.charCodeAt(i);\r\n        if (inSingle) {\r\n            if (c === 0x27 && prev !== 0x5c)\r\n                inSingle = false;\r\n        }\r\n        else if (inDouble) {\r\n            if (c === 0x22 && prev !== 0x5c)\r\n                inDouble = false;\r\n        }\r\n        else if (inTemplateString) {\r\n            if (c === 0x60 && prev !== 0x5c)\r\n                inTemplateString = false;\r\n        }\r\n        else if (inRegex) {\r\n            if (c === 0x2f && prev !== 0x5c)\r\n                inRegex = false;\r\n        }\r\n        else if (c === 0x7c && // pipe\r\n            exp.charCodeAt(i + 1) !== 0x7c &&\r\n            exp.charCodeAt(i - 1) !== 0x7c &&\r\n            !curly &&\r\n            !square &&\r\n            !paren) {\r\n            if (expression === undefined) {\r\n                // first filter, end of expression\r\n                lastFilterIndex = i + 1;\r\n                expression = exp.slice(0, i).trim();\r\n            }\r\n            else {\r\n                pushFilter();\r\n            }\r\n        }\r\n        else {\r\n            switch (c) {\r\n                case 0x22:\r\n                    inDouble = true;\r\n                    break; // \"\r\n                case 0x27:\r\n                    inSingle = true;\r\n                    break; // '\r\n                case 0x60:\r\n                    inTemplateString = true;\r\n                    break; // `\r\n                case 0x28:\r\n                    paren++;\r\n                    break; // (\r\n                case 0x29:\r\n                    paren--;\r\n                    break; // )\r\n                case 0x5b:\r\n                    square++;\r\n                    break; // [\r\n                case 0x5d:\r\n                    square--;\r\n                    break; // ]\r\n                case 0x7b:\r\n                    curly++;\r\n                    break; // {\r\n                case 0x7d:\r\n                    curly--;\r\n                    break; // }\r\n            }\r\n            if (c === 0x2f) {\r\n                // /\r\n                var j = i - 1;\r\n                var p \r\n                // find first non-whitespace prev char\r\n                = void 0;\r\n                // find first non-whitespace prev char\r\n                for (; j >= 0; j--) {\r\n                    p = exp.charAt(j);\r\n                    if (p !== ' ')\r\n                        break;\r\n                }\r\n                if (!p || !validDivisionCharRE.test(p)) {\r\n                    inRegex = true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (expression === undefined) {\r\n        expression = exp.slice(0, i).trim();\r\n    }\r\n    else if (lastFilterIndex !== 0) {\r\n        pushFilter();\r\n    }\r\n    function pushFilter() {\r\n        (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\r\n        lastFilterIndex = i + 1;\r\n    }\r\n    if (filters) {\r\n        for (i = 0; i < filters.length; i++) {\r\n            expression = wrapFilter(expression, filters[i]);\r\n        }\r\n    }\r\n    return expression;\r\n}\r\nfunction wrapFilter(exp, filter) {\r\n    var i = filter.indexOf('(');\r\n    if (i < 0) {\r\n        // _f: resolveFilter\r\n        return \"_f(\\\"\".concat(filter, \"\\\")(\").concat(exp, \")\");\r\n    }\r\n    else {\r\n        var name_1 = filter.slice(0, i);\r\n        var args = filter.slice(i + 1);\r\n        return \"_f(\\\"\".concat(name_1, \"\\\")(\").concat(exp).concat(args !== ')' ? ',' + args : args);\r\n    }\r\n}\n\n/* eslint-disable no-unused-vars */\r\nfunction baseWarn(msg, range) {\r\n    console.error(\"[Vue compiler]: \".concat(msg));\r\n}\r\n/* eslint-enable no-unused-vars */\r\nfunction pluckModuleFunction(modules, key) {\r\n    return modules ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; }) : [];\r\n}\r\nfunction addProp(el, name, value, range, dynamic) {\r\n    (el.props || (el.props = [])).push(rangeSetItem({ name: name, value: value, dynamic: dynamic }, range));\r\n    el.plain = false;\r\n}\r\nfunction addAttr(el, name, value, range, dynamic) {\r\n    var attrs = dynamic\r\n        ? el.dynamicAttrs || (el.dynamicAttrs = [])\r\n        : el.attrs || (el.attrs = []);\r\n    attrs.push(rangeSetItem({ name: name, value: value, dynamic: dynamic }, range));\r\n    el.plain = false;\r\n}\r\n// add a raw attr (use this in preTransforms)\r\nfunction addRawAttr(el, name, value, range) {\r\n    el.attrsMap[name] = value;\r\n    el.attrsList.push(rangeSetItem({ name: name, value: value }, range));\r\n}\r\nfunction addDirective(el, name, rawName, value, arg, isDynamicArg, modifiers, range) {\r\n    (el.directives || (el.directives = [])).push(rangeSetItem({\r\n        name: name,\r\n        rawName: rawName,\r\n        value: value,\r\n        arg: arg,\r\n        isDynamicArg: isDynamicArg,\r\n        modifiers: modifiers\r\n    }, range));\r\n    el.plain = false;\r\n}\r\nfunction prependModifierMarker(symbol, name, dynamic) {\r\n    return dynamic ? \"_p(\".concat(name, \",\\\"\").concat(symbol, \"\\\")\") : symbol + name; // mark the event as captured\r\n}\r\nfunction addHandler(el, name, value, modifiers, important, warn, range, dynamic) {\r\n    modifiers = modifiers || emptyObject;\r\n    // warn prevent and passive modifier\r\n    /* istanbul ignore if */\r\n    if ( true && warn && modifiers.prevent && modifiers.passive) {\r\n        warn(\"passive and prevent can't be used together. \" +\r\n            \"Passive handler can't prevent default event.\", range);\r\n    }\r\n    // normalize click.right and click.middle since they don't actually fire\r\n    // this is technically browser-specific, but at least for now browsers are\r\n    // the only target envs that have right/middle clicks.\r\n    if (modifiers.right) {\r\n        if (dynamic) {\r\n            name = \"(\".concat(name, \")==='click'?'contextmenu':(\").concat(name, \")\");\r\n        }\r\n        else if (name === 'click') {\r\n            name = 'contextmenu';\r\n            delete modifiers.right;\r\n        }\r\n    }\r\n    else if (modifiers.middle) {\r\n        if (dynamic) {\r\n            name = \"(\".concat(name, \")==='click'?'mouseup':(\").concat(name, \")\");\r\n        }\r\n        else if (name === 'click') {\r\n            name = 'mouseup';\r\n        }\r\n    }\r\n    // check capture modifier\r\n    if (modifiers.capture) {\r\n        delete modifiers.capture;\r\n        name = prependModifierMarker('!', name, dynamic);\r\n    }\r\n    if (modifiers.once) {\r\n        delete modifiers.once;\r\n        name = prependModifierMarker('~', name, dynamic);\r\n    }\r\n    /* istanbul ignore if */\r\n    if (modifiers.passive) {\r\n        delete modifiers.passive;\r\n        name = prependModifierMarker('&', name, dynamic);\r\n    }\r\n    var events;\r\n    if (modifiers.native) {\r\n        delete modifiers.native;\r\n        events = el.nativeEvents || (el.nativeEvents = {});\r\n    }\r\n    else {\r\n        events = el.events || (el.events = {});\r\n    }\r\n    var newHandler = rangeSetItem({ value: value.trim(), dynamic: dynamic }, range);\r\n    if (modifiers !== emptyObject) {\r\n        newHandler.modifiers = modifiers;\r\n    }\r\n    var handlers = events[name];\r\n    /* istanbul ignore if */\r\n    if (Array.isArray(handlers)) {\r\n        important ? handlers.unshift(newHandler) : handlers.push(newHandler);\r\n    }\r\n    else if (handlers) {\r\n        events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\r\n    }\r\n    else {\r\n        events[name] = newHandler;\r\n    }\r\n    el.plain = false;\r\n}\r\nfunction getRawBindingAttr(el, name) {\r\n    return (el.rawAttrsMap[':' + name] ||\r\n        el.rawAttrsMap['v-bind:' + name] ||\r\n        el.rawAttrsMap[name]);\r\n}\r\nfunction getBindingAttr(el, name, getStatic) {\r\n    var dynamicValue = getAndRemoveAttr(el, ':' + name) || getAndRemoveAttr(el, 'v-bind:' + name);\r\n    if (dynamicValue != null) {\r\n        return parseFilters(dynamicValue);\r\n    }\r\n    else if (getStatic !== false) {\r\n        var staticValue = getAndRemoveAttr(el, name);\r\n        if (staticValue != null) {\r\n            return JSON.stringify(staticValue);\r\n        }\r\n    }\r\n}\r\n// note: this only removes the attr from the Array (attrsList) so that it\r\n// doesn't get processed by processAttrs.\r\n// By default it does NOT remove it from the map (attrsMap) because the map is\r\n// needed during codegen.\r\nfunction getAndRemoveAttr(el, name, removeFromMap) {\r\n    var val;\r\n    if ((val = el.attrsMap[name]) != null) {\r\n        var list = el.attrsList;\r\n        for (var i = 0, l = list.length; i < l; i++) {\r\n            if (list[i].name === name) {\r\n                list.splice(i, 1);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    if (removeFromMap) {\r\n        delete el.attrsMap[name];\r\n    }\r\n    return val;\r\n}\r\nfunction getAndRemoveAttrByRegex(el, name) {\r\n    var list = el.attrsList;\r\n    for (var i = 0, l = list.length; i < l; i++) {\r\n        var attr = list[i];\r\n        if (name.test(attr.name)) {\r\n            list.splice(i, 1);\r\n            return attr;\r\n        }\r\n    }\r\n}\r\nfunction rangeSetItem(item, range) {\r\n    if (range) {\r\n        if (range.start != null) {\r\n            item.start = range.start;\r\n        }\r\n        if (range.end != null) {\r\n            item.end = range.end;\r\n        }\r\n    }\r\n    return item;\r\n}\n\n/**\r\n * Cross-platform code generation for component v-model\r\n */\r\nfunction genComponentModel(el, value, modifiers) {\r\n    var _a = modifiers || {}, number = _a.number, trim = _a.trim;\r\n    var baseValueExpression = '$$v';\r\n    var valueExpression = baseValueExpression;\r\n    if (trim) {\r\n        valueExpression =\r\n            \"(typeof \".concat(baseValueExpression, \" === 'string'\") +\r\n                \"? \".concat(baseValueExpression, \".trim()\") +\r\n                \": \".concat(baseValueExpression, \")\");\r\n    }\r\n    if (number) {\r\n        valueExpression = \"_n(\".concat(valueExpression, \")\");\r\n    }\r\n    var assignment = genAssignmentCode(value, valueExpression);\r\n    el.model = {\r\n        value: \"(\".concat(value, \")\"),\r\n        expression: JSON.stringify(value),\r\n        callback: \"function (\".concat(baseValueExpression, \") {\").concat(assignment, \"}\")\r\n    };\r\n}\r\n/**\r\n * Cross-platform codegen helper for generating v-model value assignment code.\r\n */\r\nfunction genAssignmentCode(value, assignment) {\r\n    var res = parseModel(value);\r\n    if (res.key === null) {\r\n        return \"\".concat(value, \"=\").concat(assignment);\r\n    }\r\n    else {\r\n        return \"$set(\".concat(res.exp, \", \").concat(res.key, \", \").concat(assignment, \")\");\r\n    }\r\n}\r\n/**\r\n * Parse a v-model expression into a base path and a final key segment.\r\n * Handles both dot-path and possible square brackets.\r\n *\r\n * Possible cases:\r\n *\r\n * - test\r\n * - test[key]\r\n * - test[test1[key]]\r\n * - test[\"a\"][key]\r\n * - xxx.test[a[a].test1[key]]\r\n * - test.xxx.a[\"asa\"][test1[key]]\r\n *\r\n */\r\nvar len, str, chr, index, expressionPos, expressionEndPos;\r\nfunction parseModel(val) {\r\n    // Fix https://github.com/vuejs/vue/pull/7730\r\n    // allow v-model=\"obj.val \" (trailing whitespace)\r\n    val = val.trim();\r\n    len = val.length;\r\n    if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\r\n        index = val.lastIndexOf('.');\r\n        if (index > -1) {\r\n            return {\r\n                exp: val.slice(0, index),\r\n                key: '\"' + val.slice(index + 1) + '\"'\r\n            };\r\n        }\r\n        else {\r\n            return {\r\n                exp: val,\r\n                key: null\r\n            };\r\n        }\r\n    }\r\n    str = val;\r\n    index = expressionPos = expressionEndPos = 0;\r\n    while (!eof()) {\r\n        chr = next();\r\n        /* istanbul ignore if */\r\n        if (isStringStart(chr)) {\r\n            parseString(chr);\r\n        }\r\n        else if (chr === 0x5b) {\r\n            parseBracket(chr);\r\n        }\r\n    }\r\n    return {\r\n        exp: val.slice(0, expressionPos),\r\n        key: val.slice(expressionPos + 1, expressionEndPos)\r\n    };\r\n}\r\nfunction next() {\r\n    return str.charCodeAt(++index);\r\n}\r\nfunction eof() {\r\n    return index >= len;\r\n}\r\nfunction isStringStart(chr) {\r\n    return chr === 0x22 || chr === 0x27;\r\n}\r\nfunction parseBracket(chr) {\r\n    var inBracket = 1;\r\n    expressionPos = index;\r\n    while (!eof()) {\r\n        chr = next();\r\n        if (isStringStart(chr)) {\r\n            parseString(chr);\r\n            continue;\r\n        }\r\n        if (chr === 0x5b)\r\n            inBracket++;\r\n        if (chr === 0x5d)\r\n            inBracket--;\r\n        if (inBracket === 0) {\r\n            expressionEndPos = index;\r\n            break;\r\n        }\r\n    }\r\n}\r\nfunction parseString(chr) {\r\n    var stringQuote = chr;\r\n    while (!eof()) {\r\n        chr = next();\r\n        if (chr === stringQuote) {\r\n            break;\r\n        }\r\n    }\r\n}\n\nvar warn$1;\r\n// in some cases, the event used has to be determined at runtime\r\n// so we used some reserved tokens during compile.\r\nvar RANGE_TOKEN = '__r';\r\nvar CHECKBOX_RADIO_TOKEN = '__c';\r\nfunction model$1(el, dir, _warn) {\r\n    warn$1 = _warn;\r\n    var value = dir.value;\r\n    var modifiers = dir.modifiers;\r\n    var tag = el.tag;\r\n    var type = el.attrsMap.type;\r\n    if (true) {\r\n        // inputs with type=\"file\" are read only and setting the input's\r\n        // value will throw an error.\r\n        if (tag === 'input' && type === 'file') {\r\n            warn$1(\"<\".concat(el.tag, \" v-model=\\\"\").concat(value, \"\\\" type=\\\"file\\\">:\\n\") +\r\n                \"File inputs are read only. Use a v-on:change listener instead.\", el.rawAttrsMap['v-model']);\r\n        }\r\n    }\r\n    if (el.component) {\r\n        genComponentModel(el, value, modifiers);\r\n        // component v-model doesn't need extra runtime\r\n        return false;\r\n    }\r\n    else if (tag === 'select') {\r\n        genSelect(el, value, modifiers);\r\n    }\r\n    else if (tag === 'input' && type === 'checkbox') {\r\n        genCheckboxModel(el, value, modifiers);\r\n    }\r\n    else if (tag === 'input' && type === 'radio') {\r\n        genRadioModel(el, value, modifiers);\r\n    }\r\n    else if (tag === 'input' || tag === 'textarea') {\r\n        genDefaultModel(el, value, modifiers);\r\n    }\r\n    else if (!config.isReservedTag(tag)) {\r\n        genComponentModel(el, value, modifiers);\r\n        // component v-model doesn't need extra runtime\r\n        return false;\r\n    }\r\n    else if (true) {\r\n        warn$1(\"<\".concat(el.tag, \" v-model=\\\"\").concat(value, \"\\\">: \") +\r\n            \"v-model is not supported on this element type. \" +\r\n            \"If you are working with contenteditable, it's recommended to \" +\r\n            'wrap a library dedicated for that purpose inside a custom component.', el.rawAttrsMap['v-model']);\r\n    }\r\n    // ensure runtime directive metadata\r\n    return true;\r\n}\r\nfunction genCheckboxModel(el, value, modifiers) {\r\n    var number = modifiers && modifiers.number;\r\n    var valueBinding = getBindingAttr(el, 'value') || 'null';\r\n    var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\r\n    var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\r\n    addProp(el, 'checked', \"Array.isArray(\".concat(value, \")\") +\r\n        \"?_i(\".concat(value, \",\").concat(valueBinding, \")>-1\") +\r\n        (trueValueBinding === 'true'\r\n            ? \":(\".concat(value, \")\")\r\n            : \":_q(\".concat(value, \",\").concat(trueValueBinding, \")\")));\r\n    addHandler(el, 'change', \"var $$a=\".concat(value, \",\") +\r\n        '$$el=$event.target,' +\r\n        \"$$c=$$el.checked?(\".concat(trueValueBinding, \"):(\").concat(falseValueBinding, \");\") +\r\n        'if(Array.isArray($$a)){' +\r\n        \"var $$v=\".concat(number ? '_n(' + valueBinding + ')' : valueBinding, \",\") +\r\n        '$$i=_i($$a,$$v);' +\r\n        \"if($$el.checked){$$i<0&&(\".concat(genAssignmentCode(value, '$$a.concat([$$v])'), \")}\") +\r\n        \"else{$$i>-1&&(\".concat(genAssignmentCode(value, '$$a.slice(0,$$i).concat($$a.slice($$i+1))'), \")}\") +\r\n        \"}else{\".concat(genAssignmentCode(value, '$$c'), \"}\"), null, true);\r\n}\r\nfunction genRadioModel(el, value, modifiers) {\r\n    var number = modifiers && modifiers.number;\r\n    var valueBinding = getBindingAttr(el, 'value') || 'null';\r\n    valueBinding = number ? \"_n(\".concat(valueBinding, \")\") : valueBinding;\r\n    addProp(el, 'checked', \"_q(\".concat(value, \",\").concat(valueBinding, \")\"));\r\n    addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);\r\n}\r\nfunction genSelect(el, value, modifiers) {\r\n    var number = modifiers && modifiers.number;\r\n    var selectedVal = \"Array.prototype.filter\" +\r\n        \".call($event.target.options,function(o){return o.selected})\" +\r\n        \".map(function(o){var val = \\\"_value\\\" in o ? o._value : o.value;\" +\r\n        \"return \".concat(number ? '_n(val)' : 'val', \"})\");\r\n    var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';\r\n    var code = \"var $$selectedVal = \".concat(selectedVal, \";\");\r\n    code = \"\".concat(code, \" \").concat(genAssignmentCode(value, assignment));\r\n    addHandler(el, 'change', code, null, true);\r\n}\r\nfunction genDefaultModel(el, value, modifiers) {\r\n    var type = el.attrsMap.type;\r\n    // warn if v-bind:value conflicts with v-model\r\n    // except for inputs with v-bind:type\r\n    if (true) {\r\n        var value_1 = el.attrsMap['v-bind:value'] || el.attrsMap[':value'];\r\n        var typeBinding = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];\r\n        if (value_1 && !typeBinding) {\r\n            var binding = el.attrsMap['v-bind:value'] ? 'v-bind:value' : ':value';\r\n            warn$1(\"\".concat(binding, \"=\\\"\").concat(value_1, \"\\\" conflicts with v-model on the same element \") +\r\n                'because the latter already expands to a value binding internally', el.rawAttrsMap[binding]);\r\n        }\r\n    }\r\n    var _a = modifiers || {}, lazy = _a.lazy, number = _a.number, trim = _a.trim;\r\n    var needCompositionGuard = !lazy && type !== 'range';\r\n    var event = lazy ? 'change' : type === 'range' ? RANGE_TOKEN : 'input';\r\n    var valueExpression = '$event.target.value';\r\n    if (trim) {\r\n        valueExpression = \"$event.target.value.trim()\";\r\n    }\r\n    if (number) {\r\n        valueExpression = \"_n(\".concat(valueExpression, \")\");\r\n    }\r\n    var code = genAssignmentCode(value, valueExpression);\r\n    if (needCompositionGuard) {\r\n        code = \"if($event.target.composing)return;\".concat(code);\r\n    }\r\n    addProp(el, 'value', \"(\".concat(value, \")\"));\r\n    addHandler(el, event, code, null, true);\r\n    if (trim || number) {\r\n        addHandler(el, 'blur', '$forceUpdate()');\r\n    }\r\n}\n\n// normalize v-model event tokens that can only be determined at runtime.\r\n// it's important to place the event as the first in the array because\r\n// the whole point is ensuring the v-model callback gets called before\r\n// user-attached handlers.\r\nfunction normalizeEvents(on) {\r\n    /* istanbul ignore if */\r\n    if (isDef(on[RANGE_TOKEN])) {\r\n        // IE input[type=range] only supports `change` event\r\n        var event_1 = isIE ? 'change' : 'input';\r\n        on[event_1] = [].concat(on[RANGE_TOKEN], on[event_1] || []);\r\n        delete on[RANGE_TOKEN];\r\n    }\r\n    // This was originally intended to fix #4521 but no longer necessary\r\n    // after 2.5. Keeping it for backwards compat with generated code from < 2.4\r\n    /* istanbul ignore if */\r\n    if (isDef(on[CHECKBOX_RADIO_TOKEN])) {\r\n        on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);\r\n        delete on[CHECKBOX_RADIO_TOKEN];\r\n    }\r\n}\r\nvar target;\r\nfunction createOnceHandler(event, handler, capture) {\r\n    var _target = target; // save current target element in closure\r\n    return function onceHandler() {\r\n        var res = handler.apply(null, arguments);\r\n        if (res !== null) {\r\n            remove(event, onceHandler, capture, _target);\r\n        }\r\n    };\r\n}\r\n// #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp\r\n// implementation and does not fire microtasks in between event propagation, so\r\n// safe to exclude.\r\nvar useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);\r\nfunction add(name, handler, capture, passive) {\r\n    // async edge case #6566: inner click event triggers patch, event handler\r\n    // attached to outer element during patch, and triggered again. This\r\n    // happens because browsers fire microtask ticks between event propagation.\r\n    // the solution is simple: we save the timestamp when a handler is attached,\r\n    // and the handler would only fire if the event passed to it was fired\r\n    // AFTER it was attached.\r\n    if (useMicrotaskFix) {\r\n        var attachedTimestamp_1 = currentFlushTimestamp;\r\n        var original_1 = handler;\r\n        //@ts-expect-error\r\n        handler = original_1._wrapper = function (e) {\r\n            if (\r\n            // no bubbling, should always fire.\r\n            // this is just a safety net in case event.timeStamp is unreliable in\r\n            // certain weird environments...\r\n            e.target === e.currentTarget ||\r\n                // event is fired after handler attachment\r\n                e.timeStamp >= attachedTimestamp_1 ||\r\n                // bail for environments that have buggy event.timeStamp implementations\r\n                // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState\r\n                // #9681 QtWebEngine event.timeStamp is negative value\r\n                e.timeStamp <= 0 ||\r\n                // #9448 bail if event is fired in another document in a multi-page\r\n                // electron/nw.js app, since event.timeStamp will be using a different\r\n                // starting reference\r\n                e.target.ownerDocument !== document) {\r\n                return original_1.apply(this, arguments);\r\n            }\r\n        };\r\n    }\r\n    target.addEventListener(name, handler, supportsPassive ? { capture: capture, passive: passive } : capture);\r\n}\r\nfunction remove(name, handler, capture, _target) {\r\n    (_target || target).removeEventListener(name, \r\n    //@ts-expect-error\r\n    handler._wrapper || handler, capture);\r\n}\r\nfunction updateDOMListeners(oldVnode, vnode) {\r\n    if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {\r\n        return;\r\n    }\r\n    var on = vnode.data.on || {};\r\n    var oldOn = oldVnode.data.on || {};\r\n    // vnode is empty when removing all listeners,\r\n    // and use old vnode dom element\r\n    target = vnode.elm || oldVnode.elm;\r\n    normalizeEvents(on);\r\n    updateListeners(on, oldOn, add, remove, createOnceHandler, vnode.context);\r\n    target = undefined;\r\n}\r\nvar events = {\r\n    create: updateDOMListeners,\r\n    update: updateDOMListeners,\r\n    // @ts-expect-error emptyNode has actually data\r\n    destroy: function (vnode) { return updateDOMListeners(vnode, emptyNode); }\r\n};\n\nvar svgContainer;\r\nfunction updateDOMProps(oldVnode, vnode) {\r\n    if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {\r\n        return;\r\n    }\r\n    var key, cur;\r\n    var elm = vnode.elm;\r\n    var oldProps = oldVnode.data.domProps || {};\r\n    var props = vnode.data.domProps || {};\r\n    // clone observed objects, as the user probably wants to mutate it\r\n    if (isDef(props.__ob__) || isTrue(props._v_attr_proxy)) {\r\n        props = vnode.data.domProps = extend({}, props);\r\n    }\r\n    for (key in oldProps) {\r\n        if (!(key in props)) {\r\n            elm[key] = '';\r\n        }\r\n    }\r\n    for (key in props) {\r\n        cur = props[key];\r\n        // ignore children if the node has textContent or innerHTML,\r\n        // as these will throw away existing DOM nodes and cause removal errors\r\n        // on subsequent patches (#3360)\r\n        if (key === 'textContent' || key === 'innerHTML') {\r\n            if (vnode.children)\r\n                vnode.children.length = 0;\r\n            if (cur === oldProps[key])\r\n                continue;\r\n            // #6601 work around Chrome version <= 55 bug where single textNode\r\n            // replaced by innerHTML/textContent retains its parentNode property\r\n            if (elm.childNodes.length === 1) {\r\n                elm.removeChild(elm.childNodes[0]);\r\n            }\r\n        }\r\n        if (key === 'value' && elm.tagName !== 'PROGRESS') {\r\n            // store value as _value as well since\r\n            // non-string values will be stringified\r\n            elm._value = cur;\r\n            // avoid resetting cursor position when value is the same\r\n            var strCur = isUndef(cur) ? '' : String(cur);\r\n            if (shouldUpdateValue(elm, strCur)) {\r\n                elm.value = strCur;\r\n            }\r\n        }\r\n        else if (key === 'innerHTML' &&\r\n            isSVG(elm.tagName) &&\r\n            isUndef(elm.innerHTML)) {\r\n            // IE doesn't support innerHTML for SVG elements\r\n            svgContainer = svgContainer || document.createElement('div');\r\n            svgContainer.innerHTML = \"<svg>\".concat(cur, \"</svg>\");\r\n            var svg = svgContainer.firstChild;\r\n            while (elm.firstChild) {\r\n                elm.removeChild(elm.firstChild);\r\n            }\r\n            while (svg.firstChild) {\r\n                elm.appendChild(svg.firstChild);\r\n            }\r\n        }\r\n        else if (\r\n        // skip the update if old and new VDOM state is the same.\r\n        // `value` is handled separately because the DOM value may be temporarily\r\n        // out of sync with VDOM state due to focus, composition and modifiers.\r\n        // This  #4521 by skipping the unnecessary `checked` update.\r\n        cur !== oldProps[key]) {\r\n            // some property updates can throw\r\n            // e.g. `value` on <progress> w/ non-finite value\r\n            try {\r\n                elm[key] = cur;\r\n            }\r\n            catch (e) { }\r\n        }\r\n    }\r\n}\r\nfunction shouldUpdateValue(elm, checkVal) {\r\n    return (\r\n    //@ts-expect-error\r\n    !elm.composing &&\r\n        (elm.tagName === 'OPTION' ||\r\n            isNotInFocusAndDirty(elm, checkVal) ||\r\n            isDirtyWithModifiers(elm, checkVal)));\r\n}\r\nfunction isNotInFocusAndDirty(elm, checkVal) {\r\n    // return true when textbox (.number and .trim) loses focus and its value is\r\n    // not equal to the updated value\r\n    var notInFocus = true;\r\n    // #6157\r\n    // work around IE bug when accessing document.activeElement in an iframe\r\n    try {\r\n        notInFocus = document.activeElement !== elm;\r\n    }\r\n    catch (e) { }\r\n    return notInFocus && elm.value !== checkVal;\r\n}\r\nfunction isDirtyWithModifiers(elm, newVal) {\r\n    var value = elm.value;\r\n    var modifiers = elm._vModifiers; // injected by v-model runtime\r\n    if (isDef(modifiers)) {\r\n        if (modifiers.number) {\r\n            return toNumber(value) !== toNumber(newVal);\r\n        }\r\n        if (modifiers.trim) {\r\n            return value.trim() !== newVal.trim();\r\n        }\r\n    }\r\n    return value !== newVal;\r\n}\r\nvar domProps = {\r\n    create: updateDOMProps,\r\n    update: updateDOMProps\r\n};\n\nvar parseStyleText = cached(function (cssText) {\r\n    var res = {};\r\n    var listDelimiter = /;(?![^(]*\\))/g;\r\n    var propertyDelimiter = /:(.+)/;\r\n    cssText.split(listDelimiter).forEach(function (item) {\r\n        if (item) {\r\n            var tmp = item.split(propertyDelimiter);\r\n            tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\r\n        }\r\n    });\r\n    return res;\r\n});\r\n// merge static and dynamic style data on the same vnode\r\nfunction normalizeStyleData(data) {\r\n    var style = normalizeStyleBinding(data.style);\r\n    // static style is pre-processed into an object during compilation\r\n    // and is always a fresh object, so it's safe to merge into it\r\n    return data.staticStyle ? extend(data.staticStyle, style) : style;\r\n}\r\n// normalize possible array / string values into Object\r\nfunction normalizeStyleBinding(bindingStyle) {\r\n    if (Array.isArray(bindingStyle)) {\r\n        return toObject(bindingStyle);\r\n    }\r\n    if (typeof bindingStyle === 'string') {\r\n        return parseStyleText(bindingStyle);\r\n    }\r\n    return bindingStyle;\r\n}\r\n/**\r\n * parent component style should be after child's\r\n * so that parent component's style could override it\r\n */\r\nfunction getStyle(vnode, checkChild) {\r\n    var res = {};\r\n    var styleData;\r\n    if (checkChild) {\r\n        var childNode = vnode;\r\n        while (childNode.componentInstance) {\r\n            childNode = childNode.componentInstance._vnode;\r\n            if (childNode &&\r\n                childNode.data &&\r\n                (styleData = normalizeStyleData(childNode.data))) {\r\n                extend(res, styleData);\r\n            }\r\n        }\r\n    }\r\n    if ((styleData = normalizeStyleData(vnode.data))) {\r\n        extend(res, styleData);\r\n    }\r\n    var parentNode = vnode;\r\n    // @ts-expect-error parentNode.parent not VNodeWithData\r\n    while ((parentNode = parentNode.parent)) {\r\n        if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\r\n            extend(res, styleData);\r\n        }\r\n    }\r\n    return res;\r\n}\n\nvar cssVarRE = /^--/;\r\nvar importantRE = /\\s*!important$/;\r\nvar setProp = function (el, name, val) {\r\n    /* istanbul ignore if */\r\n    if (cssVarRE.test(name)) {\r\n        el.style.setProperty(name, val);\r\n    }\r\n    else if (importantRE.test(val)) {\r\n        el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');\r\n    }\r\n    else {\r\n        var normalizedName = normalize(name);\r\n        if (Array.isArray(val)) {\r\n            // Support values array created by autoprefixer, e.g.\r\n            // {display: [\"-webkit-box\", \"-ms-flexbox\", \"flex\"]}\r\n            // Set them one by one, and the browser will only set those it can recognize\r\n            for (var i = 0, len = val.length; i < len; i++) {\r\n                el.style[normalizedName] = val[i];\r\n            }\r\n        }\r\n        else {\r\n            el.style[normalizedName] = val;\r\n        }\r\n    }\r\n};\r\nvar vendorNames = ['Webkit', 'Moz', 'ms'];\r\nvar emptyStyle;\r\nvar normalize = cached(function (prop) {\r\n    emptyStyle = emptyStyle || document.createElement('div').style;\r\n    prop = camelize(prop);\r\n    if (prop !== 'filter' && prop in emptyStyle) {\r\n        return prop;\r\n    }\r\n    var capName = prop.charAt(0).toUpperCase() + prop.slice(1);\r\n    for (var i = 0; i < vendorNames.length; i++) {\r\n        var name_1 = vendorNames[i] + capName;\r\n        if (name_1 in emptyStyle) {\r\n            return name_1;\r\n        }\r\n    }\r\n});\r\nfunction updateStyle(oldVnode, vnode) {\r\n    var data = vnode.data;\r\n    var oldData = oldVnode.data;\r\n    if (isUndef(data.staticStyle) &&\r\n        isUndef(data.style) &&\r\n        isUndef(oldData.staticStyle) &&\r\n        isUndef(oldData.style)) {\r\n        return;\r\n    }\r\n    var cur, name;\r\n    var el = vnode.elm;\r\n    var oldStaticStyle = oldData.staticStyle;\r\n    var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};\r\n    // if static style exists, stylebinding already merged into it when doing normalizeStyleData\r\n    var oldStyle = oldStaticStyle || oldStyleBinding;\r\n    var style = normalizeStyleBinding(vnode.data.style) || {};\r\n    // store normalized style under a different key for next diff\r\n    // make sure to clone it if it's reactive, since the user likely wants\r\n    // to mutate it.\r\n    vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;\r\n    var newStyle = getStyle(vnode, true);\r\n    for (name in oldStyle) {\r\n        if (isUndef(newStyle[name])) {\r\n            setProp(el, name, '');\r\n        }\r\n    }\r\n    for (name in newStyle) {\r\n        cur = newStyle[name];\r\n        if (cur !== oldStyle[name]) {\r\n            // ie9 setting to null has no effect, must use empty string\r\n            setProp(el, name, cur == null ? '' : cur);\r\n        }\r\n    }\r\n}\r\nvar style$1 = {\r\n    create: updateStyle,\r\n    update: updateStyle\r\n};\n\nvar whitespaceRE$1 = /\\s+/;\r\n/**\r\n * Add class with compatibility for SVG since classList is not supported on\r\n * SVG elements in IE\r\n */\r\nfunction addClass(el, cls) {\r\n    /* istanbul ignore if */\r\n    if (!cls || !(cls = cls.trim())) {\r\n        return;\r\n    }\r\n    /* istanbul ignore else */\r\n    if (el.classList) {\r\n        if (cls.indexOf(' ') > -1) {\r\n            cls.split(whitespaceRE$1).forEach(function (c) { return el.classList.add(c); });\r\n        }\r\n        else {\r\n            el.classList.add(cls);\r\n        }\r\n    }\r\n    else {\r\n        var cur = \" \".concat(el.getAttribute('class') || '', \" \");\r\n        if (cur.indexOf(' ' + cls + ' ') < 0) {\r\n            el.setAttribute('class', (cur + cls).trim());\r\n        }\r\n    }\r\n}\r\n/**\r\n * Remove class with compatibility for SVG since classList is not supported on\r\n * SVG elements in IE\r\n */\r\nfunction removeClass(el, cls) {\r\n    /* istanbul ignore if */\r\n    if (!cls || !(cls = cls.trim())) {\r\n        return;\r\n    }\r\n    /* istanbul ignore else */\r\n    if (el.classList) {\r\n        if (cls.indexOf(' ') > -1) {\r\n            cls.split(whitespaceRE$1).forEach(function (c) { return el.classList.remove(c); });\r\n        }\r\n        else {\r\n            el.classList.remove(cls);\r\n        }\r\n        if (!el.classList.length) {\r\n            el.removeAttribute('class');\r\n        }\r\n    }\r\n    else {\r\n        var cur = \" \".concat(el.getAttribute('class') || '', \" \");\r\n        var tar = ' ' + cls + ' ';\r\n        while (cur.indexOf(tar) >= 0) {\r\n            cur = cur.replace(tar, ' ');\r\n        }\r\n        cur = cur.trim();\r\n        if (cur) {\r\n            el.setAttribute('class', cur);\r\n        }\r\n        else {\r\n            el.removeAttribute('class');\r\n        }\r\n    }\r\n}\n\nfunction resolveTransition(def) {\r\n    if (!def) {\r\n        return;\r\n    }\r\n    /* istanbul ignore else */\r\n    if (typeof def === 'object') {\r\n        var res = {};\r\n        if (def.css !== false) {\r\n            extend(res, autoCssTransition(def.name || 'v'));\r\n        }\r\n        extend(res, def);\r\n        return res;\r\n    }\r\n    else if (typeof def === 'string') {\r\n        return autoCssTransition(def);\r\n    }\r\n}\r\nvar autoCssTransition = cached(function (name) {\r\n    return {\r\n        enterClass: \"\".concat(name, \"-enter\"),\r\n        enterToClass: \"\".concat(name, \"-enter-to\"),\r\n        enterActiveClass: \"\".concat(name, \"-enter-active\"),\r\n        leaveClass: \"\".concat(name, \"-leave\"),\r\n        leaveToClass: \"\".concat(name, \"-leave-to\"),\r\n        leaveActiveClass: \"\".concat(name, \"-leave-active\")\r\n    };\r\n});\r\nvar hasTransition = inBrowser && !isIE9;\r\nvar TRANSITION = 'transition';\r\nvar ANIMATION = 'animation';\r\n// Transition property/event sniffing\r\nvar transitionProp = 'transition';\r\nvar transitionEndEvent = 'transitionend';\r\nvar animationProp = 'animation';\r\nvar animationEndEvent = 'animationend';\r\nif (hasTransition) {\r\n    /* istanbul ignore if */\r\n    if (window.ontransitionend === undefined &&\r\n        window.onwebkittransitionend !== undefined) {\r\n        transitionProp = 'WebkitTransition';\r\n        transitionEndEvent = 'webkitTransitionEnd';\r\n    }\r\n    if (window.onanimationend === undefined &&\r\n        window.onwebkitanimationend !== undefined) {\r\n        animationProp = 'WebkitAnimation';\r\n        animationEndEvent = 'webkitAnimationEnd';\r\n    }\r\n}\r\n// binding to window is necessary to make hot reload work in IE in strict mode\r\nvar raf = inBrowser\r\n    ? window.requestAnimationFrame\r\n        ? window.requestAnimationFrame.bind(window)\r\n        : setTimeout\r\n    : /* istanbul ignore next */ function (/* istanbul ignore next */ fn) { return fn(); };\r\nfunction nextFrame(fn) {\r\n    raf(function () {\r\n        // @ts-expect-error\r\n        raf(fn);\r\n    });\r\n}\r\nfunction addTransitionClass(el, cls) {\r\n    var transitionClasses = el._transitionClasses || (el._transitionClasses = []);\r\n    if (transitionClasses.indexOf(cls) < 0) {\r\n        transitionClasses.push(cls);\r\n        addClass(el, cls);\r\n    }\r\n}\r\nfunction removeTransitionClass(el, cls) {\r\n    if (el._transitionClasses) {\r\n        remove$2(el._transitionClasses, cls);\r\n    }\r\n    removeClass(el, cls);\r\n}\r\nfunction whenTransitionEnds(el, expectedType, cb) {\r\n    var _a = getTransitionInfo(el, expectedType), type = _a.type, timeout = _a.timeout, propCount = _a.propCount;\r\n    if (!type)\r\n        return cb();\r\n    var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\r\n    var ended = 0;\r\n    var end = function () {\r\n        el.removeEventListener(event, onEnd);\r\n        cb();\r\n    };\r\n    var onEnd = function (e) {\r\n        if (e.target === el) {\r\n            if (++ended >= propCount) {\r\n                end();\r\n            }\r\n        }\r\n    };\r\n    setTimeout(function () {\r\n        if (ended < propCount) {\r\n            end();\r\n        }\r\n    }, timeout + 1);\r\n    el.addEventListener(event, onEnd);\r\n}\r\nvar transformRE = /\\b(transform|all)(,|$)/;\r\nfunction getTransitionInfo(el, expectedType) {\r\n    var styles = window.getComputedStyle(el);\r\n    // JSDOM may return undefined for transition properties\r\n    var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');\r\n    var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');\r\n    var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\r\n    var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');\r\n    var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');\r\n    var animationTimeout = getTimeout(animationDelays, animationDurations);\r\n    var type;\r\n    var timeout = 0;\r\n    var propCount = 0;\r\n    /* istanbul ignore if */\r\n    if (expectedType === TRANSITION) {\r\n        if (transitionTimeout > 0) {\r\n            type = TRANSITION;\r\n            timeout = transitionTimeout;\r\n            propCount = transitionDurations.length;\r\n        }\r\n    }\r\n    else if (expectedType === ANIMATION) {\r\n        if (animationTimeout > 0) {\r\n            type = ANIMATION;\r\n            timeout = animationTimeout;\r\n            propCount = animationDurations.length;\r\n        }\r\n    }\r\n    else {\r\n        timeout = Math.max(transitionTimeout, animationTimeout);\r\n        type =\r\n            timeout > 0\r\n                ? transitionTimeout > animationTimeout\r\n                    ? TRANSITION\r\n                    : ANIMATION\r\n                : null;\r\n        propCount = type\r\n            ? type === TRANSITION\r\n                ? transitionDurations.length\r\n                : animationDurations.length\r\n            : 0;\r\n    }\r\n    var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);\r\n    return {\r\n        type: type,\r\n        timeout: timeout,\r\n        propCount: propCount,\r\n        hasTransform: hasTransform\r\n    };\r\n}\r\nfunction getTimeout(delays, durations) {\r\n    /* istanbul ignore next */\r\n    while (delays.length < durations.length) {\r\n        delays = delays.concat(delays);\r\n    }\r\n    return Math.max.apply(null, durations.map(function (d, i) {\r\n        return toMs(d) + toMs(delays[i]);\r\n    }));\r\n}\r\n// Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers\r\n// in a locale-dependent way, using a comma instead of a dot.\r\n// If comma is not replaced with a dot, the input will be rounded down (i.e. acting\r\n// as a floor function) causing unexpected behaviors\r\nfunction toMs(s) {\r\n    return Number(s.slice(0, -1).replace(',', '.')) * 1000;\r\n}\n\nfunction enter(vnode, toggleDisplay) {\r\n    var el = vnode.elm;\r\n    // call leave callback now\r\n    if (isDef(el._leaveCb)) {\r\n        el._leaveCb.cancelled = true;\r\n        el._leaveCb();\r\n    }\r\n    var data = resolveTransition(vnode.data.transition);\r\n    if (isUndef(data)) {\r\n        return;\r\n    }\r\n    /* istanbul ignore if */\r\n    if (isDef(el._enterCb) || el.nodeType !== 1) {\r\n        return;\r\n    }\r\n    var css = data.css, type = data.type, enterClass = data.enterClass, enterToClass = data.enterToClass, enterActiveClass = data.enterActiveClass, appearClass = data.appearClass, appearToClass = data.appearToClass, appearActiveClass = data.appearActiveClass, beforeEnter = data.beforeEnter, enter = data.enter, afterEnter = data.afterEnter, enterCancelled = data.enterCancelled, beforeAppear = data.beforeAppear, appear = data.appear, afterAppear = data.afterAppear, appearCancelled = data.appearCancelled, duration = data.duration;\r\n    // activeInstance will always be the <transition> component managing this\r\n    // transition. One edge case to check is when the <transition> is placed\r\n    // as the root node of a child component. In that case we need to check\r\n    // <transition>'s parent for appear check.\r\n    var context = activeInstance;\r\n    var transitionNode = activeInstance.$vnode;\r\n    while (transitionNode && transitionNode.parent) {\r\n        context = transitionNode.context;\r\n        transitionNode = transitionNode.parent;\r\n    }\r\n    var isAppear = !context._isMounted || !vnode.isRootInsert;\r\n    if (isAppear && !appear && appear !== '') {\r\n        return;\r\n    }\r\n    var startClass = isAppear && appearClass ? appearClass : enterClass;\r\n    var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;\r\n    var toClass = isAppear && appearToClass ? appearToClass : enterToClass;\r\n    var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;\r\n    var enterHook = isAppear ? (isFunction(appear) ? appear : enter) : enter;\r\n    var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;\r\n    var enterCancelledHook = isAppear\r\n        ? appearCancelled || enterCancelled\r\n        : enterCancelled;\r\n    var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);\r\n    if ( true && explicitEnterDuration != null) {\r\n        checkDuration(explicitEnterDuration, 'enter', vnode);\r\n    }\r\n    var expectsCSS = css !== false && !isIE9;\r\n    var userWantsControl = getHookArgumentsLength(enterHook);\r\n    var cb = (el._enterCb = once(function () {\r\n        if (expectsCSS) {\r\n            removeTransitionClass(el, toClass);\r\n            removeTransitionClass(el, activeClass);\r\n        }\r\n        // @ts-expect-error\r\n        if (cb.cancelled) {\r\n            if (expectsCSS) {\r\n                removeTransitionClass(el, startClass);\r\n            }\r\n            enterCancelledHook && enterCancelledHook(el);\r\n        }\r\n        else {\r\n            afterEnterHook && afterEnterHook(el);\r\n        }\r\n        el._enterCb = null;\r\n    }));\r\n    if (!vnode.data.show) {\r\n        // remove pending leave element on enter by injecting an insert hook\r\n        mergeVNodeHook(vnode, 'insert', function () {\r\n            var parent = el.parentNode;\r\n            var pendingNode = parent && parent._pending && parent._pending[vnode.key];\r\n            if (pendingNode &&\r\n                pendingNode.tag === vnode.tag &&\r\n                pendingNode.elm._leaveCb) {\r\n                pendingNode.elm._leaveCb();\r\n            }\r\n            enterHook && enterHook(el, cb);\r\n        });\r\n    }\r\n    // start enter transition\r\n    beforeEnterHook && beforeEnterHook(el);\r\n    if (expectsCSS) {\r\n        addTransitionClass(el, startClass);\r\n        addTransitionClass(el, activeClass);\r\n        nextFrame(function () {\r\n            removeTransitionClass(el, startClass);\r\n            // @ts-expect-error\r\n            if (!cb.cancelled) {\r\n                addTransitionClass(el, toClass);\r\n                if (!userWantsControl) {\r\n                    if (isValidDuration(explicitEnterDuration)) {\r\n                        setTimeout(cb, explicitEnterDuration);\r\n                    }\r\n                    else {\r\n                        whenTransitionEnds(el, type, cb);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n    if (vnode.data.show) {\r\n        toggleDisplay && toggleDisplay();\r\n        enterHook && enterHook(el, cb);\r\n    }\r\n    if (!expectsCSS && !userWantsControl) {\r\n        cb();\r\n    }\r\n}\r\nfunction leave(vnode, rm) {\r\n    var el = vnode.elm;\r\n    // call enter callback now\r\n    if (isDef(el._enterCb)) {\r\n        el._enterCb.cancelled = true;\r\n        el._enterCb();\r\n    }\r\n    var data = resolveTransition(vnode.data.transition);\r\n    if (isUndef(data) || el.nodeType !== 1) {\r\n        return rm();\r\n    }\r\n    /* istanbul ignore if */\r\n    if (isDef(el._leaveCb)) {\r\n        return;\r\n    }\r\n    var css = data.css, type = data.type, leaveClass = data.leaveClass, leaveToClass = data.leaveToClass, leaveActiveClass = data.leaveActiveClass, beforeLeave = data.beforeLeave, leave = data.leave, afterLeave = data.afterLeave, leaveCancelled = data.leaveCancelled, delayLeave = data.delayLeave, duration = data.duration;\r\n    var expectsCSS = css !== false && !isIE9;\r\n    var userWantsControl = getHookArgumentsLength(leave);\r\n    var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);\r\n    if ( true && isDef(explicitLeaveDuration)) {\r\n        checkDuration(explicitLeaveDuration, 'leave', vnode);\r\n    }\r\n    var cb = (el._leaveCb = once(function () {\r\n        if (el.parentNode && el.parentNode._pending) {\r\n            el.parentNode._pending[vnode.key] = null;\r\n        }\r\n        if (expectsCSS) {\r\n            removeTransitionClass(el, leaveToClass);\r\n            removeTransitionClass(el, leaveActiveClass);\r\n        }\r\n        // @ts-expect-error\r\n        if (cb.cancelled) {\r\n            if (expectsCSS) {\r\n                removeTransitionClass(el, leaveClass);\r\n            }\r\n            leaveCancelled && leaveCancelled(el);\r\n        }\r\n        else {\r\n            rm();\r\n            afterLeave && afterLeave(el);\r\n        }\r\n        el._leaveCb = null;\r\n    }));\r\n    if (delayLeave) {\r\n        delayLeave(performLeave);\r\n    }\r\n    else {\r\n        performLeave();\r\n    }\r\n    function performLeave() {\r\n        // the delayed leave may have already been cancelled\r\n        // @ts-expect-error\r\n        if (cb.cancelled) {\r\n            return;\r\n        }\r\n        // record leaving element\r\n        if (!vnode.data.show && el.parentNode) {\r\n            (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] =\r\n                vnode;\r\n        }\r\n        beforeLeave && beforeLeave(el);\r\n        if (expectsCSS) {\r\n            addTransitionClass(el, leaveClass);\r\n            addTransitionClass(el, leaveActiveClass);\r\n            nextFrame(function () {\r\n                removeTransitionClass(el, leaveClass);\r\n                // @ts-expect-error\r\n                if (!cb.cancelled) {\r\n                    addTransitionClass(el, leaveToClass);\r\n                    if (!userWantsControl) {\r\n                        if (isValidDuration(explicitLeaveDuration)) {\r\n                            setTimeout(cb, explicitLeaveDuration);\r\n                        }\r\n                        else {\r\n                            whenTransitionEnds(el, type, cb);\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        leave && leave(el, cb);\r\n        if (!expectsCSS && !userWantsControl) {\r\n            cb();\r\n        }\r\n    }\r\n}\r\n// only used in dev mode\r\nfunction checkDuration(val, name, vnode) {\r\n    if (typeof val !== 'number') {\r\n        warn$2(\"<transition> explicit \".concat(name, \" duration is not a valid number - \") +\r\n            \"got \".concat(JSON.stringify(val), \".\"), vnode.context);\r\n    }\r\n    else if (isNaN(val)) {\r\n        warn$2(\"<transition> explicit \".concat(name, \" duration is NaN - \") +\r\n            'the duration expression might be incorrect.', vnode.context);\r\n    }\r\n}\r\nfunction isValidDuration(val) {\r\n    return typeof val === 'number' && !isNaN(val);\r\n}\r\n/**\r\n * Normalize a transition hook's argument length. The hook may be:\r\n * - a merged hook (invoker) with the original in .fns\r\n * - a wrapped component method (check ._length)\r\n * - a plain function (.length)\r\n */\r\nfunction getHookArgumentsLength(fn) {\r\n    if (isUndef(fn)) {\r\n        return false;\r\n    }\r\n    // @ts-expect-error\r\n    var invokerFns = fn.fns;\r\n    if (isDef(invokerFns)) {\r\n        // invoker\r\n        return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);\r\n    }\r\n    else {\r\n        // @ts-expect-error\r\n        return (fn._length || fn.length) > 1;\r\n    }\r\n}\r\nfunction _enter(_, vnode) {\r\n    if (vnode.data.show !== true) {\r\n        enter(vnode);\r\n    }\r\n}\r\nvar transition = inBrowser\r\n    ? {\r\n        create: _enter,\r\n        activate: _enter,\r\n        remove: function (vnode, rm) {\r\n            /* istanbul ignore else */\r\n            if (vnode.data.show !== true) {\r\n                // @ts-expect-error\r\n                leave(vnode, rm);\r\n            }\r\n            else {\r\n                rm();\r\n            }\r\n        }\r\n    }\r\n    : {};\n\nvar platformModules = [attrs, klass$1, events, domProps, style$1, transition];\n\n// the directive module should be applied last, after all\r\n// built-in modules have been applied.\r\nvar modules$1 = platformModules.concat(baseModules);\r\nvar patch = createPatchFunction({ nodeOps: nodeOps, modules: modules$1 });\n\n/**\r\n * Not type checking this file because flow doesn't like attaching\r\n * properties to Elements.\r\n */\r\n/* istanbul ignore if */\r\nif (isIE9) {\r\n    // http://www.matts411.com/post/internet-explorer-9-oninput/\r\n    document.addEventListener('selectionchange', function () {\r\n        var el = document.activeElement;\r\n        // @ts-expect-error\r\n        if (el && el.vmodel) {\r\n            trigger(el, 'input');\r\n        }\r\n    });\r\n}\r\nvar directive = {\r\n    inserted: function (el, binding, vnode, oldVnode) {\r\n        if (vnode.tag === 'select') {\r\n            // #6903\r\n            if (oldVnode.elm && !oldVnode.elm._vOptions) {\r\n                mergeVNodeHook(vnode, 'postpatch', function () {\r\n                    directive.componentUpdated(el, binding, vnode);\r\n                });\r\n            }\r\n            else {\r\n                setSelected(el, binding, vnode.context);\r\n            }\r\n            el._vOptions = [].map.call(el.options, getValue);\r\n        }\r\n        else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {\r\n            el._vModifiers = binding.modifiers;\r\n            if (!binding.modifiers.lazy) {\r\n                el.addEventListener('compositionstart', onCompositionStart);\r\n                el.addEventListener('compositionend', onCompositionEnd);\r\n                // Safari < 10.2 & UIWebView doesn't fire compositionend when\r\n                // switching focus before confirming composition choice\r\n                // this also fixes the issue where some browsers e.g. iOS Chrome\r\n                // fires \"change\" instead of \"input\" on autocomplete.\r\n                el.addEventListener('change', onCompositionEnd);\r\n                /* istanbul ignore if */\r\n                if (isIE9) {\r\n                    el.vmodel = true;\r\n                }\r\n            }\r\n        }\r\n    },\r\n    componentUpdated: function (el, binding, vnode) {\r\n        if (vnode.tag === 'select') {\r\n            setSelected(el, binding, vnode.context);\r\n            // in case the options rendered by v-for have changed,\r\n            // it's possible that the value is out-of-sync with the rendered options.\r\n            // detect such cases and filter out values that no longer has a matching\r\n            // option in the DOM.\r\n            var prevOptions_1 = el._vOptions;\r\n            var curOptions_1 = (el._vOptions = [].map.call(el.options, getValue));\r\n            if (curOptions_1.some(function (o, i) { return !looseEqual(o, prevOptions_1[i]); })) {\r\n                // trigger change event if\r\n                // no matching option found for at least one value\r\n                var needReset = el.multiple\r\n                    ? binding.value.some(function (v) { return hasNoMatchingOption(v, curOptions_1); })\r\n                    : binding.value !== binding.oldValue &&\r\n                        hasNoMatchingOption(binding.value, curOptions_1);\r\n                if (needReset) {\r\n                    trigger(el, 'change');\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\nfunction setSelected(el, binding, vm) {\r\n    actuallySetSelected(el, binding, vm);\r\n    /* istanbul ignore if */\r\n    if (isIE || isEdge) {\r\n        setTimeout(function () {\r\n            actuallySetSelected(el, binding, vm);\r\n        }, 0);\r\n    }\r\n}\r\nfunction actuallySetSelected(el, binding, vm) {\r\n    var value = binding.value;\r\n    var isMultiple = el.multiple;\r\n    if (isMultiple && !Array.isArray(value)) {\r\n         true &&\r\n            warn$2(\"<select multiple v-model=\\\"\".concat(binding.expression, \"\\\"> \") +\r\n                \"expects an Array value for its binding, but got \".concat(Object.prototype.toString\r\n                    .call(value)\r\n                    .slice(8, -1)), vm);\r\n        return;\r\n    }\r\n    var selected, option;\r\n    for (var i = 0, l = el.options.length; i < l; i++) {\r\n        option = el.options[i];\r\n        if (isMultiple) {\r\n            selected = looseIndexOf(value, getValue(option)) > -1;\r\n            if (option.selected !== selected) {\r\n                option.selected = selected;\r\n            }\r\n        }\r\n        else {\r\n            if (looseEqual(getValue(option), value)) {\r\n                if (el.selectedIndex !== i) {\r\n                    el.selectedIndex = i;\r\n                }\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    if (!isMultiple) {\r\n        el.selectedIndex = -1;\r\n    }\r\n}\r\nfunction hasNoMatchingOption(value, options) {\r\n    return options.every(function (o) { return !looseEqual(o, value); });\r\n}\r\nfunction getValue(option) {\r\n    return '_value' in option ? option._value : option.value;\r\n}\r\nfunction onCompositionStart(e) {\r\n    e.target.composing = true;\r\n}\r\nfunction onCompositionEnd(e) {\r\n    // prevent triggering an input event for no reason\r\n    if (!e.target.composing)\r\n        return;\r\n    e.target.composing = false;\r\n    trigger(e.target, 'input');\r\n}\r\nfunction trigger(el, type) {\r\n    var e = document.createEvent('HTMLEvents');\r\n    e.initEvent(type, true, true);\r\n    el.dispatchEvent(e);\r\n}\n\n// recursively search for possible transition defined inside the component root\r\nfunction locateNode(vnode) {\r\n    // @ts-expect-error\r\n    return vnode.componentInstance && (!vnode.data || !vnode.data.transition)\r\n        ? locateNode(vnode.componentInstance._vnode)\r\n        : vnode;\r\n}\r\nvar show = {\r\n    bind: function (el, _a, vnode) {\r\n        var value = _a.value;\r\n        vnode = locateNode(vnode);\r\n        var transition = vnode.data && vnode.data.transition;\r\n        var originalDisplay = (el.__vOriginalDisplay =\r\n            el.style.display === 'none' ? '' : el.style.display);\r\n        if (value && transition) {\r\n            vnode.data.show = true;\r\n            enter(vnode, function () {\r\n                el.style.display = originalDisplay;\r\n            });\r\n        }\r\n        else {\r\n            el.style.display = value ? originalDisplay : 'none';\r\n        }\r\n    },\r\n    update: function (el, _a, vnode) {\r\n        var value = _a.value, oldValue = _a.oldValue;\r\n        /* istanbul ignore if */\r\n        if (!value === !oldValue)\r\n            return;\r\n        vnode = locateNode(vnode);\r\n        var transition = vnode.data && vnode.data.transition;\r\n        if (transition) {\r\n            vnode.data.show = true;\r\n            if (value) {\r\n                enter(vnode, function () {\r\n                    el.style.display = el.__vOriginalDisplay;\r\n                });\r\n            }\r\n            else {\r\n                leave(vnode, function () {\r\n                    el.style.display = 'none';\r\n                });\r\n            }\r\n        }\r\n        else {\r\n            el.style.display = value ? el.__vOriginalDisplay : 'none';\r\n        }\r\n    },\r\n    unbind: function (el, binding, vnode, oldVnode, isDestroy) {\r\n        if (!isDestroy) {\r\n            el.style.display = el.__vOriginalDisplay;\r\n        }\r\n    }\r\n};\n\nvar platformDirectives = {\r\n    model: directive,\r\n    show: show\r\n};\n\n// Provides transition support for a single element/component.\r\nvar transitionProps = {\r\n    name: String,\r\n    appear: Boolean,\r\n    css: Boolean,\r\n    mode: String,\r\n    type: String,\r\n    enterClass: String,\r\n    leaveClass: String,\r\n    enterToClass: String,\r\n    leaveToClass: String,\r\n    enterActiveClass: String,\r\n    leaveActiveClass: String,\r\n    appearClass: String,\r\n    appearActiveClass: String,\r\n    appearToClass: String,\r\n    duration: [Number, String, Object]\r\n};\r\n// in case the child is also an abstract component, e.g. <keep-alive>\r\n// we want to recursively retrieve the real component to be rendered\r\nfunction getRealChild(vnode) {\r\n    var compOptions = vnode && vnode.componentOptions;\r\n    if (compOptions && compOptions.Ctor.options.abstract) {\r\n        return getRealChild(getFirstComponentChild(compOptions.children));\r\n    }\r\n    else {\r\n        return vnode;\r\n    }\r\n}\r\nfunction extractTransitionData(comp) {\r\n    var data = {};\r\n    var options = comp.$options;\r\n    // props\r\n    for (var key in options.propsData) {\r\n        data[key] = comp[key];\r\n    }\r\n    // events.\r\n    // extract listeners and pass them directly to the transition methods\r\n    var listeners = options._parentListeners;\r\n    for (var key in listeners) {\r\n        data[camelize(key)] = listeners[key];\r\n    }\r\n    return data;\r\n}\r\nfunction placeholder(h, rawChild) {\r\n    // @ts-expect-error\r\n    if (/\\d-keep-alive$/.test(rawChild.tag)) {\r\n        return h('keep-alive', {\r\n            props: rawChild.componentOptions.propsData\r\n        });\r\n    }\r\n}\r\nfunction hasParentTransition(vnode) {\r\n    while ((vnode = vnode.parent)) {\r\n        if (vnode.data.transition) {\r\n            return true;\r\n        }\r\n    }\r\n}\r\nfunction isSameChild(child, oldChild) {\r\n    return oldChild.key === child.key && oldChild.tag === child.tag;\r\n}\r\nvar isNotTextNode = function (c) { return c.tag || isAsyncPlaceholder(c); };\r\nvar isVShowDirective = function (d) { return d.name === 'show'; };\r\nvar Transition = {\r\n    name: 'transition',\r\n    props: transitionProps,\r\n    abstract: true,\r\n    render: function (h) {\r\n        var _this = this;\r\n        var children = this.$slots.default;\r\n        if (!children) {\r\n            return;\r\n        }\r\n        // filter out text nodes (possible whitespaces)\r\n        children = children.filter(isNotTextNode);\r\n        /* istanbul ignore if */\r\n        if (!children.length) {\r\n            return;\r\n        }\r\n        // warn multiple elements\r\n        if ( true && children.length > 1) {\r\n            warn$2('<transition> can only be used on a single element. Use ' +\r\n                '<transition-group> for lists.', this.$parent);\r\n        }\r\n        var mode = this.mode;\r\n        // warn invalid mode\r\n        if ( true && mode && mode !== 'in-out' && mode !== 'out-in') {\r\n            warn$2('invalid <transition> mode: ' + mode, this.$parent);\r\n        }\r\n        var rawChild = children[0];\r\n        // if this is a component root node and the component's\r\n        // parent container node also has transition, skip.\r\n        if (hasParentTransition(this.$vnode)) {\r\n            return rawChild;\r\n        }\r\n        // apply transition data to child\r\n        // use getRealChild() to ignore abstract components e.g. keep-alive\r\n        var child = getRealChild(rawChild);\r\n        /* istanbul ignore if */\r\n        if (!child) {\r\n            return rawChild;\r\n        }\r\n        if (this._leaving) {\r\n            return placeholder(h, rawChild);\r\n        }\r\n        // ensure a key that is unique to the vnode type and to this transition\r\n        // component instance. This key will be used to remove pending leaving nodes\r\n        // during entering.\r\n        var id = \"__transition-\".concat(this._uid, \"-\");\r\n        child.key =\r\n            child.key == null\r\n                ? child.isComment\r\n                    ? id + 'comment'\r\n                    : id + child.tag\r\n                : isPrimitive(child.key)\r\n                    ? String(child.key).indexOf(id) === 0\r\n                        ? child.key\r\n                        : id + child.key\r\n                    : child.key;\r\n        var data = ((child.data || (child.data = {})).transition =\r\n            extractTransitionData(this));\r\n        var oldRawChild = this._vnode;\r\n        var oldChild = getRealChild(oldRawChild);\r\n        // mark v-show\r\n        // so that the transition module can hand over the control to the directive\r\n        if (child.data.directives && child.data.directives.some(isVShowDirective)) {\r\n            child.data.show = true;\r\n        }\r\n        if (oldChild &&\r\n            oldChild.data &&\r\n            !isSameChild(child, oldChild) &&\r\n            !isAsyncPlaceholder(oldChild) &&\r\n            // #6687 component root is a comment node\r\n            !(oldChild.componentInstance &&\r\n                oldChild.componentInstance._vnode.isComment)) {\r\n            // replace old child transition data with fresh one\r\n            // important for dynamic transitions!\r\n            var oldData = (oldChild.data.transition = extend({}, data));\r\n            // handle transition mode\r\n            if (mode === 'out-in') {\r\n                // return placeholder node and queue update when leave finishes\r\n                this._leaving = true;\r\n                mergeVNodeHook(oldData, 'afterLeave', function () {\r\n                    _this._leaving = false;\r\n                    _this.$forceUpdate();\r\n                });\r\n                return placeholder(h, rawChild);\r\n            }\r\n            else if (mode === 'in-out') {\r\n                if (isAsyncPlaceholder(child)) {\r\n                    return oldRawChild;\r\n                }\r\n                var delayedLeave_1;\r\n                var performLeave = function () {\r\n                    delayedLeave_1();\r\n                };\r\n                mergeVNodeHook(data, 'afterEnter', performLeave);\r\n                mergeVNodeHook(data, 'enterCancelled', performLeave);\r\n                mergeVNodeHook(oldData, 'delayLeave', function (leave) {\r\n                    delayedLeave_1 = leave;\r\n                });\r\n            }\r\n        }\r\n        return rawChild;\r\n    }\r\n};\n\n// Provides transition support for list items.\r\nvar props = extend({\r\n    tag: String,\r\n    moveClass: String\r\n}, transitionProps);\r\ndelete props.mode;\r\nvar TransitionGroup = {\r\n    props: props,\r\n    beforeMount: function () {\r\n        var _this = this;\r\n        var update = this._update;\r\n        this._update = function (vnode, hydrating) {\r\n            var restoreActiveInstance = setActiveInstance(_this);\r\n            // force removing pass\r\n            _this.__patch__(_this._vnode, _this.kept, false, // hydrating\r\n            true // removeOnly (!important, avoids unnecessary moves)\r\n            );\r\n            _this._vnode = _this.kept;\r\n            restoreActiveInstance();\r\n            update.call(_this, vnode, hydrating);\r\n        };\r\n    },\r\n    render: function (h) {\r\n        var tag = this.tag || this.$vnode.data.tag || 'span';\r\n        var map = Object.create(null);\r\n        var prevChildren = (this.prevChildren = this.children);\r\n        var rawChildren = this.$slots.default || [];\r\n        var children = (this.children = []);\r\n        var transitionData = extractTransitionData(this);\r\n        for (var i = 0; i < rawChildren.length; i++) {\r\n            var c = rawChildren[i];\r\n            if (c.tag) {\r\n                if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\r\n                    children.push(c);\r\n                    map[c.key] = c;\r\n                    (c.data || (c.data = {})).transition = transitionData;\r\n                }\r\n                else if (true) {\r\n                    var opts = c.componentOptions;\r\n                    var name_1 = opts\r\n                        ? getComponentName(opts.Ctor.options) || opts.tag || ''\r\n                        : c.tag;\r\n                    warn$2(\"<transition-group> children must be keyed: <\".concat(name_1, \">\"));\r\n                }\r\n            }\r\n        }\r\n        if (prevChildren) {\r\n            var kept = [];\r\n            var removed = [];\r\n            for (var i = 0; i < prevChildren.length; i++) {\r\n                var c = prevChildren[i];\r\n                c.data.transition = transitionData;\r\n                // @ts-expect-error .getBoundingClientRect is not typed in Node\r\n                c.data.pos = c.elm.getBoundingClientRect();\r\n                if (map[c.key]) {\r\n                    kept.push(c);\r\n                }\r\n                else {\r\n                    removed.push(c);\r\n                }\r\n            }\r\n            this.kept = h(tag, null, kept);\r\n            this.removed = removed;\r\n        }\r\n        return h(tag, null, children);\r\n    },\r\n    updated: function () {\r\n        var children = this.prevChildren;\r\n        var moveClass = this.moveClass || (this.name || 'v') + '-move';\r\n        if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\r\n            return;\r\n        }\r\n        // we divide the work into three loops to avoid mixing DOM reads and writes\r\n        // in each iteration - which helps prevent layout thrashing.\r\n        children.forEach(callPendingCbs);\r\n        children.forEach(recordPosition);\r\n        children.forEach(applyTranslation);\r\n        // force reflow to put everything in position\r\n        // assign to this to avoid being removed in tree-shaking\r\n        // $flow-disable-line\r\n        this._reflow = document.body.offsetHeight;\r\n        children.forEach(function (c) {\r\n            if (c.data.moved) {\r\n                var el_1 = c.elm;\r\n                var s = el_1.style;\r\n                addTransitionClass(el_1, moveClass);\r\n                s.transform = s.WebkitTransform = s.transitionDuration = '';\r\n                el_1.addEventListener(transitionEndEvent, (el_1._moveCb = function cb(e) {\r\n                    if (e && e.target !== el_1) {\r\n                        return;\r\n                    }\r\n                    if (!e || /transform$/.test(e.propertyName)) {\r\n                        el_1.removeEventListener(transitionEndEvent, cb);\r\n                        el_1._moveCb = null;\r\n                        removeTransitionClass(el_1, moveClass);\r\n                    }\r\n                }));\r\n            }\r\n        });\r\n    },\r\n    methods: {\r\n        hasMove: function (el, moveClass) {\r\n            /* istanbul ignore if */\r\n            if (!hasTransition) {\r\n                return false;\r\n            }\r\n            /* istanbul ignore if */\r\n            if (this._hasMove) {\r\n                return this._hasMove;\r\n            }\r\n            // Detect whether an element with the move class applied has\r\n            // CSS transitions. Since the element may be inside an entering\r\n            // transition at this very moment, we make a clone of it and remove\r\n            // all other transition classes applied to ensure only the move class\r\n            // is applied.\r\n            var clone = el.cloneNode();\r\n            if (el._transitionClasses) {\r\n                el._transitionClasses.forEach(function (cls) {\r\n                    removeClass(clone, cls);\r\n                });\r\n            }\r\n            addClass(clone, moveClass);\r\n            clone.style.display = 'none';\r\n            this.$el.appendChild(clone);\r\n            var info = getTransitionInfo(clone);\r\n            this.$el.removeChild(clone);\r\n            return (this._hasMove = info.hasTransform);\r\n        }\r\n    }\r\n};\r\nfunction callPendingCbs(c) {\r\n    /* istanbul ignore if */\r\n    if (c.elm._moveCb) {\r\n        c.elm._moveCb();\r\n    }\r\n    /* istanbul ignore if */\r\n    if (c.elm._enterCb) {\r\n        c.elm._enterCb();\r\n    }\r\n}\r\nfunction recordPosition(c) {\r\n    c.data.newPos = c.elm.getBoundingClientRect();\r\n}\r\nfunction applyTranslation(c) {\r\n    var oldPos = c.data.pos;\r\n    var newPos = c.data.newPos;\r\n    var dx = oldPos.left - newPos.left;\r\n    var dy = oldPos.top - newPos.top;\r\n    if (dx || dy) {\r\n        c.data.moved = true;\r\n        var s = c.elm.style;\r\n        s.transform = s.WebkitTransform = \"translate(\".concat(dx, \"px,\").concat(dy, \"px)\");\r\n        s.transitionDuration = '0s';\r\n    }\r\n}\n\nvar platformComponents = {\r\n    Transition: Transition,\r\n    TransitionGroup: TransitionGroup\r\n};\n\n// install platform specific utils\r\nVue.config.mustUseProp = mustUseProp;\r\nVue.config.isReservedTag = isReservedTag;\r\nVue.config.isReservedAttr = isReservedAttr;\r\nVue.config.getTagNamespace = getTagNamespace;\r\nVue.config.isUnknownElement = isUnknownElement;\r\n// install platform runtime directives & components\r\nextend(Vue.options.directives, platformDirectives);\r\nextend(Vue.options.components, platformComponents);\r\n// install platform patch function\r\nVue.prototype.__patch__ = inBrowser ? patch : noop;\r\n// public mount method\r\nVue.prototype.$mount = function (el, hydrating) {\r\n    el = el && inBrowser ? query(el) : undefined;\r\n    return mountComponent(this, el, hydrating);\r\n};\r\n// devtools global hook\r\n/* istanbul ignore next */\r\nif (inBrowser) {\r\n    setTimeout(function () {\r\n        if (config.devtools) {\r\n            if (devtools) {\r\n                devtools.emit('init', Vue);\r\n            }\r\n            else if (true) {\r\n                // @ts-expect-error\r\n                console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\\n' +\r\n                    'https://github.com/vuejs/vue-devtools');\r\n            }\r\n        }\r\n        if ( true &&\r\n            config.productionTip !== false &&\r\n            typeof console !== 'undefined') {\r\n            // @ts-expect-error\r\n            console[console.info ? 'info' : 'log'](\"You are running Vue in development mode.\\n\" +\r\n                \"Make sure to turn on production mode when deploying for production.\\n\" +\r\n                \"See more tips at https://vuejs.org/guide/deployment.html\");\r\n        }\r\n    }, 0);\r\n}\n\nvar defaultTagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g;\r\nvar regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\r\nvar buildRegex = cached(function (delimiters) {\r\n    var open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\r\n    var close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\r\n    return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g');\r\n});\r\nfunction parseText(text, delimiters) {\r\n    //@ts-expect-error\r\n    var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\r\n    if (!tagRE.test(text)) {\r\n        return;\r\n    }\r\n    var tokens = [];\r\n    var rawTokens = [];\r\n    var lastIndex = (tagRE.lastIndex = 0);\r\n    var match, index, tokenValue;\r\n    while ((match = tagRE.exec(text))) {\r\n        index = match.index;\r\n        // push text token\r\n        if (index > lastIndex) {\r\n            rawTokens.push((tokenValue = text.slice(lastIndex, index)));\r\n            tokens.push(JSON.stringify(tokenValue));\r\n        }\r\n        // tag token\r\n        var exp = parseFilters(match[1].trim());\r\n        tokens.push(\"_s(\".concat(exp, \")\"));\r\n        rawTokens.push({ '@binding': exp });\r\n        lastIndex = index + match[0].length;\r\n    }\r\n    if (lastIndex < text.length) {\r\n        rawTokens.push((tokenValue = text.slice(lastIndex)));\r\n        tokens.push(JSON.stringify(tokenValue));\r\n    }\r\n    return {\r\n        expression: tokens.join('+'),\r\n        tokens: rawTokens\r\n    };\r\n}\n\nfunction transformNode$1(el, options) {\r\n    var warn = options.warn || baseWarn;\r\n    var staticClass = getAndRemoveAttr(el, 'class');\r\n    if ( true && staticClass) {\r\n        var res = parseText(staticClass, options.delimiters);\r\n        if (res) {\r\n            warn(\"class=\\\"\".concat(staticClass, \"\\\": \") +\r\n                'Interpolation inside attributes has been removed. ' +\r\n                'Use v-bind or the colon shorthand instead. For example, ' +\r\n                'instead of <div class=\"{{ val }}\">, use <div :class=\"val\">.', el.rawAttrsMap['class']);\r\n        }\r\n    }\r\n    if (staticClass) {\r\n        el.staticClass = JSON.stringify(staticClass.replace(/\\s+/g, ' ').trim());\r\n    }\r\n    var classBinding = getBindingAttr(el, 'class', false /* getStatic */);\r\n    if (classBinding) {\r\n        el.classBinding = classBinding;\r\n    }\r\n}\r\nfunction genData$2(el) {\r\n    var data = '';\r\n    if (el.staticClass) {\r\n        data += \"staticClass:\".concat(el.staticClass, \",\");\r\n    }\r\n    if (el.classBinding) {\r\n        data += \"class:\".concat(el.classBinding, \",\");\r\n    }\r\n    return data;\r\n}\r\nvar klass = {\r\n    staticKeys: ['staticClass'],\r\n    transformNode: transformNode$1,\r\n    genData: genData$2\r\n};\n\nfunction transformNode(el, options) {\r\n    var warn = options.warn || baseWarn;\r\n    var staticStyle = getAndRemoveAttr(el, 'style');\r\n    if (staticStyle) {\r\n        /* istanbul ignore if */\r\n        if (true) {\r\n            var res = parseText(staticStyle, options.delimiters);\r\n            if (res) {\r\n                warn(\"style=\\\"\".concat(staticStyle, \"\\\": \") +\r\n                    'Interpolation inside attributes has been removed. ' +\r\n                    'Use v-bind or the colon shorthand instead. For example, ' +\r\n                    'instead of <div style=\"{{ val }}\">, use <div :style=\"val\">.', el.rawAttrsMap['style']);\r\n            }\r\n        }\r\n        el.staticStyle = JSON.stringify(parseStyleText(staticStyle));\r\n    }\r\n    var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);\r\n    if (styleBinding) {\r\n        el.styleBinding = styleBinding;\r\n    }\r\n}\r\nfunction genData$1(el) {\r\n    var data = '';\r\n    if (el.staticStyle) {\r\n        data += \"staticStyle:\".concat(el.staticStyle, \",\");\r\n    }\r\n    if (el.styleBinding) {\r\n        data += \"style:(\".concat(el.styleBinding, \"),\");\r\n    }\r\n    return data;\r\n}\r\nvar style = {\r\n    staticKeys: ['staticStyle'],\r\n    transformNode: transformNode,\r\n    genData: genData$1\r\n};\n\nvar decoder;\r\nvar he = {\r\n    decode: function (html) {\r\n        decoder = decoder || document.createElement('div');\r\n        decoder.innerHTML = html;\r\n        return decoder.textContent;\r\n    }\r\n};\n\nvar isUnaryTag = makeMap('area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +\r\n    'link,meta,param,source,track,wbr');\r\n// Elements that you can, intentionally, leave open\r\n// (and which close themselves)\r\nvar canBeLeftOpenTag = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source');\r\n// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\r\n// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\r\nvar isNonPhrasingTag = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +\r\n    'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +\r\n    'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +\r\n    'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +\r\n    'title,tr,track');\n\n/**\r\n * Not type-checking this file because it's mostly vendor code.\r\n */\r\n// Regular Expressions for parsing tags and attributes\r\nvar attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\r\nvar dynamicArgAttribute = /^\\s*((?:v-[\\w-]+:|@|:|#)\\[[^=]+?\\][^\\s\"'<>\\/=]*)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\r\nvar ncname = \"[a-zA-Z_][\\\\-\\\\.0-9_a-zA-Z\".concat(unicodeRegExp.source, \"]*\");\r\nvar qnameCapture = \"((?:\".concat(ncname, \"\\\\:)?\").concat(ncname, \")\");\r\nvar startTagOpen = new RegExp(\"^<\".concat(qnameCapture));\r\nvar startTagClose = /^\\s*(\\/?)>/;\r\nvar endTag = new RegExp(\"^<\\\\/\".concat(qnameCapture, \"[^>]*>\"));\r\nvar doctype = /^<!DOCTYPE [^>]+>/i;\r\n// #7298: escape - to avoid being passed as HTML comment when inlined in page\r\nvar comment = /^<!\\--/;\r\nvar conditionalComment = /^<!\\[/;\r\n// Special Elements (can contain anything)\r\nvar isPlainTextElement = makeMap('script,style,textarea', true);\r\nvar reCache = {};\r\nvar decodingMap = {\r\n    '&lt;': '<',\r\n    '&gt;': '>',\r\n    '&quot;': '\"',\r\n    '&amp;': '&',\r\n    '&#10;': '\\n',\r\n    '&#9;': '\\t',\r\n    '&#39;': \"'\"\r\n};\r\nvar encodedAttr = /&(?:lt|gt|quot|amp|#39);/g;\r\nvar encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#39|#10|#9);/g;\r\n// #5992\r\nvar isIgnoreNewlineTag = makeMap('pre,textarea', true);\r\nvar shouldIgnoreFirstNewline = function (tag, html) {\r\n    return tag && isIgnoreNewlineTag(tag) && html[0] === '\\n';\r\n};\r\nfunction decodeAttr(value, shouldDecodeNewlines) {\r\n    var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;\r\n    return value.replace(re, function (match) { return decodingMap[match]; });\r\n}\r\nfunction parseHTML(html, options) {\r\n    var stack = [];\r\n    var expectHTML = options.expectHTML;\r\n    var isUnaryTag = options.isUnaryTag || no;\r\n    var canBeLeftOpenTag = options.canBeLeftOpenTag || no;\r\n    var index = 0;\r\n    var last, lastTag;\r\n    var _loop_1 = function () {\r\n        last = html;\r\n        // Make sure we're not in a plaintext content element like script/style\r\n        if (!lastTag || !isPlainTextElement(lastTag)) {\r\n            var textEnd = html.indexOf('<');\r\n            if (textEnd === 0) {\r\n                // Comment:\r\n                if (comment.test(html)) {\r\n                    var commentEnd = html.indexOf('-->');\r\n                    if (commentEnd >= 0) {\r\n                        if (options.shouldKeepComment && options.comment) {\r\n                            options.comment(html.substring(4, commentEnd), index, index + commentEnd + 3);\r\n                        }\r\n                        advance(commentEnd + 3);\r\n                        return \"continue\";\r\n                    }\r\n                }\r\n                // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\r\n                if (conditionalComment.test(html)) {\r\n                    var conditionalEnd = html.indexOf(']>');\r\n                    if (conditionalEnd >= 0) {\r\n                        advance(conditionalEnd + 2);\r\n                        return \"continue\";\r\n                    }\r\n                }\r\n                // Doctype:\r\n                var doctypeMatch = html.match(doctype);\r\n                if (doctypeMatch) {\r\n                    advance(doctypeMatch[0].length);\r\n                    return \"continue\";\r\n                }\r\n                // End tag:\r\n                var endTagMatch = html.match(endTag);\r\n                if (endTagMatch) {\r\n                    var curIndex = index;\r\n                    advance(endTagMatch[0].length);\r\n                    parseEndTag(endTagMatch[1], curIndex, index);\r\n                    return \"continue\";\r\n                }\r\n                // Start tag:\r\n                var startTagMatch = parseStartTag();\r\n                if (startTagMatch) {\r\n                    handleStartTag(startTagMatch);\r\n                    if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) {\r\n                        advance(1);\r\n                    }\r\n                    return \"continue\";\r\n                }\r\n            }\r\n            var text = void 0, rest = void 0, next = void 0;\r\n            if (textEnd >= 0) {\r\n                rest = html.slice(textEnd);\r\n                while (!endTag.test(rest) &&\r\n                    !startTagOpen.test(rest) &&\r\n                    !comment.test(rest) &&\r\n                    !conditionalComment.test(rest)) {\r\n                    // < in plain text, be forgiving and treat it as text\r\n                    next = rest.indexOf('<', 1);\r\n                    if (next < 0)\r\n                        break;\r\n                    textEnd += next;\r\n                    rest = html.slice(textEnd);\r\n                }\r\n                text = html.substring(0, textEnd);\r\n            }\r\n            if (textEnd < 0) {\r\n                text = html;\r\n            }\r\n            if (text) {\r\n                advance(text.length);\r\n            }\r\n            if (options.chars && text) {\r\n                options.chars(text, index - text.length, index);\r\n            }\r\n        }\r\n        else {\r\n            var endTagLength_1 = 0;\r\n            var stackedTag_1 = lastTag.toLowerCase();\r\n            var reStackedTag = reCache[stackedTag_1] ||\r\n                (reCache[stackedTag_1] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag_1 + '[^>]*>)', 'i'));\r\n            var rest = html.replace(reStackedTag, function (all, text, endTag) {\r\n                endTagLength_1 = endTag.length;\r\n                if (!isPlainTextElement(stackedTag_1) && stackedTag_1 !== 'noscript') {\r\n                    text = text\r\n                        .replace(/<!\\--([\\s\\S]*?)-->/g, '$1') // #7298\r\n                        .replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\r\n                }\r\n                if (shouldIgnoreFirstNewline(stackedTag_1, text)) {\r\n                    text = text.slice(1);\r\n                }\r\n                if (options.chars) {\r\n                    options.chars(text);\r\n                }\r\n                return '';\r\n            });\r\n            index += html.length - rest.length;\r\n            html = rest;\r\n            parseEndTag(stackedTag_1, index - endTagLength_1, index);\r\n        }\r\n        if (html === last) {\r\n            options.chars && options.chars(html);\r\n            if ( true && !stack.length && options.warn) {\r\n                options.warn(\"Mal-formatted tag at end of template: \\\"\".concat(html, \"\\\"\"), {\r\n                    start: index + html.length\r\n                });\r\n            }\r\n            return \"break\";\r\n        }\r\n    };\r\n    while (html) {\r\n        var state_1 = _loop_1();\r\n        if (state_1 === \"break\")\r\n            break;\r\n    }\r\n    // Clean up any remaining tags\r\n    parseEndTag();\r\n    function advance(n) {\r\n        index += n;\r\n        html = html.substring(n);\r\n    }\r\n    function parseStartTag() {\r\n        var start = html.match(startTagOpen);\r\n        if (start) {\r\n            var match = {\r\n                tagName: start[1],\r\n                attrs: [],\r\n                start: index\r\n            };\r\n            advance(start[0].length);\r\n            var end = void 0, attr = void 0;\r\n            while (!(end = html.match(startTagClose)) &&\r\n                (attr = html.match(dynamicArgAttribute) || html.match(attribute))) {\r\n                attr.start = index;\r\n                advance(attr[0].length);\r\n                attr.end = index;\r\n                match.attrs.push(attr);\r\n            }\r\n            if (end) {\r\n                match.unarySlash = end[1];\r\n                advance(end[0].length);\r\n                match.end = index;\r\n                return match;\r\n            }\r\n        }\r\n    }\r\n    function handleStartTag(match) {\r\n        var tagName = match.tagName;\r\n        var unarySlash = match.unarySlash;\r\n        if (expectHTML) {\r\n            if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\r\n                parseEndTag(lastTag);\r\n            }\r\n            if (canBeLeftOpenTag(tagName) && lastTag === tagName) {\r\n                parseEndTag(tagName);\r\n            }\r\n        }\r\n        var unary = isUnaryTag(tagName) || !!unarySlash;\r\n        var l = match.attrs.length;\r\n        var attrs = new Array(l);\r\n        for (var i = 0; i < l; i++) {\r\n            var args = match.attrs[i];\r\n            var value = args[3] || args[4] || args[5] || '';\r\n            var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href'\r\n                ? options.shouldDecodeNewlinesForHref\r\n                : options.shouldDecodeNewlines;\r\n            attrs[i] = {\r\n                name: args[1],\r\n                value: decodeAttr(value, shouldDecodeNewlines)\r\n            };\r\n            if ( true && options.outputSourceRange) {\r\n                attrs[i].start = args.start + args[0].match(/^\\s*/).length;\r\n                attrs[i].end = args.end;\r\n            }\r\n        }\r\n        if (!unary) {\r\n            stack.push({\r\n                tag: tagName,\r\n                lowerCasedTag: tagName.toLowerCase(),\r\n                attrs: attrs,\r\n                start: match.start,\r\n                end: match.end\r\n            });\r\n            lastTag = tagName;\r\n        }\r\n        if (options.start) {\r\n            options.start(tagName, attrs, unary, match.start, match.end);\r\n        }\r\n    }\r\n    function parseEndTag(tagName, start, end) {\r\n        var pos, lowerCasedTagName;\r\n        if (start == null)\r\n            start = index;\r\n        if (end == null)\r\n            end = index;\r\n        // Find the closest opened tag of the same type\r\n        if (tagName) {\r\n            lowerCasedTagName = tagName.toLowerCase();\r\n            for (pos = stack.length - 1; pos >= 0; pos--) {\r\n                if (stack[pos].lowerCasedTag === lowerCasedTagName) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            // If no tag name is provided, clean shop\r\n            pos = 0;\r\n        }\r\n        if (pos >= 0) {\r\n            // Close all the open elements, up the stack\r\n            for (var i = stack.length - 1; i >= pos; i--) {\r\n                if ( true && (i > pos || !tagName) && options.warn) {\r\n                    options.warn(\"tag <\".concat(stack[i].tag, \"> has no matching end tag.\"), {\r\n                        start: stack[i].start,\r\n                        end: stack[i].end\r\n                    });\r\n                }\r\n                if (options.end) {\r\n                    options.end(stack[i].tag, start, end);\r\n                }\r\n            }\r\n            // Remove the open elements from the stack\r\n            stack.length = pos;\r\n            lastTag = pos && stack[pos - 1].tag;\r\n        }\r\n        else if (lowerCasedTagName === 'br') {\r\n            if (options.start) {\r\n                options.start(tagName, [], true, start, end);\r\n            }\r\n        }\r\n        else if (lowerCasedTagName === 'p') {\r\n            if (options.start) {\r\n                options.start(tagName, [], false, start, end);\r\n            }\r\n            if (options.end) {\r\n                options.end(tagName, start, end);\r\n            }\r\n        }\r\n    }\r\n}\n\nvar onRE = /^@|^v-on:/;\r\nvar dirRE = /^v-|^@|^:|^#/;\r\nvar forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/;\r\nvar forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/;\r\nvar stripParensRE = /^\\(|\\)$/g;\r\nvar dynamicArgRE = /^\\[.*\\]$/;\r\nvar argRE = /:(.*)$/;\r\nvar bindRE = /^:|^\\.|^v-bind:/;\r\nvar modifierRE = /\\.[^.\\]]+(?=[^\\]]*$)/g;\r\nvar slotRE = /^v-slot(:|$)|^#/;\r\nvar lineBreakRE = /[\\r\\n]/;\r\nvar whitespaceRE = /[ \\f\\t\\r\\n]+/g;\r\nvar invalidAttributeRE = /[\\s\"'<>\\/=]/;\r\nvar decodeHTMLCached = cached(he.decode);\r\nvar emptySlotScopeToken = \"_empty_\";\r\n// configurable state\r\nvar warn;\r\nvar delimiters;\r\nvar transforms;\r\nvar preTransforms;\r\nvar postTransforms;\r\nvar platformIsPreTag;\r\nvar platformMustUseProp;\r\nvar platformGetTagNamespace;\r\nvar maybeComponent;\r\nfunction createASTElement(tag, attrs, parent) {\r\n    return {\r\n        type: 1,\r\n        tag: tag,\r\n        attrsList: attrs,\r\n        attrsMap: makeAttrsMap(attrs),\r\n        rawAttrsMap: {},\r\n        parent: parent,\r\n        children: []\r\n    };\r\n}\r\n/**\r\n * Convert HTML string to AST.\r\n */\r\nfunction parse(template, options) {\r\n    warn = options.warn || baseWarn;\r\n    platformIsPreTag = options.isPreTag || no;\r\n    platformMustUseProp = options.mustUseProp || no;\r\n    platformGetTagNamespace = options.getTagNamespace || no;\r\n    var isReservedTag = options.isReservedTag || no;\r\n    maybeComponent = function (el) {\r\n        return !!(el.component ||\r\n            el.attrsMap[':is'] ||\r\n            el.attrsMap['v-bind:is'] ||\r\n            !(el.attrsMap.is ? isReservedTag(el.attrsMap.is) : isReservedTag(el.tag)));\r\n    };\r\n    transforms = pluckModuleFunction(options.modules, 'transformNode');\r\n    preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\r\n    postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\r\n    delimiters = options.delimiters;\r\n    var stack = [];\r\n    var preserveWhitespace = options.preserveWhitespace !== false;\r\n    var whitespaceOption = options.whitespace;\r\n    var root;\r\n    var currentParent;\r\n    var inVPre = false;\r\n    var inPre = false;\r\n    var warned = false;\r\n    function warnOnce(msg, range) {\r\n        if (!warned) {\r\n            warned = true;\r\n            warn(msg, range);\r\n        }\r\n    }\r\n    function closeElement(element) {\r\n        trimEndingWhitespace(element);\r\n        if (!inVPre && !element.processed) {\r\n            element = processElement(element, options);\r\n        }\r\n        // tree management\r\n        if (!stack.length && element !== root) {\r\n            // allow root elements with v-if, v-else-if and v-else\r\n            if (root.if && (element.elseif || element.else)) {\r\n                if (true) {\r\n                    checkRootConstraints(element);\r\n                }\r\n                addIfCondition(root, {\r\n                    exp: element.elseif,\r\n                    block: element\r\n                });\r\n            }\r\n            else if (true) {\r\n                warnOnce(\"Component template should contain exactly one root element. \" +\r\n                    \"If you are using v-if on multiple elements, \" +\r\n                    \"use v-else-if to chain them instead.\", { start: element.start });\r\n            }\r\n        }\r\n        if (currentParent && !element.forbidden) {\r\n            if (element.elseif || element.else) {\r\n                processIfConditions(element, currentParent);\r\n            }\r\n            else {\r\n                if (element.slotScope) {\r\n                    // scoped slot\r\n                    // keep it in the children list so that v-else(-if) conditions can\r\n                    // find it as the prev node.\r\n                    var name_1 = element.slotTarget || '\"default\"';\r\n                    (currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name_1] = element;\r\n                }\r\n                currentParent.children.push(element);\r\n                element.parent = currentParent;\r\n            }\r\n        }\r\n        // final children cleanup\r\n        // filter out scoped slots\r\n        element.children = element.children.filter(function (c) { return !c.slotScope; });\r\n        // remove trailing whitespace node again\r\n        trimEndingWhitespace(element);\r\n        // check pre state\r\n        if (element.pre) {\r\n            inVPre = false;\r\n        }\r\n        if (platformIsPreTag(element.tag)) {\r\n            inPre = false;\r\n        }\r\n        // apply post-transforms\r\n        for (var i = 0; i < postTransforms.length; i++) {\r\n            postTransforms[i](element, options);\r\n        }\r\n    }\r\n    function trimEndingWhitespace(el) {\r\n        // remove trailing whitespace node\r\n        if (!inPre) {\r\n            var lastNode = void 0;\r\n            while ((lastNode = el.children[el.children.length - 1]) &&\r\n                lastNode.type === 3 &&\r\n                lastNode.text === ' ') {\r\n                el.children.pop();\r\n            }\r\n        }\r\n    }\r\n    function checkRootConstraints(el) {\r\n        if (el.tag === 'slot' || el.tag === 'template') {\r\n            warnOnce(\"Cannot use <\".concat(el.tag, \"> as component root element because it may \") +\r\n                'contain multiple nodes.', { start: el.start });\r\n        }\r\n        if (el.attrsMap.hasOwnProperty('v-for')) {\r\n            warnOnce('Cannot use v-for on stateful component root element because ' +\r\n                'it renders multiple elements.', el.rawAttrsMap['v-for']);\r\n        }\r\n    }\r\n    parseHTML(template, {\r\n        warn: warn,\r\n        expectHTML: options.expectHTML,\r\n        isUnaryTag: options.isUnaryTag,\r\n        canBeLeftOpenTag: options.canBeLeftOpenTag,\r\n        shouldDecodeNewlines: options.shouldDecodeNewlines,\r\n        shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,\r\n        shouldKeepComment: options.comments,\r\n        outputSourceRange: options.outputSourceRange,\r\n        start: function (tag, attrs, unary, start, end) {\r\n            // check namespace.\r\n            // inherit parent ns if there is one\r\n            var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);\r\n            // handle IE svg bug\r\n            /* istanbul ignore if */\r\n            if (isIE && ns === 'svg') {\r\n                attrs = guardIESVGBug(attrs);\r\n            }\r\n            var element = createASTElement(tag, attrs, currentParent);\r\n            if (ns) {\r\n                element.ns = ns;\r\n            }\r\n            if (true) {\r\n                if (options.outputSourceRange) {\r\n                    element.start = start;\r\n                    element.end = end;\r\n                    element.rawAttrsMap = element.attrsList.reduce(function (cumulated, attr) {\r\n                        cumulated[attr.name] = attr;\r\n                        return cumulated;\r\n                    }, {});\r\n                }\r\n                attrs.forEach(function (attr) {\r\n                    if (invalidAttributeRE.test(attr.name)) {\r\n                        warn(\"Invalid dynamic argument expression: attribute names cannot contain \" +\r\n                            \"spaces, quotes, <, >, / or =.\", options.outputSourceRange\r\n                            ? {\r\n                                start: attr.start + attr.name.indexOf(\"[\"),\r\n                                end: attr.start + attr.name.length\r\n                            }\r\n                            : undefined);\r\n                    }\r\n                });\r\n            }\r\n            if (isForbiddenTag(element) && !isServerRendering()) {\r\n                element.forbidden = true;\r\n                 true &&\r\n                    warn('Templates should only be responsible for mapping the state to the ' +\r\n                        'UI. Avoid placing tags with side-effects in your templates, such as ' +\r\n                        \"<\".concat(tag, \">\") +\r\n                        ', as they will not be parsed.', { start: element.start });\r\n            }\r\n            // apply pre-transforms\r\n            for (var i = 0; i < preTransforms.length; i++) {\r\n                element = preTransforms[i](element, options) || element;\r\n            }\r\n            if (!inVPre) {\r\n                processPre(element);\r\n                if (element.pre) {\r\n                    inVPre = true;\r\n                }\r\n            }\r\n            if (platformIsPreTag(element.tag)) {\r\n                inPre = true;\r\n            }\r\n            if (inVPre) {\r\n                processRawAttrs(element);\r\n            }\r\n            else if (!element.processed) {\r\n                // structural directives\r\n                processFor(element);\r\n                processIf(element);\r\n                processOnce(element);\r\n            }\r\n            if (!root) {\r\n                root = element;\r\n                if (true) {\r\n                    checkRootConstraints(root);\r\n                }\r\n            }\r\n            if (!unary) {\r\n                currentParent = element;\r\n                stack.push(element);\r\n            }\r\n            else {\r\n                closeElement(element);\r\n            }\r\n        },\r\n        end: function (tag, start, end) {\r\n            var element = stack[stack.length - 1];\r\n            // pop stack\r\n            stack.length -= 1;\r\n            currentParent = stack[stack.length - 1];\r\n            if ( true && options.outputSourceRange) {\r\n                element.end = end;\r\n            }\r\n            closeElement(element);\r\n        },\r\n        chars: function (text, start, end) {\r\n            if (!currentParent) {\r\n                if (true) {\r\n                    if (text === template) {\r\n                        warnOnce('Component template requires a root element, rather than just text.', { start: start });\r\n                    }\r\n                    else if ((text = text.trim())) {\r\n                        warnOnce(\"text \\\"\".concat(text, \"\\\" outside root element will be ignored.\"), {\r\n                            start: start\r\n                        });\r\n                    }\r\n                }\r\n                return;\r\n            }\r\n            // IE textarea placeholder bug\r\n            /* istanbul ignore if */\r\n            if (isIE &&\r\n                currentParent.tag === 'textarea' &&\r\n                currentParent.attrsMap.placeholder === text) {\r\n                return;\r\n            }\r\n            var children = currentParent.children;\r\n            if (inPre || text.trim()) {\r\n                text = isTextTag(currentParent)\r\n                    ? text\r\n                    : decodeHTMLCached(text);\r\n            }\r\n            else if (!children.length) {\r\n                // remove the whitespace-only node right after an opening tag\r\n                text = '';\r\n            }\r\n            else if (whitespaceOption) {\r\n                if (whitespaceOption === 'condense') {\r\n                    // in condense mode, remove the whitespace node if it contains\r\n                    // line break, otherwise condense to a single space\r\n                    text = lineBreakRE.test(text) ? '' : ' ';\r\n                }\r\n                else {\r\n                    text = ' ';\r\n                }\r\n            }\r\n            else {\r\n                text = preserveWhitespace ? ' ' : '';\r\n            }\r\n            if (text) {\r\n                if (!inPre && whitespaceOption === 'condense') {\r\n                    // condense consecutive whitespaces into single space\r\n                    text = text.replace(whitespaceRE, ' ');\r\n                }\r\n                var res = void 0;\r\n                var child = void 0;\r\n                if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {\r\n                    child = {\r\n                        type: 2,\r\n                        expression: res.expression,\r\n                        tokens: res.tokens,\r\n                        text: text\r\n                    };\r\n                }\r\n                else if (text !== ' ' ||\r\n                    !children.length ||\r\n                    children[children.length - 1].text !== ' ') {\r\n                    child = {\r\n                        type: 3,\r\n                        text: text\r\n                    };\r\n                }\r\n                if (child) {\r\n                    if ( true && options.outputSourceRange) {\r\n                        child.start = start;\r\n                        child.end = end;\r\n                    }\r\n                    children.push(child);\r\n                }\r\n            }\r\n        },\r\n        comment: function (text, start, end) {\r\n            // adding anything as a sibling to the root node is forbidden\r\n            // comments should still be allowed, but ignored\r\n            if (currentParent) {\r\n                var child = {\r\n                    type: 3,\r\n                    text: text,\r\n                    isComment: true\r\n                };\r\n                if ( true && options.outputSourceRange) {\r\n                    child.start = start;\r\n                    child.end = end;\r\n                }\r\n                currentParent.children.push(child);\r\n            }\r\n        }\r\n    });\r\n    return root;\r\n}\r\nfunction processPre(el) {\r\n    if (getAndRemoveAttr(el, 'v-pre') != null) {\r\n        el.pre = true;\r\n    }\r\n}\r\nfunction processRawAttrs(el) {\r\n    var list = el.attrsList;\r\n    var len = list.length;\r\n    if (len) {\r\n        var attrs = (el.attrs = new Array(len));\r\n        for (var i = 0; i < len; i++) {\r\n            attrs[i] = {\r\n                name: list[i].name,\r\n                value: JSON.stringify(list[i].value)\r\n            };\r\n            if (list[i].start != null) {\r\n                attrs[i].start = list[i].start;\r\n                attrs[i].end = list[i].end;\r\n            }\r\n        }\r\n    }\r\n    else if (!el.pre) {\r\n        // non root node in pre blocks with no attributes\r\n        el.plain = true;\r\n    }\r\n}\r\nfunction processElement(element, options) {\r\n    processKey(element);\r\n    // determine whether this is a plain element after\r\n    // removing structural attributes\r\n    element.plain =\r\n        !element.key && !element.scopedSlots && !element.attrsList.length;\r\n    processRef(element);\r\n    processSlotContent(element);\r\n    processSlotOutlet(element);\r\n    processComponent(element);\r\n    for (var i = 0; i < transforms.length; i++) {\r\n        element = transforms[i](element, options) || element;\r\n    }\r\n    processAttrs(element);\r\n    return element;\r\n}\r\nfunction processKey(el) {\r\n    var exp = getBindingAttr(el, 'key');\r\n    if (exp) {\r\n        if (true) {\r\n            if (el.tag === 'template') {\r\n                warn(\"<template> cannot be keyed. Place the key on real elements instead.\", getRawBindingAttr(el, 'key'));\r\n            }\r\n            if (el.for) {\r\n                var iterator = el.iterator2 || el.iterator1;\r\n                var parent_1 = el.parent;\r\n                if (iterator &&\r\n                    iterator === exp &&\r\n                    parent_1 &&\r\n                    parent_1.tag === 'transition-group') {\r\n                    warn(\"Do not use v-for index as key on <transition-group> children, \" +\r\n                        \"this is the same as not using keys.\", getRawBindingAttr(el, 'key'), true /* tip */);\r\n                }\r\n            }\r\n        }\r\n        el.key = exp;\r\n    }\r\n}\r\nfunction processRef(el) {\r\n    var ref = getBindingAttr(el, 'ref');\r\n    if (ref) {\r\n        el.ref = ref;\r\n        el.refInFor = checkInFor(el);\r\n    }\r\n}\r\nfunction processFor(el) {\r\n    var exp;\r\n    if ((exp = getAndRemoveAttr(el, 'v-for'))) {\r\n        var res = parseFor(exp);\r\n        if (res) {\r\n            extend(el, res);\r\n        }\r\n        else if (true) {\r\n            warn(\"Invalid v-for expression: \".concat(exp), el.rawAttrsMap['v-for']);\r\n        }\r\n    }\r\n}\r\nfunction parseFor(exp) {\r\n    var inMatch = exp.match(forAliasRE);\r\n    if (!inMatch)\r\n        return;\r\n    var res = {};\r\n    res.for = inMatch[2].trim();\r\n    var alias = inMatch[1].trim().replace(stripParensRE, '');\r\n    var iteratorMatch = alias.match(forIteratorRE);\r\n    if (iteratorMatch) {\r\n        res.alias = alias.replace(forIteratorRE, '').trim();\r\n        res.iterator1 = iteratorMatch[1].trim();\r\n        if (iteratorMatch[2]) {\r\n            res.iterator2 = iteratorMatch[2].trim();\r\n        }\r\n    }\r\n    else {\r\n        res.alias = alias;\r\n    }\r\n    return res;\r\n}\r\nfunction processIf(el) {\r\n    var exp = getAndRemoveAttr(el, 'v-if');\r\n    if (exp) {\r\n        el.if = exp;\r\n        addIfCondition(el, {\r\n            exp: exp,\r\n            block: el\r\n        });\r\n    }\r\n    else {\r\n        if (getAndRemoveAttr(el, 'v-else') != null) {\r\n            el.else = true;\r\n        }\r\n        var elseif = getAndRemoveAttr(el, 'v-else-if');\r\n        if (elseif) {\r\n            el.elseif = elseif;\r\n        }\r\n    }\r\n}\r\nfunction processIfConditions(el, parent) {\r\n    var prev = findPrevElement(parent.children);\r\n    if (prev && prev.if) {\r\n        addIfCondition(prev, {\r\n            exp: el.elseif,\r\n            block: el\r\n        });\r\n    }\r\n    else if (true) {\r\n        warn(\"v-\".concat(el.elseif ? 'else-if=\"' + el.elseif + '\"' : 'else', \" \") +\r\n            \"used on element <\".concat(el.tag, \"> without corresponding v-if.\"), el.rawAttrsMap[el.elseif ? 'v-else-if' : 'v-else']);\r\n    }\r\n}\r\nfunction findPrevElement(children) {\r\n    var i = children.length;\r\n    while (i--) {\r\n        if (children[i].type === 1) {\r\n            return children[i];\r\n        }\r\n        else {\r\n            if ( true && children[i].text !== ' ') {\r\n                warn(\"text \\\"\".concat(children[i].text.trim(), \"\\\" between v-if and v-else(-if) \") +\r\n                    \"will be ignored.\", children[i]);\r\n            }\r\n            children.pop();\r\n        }\r\n    }\r\n}\r\nfunction addIfCondition(el, condition) {\r\n    if (!el.ifConditions) {\r\n        el.ifConditions = [];\r\n    }\r\n    el.ifConditions.push(condition);\r\n}\r\nfunction processOnce(el) {\r\n    var once = getAndRemoveAttr(el, 'v-once');\r\n    if (once != null) {\r\n        el.once = true;\r\n    }\r\n}\r\n// handle content being passed to a component as slot,\r\n// e.g. <template slot=\"xxx\">, <div slot-scope=\"xxx\">\r\nfunction processSlotContent(el) {\r\n    var slotScope;\r\n    if (el.tag === 'template') {\r\n        slotScope = getAndRemoveAttr(el, 'scope');\r\n        /* istanbul ignore if */\r\n        if ( true && slotScope) {\r\n            warn(\"the \\\"scope\\\" attribute for scoped slots have been deprecated and \" +\r\n                \"replaced by \\\"slot-scope\\\" since 2.5. The new \\\"slot-scope\\\" attribute \" +\r\n                \"can also be used on plain elements in addition to <template> to \" +\r\n                \"denote scoped slots.\", el.rawAttrsMap['scope'], true);\r\n        }\r\n        el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');\r\n    }\r\n    else if ((slotScope = getAndRemoveAttr(el, 'slot-scope'))) {\r\n        /* istanbul ignore if */\r\n        if ( true && el.attrsMap['v-for']) {\r\n            warn(\"Ambiguous combined usage of slot-scope and v-for on <\".concat(el.tag, \"> \") +\r\n                \"(v-for takes higher priority). Use a wrapper <template> for the \" +\r\n                \"scoped slot to make it clearer.\", el.rawAttrsMap['slot-scope'], true);\r\n        }\r\n        el.slotScope = slotScope;\r\n    }\r\n    // slot=\"xxx\"\r\n    var slotTarget = getBindingAttr(el, 'slot');\r\n    if (slotTarget) {\r\n        el.slotTarget = slotTarget === '\"\"' ? '\"default\"' : slotTarget;\r\n        el.slotTargetDynamic = !!(el.attrsMap[':slot'] || el.attrsMap['v-bind:slot']);\r\n        // preserve slot as an attribute for native shadow DOM compat\r\n        // only for non-scoped slots.\r\n        if (el.tag !== 'template' && !el.slotScope) {\r\n            addAttr(el, 'slot', slotTarget, getRawBindingAttr(el, 'slot'));\r\n        }\r\n    }\r\n    // 2.6 v-slot syntax\r\n    {\r\n        if (el.tag === 'template') {\r\n            // v-slot on <template>\r\n            var slotBinding = getAndRemoveAttrByRegex(el, slotRE);\r\n            if (slotBinding) {\r\n                if (true) {\r\n                    if (el.slotTarget || el.slotScope) {\r\n                        warn(\"Unexpected mixed usage of different slot syntaxes.\", el);\r\n                    }\r\n                    if (el.parent && !maybeComponent(el.parent)) {\r\n                        warn(\"<template v-slot> can only appear at the root level inside \" +\r\n                            \"the receiving component\", el);\r\n                    }\r\n                }\r\n                var _a = getSlotName(slotBinding), name_2 = _a.name, dynamic = _a.dynamic;\r\n                el.slotTarget = name_2;\r\n                el.slotTargetDynamic = dynamic;\r\n                el.slotScope = slotBinding.value || emptySlotScopeToken; // force it into a scoped slot for perf\r\n            }\r\n        }\r\n        else {\r\n            // v-slot on component, denotes default slot\r\n            var slotBinding = getAndRemoveAttrByRegex(el, slotRE);\r\n            if (slotBinding) {\r\n                if (true) {\r\n                    if (!maybeComponent(el)) {\r\n                        warn(\"v-slot can only be used on components or <template>.\", slotBinding);\r\n                    }\r\n                    if (el.slotScope || el.slotTarget) {\r\n                        warn(\"Unexpected mixed usage of different slot syntaxes.\", el);\r\n                    }\r\n                    if (el.scopedSlots) {\r\n                        warn(\"To avoid scope ambiguity, the default slot should also use \" +\r\n                            \"<template> syntax when there are other named slots.\", slotBinding);\r\n                    }\r\n                }\r\n                // add the component's children to its default slot\r\n                var slots = el.scopedSlots || (el.scopedSlots = {});\r\n                var _b = getSlotName(slotBinding), name_3 = _b.name, dynamic = _b.dynamic;\r\n                var slotContainer_1 = (slots[name_3] = createASTElement('template', [], el));\r\n                slotContainer_1.slotTarget = name_3;\r\n                slotContainer_1.slotTargetDynamic = dynamic;\r\n                slotContainer_1.children = el.children.filter(function (c) {\r\n                    if (!c.slotScope) {\r\n                        c.parent = slotContainer_1;\r\n                        return true;\r\n                    }\r\n                });\r\n                slotContainer_1.slotScope = slotBinding.value || emptySlotScopeToken;\r\n                // remove children as they are returned from scopedSlots now\r\n                el.children = [];\r\n                // mark el non-plain so data gets generated\r\n                el.plain = false;\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction getSlotName(binding) {\r\n    var name = binding.name.replace(slotRE, '');\r\n    if (!name) {\r\n        if (binding.name[0] !== '#') {\r\n            name = 'default';\r\n        }\r\n        else if (true) {\r\n            warn(\"v-slot shorthand syntax requires a slot name.\", binding);\r\n        }\r\n    }\r\n    return dynamicArgRE.test(name)\r\n        ? // dynamic [name]\r\n            { name: name.slice(1, -1), dynamic: true }\r\n        : // static name\r\n            { name: \"\\\"\".concat(name, \"\\\"\"), dynamic: false };\r\n}\r\n// handle <slot/> outlets\r\nfunction processSlotOutlet(el) {\r\n    if (el.tag === 'slot') {\r\n        el.slotName = getBindingAttr(el, 'name');\r\n        if ( true && el.key) {\r\n            warn(\"`key` does not work on <slot> because slots are abstract outlets \" +\r\n                \"and can possibly expand into multiple elements. \" +\r\n                \"Use the key on a wrapping element instead.\", getRawBindingAttr(el, 'key'));\r\n        }\r\n    }\r\n}\r\nfunction processComponent(el) {\r\n    var binding;\r\n    if ((binding = getBindingAttr(el, 'is'))) {\r\n        el.component = binding;\r\n    }\r\n    if (getAndRemoveAttr(el, 'inline-template') != null) {\r\n        el.inlineTemplate = true;\r\n    }\r\n}\r\nfunction processAttrs(el) {\r\n    var list = el.attrsList;\r\n    var i, l, name, rawName, value, modifiers, syncGen, isDynamic;\r\n    for (i = 0, l = list.length; i < l; i++) {\r\n        name = rawName = list[i].name;\r\n        value = list[i].value;\r\n        if (dirRE.test(name)) {\r\n            // mark element as dynamic\r\n            el.hasBindings = true;\r\n            // modifiers\r\n            modifiers = parseModifiers(name.replace(dirRE, ''));\r\n            // support .foo shorthand syntax for the .prop modifier\r\n            if (modifiers) {\r\n                name = name.replace(modifierRE, '');\r\n            }\r\n            if (bindRE.test(name)) {\r\n                // v-bind\r\n                name = name.replace(bindRE, '');\r\n                value = parseFilters(value);\r\n                isDynamic = dynamicArgRE.test(name);\r\n                if (isDynamic) {\r\n                    name = name.slice(1, -1);\r\n                }\r\n                if ( true && value.trim().length === 0) {\r\n                    warn(\"The value for a v-bind expression cannot be empty. Found in \\\"v-bind:\".concat(name, \"\\\"\"));\r\n                }\r\n                if (modifiers) {\r\n                    if (modifiers.prop && !isDynamic) {\r\n                        name = camelize(name);\r\n                        if (name === 'innerHtml')\r\n                            name = 'innerHTML';\r\n                    }\r\n                    if (modifiers.camel && !isDynamic) {\r\n                        name = camelize(name);\r\n                    }\r\n                    if (modifiers.sync) {\r\n                        syncGen = genAssignmentCode(value, \"$event\");\r\n                        if (!isDynamic) {\r\n                            addHandler(el, \"update:\".concat(camelize(name)), syncGen, null, false, warn, list[i]);\r\n                            if (hyphenate(name) !== camelize(name)) {\r\n                                addHandler(el, \"update:\".concat(hyphenate(name)), syncGen, null, false, warn, list[i]);\r\n                            }\r\n                        }\r\n                        else {\r\n                            // handler w/ dynamic event name\r\n                            addHandler(el, \"\\\"update:\\\"+(\".concat(name, \")\"), syncGen, null, false, warn, list[i], true // dynamic\r\n                            );\r\n                        }\r\n                    }\r\n                }\r\n                if ((modifiers && modifiers.prop) ||\r\n                    (!el.component && platformMustUseProp(el.tag, el.attrsMap.type, name))) {\r\n                    addProp(el, name, value, list[i], isDynamic);\r\n                }\r\n                else {\r\n                    addAttr(el, name, value, list[i], isDynamic);\r\n                }\r\n            }\r\n            else if (onRE.test(name)) {\r\n                // v-on\r\n                name = name.replace(onRE, '');\r\n                isDynamic = dynamicArgRE.test(name);\r\n                if (isDynamic) {\r\n                    name = name.slice(1, -1);\r\n                }\r\n                addHandler(el, name, value, modifiers, false, warn, list[i], isDynamic);\r\n            }\r\n            else {\r\n                // normal directives\r\n                name = name.replace(dirRE, '');\r\n                // parse arg\r\n                var argMatch = name.match(argRE);\r\n                var arg = argMatch && argMatch[1];\r\n                isDynamic = false;\r\n                if (arg) {\r\n                    name = name.slice(0, -(arg.length + 1));\r\n                    if (dynamicArgRE.test(arg)) {\r\n                        arg = arg.slice(1, -1);\r\n                        isDynamic = true;\r\n                    }\r\n                }\r\n                addDirective(el, name, rawName, value, arg, isDynamic, modifiers, list[i]);\r\n                if ( true && name === 'model') {\r\n                    checkForAliasModel(el, value);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            // literal attribute\r\n            if (true) {\r\n                var res = parseText(value, delimiters);\r\n                if (res) {\r\n                    warn(\"\".concat(name, \"=\\\"\").concat(value, \"\\\": \") +\r\n                        'Interpolation inside attributes has been removed. ' +\r\n                        'Use v-bind or the colon shorthand instead. For example, ' +\r\n                        'instead of <div id=\"{{ val }}\">, use <div :id=\"val\">.', list[i]);\r\n                }\r\n            }\r\n            addAttr(el, name, JSON.stringify(value), list[i]);\r\n            // #6887 firefox doesn't update muted state if set via attribute\r\n            // even immediately after element creation\r\n            if (!el.component &&\r\n                name === 'muted' &&\r\n                platformMustUseProp(el.tag, el.attrsMap.type, name)) {\r\n                addProp(el, name, 'true', list[i]);\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction checkInFor(el) {\r\n    var parent = el;\r\n    while (parent) {\r\n        if (parent.for !== undefined) {\r\n            return true;\r\n        }\r\n        parent = parent.parent;\r\n    }\r\n    return false;\r\n}\r\nfunction parseModifiers(name) {\r\n    var match = name.match(modifierRE);\r\n    if (match) {\r\n        var ret_1 = {};\r\n        match.forEach(function (m) {\r\n            ret_1[m.slice(1)] = true;\r\n        });\r\n        return ret_1;\r\n    }\r\n}\r\nfunction makeAttrsMap(attrs) {\r\n    var map = {};\r\n    for (var i = 0, l = attrs.length; i < l; i++) {\r\n        if ( true && map[attrs[i].name] && !isIE && !isEdge) {\r\n            warn('duplicate attribute: ' + attrs[i].name, attrs[i]);\r\n        }\r\n        map[attrs[i].name] = attrs[i].value;\r\n    }\r\n    return map;\r\n}\r\n// for script (e.g. type=\"x/template\") or style, do not decode content\r\nfunction isTextTag(el) {\r\n    return el.tag === 'script' || el.tag === 'style';\r\n}\r\nfunction isForbiddenTag(el) {\r\n    return (el.tag === 'style' ||\r\n        (el.tag === 'script' &&\r\n            (!el.attrsMap.type || el.attrsMap.type === 'text/javascript')));\r\n}\r\nvar ieNSBug = /^xmlns:NS\\d+/;\r\nvar ieNSPrefix = /^NS\\d+:/;\r\n/* istanbul ignore next */\r\nfunction guardIESVGBug(attrs) {\r\n    var res = [];\r\n    for (var i = 0; i < attrs.length; i++) {\r\n        var attr = attrs[i];\r\n        if (!ieNSBug.test(attr.name)) {\r\n            attr.name = attr.name.replace(ieNSPrefix, '');\r\n            res.push(attr);\r\n        }\r\n    }\r\n    return res;\r\n}\r\nfunction checkForAliasModel(el, value) {\r\n    var _el = el;\r\n    while (_el) {\r\n        if (_el.for && _el.alias === value) {\r\n            warn(\"<\".concat(el.tag, \" v-model=\\\"\").concat(value, \"\\\">: \") +\r\n                \"You are binding v-model directly to a v-for iteration alias. \" +\r\n                \"This will not be able to modify the v-for source array because \" +\r\n                \"writing to the alias is like modifying a function local variable. \" +\r\n                \"Consider using an array of objects and use v-model on an object property instead.\", el.rawAttrsMap['v-model']);\r\n        }\r\n        _el = _el.parent;\r\n    }\r\n}\n\n/**\r\n * Expand input[v-model] with dynamic type bindings into v-if-else chains\r\n * Turn this:\r\n *   <input v-model=\"data[type]\" :type=\"type\">\r\n * into this:\r\n *   <input v-if=\"type === 'checkbox'\" type=\"checkbox\" v-model=\"data[type]\">\r\n *   <input v-else-if=\"type === 'radio'\" type=\"radio\" v-model=\"data[type]\">\r\n *   <input v-else :type=\"type\" v-model=\"data[type]\">\r\n */\r\nfunction preTransformNode(el, options) {\r\n    if (el.tag === 'input') {\r\n        var map = el.attrsMap;\r\n        if (!map['v-model']) {\r\n            return;\r\n        }\r\n        var typeBinding = void 0;\r\n        if (map[':type'] || map['v-bind:type']) {\r\n            typeBinding = getBindingAttr(el, 'type');\r\n        }\r\n        if (!map.type && !typeBinding && map['v-bind']) {\r\n            typeBinding = \"(\".concat(map['v-bind'], \").type\");\r\n        }\r\n        if (typeBinding) {\r\n            var ifCondition = getAndRemoveAttr(el, 'v-if', true);\r\n            var ifConditionExtra = ifCondition ? \"&&(\".concat(ifCondition, \")\") : \"\";\r\n            var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;\r\n            var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true);\r\n            // 1. checkbox\r\n            var branch0 = cloneASTElement(el);\r\n            // process for on the main node\r\n            processFor(branch0);\r\n            addRawAttr(branch0, 'type', 'checkbox');\r\n            processElement(branch0, options);\r\n            branch0.processed = true; // prevent it from double-processed\r\n            branch0.if = \"(\".concat(typeBinding, \")==='checkbox'\") + ifConditionExtra;\r\n            addIfCondition(branch0, {\r\n                exp: branch0.if,\r\n                block: branch0\r\n            });\r\n            // 2. add radio else-if condition\r\n            var branch1 = cloneASTElement(el);\r\n            getAndRemoveAttr(branch1, 'v-for', true);\r\n            addRawAttr(branch1, 'type', 'radio');\r\n            processElement(branch1, options);\r\n            addIfCondition(branch0, {\r\n                exp: \"(\".concat(typeBinding, \")==='radio'\") + ifConditionExtra,\r\n                block: branch1\r\n            });\r\n            // 3. other\r\n            var branch2 = cloneASTElement(el);\r\n            getAndRemoveAttr(branch2, 'v-for', true);\r\n            addRawAttr(branch2, ':type', typeBinding);\r\n            processElement(branch2, options);\r\n            addIfCondition(branch0, {\r\n                exp: ifCondition,\r\n                block: branch2\r\n            });\r\n            if (hasElse) {\r\n                branch0.else = true;\r\n            }\r\n            else if (elseIfCondition) {\r\n                branch0.elseif = elseIfCondition;\r\n            }\r\n            return branch0;\r\n        }\r\n    }\r\n}\r\nfunction cloneASTElement(el) {\r\n    return createASTElement(el.tag, el.attrsList.slice(), el.parent);\r\n}\r\nvar model = {\r\n    preTransformNode: preTransformNode\r\n};\n\nvar modules = [klass, style, model];\n\nfunction text(el, dir) {\r\n    if (dir.value) {\r\n        addProp(el, 'textContent', \"_s(\".concat(dir.value, \")\"), dir);\r\n    }\r\n}\n\nfunction html(el, dir) {\r\n    if (dir.value) {\r\n        addProp(el, 'innerHTML', \"_s(\".concat(dir.value, \")\"), dir);\r\n    }\r\n}\n\nvar directives = {\r\n    model: model$1,\r\n    text: text,\r\n    html: html\r\n};\n\nvar baseOptions = {\r\n    expectHTML: true,\r\n    modules: modules,\r\n    directives: directives,\r\n    isPreTag: isPreTag,\r\n    isUnaryTag: isUnaryTag,\r\n    mustUseProp: mustUseProp,\r\n    canBeLeftOpenTag: canBeLeftOpenTag,\r\n    isReservedTag: isReservedTag,\r\n    getTagNamespace: getTagNamespace,\r\n    staticKeys: genStaticKeys$1(modules)\r\n};\n\nvar isStaticKey;\r\nvar isPlatformReservedTag;\r\nvar genStaticKeysCached = cached(genStaticKeys);\r\n/**\r\n * Goal of the optimizer: walk the generated template AST tree\r\n * and detect sub-trees that are purely static, i.e. parts of\r\n * the DOM that never needs to change.\r\n *\r\n * Once we detect these sub-trees, we can:\r\n *\r\n * 1. Hoist them into constants, so that we no longer need to\r\n *    create fresh nodes for them on each re-render;\r\n * 2. Completely skip them in the patching process.\r\n */\r\nfunction optimize(root, options) {\r\n    if (!root)\r\n        return;\r\n    isStaticKey = genStaticKeysCached(options.staticKeys || '');\r\n    isPlatformReservedTag = options.isReservedTag || no;\r\n    // first pass: mark all non-static nodes.\r\n    markStatic(root);\r\n    // second pass: mark static roots.\r\n    markStaticRoots(root, false);\r\n}\r\nfunction genStaticKeys(keys) {\r\n    return makeMap('type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap' +\r\n        (keys ? ',' + keys : ''));\r\n}\r\nfunction markStatic(node) {\r\n    node.static = isStatic(node);\r\n    if (node.type === 1) {\r\n        // do not make component slot content static. this avoids\r\n        // 1. components not able to mutate slot nodes\r\n        // 2. static slot content fails for hot-reloading\r\n        if (!isPlatformReservedTag(node.tag) &&\r\n            node.tag !== 'slot' &&\r\n            node.attrsMap['inline-template'] == null) {\r\n            return;\r\n        }\r\n        for (var i = 0, l = node.children.length; i < l; i++) {\r\n            var child = node.children[i];\r\n            markStatic(child);\r\n            if (!child.static) {\r\n                node.static = false;\r\n            }\r\n        }\r\n        if (node.ifConditions) {\r\n            for (var i = 1, l = node.ifConditions.length; i < l; i++) {\r\n                var block = node.ifConditions[i].block;\r\n                markStatic(block);\r\n                if (!block.static) {\r\n                    node.static = false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction markStaticRoots(node, isInFor) {\r\n    if (node.type === 1) {\r\n        if (node.static || node.once) {\r\n            node.staticInFor = isInFor;\r\n        }\r\n        // For a node to qualify as a static root, it should have children that\r\n        // are not just static text. Otherwise the cost of hoisting out will\r\n        // outweigh the benefits and it's better off to just always render it fresh.\r\n        if (node.static &&\r\n            node.children.length &&\r\n            !(node.children.length === 1 && node.children[0].type === 3)) {\r\n            node.staticRoot = true;\r\n            return;\r\n        }\r\n        else {\r\n            node.staticRoot = false;\r\n        }\r\n        if (node.children) {\r\n            for (var i = 0, l = node.children.length; i < l; i++) {\r\n                markStaticRoots(node.children[i], isInFor || !!node.for);\r\n            }\r\n        }\r\n        if (node.ifConditions) {\r\n            for (var i = 1, l = node.ifConditions.length; i < l; i++) {\r\n                markStaticRoots(node.ifConditions[i].block, isInFor);\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction isStatic(node) {\r\n    if (node.type === 2) {\r\n        // expression\r\n        return false;\r\n    }\r\n    if (node.type === 3) {\r\n        // text\r\n        return true;\r\n    }\r\n    return !!(node.pre ||\r\n        (!node.hasBindings && // no dynamic bindings\r\n            !node.if &&\r\n            !node.for && // not v-if or v-for or v-else\r\n            !isBuiltInTag(node.tag) && // not a built-in\r\n            isPlatformReservedTag(node.tag) && // not a component\r\n            !isDirectChildOfTemplateFor(node) &&\r\n            Object.keys(node).every(isStaticKey)));\r\n}\r\nfunction isDirectChildOfTemplateFor(node) {\r\n    while (node.parent) {\r\n        node = node.parent;\r\n        if (node.tag !== 'template') {\r\n            return false;\r\n        }\r\n        if (node.for) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\n\nvar fnExpRE = /^([\\w$_]+|\\([^)]*?\\))\\s*=>|^function(?:\\s+[\\w$]+)?\\s*\\(/;\r\nvar fnInvokeRE = /\\([^)]*?\\);*$/;\r\nvar simplePathRE = /^[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['[^']*?']|\\[\"[^\"]*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*$/;\r\n// KeyboardEvent.keyCode aliases\r\nvar keyCodes = {\r\n    esc: 27,\r\n    tab: 9,\r\n    enter: 13,\r\n    space: 32,\r\n    up: 38,\r\n    left: 37,\r\n    right: 39,\r\n    down: 40,\r\n    delete: [8, 46]\r\n};\r\n// KeyboardEvent.key aliases\r\nvar keyNames = {\r\n    // #7880: IE11 and Edge use `Esc` for Escape key name.\r\n    esc: ['Esc', 'Escape'],\r\n    tab: 'Tab',\r\n    enter: 'Enter',\r\n    // #9112: IE11 uses `Spacebar` for Space key name.\r\n    space: [' ', 'Spacebar'],\r\n    // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.\r\n    up: ['Up', 'ArrowUp'],\r\n    left: ['Left', 'ArrowLeft'],\r\n    right: ['Right', 'ArrowRight'],\r\n    down: ['Down', 'ArrowDown'],\r\n    // #9112: IE11 uses `Del` for Delete key name.\r\n    delete: ['Backspace', 'Delete', 'Del']\r\n};\r\n// #4868: modifiers that prevent the execution of the listener\r\n// need to explicitly return null so that we can determine whether to remove\r\n// the listener for .once\r\nvar genGuard = function (condition) { return \"if(\".concat(condition, \")return null;\"); };\r\nvar modifierCode = {\r\n    stop: '$event.stopPropagation();',\r\n    prevent: '$event.preventDefault();',\r\n    self: genGuard(\"$event.target !== $event.currentTarget\"),\r\n    ctrl: genGuard(\"!$event.ctrlKey\"),\r\n    shift: genGuard(\"!$event.shiftKey\"),\r\n    alt: genGuard(\"!$event.altKey\"),\r\n    meta: genGuard(\"!$event.metaKey\"),\r\n    left: genGuard(\"'button' in $event && $event.button !== 0\"),\r\n    middle: genGuard(\"'button' in $event && $event.button !== 1\"),\r\n    right: genGuard(\"'button' in $event && $event.button !== 2\")\r\n};\r\nfunction genHandlers(events, isNative) {\r\n    var prefix = isNative ? 'nativeOn:' : 'on:';\r\n    var staticHandlers = \"\";\r\n    var dynamicHandlers = \"\";\r\n    for (var name_1 in events) {\r\n        var handlerCode = genHandler(events[name_1]);\r\n        //@ts-expect-error\r\n        if (events[name_1] && events[name_1].dynamic) {\r\n            dynamicHandlers += \"\".concat(name_1, \",\").concat(handlerCode, \",\");\r\n        }\r\n        else {\r\n            staticHandlers += \"\\\"\".concat(name_1, \"\\\":\").concat(handlerCode, \",\");\r\n        }\r\n    }\r\n    staticHandlers = \"{\".concat(staticHandlers.slice(0, -1), \"}\");\r\n    if (dynamicHandlers) {\r\n        return prefix + \"_d(\".concat(staticHandlers, \",[\").concat(dynamicHandlers.slice(0, -1), \"])\");\r\n    }\r\n    else {\r\n        return prefix + staticHandlers;\r\n    }\r\n}\r\nfunction genHandler(handler) {\r\n    if (!handler) {\r\n        return 'function(){}';\r\n    }\r\n    if (Array.isArray(handler)) {\r\n        return \"[\".concat(handler.map(function (handler) { return genHandler(handler); }).join(','), \"]\");\r\n    }\r\n    var isMethodPath = simplePathRE.test(handler.value);\r\n    var isFunctionExpression = fnExpRE.test(handler.value);\r\n    var isFunctionInvocation = simplePathRE.test(handler.value.replace(fnInvokeRE, ''));\r\n    if (!handler.modifiers) {\r\n        if (isMethodPath || isFunctionExpression) {\r\n            return handler.value;\r\n        }\r\n        return \"function($event){\".concat(isFunctionInvocation ? \"return \".concat(handler.value) : handler.value, \"}\"); // inline statement\r\n    }\r\n    else {\r\n        var code = '';\r\n        var genModifierCode = '';\r\n        var keys = [];\r\n        var _loop_1 = function (key) {\r\n            if (modifierCode[key]) {\r\n                genModifierCode += modifierCode[key];\r\n                // left/right\r\n                if (keyCodes[key]) {\r\n                    keys.push(key);\r\n                }\r\n            }\r\n            else if (key === 'exact') {\r\n                var modifiers_1 = handler.modifiers;\r\n                genModifierCode += genGuard(['ctrl', 'shift', 'alt', 'meta']\r\n                    .filter(function (keyModifier) { return !modifiers_1[keyModifier]; })\r\n                    .map(function (keyModifier) { return \"$event.\".concat(keyModifier, \"Key\"); })\r\n                    .join('||'));\r\n            }\r\n            else {\r\n                keys.push(key);\r\n            }\r\n        };\r\n        for (var key in handler.modifiers) {\r\n            _loop_1(key);\r\n        }\r\n        if (keys.length) {\r\n            code += genKeyFilter(keys);\r\n        }\r\n        // Make sure modifiers like prevent and stop get executed after key filtering\r\n        if (genModifierCode) {\r\n            code += genModifierCode;\r\n        }\r\n        var handlerCode = isMethodPath\r\n            ? \"return \".concat(handler.value, \".apply(null, arguments)\")\r\n            : isFunctionExpression\r\n                ? \"return (\".concat(handler.value, \").apply(null, arguments)\")\r\n                : isFunctionInvocation\r\n                    ? \"return \".concat(handler.value)\r\n                    : handler.value;\r\n        return \"function($event){\".concat(code).concat(handlerCode, \"}\");\r\n    }\r\n}\r\nfunction genKeyFilter(keys) {\r\n    return (\r\n    // make sure the key filters only apply to KeyboardEvents\r\n    // #9441: can't use 'keyCode' in $event because Chrome autofill fires fake\r\n    // key events that do not have keyCode property...\r\n    \"if(!$event.type.indexOf('key')&&\" +\r\n        \"\".concat(keys.map(genFilterCode).join('&&'), \")return null;\"));\r\n}\r\nfunction genFilterCode(key) {\r\n    var keyVal = parseInt(key, 10);\r\n    if (keyVal) {\r\n        return \"$event.keyCode!==\".concat(keyVal);\r\n    }\r\n    var keyCode = keyCodes[key];\r\n    var keyName = keyNames[key];\r\n    return (\"_k($event.keyCode,\" +\r\n        \"\".concat(JSON.stringify(key), \",\") +\r\n        \"\".concat(JSON.stringify(keyCode), \",\") +\r\n        \"$event.key,\" +\r\n        \"\".concat(JSON.stringify(keyName)) +\r\n        \")\");\r\n}\n\nfunction on(el, dir) {\r\n    if ( true && dir.modifiers) {\r\n        warn$2(\"v-on without argument does not support modifiers.\");\r\n    }\r\n    el.wrapListeners = function (code) { return \"_g(\".concat(code, \",\").concat(dir.value, \")\"); };\r\n}\n\nfunction bind(el, dir) {\r\n    el.wrapData = function (code) {\r\n        return \"_b(\".concat(code, \",'\").concat(el.tag, \"',\").concat(dir.value, \",\").concat(dir.modifiers && dir.modifiers.prop ? 'true' : 'false').concat(dir.modifiers && dir.modifiers.sync ? ',true' : '', \")\");\r\n    };\r\n}\n\nvar baseDirectives = {\r\n    on: on,\r\n    bind: bind,\r\n    cloak: noop\r\n};\n\nvar CodegenState = /** @class */ (function () {\r\n    function CodegenState(options) {\r\n        this.options = options;\r\n        this.warn = options.warn || baseWarn;\r\n        this.transforms = pluckModuleFunction(options.modules, 'transformCode');\r\n        this.dataGenFns = pluckModuleFunction(options.modules, 'genData');\r\n        this.directives = extend(extend({}, baseDirectives), options.directives);\r\n        var isReservedTag = options.isReservedTag || no;\r\n        this.maybeComponent = function (el) {\r\n            return !!el.component || !isReservedTag(el.tag);\r\n        };\r\n        this.onceId = 0;\r\n        this.staticRenderFns = [];\r\n        this.pre = false;\r\n    }\r\n    return CodegenState;\r\n}());\r\nfunction generate(ast, options) {\r\n    var state = new CodegenState(options);\r\n    // fix #11483, Root level <script> tags should not be rendered.\r\n    var code = ast\r\n        ? ast.tag === 'script'\r\n            ? 'null'\r\n            : genElement(ast, state)\r\n        : '_c(\"div\")';\r\n    return {\r\n        render: \"with(this){return \".concat(code, \"}\"),\r\n        staticRenderFns: state.staticRenderFns\r\n    };\r\n}\r\nfunction genElement(el, state) {\r\n    if (el.parent) {\r\n        el.pre = el.pre || el.parent.pre;\r\n    }\r\n    if (el.staticRoot && !el.staticProcessed) {\r\n        return genStatic(el, state);\r\n    }\r\n    else if (el.once && !el.onceProcessed) {\r\n        return genOnce(el, state);\r\n    }\r\n    else if (el.for && !el.forProcessed) {\r\n        return genFor(el, state);\r\n    }\r\n    else if (el.if && !el.ifProcessed) {\r\n        return genIf(el, state);\r\n    }\r\n    else if (el.tag === 'template' && !el.slotTarget && !state.pre) {\r\n        return genChildren(el, state) || 'void 0';\r\n    }\r\n    else if (el.tag === 'slot') {\r\n        return genSlot(el, state);\r\n    }\r\n    else {\r\n        // component or element\r\n        var code = void 0;\r\n        if (el.component) {\r\n            code = genComponent(el.component, el, state);\r\n        }\r\n        else {\r\n            var data = void 0;\r\n            var maybeComponent = state.maybeComponent(el);\r\n            if (!el.plain || (el.pre && maybeComponent)) {\r\n                data = genData(el, state);\r\n            }\r\n            var tag \r\n            // check if this is a component in <script setup>\r\n            = void 0;\r\n            // check if this is a component in <script setup>\r\n            var bindings = state.options.bindings;\r\n            if (maybeComponent && bindings && bindings.__isScriptSetup !== false) {\r\n                tag = checkBindingType(bindings, el.tag);\r\n            }\r\n            if (!tag)\r\n                tag = \"'\".concat(el.tag, \"'\");\r\n            var children = el.inlineTemplate ? null : genChildren(el, state, true);\r\n            code = \"_c(\".concat(tag).concat(data ? \",\".concat(data) : '' // data\r\n            ).concat(children ? \",\".concat(children) : '' // children\r\n            , \")\");\r\n        }\r\n        // module transforms\r\n        for (var i = 0; i < state.transforms.length; i++) {\r\n            code = state.transforms[i](el, code);\r\n        }\r\n        return code;\r\n    }\r\n}\r\nfunction checkBindingType(bindings, key) {\r\n    var camelName = camelize(key);\r\n    var PascalName = capitalize(camelName);\r\n    var checkType = function (type) {\r\n        if (bindings[key] === type) {\r\n            return key;\r\n        }\r\n        if (bindings[camelName] === type) {\r\n            return camelName;\r\n        }\r\n        if (bindings[PascalName] === type) {\r\n            return PascalName;\r\n        }\r\n    };\r\n    var fromConst = checkType(\"setup-const\" /* BindingTypes.SETUP_CONST */) ||\r\n        checkType(\"setup-reactive-const\" /* BindingTypes.SETUP_REACTIVE_CONST */);\r\n    if (fromConst) {\r\n        return fromConst;\r\n    }\r\n    var fromMaybeRef = checkType(\"setup-let\" /* BindingTypes.SETUP_LET */) ||\r\n        checkType(\"setup-ref\" /* BindingTypes.SETUP_REF */) ||\r\n        checkType(\"setup-maybe-ref\" /* BindingTypes.SETUP_MAYBE_REF */);\r\n    if (fromMaybeRef) {\r\n        return fromMaybeRef;\r\n    }\r\n}\r\n// hoist static sub-trees out\r\nfunction genStatic(el, state) {\r\n    el.staticProcessed = true;\r\n    // Some elements (templates) need to behave differently inside of a v-pre\r\n    // node.  All pre nodes are static roots, so we can use this as a location to\r\n    // wrap a state change and reset it upon exiting the pre node.\r\n    var originalPreState = state.pre;\r\n    if (el.pre) {\r\n        state.pre = el.pre;\r\n    }\r\n    state.staticRenderFns.push(\"with(this){return \".concat(genElement(el, state), \"}\"));\r\n    state.pre = originalPreState;\r\n    return \"_m(\".concat(state.staticRenderFns.length - 1).concat(el.staticInFor ? ',true' : '', \")\");\r\n}\r\n// v-once\r\nfunction genOnce(el, state) {\r\n    el.onceProcessed = true;\r\n    if (el.if && !el.ifProcessed) {\r\n        return genIf(el, state);\r\n    }\r\n    else if (el.staticInFor) {\r\n        var key = '';\r\n        var parent_1 = el.parent;\r\n        while (parent_1) {\r\n            if (parent_1.for) {\r\n                key = parent_1.key;\r\n                break;\r\n            }\r\n            parent_1 = parent_1.parent;\r\n        }\r\n        if (!key) {\r\n             true &&\r\n                state.warn(\"v-once can only be used inside v-for that is keyed. \", el.rawAttrsMap['v-once']);\r\n            return genElement(el, state);\r\n        }\r\n        return \"_o(\".concat(genElement(el, state), \",\").concat(state.onceId++, \",\").concat(key, \")\");\r\n    }\r\n    else {\r\n        return genStatic(el, state);\r\n    }\r\n}\r\nfunction genIf(el, state, altGen, altEmpty) {\r\n    el.ifProcessed = true; // avoid recursion\r\n    return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty);\r\n}\r\nfunction genIfConditions(conditions, state, altGen, altEmpty) {\r\n    if (!conditions.length) {\r\n        return altEmpty || '_e()';\r\n    }\r\n    var condition = conditions.shift();\r\n    if (condition.exp) {\r\n        return \"(\".concat(condition.exp, \")?\").concat(genTernaryExp(condition.block), \":\").concat(genIfConditions(conditions, state, altGen, altEmpty));\r\n    }\r\n    else {\r\n        return \"\".concat(genTernaryExp(condition.block));\r\n    }\r\n    // v-if with v-once should generate code like (a)?_m(0):_m(1)\r\n    function genTernaryExp(el) {\r\n        return altGen\r\n            ? altGen(el, state)\r\n            : el.once\r\n                ? genOnce(el, state)\r\n                : genElement(el, state);\r\n    }\r\n}\r\nfunction genFor(el, state, altGen, altHelper) {\r\n    var exp = el.for;\r\n    var alias = el.alias;\r\n    var iterator1 = el.iterator1 ? \",\".concat(el.iterator1) : '';\r\n    var iterator2 = el.iterator2 ? \",\".concat(el.iterator2) : '';\r\n    if ( true &&\r\n        state.maybeComponent(el) &&\r\n        el.tag !== 'slot' &&\r\n        el.tag !== 'template' &&\r\n        !el.key) {\r\n        state.warn(\"<\".concat(el.tag, \" v-for=\\\"\").concat(alias, \" in \").concat(exp, \"\\\">: component lists rendered with \") +\r\n            \"v-for should have explicit keys. \" +\r\n            \"See https://vuejs.org/guide/list.html#key for more info.\", el.rawAttrsMap['v-for'], true /* tip */);\r\n    }\r\n    el.forProcessed = true; // avoid recursion\r\n    return (\"\".concat(altHelper || '_l', \"((\").concat(exp, \"),\") +\r\n        \"function(\".concat(alias).concat(iterator1).concat(iterator2, \"){\") +\r\n        \"return \".concat((altGen || genElement)(el, state)) +\r\n        '})');\r\n}\r\nfunction genData(el, state) {\r\n    var data = '{';\r\n    // directives first.\r\n    // directives may mutate the el's other properties before they are generated.\r\n    var dirs = genDirectives(el, state);\r\n    if (dirs)\r\n        data += dirs + ',';\r\n    // key\r\n    if (el.key) {\r\n        data += \"key:\".concat(el.key, \",\");\r\n    }\r\n    // ref\r\n    if (el.ref) {\r\n        data += \"ref:\".concat(el.ref, \",\");\r\n    }\r\n    if (el.refInFor) {\r\n        data += \"refInFor:true,\";\r\n    }\r\n    // pre\r\n    if (el.pre) {\r\n        data += \"pre:true,\";\r\n    }\r\n    // record original tag name for components using \"is\" attribute\r\n    if (el.component) {\r\n        data += \"tag:\\\"\".concat(el.tag, \"\\\",\");\r\n    }\r\n    // module data generation functions\r\n    for (var i = 0; i < state.dataGenFns.length; i++) {\r\n        data += state.dataGenFns[i](el);\r\n    }\r\n    // attributes\r\n    if (el.attrs) {\r\n        data += \"attrs:\".concat(genProps(el.attrs), \",\");\r\n    }\r\n    // DOM props\r\n    if (el.props) {\r\n        data += \"domProps:\".concat(genProps(el.props), \",\");\r\n    }\r\n    // event handlers\r\n    if (el.events) {\r\n        data += \"\".concat(genHandlers(el.events, false), \",\");\r\n    }\r\n    if (el.nativeEvents) {\r\n        data += \"\".concat(genHandlers(el.nativeEvents, true), \",\");\r\n    }\r\n    // slot target\r\n    // only for non-scoped slots\r\n    if (el.slotTarget && !el.slotScope) {\r\n        data += \"slot:\".concat(el.slotTarget, \",\");\r\n    }\r\n    // scoped slots\r\n    if (el.scopedSlots) {\r\n        data += \"\".concat(genScopedSlots(el, el.scopedSlots, state), \",\");\r\n    }\r\n    // component v-model\r\n    if (el.model) {\r\n        data += \"model:{value:\".concat(el.model.value, \",callback:\").concat(el.model.callback, \",expression:\").concat(el.model.expression, \"},\");\r\n    }\r\n    // inline-template\r\n    if (el.inlineTemplate) {\r\n        var inlineTemplate = genInlineTemplate(el, state);\r\n        if (inlineTemplate) {\r\n            data += \"\".concat(inlineTemplate, \",\");\r\n        }\r\n    }\r\n    data = data.replace(/,$/, '') + '}';\r\n    // v-bind dynamic argument wrap\r\n    // v-bind with dynamic arguments must be applied using the same v-bind object\r\n    // merge helper so that class/style/mustUseProp attrs are handled correctly.\r\n    if (el.dynamicAttrs) {\r\n        data = \"_b(\".concat(data, \",\\\"\").concat(el.tag, \"\\\",\").concat(genProps(el.dynamicAttrs), \")\");\r\n    }\r\n    // v-bind data wrap\r\n    if (el.wrapData) {\r\n        data = el.wrapData(data);\r\n    }\r\n    // v-on data wrap\r\n    if (el.wrapListeners) {\r\n        data = el.wrapListeners(data);\r\n    }\r\n    return data;\r\n}\r\nfunction genDirectives(el, state) {\r\n    var dirs = el.directives;\r\n    if (!dirs)\r\n        return;\r\n    var res = 'directives:[';\r\n    var hasRuntime = false;\r\n    var i, l, dir, needRuntime;\r\n    for (i = 0, l = dirs.length; i < l; i++) {\r\n        dir = dirs[i];\r\n        needRuntime = true;\r\n        var gen = state.directives[dir.name];\r\n        if (gen) {\r\n            // compile-time directive that manipulates AST.\r\n            // returns true if it also needs a runtime counterpart.\r\n            needRuntime = !!gen(el, dir, state.warn);\r\n        }\r\n        if (needRuntime) {\r\n            hasRuntime = true;\r\n            res += \"{name:\\\"\".concat(dir.name, \"\\\",rawName:\\\"\").concat(dir.rawName, \"\\\"\").concat(dir.value\r\n                ? \",value:(\".concat(dir.value, \"),expression:\").concat(JSON.stringify(dir.value))\r\n                : '').concat(dir.arg ? \",arg:\".concat(dir.isDynamicArg ? dir.arg : \"\\\"\".concat(dir.arg, \"\\\"\")) : '').concat(dir.modifiers ? \",modifiers:\".concat(JSON.stringify(dir.modifiers)) : '', \"},\");\r\n        }\r\n    }\r\n    if (hasRuntime) {\r\n        return res.slice(0, -1) + ']';\r\n    }\r\n}\r\nfunction genInlineTemplate(el, state) {\r\n    var ast = el.children[0];\r\n    if ( true && (el.children.length !== 1 || ast.type !== 1)) {\r\n        state.warn('Inline-template components must have exactly one child element.', { start: el.start });\r\n    }\r\n    if (ast && ast.type === 1) {\r\n        var inlineRenderFns = generate(ast, state.options);\r\n        return \"inlineTemplate:{render:function(){\".concat(inlineRenderFns.render, \"},staticRenderFns:[\").concat(inlineRenderFns.staticRenderFns\r\n            .map(function (code) { return \"function(){\".concat(code, \"}\"); })\r\n            .join(','), \"]}\");\r\n    }\r\n}\r\nfunction genScopedSlots(el, slots, state) {\r\n    // by default scoped slots are considered \"stable\", this allows child\r\n    // components with only scoped slots to skip forced updates from parent.\r\n    // but in some cases we have to bail-out of this optimization\r\n    // for example if the slot contains dynamic names, has v-if or v-for on them...\r\n    var needsForceUpdate = el.for ||\r\n        Object.keys(slots).some(function (key) {\r\n            var slot = slots[key];\r\n            return (slot.slotTargetDynamic || slot.if || slot.for || containsSlotChild(slot) // is passing down slot from parent which may be dynamic\r\n            );\r\n        });\r\n    // #9534: if a component with scoped slots is inside a conditional branch,\r\n    // it's possible for the same component to be reused but with different\r\n    // compiled slot content. To avoid that, we generate a unique key based on\r\n    // the generated code of all the slot contents.\r\n    var needsKey = !!el.if;\r\n    // OR when it is inside another scoped slot or v-for (the reactivity may be\r\n    // disconnected due to the intermediate scope variable)\r\n    // #9438, #9506\r\n    // TODO: this can be further optimized by properly analyzing in-scope bindings\r\n    // and skip force updating ones that do not actually use scope variables.\r\n    if (!needsForceUpdate) {\r\n        var parent_2 = el.parent;\r\n        while (parent_2) {\r\n            if ((parent_2.slotScope && parent_2.slotScope !== emptySlotScopeToken) ||\r\n                parent_2.for) {\r\n                needsForceUpdate = true;\r\n                break;\r\n            }\r\n            if (parent_2.if) {\r\n                needsKey = true;\r\n            }\r\n            parent_2 = parent_2.parent;\r\n        }\r\n    }\r\n    var generatedSlots = Object.keys(slots)\r\n        .map(function (key) { return genScopedSlot(slots[key], state); })\r\n        .join(',');\r\n    return \"scopedSlots:_u([\".concat(generatedSlots, \"]\").concat(needsForceUpdate ? \",null,true\" : \"\").concat(!needsForceUpdate && needsKey ? \",null,false,\".concat(hash(generatedSlots)) : \"\", \")\");\r\n}\r\nfunction hash(str) {\r\n    var hash = 5381;\r\n    var i = str.length;\r\n    while (i) {\r\n        hash = (hash * 33) ^ str.charCodeAt(--i);\r\n    }\r\n    return hash >>> 0;\r\n}\r\nfunction containsSlotChild(el) {\r\n    if (el.type === 1) {\r\n        if (el.tag === 'slot') {\r\n            return true;\r\n        }\r\n        return el.children.some(containsSlotChild);\r\n    }\r\n    return false;\r\n}\r\nfunction genScopedSlot(el, state) {\r\n    var isLegacySyntax = el.attrsMap['slot-scope'];\r\n    if (el.if && !el.ifProcessed && !isLegacySyntax) {\r\n        return genIf(el, state, genScopedSlot, \"null\");\r\n    }\r\n    if (el.for && !el.forProcessed) {\r\n        return genFor(el, state, genScopedSlot);\r\n    }\r\n    var slotScope = el.slotScope === emptySlotScopeToken ? \"\" : String(el.slotScope);\r\n    var fn = \"function(\".concat(slotScope, \"){\") +\r\n        \"return \".concat(el.tag === 'template'\r\n            ? el.if && isLegacySyntax\r\n                ? \"(\".concat(el.if, \")?\").concat(genChildren(el, state) || 'undefined', \":undefined\")\r\n                : genChildren(el, state) || 'undefined'\r\n            : genElement(el, state), \"}\");\r\n    // reverse proxy v-slot without scope on this.$slots\r\n    var reverseProxy = slotScope ? \"\" : \",proxy:true\";\r\n    return \"{key:\".concat(el.slotTarget || \"\\\"default\\\"\", \",fn:\").concat(fn).concat(reverseProxy, \"}\");\r\n}\r\nfunction genChildren(el, state, checkSkip, altGenElement, altGenNode) {\r\n    var children = el.children;\r\n    if (children.length) {\r\n        var el_1 = children[0];\r\n        // optimize single v-for\r\n        if (children.length === 1 &&\r\n            el_1.for &&\r\n            el_1.tag !== 'template' &&\r\n            el_1.tag !== 'slot') {\r\n            var normalizationType_1 = checkSkip\r\n                ? state.maybeComponent(el_1)\r\n                    ? \",1\"\r\n                    : \",0\"\r\n                : \"\";\r\n            return \"\".concat((altGenElement || genElement)(el_1, state)).concat(normalizationType_1);\r\n        }\r\n        var normalizationType = checkSkip\r\n            ? getNormalizationType(children, state.maybeComponent)\r\n            : 0;\r\n        var gen_1 = altGenNode || genNode;\r\n        return \"[\".concat(children.map(function (c) { return gen_1(c, state); }).join(','), \"]\").concat(normalizationType ? \",\".concat(normalizationType) : '');\r\n    }\r\n}\r\n// determine the normalization needed for the children array.\r\n// 0: no normalization needed\r\n// 1: simple normalization needed (possible 1-level deep nested array)\r\n// 2: full normalization needed\r\nfunction getNormalizationType(children, maybeComponent) {\r\n    var res = 0;\r\n    for (var i = 0; i < children.length; i++) {\r\n        var el = children[i];\r\n        if (el.type !== 1) {\r\n            continue;\r\n        }\r\n        if (needsNormalization(el) ||\r\n            (el.ifConditions &&\r\n                el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {\r\n            res = 2;\r\n            break;\r\n        }\r\n        if (maybeComponent(el) ||\r\n            (el.ifConditions && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {\r\n            res = 1;\r\n        }\r\n    }\r\n    return res;\r\n}\r\nfunction needsNormalization(el) {\r\n    return el.for !== undefined || el.tag === 'template' || el.tag === 'slot';\r\n}\r\nfunction genNode(node, state) {\r\n    if (node.type === 1) {\r\n        return genElement(node, state);\r\n    }\r\n    else if (node.type === 3 && node.isComment) {\r\n        return genComment(node);\r\n    }\r\n    else {\r\n        return genText(node);\r\n    }\r\n}\r\nfunction genText(text) {\r\n    return \"_v(\".concat(text.type === 2\r\n        ? text.expression // no need for () because already wrapped in _s()\r\n        : transformSpecialNewlines(JSON.stringify(text.text)), \")\");\r\n}\r\nfunction genComment(comment) {\r\n    return \"_e(\".concat(JSON.stringify(comment.text), \")\");\r\n}\r\nfunction genSlot(el, state) {\r\n    var slotName = el.slotName || '\"default\"';\r\n    var children = genChildren(el, state);\r\n    var res = \"_t(\".concat(slotName).concat(children ? \",function(){return \".concat(children, \"}\") : '');\r\n    var attrs = el.attrs || el.dynamicAttrs\r\n        ? genProps((el.attrs || []).concat(el.dynamicAttrs || []).map(function (attr) { return ({\r\n            // slot props are camelized\r\n            name: camelize(attr.name),\r\n            value: attr.value,\r\n            dynamic: attr.dynamic\r\n        }); }))\r\n        : null;\r\n    var bind = el.attrsMap['v-bind'];\r\n    if ((attrs || bind) && !children) {\r\n        res += \",null\";\r\n    }\r\n    if (attrs) {\r\n        res += \",\".concat(attrs);\r\n    }\r\n    if (bind) {\r\n        res += \"\".concat(attrs ? '' : ',null', \",\").concat(bind);\r\n    }\r\n    return res + ')';\r\n}\r\n// componentName is el.component, take it as argument to shun flow's pessimistic refinement\r\nfunction genComponent(componentName, el, state) {\r\n    var children = el.inlineTemplate ? null : genChildren(el, state, true);\r\n    return \"_c(\".concat(componentName, \",\").concat(genData(el, state)).concat(children ? \",\".concat(children) : '', \")\");\r\n}\r\nfunction genProps(props) {\r\n    var staticProps = \"\";\r\n    var dynamicProps = \"\";\r\n    for (var i = 0; i < props.length; i++) {\r\n        var prop = props[i];\r\n        var value = transformSpecialNewlines(prop.value);\r\n        if (prop.dynamic) {\r\n            dynamicProps += \"\".concat(prop.name, \",\").concat(value, \",\");\r\n        }\r\n        else {\r\n            staticProps += \"\\\"\".concat(prop.name, \"\\\":\").concat(value, \",\");\r\n        }\r\n    }\r\n    staticProps = \"{\".concat(staticProps.slice(0, -1), \"}\");\r\n    if (dynamicProps) {\r\n        return \"_d(\".concat(staticProps, \",[\").concat(dynamicProps.slice(0, -1), \"])\");\r\n    }\r\n    else {\r\n        return staticProps;\r\n    }\r\n}\r\n// #3895, #4268\r\nfunction transformSpecialNewlines(text) {\r\n    return text.replace(/\\u2028/g, '\\\\u2028').replace(/\\u2029/g, '\\\\u2029');\r\n}\n\n// these keywords should not appear inside expressions, but operators like\r\n// typeof, instanceof and in are allowed\r\nvar prohibitedKeywordRE = new RegExp('\\\\b' +\r\n    ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +\r\n        'super,throw,while,yield,delete,export,import,return,switch,default,' +\r\n        'extends,finally,continue,debugger,function,arguments')\r\n        .split(',')\r\n        .join('\\\\b|\\\\b') +\r\n    '\\\\b');\r\n// these unary operators should not be used as property/method names\r\nvar unaryOperatorsRE = new RegExp('\\\\b' +\r\n    'delete,typeof,void'.split(',').join('\\\\s*\\\\([^\\\\)]*\\\\)|\\\\b') +\r\n    '\\\\s*\\\\([^\\\\)]*\\\\)');\r\n// strip strings in expressions\r\nvar stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\r\n// detect problematic expressions in a template\r\nfunction detectErrors(ast, warn) {\r\n    if (ast) {\r\n        checkNode(ast, warn);\r\n    }\r\n}\r\nfunction checkNode(node, warn) {\r\n    if (node.type === 1) {\r\n        for (var name_1 in node.attrsMap) {\r\n            if (dirRE.test(name_1)) {\r\n                var value = node.attrsMap[name_1];\r\n                if (value) {\r\n                    var range = node.rawAttrsMap[name_1];\r\n                    if (name_1 === 'v-for') {\r\n                        checkFor(node, \"v-for=\\\"\".concat(value, \"\\\"\"), warn, range);\r\n                    }\r\n                    else if (name_1 === 'v-slot' || name_1[0] === '#') {\r\n                        checkFunctionParameterExpression(value, \"\".concat(name_1, \"=\\\"\").concat(value, \"\\\"\"), warn, range);\r\n                    }\r\n                    else if (onRE.test(name_1)) {\r\n                        checkEvent(value, \"\".concat(name_1, \"=\\\"\").concat(value, \"\\\"\"), warn, range);\r\n                    }\r\n                    else {\r\n                        checkExpression(value, \"\".concat(name_1, \"=\\\"\").concat(value, \"\\\"\"), warn, range);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (node.children) {\r\n            for (var i = 0; i < node.children.length; i++) {\r\n                checkNode(node.children[i], warn);\r\n            }\r\n        }\r\n    }\r\n    else if (node.type === 2) {\r\n        checkExpression(node.expression, node.text, warn, node);\r\n    }\r\n}\r\nfunction checkEvent(exp, text, warn, range) {\r\n    var stripped = exp.replace(stripStringRE, '');\r\n    var keywordMatch = stripped.match(unaryOperatorsRE);\r\n    if (keywordMatch && stripped.charAt(keywordMatch.index - 1) !== '$') {\r\n        warn(\"avoid using JavaScript unary operator as property name: \" +\r\n            \"\\\"\".concat(keywordMatch[0], \"\\\" in expression \").concat(text.trim()), range);\r\n    }\r\n    checkExpression(exp, text, warn, range);\r\n}\r\nfunction checkFor(node, text, warn, range) {\r\n    checkExpression(node.for || '', text, warn, range);\r\n    checkIdentifier(node.alias, 'v-for alias', text, warn, range);\r\n    checkIdentifier(node.iterator1, 'v-for iterator', text, warn, range);\r\n    checkIdentifier(node.iterator2, 'v-for iterator', text, warn, range);\r\n}\r\nfunction checkIdentifier(ident, type, text, warn, range) {\r\n    if (typeof ident === 'string') {\r\n        try {\r\n            new Function(\"var \".concat(ident, \"=_\"));\r\n        }\r\n        catch (e) {\r\n            warn(\"invalid \".concat(type, \" \\\"\").concat(ident, \"\\\" in expression: \").concat(text.trim()), range);\r\n        }\r\n    }\r\n}\r\nfunction checkExpression(exp, text, warn, range) {\r\n    try {\r\n        new Function(\"return \".concat(exp));\r\n    }\r\n    catch (e) {\r\n        var keywordMatch = exp\r\n            .replace(stripStringRE, '')\r\n            .match(prohibitedKeywordRE);\r\n        if (keywordMatch) {\r\n            warn(\"avoid using JavaScript keyword as property name: \" +\r\n                \"\\\"\".concat(keywordMatch[0], \"\\\"\\n  Raw expression: \").concat(text.trim()), range);\r\n        }\r\n        else {\r\n            warn(\"invalid expression: \".concat(e.message, \" in\\n\\n\") +\r\n                \"    \".concat(exp, \"\\n\\n\") +\r\n                \"  Raw expression: \".concat(text.trim(), \"\\n\"), range);\r\n        }\r\n    }\r\n}\r\nfunction checkFunctionParameterExpression(exp, text, warn, range) {\r\n    try {\r\n        new Function(exp, '');\r\n    }\r\n    catch (e) {\r\n        warn(\"invalid function parameter expression: \".concat(e.message, \" in\\n\\n\") +\r\n            \"    \".concat(exp, \"\\n\\n\") +\r\n            \"  Raw expression: \".concat(text.trim(), \"\\n\"), range);\r\n    }\r\n}\n\nvar range = 2;\r\nfunction generateCodeFrame(source, start, end) {\r\n    if (start === void 0) { start = 0; }\r\n    if (end === void 0) { end = source.length; }\r\n    var lines = source.split(/\\r?\\n/);\r\n    var count = 0;\r\n    var res = [];\r\n    for (var i = 0; i < lines.length; i++) {\r\n        count += lines[i].length + 1;\r\n        if (count >= start) {\r\n            for (var j = i - range; j <= i + range || end > count; j++) {\r\n                if (j < 0 || j >= lines.length)\r\n                    continue;\r\n                res.push(\"\".concat(j + 1).concat(repeat(\" \", 3 - String(j + 1).length), \"|  \").concat(lines[j]));\r\n                var lineLength = lines[j].length;\r\n                if (j === i) {\r\n                    // push underline\r\n                    var pad = start - (count - lineLength) + 1;\r\n                    var length_1 = end > count ? lineLength - pad : end - start;\r\n                    res.push(\"   |  \" + repeat(\" \", pad) + repeat(\"^\", length_1));\r\n                }\r\n                else if (j > i) {\r\n                    if (end > count) {\r\n                        var length_2 = Math.min(end - count, lineLength);\r\n                        res.push(\"   |  \" + repeat(\"^\", length_2));\r\n                    }\r\n                    count += lineLength + 1;\r\n                }\r\n            }\r\n            break;\r\n        }\r\n    }\r\n    return res.join('\\n');\r\n}\r\nfunction repeat(str, n) {\r\n    var result = '';\r\n    if (n > 0) {\r\n        // eslint-disable-next-line no-constant-condition\r\n        while (true) {\r\n            // eslint-disable-line\r\n            if (n & 1)\r\n                result += str;\r\n            n >>>= 1;\r\n            if (n <= 0)\r\n                break;\r\n            str += str;\r\n        }\r\n    }\r\n    return result;\r\n}\n\nfunction createFunction(code, errors) {\r\n    try {\r\n        return new Function(code);\r\n    }\r\n    catch (err) {\r\n        errors.push({ err: err, code: code });\r\n        return noop;\r\n    }\r\n}\r\nfunction createCompileToFunctionFn(compile) {\r\n    var cache = Object.create(null);\r\n    return function compileToFunctions(template, options, vm) {\r\n        options = extend({}, options);\r\n        var warn = options.warn || warn$2;\r\n        delete options.warn;\r\n        /* istanbul ignore if */\r\n        if (true) {\r\n            // detect possible CSP restriction\r\n            try {\r\n                new Function('return 1');\r\n            }\r\n            catch (e) {\r\n                if (e.toString().match(/unsafe-eval|CSP/)) {\r\n                    warn('It seems you are using the standalone build of Vue.js in an ' +\r\n                        'environment with Content Security Policy that prohibits unsafe-eval. ' +\r\n                        'The template compiler cannot work in this environment. Consider ' +\r\n                        'relaxing the policy to allow unsafe-eval or pre-compiling your ' +\r\n                        'templates into render functions.');\r\n                }\r\n            }\r\n        }\r\n        // check cache\r\n        var key = options.delimiters\r\n            ? String(options.delimiters) + template\r\n            : template;\r\n        if (cache[key]) {\r\n            return cache[key];\r\n        }\r\n        // compile\r\n        var compiled = compile(template, options);\r\n        // check compilation errors/tips\r\n        if (true) {\r\n            if (compiled.errors && compiled.errors.length) {\r\n                if (options.outputSourceRange) {\r\n                    compiled.errors.forEach(function (e) {\r\n                        warn(\"Error compiling template:\\n\\n\".concat(e.msg, \"\\n\\n\") +\r\n                            generateCodeFrame(template, e.start, e.end), vm);\r\n                    });\r\n                }\r\n                else {\r\n                    warn(\"Error compiling template:\\n\\n\".concat(template, \"\\n\\n\") +\r\n                        compiled.errors.map(function (e) { return \"- \".concat(e); }).join('\\n') +\r\n                        '\\n', vm);\r\n                }\r\n            }\r\n            if (compiled.tips && compiled.tips.length) {\r\n                if (options.outputSourceRange) {\r\n                    compiled.tips.forEach(function (e) { return tip(e.msg, vm); });\r\n                }\r\n                else {\r\n                    compiled.tips.forEach(function (msg) { return tip(msg, vm); });\r\n                }\r\n            }\r\n        }\r\n        // turn code into functions\r\n        var res = {};\r\n        var fnGenErrors = [];\r\n        res.render = createFunction(compiled.render, fnGenErrors);\r\n        res.staticRenderFns = compiled.staticRenderFns.map(function (code) {\r\n            return createFunction(code, fnGenErrors);\r\n        });\r\n        // check function generation errors.\r\n        // this should only happen if there is a bug in the compiler itself.\r\n        // mostly for codegen development use\r\n        /* istanbul ignore if */\r\n        if (true) {\r\n            if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {\r\n                warn(\"Failed to generate render function:\\n\\n\" +\r\n                    fnGenErrors\r\n                        .map(function (_a) {\r\n                        var err = _a.err, code = _a.code;\r\n                        return \"\".concat(err.toString(), \" in\\n\\n\").concat(code, \"\\n\");\r\n                    })\r\n                        .join('\\n'), vm);\r\n            }\r\n        }\r\n        return (cache[key] = res);\r\n    };\r\n}\n\nfunction createCompilerCreator(baseCompile) {\r\n    return function createCompiler(baseOptions) {\r\n        function compile(template, options) {\r\n            var finalOptions = Object.create(baseOptions);\r\n            var errors = [];\r\n            var tips = [];\r\n            var warn = function (msg, range, tip) {\r\n                (tip ? tips : errors).push(msg);\r\n            };\r\n            if (options) {\r\n                if ( true && options.outputSourceRange) {\r\n                    // $flow-disable-line\r\n                    var leadingSpaceLength_1 = template.match(/^\\s*/)[0].length;\r\n                    warn = function (msg, range, tip) {\r\n                        var data = typeof msg === 'string' ? { msg: msg } : msg;\r\n                        if (range) {\r\n                            if (range.start != null) {\r\n                                data.start = range.start + leadingSpaceLength_1;\r\n                            }\r\n                            if (range.end != null) {\r\n                                data.end = range.end + leadingSpaceLength_1;\r\n                            }\r\n                        }\r\n                        (tip ? tips : errors).push(data);\r\n                    };\r\n                }\r\n                // merge custom modules\r\n                if (options.modules) {\r\n                    finalOptions.modules = (baseOptions.modules || []).concat(options.modules);\r\n                }\r\n                // merge custom directives\r\n                if (options.directives) {\r\n                    finalOptions.directives = extend(Object.create(baseOptions.directives || null), options.directives);\r\n                }\r\n                // copy other options\r\n                for (var key in options) {\r\n                    if (key !== 'modules' && key !== 'directives') {\r\n                        finalOptions[key] = options[key];\r\n                    }\r\n                }\r\n            }\r\n            finalOptions.warn = warn;\r\n            var compiled = baseCompile(template.trim(), finalOptions);\r\n            if (true) {\r\n                detectErrors(compiled.ast, warn);\r\n            }\r\n            compiled.errors = errors;\r\n            compiled.tips = tips;\r\n            return compiled;\r\n        }\r\n        return {\r\n            compile: compile,\r\n            compileToFunctions: createCompileToFunctionFn(compile)\r\n        };\r\n    };\r\n}\n\n// `createCompilerCreator` allows creating compilers that use alternative\r\n// parser/optimizer/codegen, e.g the SSR optimizing compiler.\r\n// Here we just export a default compiler using the default parts.\r\nvar createCompiler = createCompilerCreator(function baseCompile(template, options) {\r\n    var ast = parse(template.trim(), options);\r\n    if (options.optimize !== false) {\r\n        optimize(ast, options);\r\n    }\r\n    var code = generate(ast, options);\r\n    return {\r\n        ast: ast,\r\n        render: code.render,\r\n        staticRenderFns: code.staticRenderFns\r\n    };\r\n});\n\nvar _a = createCompiler(baseOptions), compileToFunctions = _a.compileToFunctions;\n\n// check whether current browser encodes a char inside attribute values\r\nvar div;\r\nfunction getShouldDecode(href) {\r\n    div = div || document.createElement('div');\r\n    div.innerHTML = href ? \"<a href=\\\"\\n\\\"/>\" : \"<div a=\\\"\\n\\\"/>\";\r\n    return div.innerHTML.indexOf('&#10;') > 0;\r\n}\r\n// #3663: IE encodes newlines inside attribute values while other browsers don't\r\nvar shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false;\r\n// #6828: chrome encodes content in a[href]\r\nvar shouldDecodeNewlinesForHref = inBrowser\r\n    ? getShouldDecode(true)\r\n    : false;\n\nvar idToTemplate = cached(function (id) {\r\n    var el = query(id);\r\n    return el && el.innerHTML;\r\n});\r\nvar mount = Vue.prototype.$mount;\r\nVue.prototype.$mount = function (el, hydrating) {\r\n    el = el && query(el);\r\n    /* istanbul ignore if */\r\n    if (el === document.body || el === document.documentElement) {\r\n         true &&\r\n            warn$2(\"Do not mount Vue to <html> or <body> - mount to normal elements instead.\");\r\n        return this;\r\n    }\r\n    var options = this.$options;\r\n    // resolve template/el and convert to render function\r\n    if (!options.render) {\r\n        var template = options.template;\r\n        if (template) {\r\n            if (typeof template === 'string') {\r\n                if (template.charAt(0) === '#') {\r\n                    template = idToTemplate(template);\r\n                    /* istanbul ignore if */\r\n                    if ( true && !template) {\r\n                        warn$2(\"Template element not found or is empty: \".concat(options.template), this);\r\n                    }\r\n                }\r\n            }\r\n            else if (template.nodeType) {\r\n                template = template.innerHTML;\r\n            }\r\n            else {\r\n                if (true) {\r\n                    warn$2('invalid template option:' + template, this);\r\n                }\r\n                return this;\r\n            }\r\n        }\r\n        else if (el) {\r\n            // @ts-expect-error\r\n            template = getOuterHTML(el);\r\n        }\r\n        if (template) {\r\n            /* istanbul ignore if */\r\n            if ( true && config.performance && mark) {\r\n                mark('compile');\r\n            }\r\n            var _a = compileToFunctions(template, {\r\n                outputSourceRange: \"development\" !== 'production',\r\n                shouldDecodeNewlines: shouldDecodeNewlines,\r\n                shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,\r\n                delimiters: options.delimiters,\r\n                comments: options.comments\r\n            }, this), render = _a.render, staticRenderFns = _a.staticRenderFns;\r\n            options.render = render;\r\n            options.staticRenderFns = staticRenderFns;\r\n            /* istanbul ignore if */\r\n            if ( true && config.performance && mark) {\r\n                mark('compile end');\r\n                measure(\"vue \".concat(this._name, \" compile\"), 'compile', 'compile end');\r\n            }\r\n        }\r\n    }\r\n    return mount.call(this, el, hydrating);\r\n};\r\n/**\r\n * Get outerHTML of elements, taking care\r\n * of SVG elements in IE as well.\r\n */\r\nfunction getOuterHTML(el) {\r\n    if (el.outerHTML) {\r\n        return el.outerHTML;\r\n    }\r\n    else {\r\n        var container = document.createElement('div');\r\n        container.appendChild(el.cloneNode(true));\r\n        return container.innerHTML;\r\n    }\r\n}\r\nVue.compile = compileToFunctions;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnVlL2Rpc3QvdnVlLmVzbS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBLCtDQUErQyxpQ0FBaUMsbUJBQW1CO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxvQ0FBb0M7QUFDekYsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixhQUFvQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxjQUFjLGFBQW9CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9C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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsSUFBcUM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsS0FBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxLQUFxQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixLQUFxQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsT0FBTztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxPQUFPO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsS0FBcUM7QUFDckQ7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsY0FBYztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksS0FBcUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksS0FBcUM7QUFDakQ7QUFDQTtBQUNBLG1EQUFtRCxlQUFlO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixLQUFxQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxPQUFPO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLE9BQU87QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxTQUFTO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksSUFBcUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksSUFBcUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLEtBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0MsZ0RBQWdEO0FBQ2hELGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxLQUFxQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGtCQUFrQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHVEQUF1RDtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLElBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxZQUFZLEtBQXFDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxLQUFxQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxLQUFxQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsS0FBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFELHlEQUF5RDtBQUN6RDtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixLQUFxQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLEtBQXFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBLFlBQVksS0FBcUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsSUFBcUM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLEtBQXFDLHdCQUF3QixDQUFFO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsS0FBcUM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxJQUFxQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0ZBQStGO0FBQy9GO0FBQ0E7QUFDQSxZQUFZLElBQXFDO0FBQ2pEO0FBQ0E7QUFDQSxhQUFhLEVBRUo7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLFlBQVksS0FBcUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLElBQXFDO0FBQzdDLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksSUFBcUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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cUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELE9BQU87QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxLQUFxQztBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxJQUFxQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxLQUFxQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDJCQUEyQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELFdBQVc7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFNBQVM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxzQ0FBc0M7QUFDekY7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0EsdUNBQXVDLDBDQUEwQztBQUNqRjs7QUFFQTtBQUNBLFFBQVEsS0FBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxLQUFxQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLEtBQXFDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELDRCQUE0QjtBQUM1RSxTQUFTO0FBQ1Q7QUFDQSxnREFBZ0QsNkJBQTZCO0FBQzdFLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyxRQUFRLElBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxLQUFxQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDJCQUEyQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsOEJBQThCO0FBQzFEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRkFBMEY7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsZ0JBQWdCLHdCQUF3QixXQUFXO0FBQ25HO0FBQ0E7QUFDQSxzREFBc0QsNENBQTRDO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw0Q0FBNEM7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQywwQkFBMEI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxLQUFxQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0Esb0NBQW9DLHVDQUF1QztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLE9BQU87QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELHdCQUF3QjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxJQUFxQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxJQUFxQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGO0FBQzFGLGdDQUFnQztBQUNoQztBQUNBLHlCQUF5QjtBQUN6QiwwQkFBMEIsbUVBQW1FO0FBQzdGLGNBQWMsNEZBQTRGO0FBQzFHLFVBQVUsS0FBSyw0Q0FBNEM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxrQkFBa0I7QUFDbkUsMEJBQTBCLCtDQUErQztBQUN6RSx1REFBdUQ7QUFDdkQ7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLElBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QscUNBQXFDO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsOENBQThDLFNBQVM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsNkJBQTZCO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxnQ0FBZ0M7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLEtBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxLQUFxQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxzQ0FBc0M7O0FBRXhFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELDBDQUEwQztBQUM5RjtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsOENBQThDO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLEtBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLCtCQUErQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksS0FBcUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksS0FBcUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBLHlCQUF5QixJQUFxQztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHlCQUF5QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixJQUF3RTtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxLQUMrQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQSxzQkFBc0IsRUFBRSxpQkFBaUIsRUFBRTtBQUMzQywrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixpQkFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLEtBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsTUFBTTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxJQUFxQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLE1BQU07QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFNBQVM7QUFDVCxXQUFXO0FBQ1gsVUFBVTtBQUNWLFVBQVU7QUFDVixTQUFTO0FBQ1QsVUFBVTtBQUNWO0FBQ0EsMkNBQTJDO0FBQzNDLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCw0QkFBNEI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixLQUFxQztBQUNyRDtBQUNBO0FBQ0EsaUJBQWlC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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELE9BQU87QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsT0FBTztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsT0FBTztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxPQUFPO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyw2Q0FBNkM7QUFDbkY7QUFDQSxvQ0FBb0M7QUFDcEMsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsd0NBQXdDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0EsMkRBQTJELDZCQUE2QjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLG1GQUFtRixJQUFJO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELG1DQUFtQztBQUN4RixrREFBa0QsOENBQThDO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMscUNBQXFDO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxLQUFxQztBQUM3QztBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix3QkFBd0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw2QkFBNkI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMEJBQTBCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0Esb0NBQW9DLCtCQUErQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLFlBQVksSUFBcUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxJQUFxQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCx3QkFBd0I7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCx3QkFBd0I7QUFDakY7QUFDQTtBQUNBLDJEQUEyRCxzQkFBc0I7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxJQUFxQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLEtBQXFDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxXQUFXO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLElBQXFDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxLQUFxQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsS0FBcUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixJQUFxQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLEtBQXFDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxhQUFvQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsS0FBcUM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTZzQiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92dWUvZGlzdC92dWUuZXNtLmpzPzRiMjkiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBWdWUuanMgdjIuNy44XG4gKiAoYykgMjAxNC0yMDIyIEV2YW4gWW91XG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbnZhciBlbXB0eU9iamVjdCA9IE9iamVjdC5mcmVlemUoe30pO1xyXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XHJcbi8vIFRoZXNlIGhlbHBlcnMgcHJvZHVjZSBiZXR0ZXIgVk0gY29kZSBpbiBKUyBlbmdpbmVzIGR1ZSB0byB0aGVpclxyXG4vLyBleHBsaWNpdG5lc3MgYW5kIGZ1bmN0aW9uIGlubGluaW5nLlxyXG5mdW5jdGlvbiBpc1VuZGVmKHYpIHtcclxuICAgIHJldHVybiB2ID09PSB1bmRlZmluZWQgfHwgdiA9PT0gbnVsbDtcclxufVxyXG5mdW5jdGlvbiBpc0RlZih2KSB7XHJcbiAgICByZXR1cm4gdiAhPT0gdW5kZWZpbmVkICYmIHYgIT09IG51bGw7XHJcbn1cclxuZnVuY3Rpb24gaXNUcnVlKHYpIHtcclxuICAgIHJldHVybiB2ID09PSB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIGlzRmFsc2Uodikge1xyXG4gICAgcmV0dXJuIHYgPT09IGZhbHNlO1xyXG59XHJcbi8qKlxyXG4gKiBDaGVjayBpZiB2YWx1ZSBpcyBwcmltaXRpdmUuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8XHJcbiAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fFxyXG4gICAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxyXG4gICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcgfHxcclxuICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyk7XHJcbn1cclxuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcclxufVxyXG4vKipcclxuICogUXVpY2sgb2JqZWN0IGNoZWNrIC0gdGhpcyBpcyBwcmltYXJpbHkgdXNlZCB0byB0ZWxsXHJcbiAqIG9iamVjdHMgZnJvbSBwcmltaXRpdmUgdmFsdWVzIHdoZW4gd2Uga25vdyB0aGUgdmFsdWVcclxuICogaXMgYSBKU09OLWNvbXBsaWFudCB0eXBlLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XHJcbiAgICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnO1xyXG59XHJcbi8qKlxyXG4gKiBHZXQgdGhlIHJhdyB0eXBlIHN0cmluZyBvZiBhIHZhbHVlLCBlLmcuLCBbb2JqZWN0IE9iamVjdF0uXHJcbiAqL1xyXG52YXIgX3RvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcclxuZnVuY3Rpb24gdG9SYXdUeXBlKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gX3RvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKTtcclxufVxyXG4vKipcclxuICogU3RyaWN0IG9iamVjdCB0eXBlIGNoZWNrLiBPbmx5IHJldHVybnMgdHJ1ZVxyXG4gKiBmb3IgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3RzLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNQbGFpbk9iamVjdChvYmopIHtcclxuICAgIHJldHVybiBfdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBPYmplY3RdJztcclxufVxyXG5mdW5jdGlvbiBpc1JlZ0V4cCh2KSB7XHJcbiAgICByZXR1cm4gX3RvU3RyaW5nLmNhbGwodikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xyXG59XHJcbi8qKlxyXG4gKiBDaGVjayBpZiB2YWwgaXMgYSB2YWxpZCBhcnJheSBpbmRleC5cclxuICovXHJcbmZ1bmN0aW9uIGlzVmFsaWRBcnJheUluZGV4KHZhbCkge1xyXG4gICAgdmFyIG4gPSBwYXJzZUZsb2F0KFN0cmluZyh2YWwpKTtcclxuICAgIHJldHVybiBuID49IDAgJiYgTWF0aC5mbG9vcihuKSA9PT0gbiAmJiBpc0Zpbml0ZSh2YWwpO1xyXG59XHJcbmZ1bmN0aW9uIGlzUHJvbWlzZSh2YWwpIHtcclxuICAgIHJldHVybiAoaXNEZWYodmFsKSAmJlxyXG4gICAgICAgIHR5cGVvZiB2YWwudGhlbiA9PT0gJ2Z1bmN0aW9uJyAmJlxyXG4gICAgICAgIHR5cGVvZiB2YWwuY2F0Y2ggPT09ICdmdW5jdGlvbicpO1xyXG59XHJcbi8qKlxyXG4gKiBDb252ZXJ0IGEgdmFsdWUgdG8gYSBzdHJpbmcgdGhhdCBpcyBhY3R1YWxseSByZW5kZXJlZC5cclxuICovXHJcbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbCkge1xyXG4gICAgcmV0dXJuIHZhbCA9PSBudWxsXHJcbiAgICAgICAgPyAnJ1xyXG4gICAgICAgIDogQXJyYXkuaXNBcnJheSh2YWwpIHx8IChpc1BsYWluT2JqZWN0KHZhbCkgJiYgdmFsLnRvU3RyaW5nID09PSBfdG9TdHJpbmcpXHJcbiAgICAgICAgICAgID8gSlNPTi5zdHJpbmdpZnkodmFsLCBudWxsLCAyKVxyXG4gICAgICAgICAgICA6IFN0cmluZyh2YWwpO1xyXG59XHJcbi8qKlxyXG4gKiBDb252ZXJ0IGFuIGlucHV0IHZhbHVlIHRvIGEgbnVtYmVyIGZvciBwZXJzaXN0ZW5jZS5cclxuICogSWYgdGhlIGNvbnZlcnNpb24gZmFpbHMsIHJldHVybiBvcmlnaW5hbCBzdHJpbmcuXHJcbiAqL1xyXG5mdW5jdGlvbiB0b051bWJlcih2YWwpIHtcclxuICAgIHZhciBuID0gcGFyc2VGbG9hdCh2YWwpO1xyXG4gICAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogbjtcclxufVxyXG4vKipcclxuICogTWFrZSBhIG1hcCBhbmQgcmV0dXJuIGEgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGEga2V5XHJcbiAqIGlzIGluIHRoYXQgbWFwLlxyXG4gKi9cclxuZnVuY3Rpb24gbWFrZU1hcChzdHIsIGV4cGVjdHNMb3dlckNhc2UpIHtcclxuICAgIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgdmFyIGxpc3QgPSBzdHIuc3BsaXQoJywnKTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIG1hcFtsaXN0W2ldXSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZXhwZWN0c0xvd2VyQ2FzZSA/IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIG1hcFt2YWwudG9Mb3dlckNhc2UoKV07IH0gOiBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBtYXBbdmFsXTsgfTtcclxufVxyXG4vKipcclxuICogQ2hlY2sgaWYgYSB0YWcgaXMgYSBidWlsdC1pbiB0YWcuXHJcbiAqL1xyXG52YXIgaXNCdWlsdEluVGFnID0gbWFrZU1hcCgnc2xvdCxjb21wb25lbnQnLCB0cnVlKTtcclxuLyoqXHJcbiAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBpcyBhIHJlc2VydmVkIGF0dHJpYnV0ZS5cclxuICovXHJcbnZhciBpc1Jlc2VydmVkQXR0cmlidXRlID0gbWFrZU1hcCgna2V5LHJlZixzbG90LHNsb3Qtc2NvcGUsaXMnKTtcclxuLyoqXHJcbiAqIFJlbW92ZSBhbiBpdGVtIGZyb20gYW4gYXJyYXkuXHJcbiAqL1xyXG5mdW5jdGlvbiByZW1vdmUkMihhcnIsIGl0ZW0pIHtcclxuICAgIGlmIChhcnIubGVuZ3RoKSB7XHJcbiAgICAgICAgdmFyIGluZGV4ID0gYXJyLmluZGV4T2YoaXRlbSk7XHJcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFyci5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ2hlY2sgd2hldGhlciBhbiBvYmplY3QgaGFzIHRoZSBwcm9wZXJ0eS5cclxuICovXHJcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XHJcbmZ1bmN0aW9uIGhhc093bihvYmosIGtleSkge1xyXG4gICAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGUgYSBjYWNoZWQgdmVyc2lvbiBvZiBhIHB1cmUgZnVuY3Rpb24uXHJcbiAqL1xyXG5mdW5jdGlvbiBjYWNoZWQoZm4pIHtcclxuICAgIHZhciBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gY2FjaGVkRm4oc3RyKSB7XHJcbiAgICAgICAgdmFyIGhpdCA9IGNhY2hlW3N0cl07XHJcbiAgICAgICAgcmV0dXJuIGhpdCB8fCAoY2FjaGVbc3RyXSA9IGZuKHN0cikpO1xyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogQ2FtZWxpemUgYSBoeXBoZW4tZGVsaW1pdGVkIHN0cmluZy5cclxuICovXHJcbnZhciBjYW1lbGl6ZVJFID0gLy0oXFx3KS9nO1xyXG52YXIgY2FtZWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xyXG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIGZ1bmN0aW9uIChfLCBjKSB7IHJldHVybiAoYyA/IGMudG9VcHBlckNhc2UoKSA6ICcnKTsgfSk7XHJcbn0pO1xyXG4vKipcclxuICogQ2FwaXRhbGl6ZSBhIHN0cmluZy5cclxuICovXHJcbnZhciBjYXBpdGFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcclxuICAgIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XHJcbn0pO1xyXG4vKipcclxuICogSHlwaGVuYXRlIGEgY2FtZWxDYXNlIHN0cmluZy5cclxuICovXHJcbnZhciBoeXBoZW5hdGVSRSA9IC9cXEIoW0EtWl0pL2c7XHJcbnZhciBoeXBoZW5hdGUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xyXG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnLSQxJykudG9Mb3dlckNhc2UoKTtcclxufSk7XHJcbi8qKlxyXG4gKiBTaW1wbGUgYmluZCBwb2x5ZmlsbCBmb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IHN1cHBvcnQgaXQsXHJcbiAqIGUuZy4sIFBoYW50b21KUyAxLnguIFRlY2huaWNhbGx5LCB3ZSBkb24ndCBuZWVkIHRoaXMgYW55bW9yZVxyXG4gKiBzaW5jZSBuYXRpdmUgYmluZCBpcyBub3cgcGVyZm9ybWFudCBlbm91Z2ggaW4gbW9zdCBicm93c2Vycy5cclxuICogQnV0IHJlbW92aW5nIGl0IHdvdWxkIG1lYW4gYnJlYWtpbmcgY29kZSB0aGF0IHdhcyBhYmxlIHRvIHJ1biBpblxyXG4gKiBQaGFudG9tSlMgMS54LCBzbyB0aGlzIG11c3QgYmUga2VwdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS5cclxuICovXHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbmZ1bmN0aW9uIHBvbHlmaWxsQmluZChmbiwgY3R4KSB7XHJcbiAgICBmdW5jdGlvbiBib3VuZEZuKGEpIHtcclxuICAgICAgICB2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XHJcbiAgICAgICAgcmV0dXJuIGxcclxuICAgICAgICAgICAgPyBsID4gMVxyXG4gICAgICAgICAgICAgICAgPyBmbi5hcHBseShjdHgsIGFyZ3VtZW50cylcclxuICAgICAgICAgICAgICAgIDogZm4uY2FsbChjdHgsIGEpXHJcbiAgICAgICAgICAgIDogZm4uY2FsbChjdHgpO1xyXG4gICAgfVxyXG4gICAgYm91bmRGbi5fbGVuZ3RoID0gZm4ubGVuZ3RoO1xyXG4gICAgcmV0dXJuIGJvdW5kRm47XHJcbn1cclxuZnVuY3Rpb24gbmF0aXZlQmluZChmbiwgY3R4KSB7XHJcbiAgICByZXR1cm4gZm4uYmluZChjdHgpO1xyXG59XHJcbi8vIEB0cy1leHBlY3QtZXJyb3IgYmluZCBjYW5ub3QgYmUgYHVuZGVmaW5lZGBcclxudmFyIGJpbmQkMSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kID8gbmF0aXZlQmluZCA6IHBvbHlmaWxsQmluZDtcclxuLyoqXHJcbiAqIENvbnZlcnQgYW4gQXJyYXktbGlrZSBvYmplY3QgdG8gYSByZWFsIEFycmF5LlxyXG4gKi9cclxuZnVuY3Rpb24gdG9BcnJheShsaXN0LCBzdGFydCkge1xyXG4gICAgc3RhcnQgPSBzdGFydCB8fCAwO1xyXG4gICAgdmFyIGkgPSBsaXN0Lmxlbmd0aCAtIHN0YXJ0O1xyXG4gICAgdmFyIHJldCA9IG5ldyBBcnJheShpKTtcclxuICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICByZXRbaV0gPSBsaXN0W2kgKyBzdGFydF07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0O1xyXG59XHJcbi8qKlxyXG4gKiBNaXggcHJvcGVydGllcyBpbnRvIHRhcmdldCBvYmplY3QuXHJcbiAqL1xyXG5mdW5jdGlvbiBleHRlbmQodG8sIF9mcm9tKSB7XHJcbiAgICBmb3IgKHZhciBrZXkgaW4gX2Zyb20pIHtcclxuICAgICAgICB0b1trZXldID0gX2Zyb21ba2V5XTtcclxuICAgIH1cclxuICAgIHJldHVybiB0bztcclxufVxyXG4vKipcclxuICogTWVyZ2UgYW4gQXJyYXkgb2YgT2JqZWN0cyBpbnRvIGEgc2luZ2xlIE9iamVjdC5cclxuICovXHJcbmZ1bmN0aW9uIHRvT2JqZWN0KGFycikge1xyXG4gICAgdmFyIHJlcyA9IHt9O1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAoYXJyW2ldKSB7XHJcbiAgICAgICAgICAgIGV4dGVuZChyZXMsIGFycltpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xyXG4vKipcclxuICogUGVyZm9ybSBubyBvcGVyYXRpb24uXHJcbiAqIFN0dWJiaW5nIGFyZ3MgdG8gbWFrZSBGbG93IGhhcHB5IHdpdGhvdXQgbGVhdmluZyB1c2VsZXNzIHRyYW5zcGlsZWQgY29kZVxyXG4gKiB3aXRoIC4uLnJlc3QgKGh0dHBzOi8vZmxvdy5vcmcvYmxvZy8yMDE3LzA1LzA3L1N0cmljdC1GdW5jdGlvbi1DYWxsLUFyaXR5LykuXHJcbiAqL1xyXG5mdW5jdGlvbiBub29wKGEsIGIsIGMpIHsgfVxyXG4vKipcclxuICogQWx3YXlzIHJldHVybiBmYWxzZS5cclxuICovXHJcbnZhciBubyA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7IHJldHVybiBmYWxzZTsgfTtcclxuLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xyXG4vKipcclxuICogUmV0dXJuIHRoZSBzYW1lIHZhbHVlLlxyXG4gKi9cclxudmFyIGlkZW50aXR5ID0gZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF87IH07XHJcbi8qKlxyXG4gKiBHZW5lcmF0ZSBhIHN0cmluZyBjb250YWluaW5nIHN0YXRpYyBrZXlzIGZyb20gY29tcGlsZXIgbW9kdWxlcy5cclxuICovXHJcbmZ1bmN0aW9uIGdlblN0YXRpY0tleXMkMShtb2R1bGVzKSB7XHJcbiAgICByZXR1cm4gbW9kdWxlc1xyXG4gICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKGtleXMsIG0pIHtcclxuICAgICAgICByZXR1cm4ga2V5cy5jb25jYXQobS5zdGF0aWNLZXlzIHx8IFtdKTtcclxuICAgIH0sIFtdKVxyXG4gICAgICAgIC5qb2luKCcsJyk7XHJcbn1cclxuLyoqXHJcbiAqIENoZWNrIGlmIHR3byB2YWx1ZXMgYXJlIGxvb3NlbHkgZXF1YWwgLSB0aGF0IGlzLFxyXG4gKiBpZiB0aGV5IGFyZSBwbGFpbiBvYmplY3RzLCBkbyB0aGV5IGhhdmUgdGhlIHNhbWUgc2hhcGU/XHJcbiAqL1xyXG5mdW5jdGlvbiBsb29zZUVxdWFsKGEsIGIpIHtcclxuICAgIGlmIChhID09PSBiKVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgdmFyIGlzT2JqZWN0QSA9IGlzT2JqZWN0KGEpO1xyXG4gICAgdmFyIGlzT2JqZWN0QiA9IGlzT2JqZWN0KGIpO1xyXG4gICAgaWYgKGlzT2JqZWN0QSAmJiBpc09iamVjdEIpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB2YXIgaXNBcnJheUEgPSBBcnJheS5pc0FycmF5KGEpO1xyXG4gICAgICAgICAgICB2YXIgaXNBcnJheUIgPSBBcnJheS5pc0FycmF5KGIpO1xyXG4gICAgICAgICAgICBpZiAoaXNBcnJheUEgJiYgaXNBcnJheUIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoYS5sZW5ndGggPT09IGIubGVuZ3RoICYmXHJcbiAgICAgICAgICAgICAgICAgICAgYS5ldmVyeShmdW5jdGlvbiAoZSwgaSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9vc2VFcXVhbChlLCBiW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoYSBpbnN0YW5jZW9mIERhdGUgJiYgYiBpbnN0YW5jZW9mIERhdGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhLmdldFRpbWUoKSA9PT0gYi5nZXRUaW1lKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzQXJyYXlBICYmICFpc0FycmF5Qikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMoYSk7XHJcbiAgICAgICAgICAgICAgICB2YXIga2V5c0IgPSBPYmplY3Qua2V5cyhiKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoa2V5c0EubGVuZ3RoID09PSBrZXlzQi5sZW5ndGggJiZcclxuICAgICAgICAgICAgICAgICAgICBrZXlzQS5ldmVyeShmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsb29zZUVxdWFsKGFba2V5XSwgYltrZXldKTtcclxuICAgICAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICghaXNPYmplY3RBICYmICFpc09iamVjdEIpIHtcclxuICAgICAgICByZXR1cm4gU3RyaW5nKGEpID09PSBTdHJpbmcoYik7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybiB0aGUgZmlyc3QgaW5kZXggYXQgd2hpY2ggYSBsb29zZWx5IGVxdWFsIHZhbHVlIGNhbiBiZVxyXG4gKiBmb3VuZCBpbiB0aGUgYXJyYXkgKGlmIHZhbHVlIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGUgYXJyYXkgbXVzdFxyXG4gKiBjb250YWluIGFuIG9iamVjdCBvZiB0aGUgc2FtZSBzaGFwZSksIG9yIC0xIGlmIGl0IGlzIG5vdCBwcmVzZW50LlxyXG4gKi9cclxuZnVuY3Rpb24gbG9vc2VJbmRleE9mKGFyciwgdmFsKSB7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChsb29zZUVxdWFsKGFycltpXSwgdmFsKSlcclxuICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gLTE7XHJcbn1cclxuLyoqXHJcbiAqIEVuc3VyZSBhIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbmx5IG9uY2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBvbmNlKGZuKSB7XHJcbiAgICB2YXIgY2FsbGVkID0gZmFsc2U7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghY2FsbGVkKSB7XHJcbiAgICAgICAgICAgIGNhbGxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXMjcG9seWZpbGxcclxuZnVuY3Rpb24gaGFzQ2hhbmdlZCh4LCB5KSB7XHJcbiAgICBpZiAoeCA9PT0geSkge1xyXG4gICAgICAgIHJldHVybiB4ID09PSAwICYmIDEgLyB4ICE9PSAxIC8geTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB4ID09PSB4IHx8IHkgPT09IHk7XHJcbiAgICB9XHJcbn1cblxudmFyIFNTUl9BVFRSID0gJ2RhdGEtc2VydmVyLXJlbmRlcmVkJztcclxudmFyIEFTU0VUX1RZUEVTID0gWydjb21wb25lbnQnLCAnZGlyZWN0aXZlJywgJ2ZpbHRlciddO1xyXG52YXIgTElGRUNZQ0xFX0hPT0tTID0gW1xyXG4gICAgJ2JlZm9yZUNyZWF0ZScsXHJcbiAgICAnY3JlYXRlZCcsXHJcbiAgICAnYmVmb3JlTW91bnQnLFxyXG4gICAgJ21vdW50ZWQnLFxyXG4gICAgJ2JlZm9yZVVwZGF0ZScsXHJcbiAgICAndXBkYXRlZCcsXHJcbiAgICAnYmVmb3JlRGVzdHJveScsXHJcbiAgICAnZGVzdHJveWVkJyxcclxuICAgICdhY3RpdmF0ZWQnLFxyXG4gICAgJ2RlYWN0aXZhdGVkJyxcclxuICAgICdlcnJvckNhcHR1cmVkJyxcclxuICAgICdzZXJ2ZXJQcmVmZXRjaCcsXHJcbiAgICAncmVuZGVyVHJhY2tlZCcsXHJcbiAgICAncmVuZGVyVHJpZ2dlcmVkJ1xyXG5dO1xuXG52YXIgY29uZmlnID0ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBPcHRpb24gbWVyZ2Ugc3RyYXRlZ2llcyAodXNlZCBpbiBjb3JlL3V0aWwvb3B0aW9ucylcclxuICAgICAqL1xyXG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXHJcbiAgICBvcHRpb25NZXJnZVN0cmF0ZWdpZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdG8gc3VwcHJlc3Mgd2FybmluZ3MuXHJcbiAgICAgKi9cclxuICAgIHNpbGVudDogZmFsc2UsXHJcbiAgICAvKipcclxuICAgICAqIFNob3cgcHJvZHVjdGlvbiBtb2RlIHRpcCBtZXNzYWdlIG9uIGJvb3Q/XHJcbiAgICAgKi9cclxuICAgIHByb2R1Y3Rpb25UaXA6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdG8gZW5hYmxlIGRldnRvb2xzXHJcbiAgICAgKi9cclxuICAgIGRldnRvb2xzOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLFxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRvIHJlY29yZCBwZXJmXHJcbiAgICAgKi9cclxuICAgIHBlcmZvcm1hbmNlOiBmYWxzZSxcclxuICAgIC8qKlxyXG4gICAgICogRXJyb3IgaGFuZGxlciBmb3Igd2F0Y2hlciBlcnJvcnNcclxuICAgICAqL1xyXG4gICAgZXJyb3JIYW5kbGVyOiBudWxsLFxyXG4gICAgLyoqXHJcbiAgICAgKiBXYXJuIGhhbmRsZXIgZm9yIHdhdGNoZXIgd2FybnNcclxuICAgICAqL1xyXG4gICAgd2FybkhhbmRsZXI6IG51bGwsXHJcbiAgICAvKipcclxuICAgICAqIElnbm9yZSBjZXJ0YWluIGN1c3RvbSBlbGVtZW50c1xyXG4gICAgICovXHJcbiAgICBpZ25vcmVkRWxlbWVudHM6IFtdLFxyXG4gICAgLyoqXHJcbiAgICAgKiBDdXN0b20gdXNlciBrZXkgYWxpYXNlcyBmb3Igdi1vblxyXG4gICAgICovXHJcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcclxuICAgIGtleUNvZGVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjayBpZiBhIHRhZyBpcyByZXNlcnZlZCBzbyB0aGF0IGl0IGNhbm5vdCBiZSByZWdpc3RlcmVkIGFzIGFcclxuICAgICAqIGNvbXBvbmVudC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cclxuICAgICAqL1xyXG4gICAgaXNSZXNlcnZlZFRhZzogbm8sXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBpcyByZXNlcnZlZCBzbyB0aGF0IGl0IGNhbm5vdCBiZSB1c2VkIGFzIGEgY29tcG9uZW50XHJcbiAgICAgKiBwcm9wLiBUaGlzIGlzIHBsYXRmb3JtLWRlcGVuZGVudCBhbmQgbWF5IGJlIG92ZXJ3cml0dGVuLlxyXG4gICAgICovXHJcbiAgICBpc1Jlc2VydmVkQXR0cjogbm8sXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrIGlmIGEgdGFnIGlzIGFuIHVua25vd24gZWxlbWVudC5cclxuICAgICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cclxuICAgICAqL1xyXG4gICAgaXNVbmtub3duRWxlbWVudDogbm8sXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgbmFtZXNwYWNlIG9mIGFuIGVsZW1lbnRcclxuICAgICAqL1xyXG4gICAgZ2V0VGFnTmFtZXNwYWNlOiBub29wLFxyXG4gICAgLyoqXHJcbiAgICAgKiBQYXJzZSB0aGUgcmVhbCB0YWcgbmFtZSBmb3IgdGhlIHNwZWNpZmljIHBsYXRmb3JtLlxyXG4gICAgICovXHJcbiAgICBwYXJzZVBsYXRmb3JtVGFnTmFtZTogaWRlbnRpdHksXHJcbiAgICAvKipcclxuICAgICAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBtdXN0IGJlIGJvdW5kIHVzaW5nIHByb3BlcnR5LCBlLmcuIHZhbHVlXHJcbiAgICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXHJcbiAgICAgKi9cclxuICAgIG11c3RVc2VQcm9wOiBubyxcclxuICAgIC8qKlxyXG4gICAgICogUGVyZm9ybSB1cGRhdGVzIGFzeW5jaHJvbm91c2x5LiBJbnRlbmRlZCB0byBiZSB1c2VkIGJ5IFZ1ZSBUZXN0IFV0aWxzXHJcbiAgICAgKiBUaGlzIHdpbGwgc2lnbmlmaWNhbnRseSByZWR1Y2UgcGVyZm9ybWFuY2UgaWYgc2V0IHRvIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBhc3luYzogdHJ1ZSxcclxuICAgIC8qKlxyXG4gICAgICogRXhwb3NlZCBmb3IgbGVnYWN5IHJlYXNvbnNcclxuICAgICAqL1xyXG4gICAgX2xpZmVjeWNsZUhvb2tzOiBMSUZFQ1lDTEVfSE9PS1NcclxufTtcblxuLyoqXHJcbiAqIHVuaWNvZGUgbGV0dGVycyB1c2VkIGZvciBwYXJzaW5nIGh0bWwgdGFncywgY29tcG9uZW50IG5hbWVzIGFuZCBwcm9wZXJ0eSBwYXRocy5cclxuICogdXNpbmcgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1My9zZW1hbnRpY3Mtc2NyaXB0aW5nLmh0bWwjcG90ZW50aWFsY3VzdG9tZWxlbWVudG5hbWVcclxuICogc2tpcHBpbmcgXFx1MTAwMDAtXFx1RUZGRkYgZHVlIHRvIGl0IGZyZWV6aW5nIHVwIFBoYW50b21KU1xyXG4gKi9cclxudmFyIHVuaWNvZGVSZWdFeHAgPSAvYS16QS1aXFx1MDBCN1xcdTAwQzAtXFx1MDBENlxcdTAwRDgtXFx1MDBGNlxcdTAwRjgtXFx1MDM3RFxcdTAzN0YtXFx1MUZGRlxcdTIwMEMtXFx1MjAwRFxcdTIwM0YtXFx1MjA0MFxcdTIwNzAtXFx1MjE4RlxcdTJDMDAtXFx1MkZFRlxcdTMwMDEtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZGRC87XHJcbi8qKlxyXG4gKiBDaGVjayBpZiBhIHN0cmluZyBzdGFydHMgd2l0aCAkIG9yIF9cclxuICovXHJcbmZ1bmN0aW9uIGlzUmVzZXJ2ZWQoc3RyKSB7XHJcbiAgICB2YXIgYyA9IChzdHIgKyAnJykuY2hhckNvZGVBdCgwKTtcclxuICAgIHJldHVybiBjID09PSAweDI0IHx8IGMgPT09IDB4NWY7XHJcbn1cclxuLyoqXHJcbiAqIERlZmluZSBhIHByb3BlcnR5LlxyXG4gKi9cclxuZnVuY3Rpb24gZGVmKG9iaiwga2V5LCB2YWwsIGVudW1lcmFibGUpIHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xyXG4gICAgICAgIHZhbHVlOiB2YWwsXHJcbiAgICAgICAgZW51bWVyYWJsZTogISFlbnVtZXJhYmxlLFxyXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIFBhcnNlIHNpbXBsZSBwYXRoLlxyXG4gKi9cclxudmFyIGJhaWxSRSA9IG5ldyBSZWdFeHAoXCJbXlwiLmNvbmNhdCh1bmljb2RlUmVnRXhwLnNvdXJjZSwgXCIuJF9cXFxcZF1cIikpO1xyXG5mdW5jdGlvbiBwYXJzZVBhdGgocGF0aCkge1xyXG4gICAgaWYgKGJhaWxSRS50ZXN0KHBhdGgpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdmFyIHNlZ21lbnRzID0gcGF0aC5zcGxpdCgnLicpO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICghb2JqKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICBvYmogPSBvYmpbc2VnbWVudHNbaV1dO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgfTtcclxufVxuXG4vLyBjYW4gd2UgdXNlIF9fcHJvdG9fXz9cclxudmFyIGhhc1Byb3RvID0gJ19fcHJvdG9fXycgaW4ge307XHJcbi8vIEJyb3dzZXIgZW52aXJvbm1lbnQgc25pZmZpbmdcclxudmFyIGluQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xyXG52YXIgVUEgPSBpbkJyb3dzZXIgJiYgd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcclxudmFyIGlzSUUgPSBVQSAmJiAvbXNpZXx0cmlkZW50Ly50ZXN0KFVBKTtcclxudmFyIGlzSUU5ID0gVUEgJiYgVUEuaW5kZXhPZignbXNpZSA5LjAnKSA+IDA7XHJcbnZhciBpc0VkZ2UgPSBVQSAmJiBVQS5pbmRleE9mKCdlZGdlLycpID4gMDtcclxuVUEgJiYgVUEuaW5kZXhPZignYW5kcm9pZCcpID4gMDtcclxudmFyIGlzSU9TID0gVUEgJiYgL2lwaG9uZXxpcGFkfGlwb2R8aW9zLy50ZXN0KFVBKTtcclxuVUEgJiYgL2Nocm9tZVxcL1xcZCsvLnRlc3QoVUEpICYmICFpc0VkZ2U7XHJcblVBICYmIC9waGFudG9tanMvLnRlc3QoVUEpO1xyXG52YXIgaXNGRiA9IFVBICYmIFVBLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLyk7XHJcbi8vIEZpcmVmb3ggaGFzIGEgXCJ3YXRjaFwiIGZ1bmN0aW9uIG9uIE9iamVjdC5wcm90b3R5cGUuLi5cclxuLy8gQHRzLWV4cGVjdC1lcnJvciBmaXJlYm94IHN1cHBvcnRcclxudmFyIG5hdGl2ZVdhdGNoID0ge30ud2F0Y2g7XHJcbnZhciBzdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcclxuaWYgKGluQnJvd3Nlcikge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB2YXIgb3B0cyA9IHt9O1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcHRzLCAncGFzc2l2ZScsIHtcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgICAgICAgICAgc3VwcG9ydHNQYXNzaXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMjg1XHJcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QtcGFzc2l2ZScsIG51bGwsIG9wdHMpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHsgfVxyXG59XHJcbi8vIHRoaXMgbmVlZHMgdG8gYmUgbGF6eS1ldmFsZWQgYmVjYXVzZSB2dWUgbWF5IGJlIHJlcXVpcmVkIGJlZm9yZVxyXG4vLyB2dWUtc2VydmVyLXJlbmRlcmVyIGNhbiBzZXQgVlVFX0VOVlxyXG52YXIgX2lzU2VydmVyO1xyXG52YXIgaXNTZXJ2ZXJSZW5kZXJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAoX2lzU2VydmVyID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgICBpZiAoIWluQnJvd3NlciAmJiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAvLyBkZXRlY3QgcHJlc2VuY2Ugb2YgdnVlLXNlcnZlci1yZW5kZXJlciBhbmQgYXZvaWRcclxuICAgICAgICAgICAgLy8gV2VicGFjayBzaGltbWluZyB0aGUgcHJvY2Vzc1xyXG4gICAgICAgICAgICBfaXNTZXJ2ZXIgPVxyXG4gICAgICAgICAgICAgICAgZ2xvYmFsWydwcm9jZXNzJ10gJiYgZ2xvYmFsWydwcm9jZXNzJ10uZW52LlZVRV9FTlYgPT09ICdzZXJ2ZXInO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgX2lzU2VydmVyID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9pc1NlcnZlcjtcclxufTtcclxuLy8gZGV0ZWN0IGRldnRvb2xzXHJcbnZhciBkZXZ0b29scyA9IGluQnJvd3NlciAmJiB3aW5kb3cuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztcclxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuZnVuY3Rpb24gaXNOYXRpdmUoQ3Rvcikge1xyXG4gICAgcmV0dXJuIHR5cGVvZiBDdG9yID09PSAnZnVuY3Rpb24nICYmIC9uYXRpdmUgY29kZS8udGVzdChDdG9yLnRvU3RyaW5nKCkpO1xyXG59XHJcbnZhciBoYXNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJlxyXG4gICAgaXNOYXRpdmUoU3ltYm9sKSAmJlxyXG4gICAgdHlwZW9mIFJlZmxlY3QgIT09ICd1bmRlZmluZWQnICYmXHJcbiAgICBpc05hdGl2ZShSZWZsZWN0Lm93bktleXMpO1xyXG52YXIgX1NldDsgLy8gJGZsb3ctZGlzYWJsZS1saW5lXHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqLyBpZiAodHlwZW9mIFNldCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU2V0KSkge1xyXG4gICAgLy8gdXNlIG5hdGl2ZSBTZXQgd2hlbiBhdmFpbGFibGUuXHJcbiAgICBfU2V0ID0gU2V0O1xyXG59XHJcbmVsc2Uge1xyXG4gICAgLy8gYSBub24tc3RhbmRhcmQgU2V0IHBvbHlmaWxsIHRoYXQgb25seSB3b3JrcyB3aXRoIHByaW1pdGl2ZSBrZXlzLlxyXG4gICAgX1NldCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBTZXQoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgU2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldFtrZXldID09PSB0cnVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgU2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0W2tleV0gPSB0cnVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgU2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFNldDtcclxuICAgIH0oKSk7XHJcbn1cblxudmFyIGN1cnJlbnRJbnN0YW5jZSA9IG51bGw7XHJcbi8qKlxyXG4gKiBUaGlzIGlzIGV4cG9zZWQgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCB2MyAoZS5nLiBzb21lIGZ1bmN0aW9ucyBpbiBWdWVVc2VcclxuICogcmVsaWVzIG9uIGl0KS4gRG8gbm90IHVzZSB0aGlzIGludGVybmFsbHksIGp1c3QgdXNlIGBjdXJyZW50SW5zdGFuY2VgLlxyXG4gKlxyXG4gKiBAaW50ZXJuYWwgdGhpcyBmdW5jdGlvbiBuZWVkcyBtYW51YWwgdHlwZSBkZWNsYXJhdGlvbiBiZWNhdXNlIGl0IHJlbGllc1xyXG4gKiBvbiBwcmV2aW91c2x5IG1hbnVhbGx5IGF1dGhvcmVkIHR5cGVzIGZyb20gVnVlIDJcclxuICovXHJcbmZ1bmN0aW9uIGdldEN1cnJlbnRJbnN0YW5jZSgpIHtcclxuICAgIHJldHVybiBjdXJyZW50SW5zdGFuY2UgJiYgeyBwcm94eTogY3VycmVudEluc3RhbmNlIH07XHJcbn1cclxuLyoqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gc2V0Q3VycmVudEluc3RhbmNlKHZtKSB7XHJcbiAgICBpZiAodm0gPT09IHZvaWQgMCkgeyB2bSA9IG51bGw7IH1cclxuICAgIGlmICghdm0pXHJcbiAgICAgICAgY3VycmVudEluc3RhbmNlICYmIGN1cnJlbnRJbnN0YW5jZS5fc2NvcGUub2ZmKCk7XHJcbiAgICBjdXJyZW50SW5zdGFuY2UgPSB2bTtcclxuICAgIHZtICYmIHZtLl9zY29wZS5vbigpO1xyXG59XG5cbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbnZhciBWTm9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFZOb2RlKHRhZywgZGF0YSwgY2hpbGRyZW4sIHRleHQsIGVsbSwgY29udGV4dCwgY29tcG9uZW50T3B0aW9ucywgYXN5bmNGYWN0b3J5KSB7XHJcbiAgICAgICAgdGhpcy50YWcgPSB0YWc7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XHJcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcclxuICAgICAgICB0aGlzLmVsbSA9IGVsbTtcclxuICAgICAgICB0aGlzLm5zID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XHJcbiAgICAgICAgdGhpcy5mbkNvbnRleHQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5mbk9wdGlvbnMgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5mblNjb3BlSWQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5rZXkgPSBkYXRhICYmIGRhdGEua2V5O1xyXG4gICAgICAgIHRoaXMuY29tcG9uZW50T3B0aW9ucyA9IGNvbXBvbmVudE9wdGlvbnM7XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnRJbnN0YW5jZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLnJhdyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaXNTdGF0aWMgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmlzUm9vdEluc2VydCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5pc0NvbW1lbnQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmlzQ2xvbmVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5pc09uY2UgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmFzeW5jRmFjdG9yeSA9IGFzeW5jRmFjdG9yeTtcclxuICAgICAgICB0aGlzLmFzeW5jTWV0YSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLmlzQXN5bmNQbGFjZWhvbGRlciA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZOb2RlLnByb3RvdHlwZSwgXCJjaGlsZFwiLCB7XHJcbiAgICAgICAgLy8gREVQUkVDQVRFRDogYWxpYXMgZm9yIGNvbXBvbmVudEluc3RhbmNlIGZvciBiYWNrd2FyZHMgY29tcGF0LlxyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudEluc3RhbmNlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBWTm9kZTtcclxufSgpKTtcclxudmFyIGNyZWF0ZUVtcHR5Vk5vZGUgPSBmdW5jdGlvbiAodGV4dCkge1xyXG4gICAgaWYgKHRleHQgPT09IHZvaWQgMCkgeyB0ZXh0ID0gJyc7IH1cclxuICAgIHZhciBub2RlID0gbmV3IFZOb2RlKCk7XHJcbiAgICBub2RlLnRleHQgPSB0ZXh0O1xyXG4gICAgbm9kZS5pc0NvbW1lbnQgPSB0cnVlO1xyXG4gICAgcmV0dXJuIG5vZGU7XHJcbn07XHJcbmZ1bmN0aW9uIGNyZWF0ZVRleHRWTm9kZSh2YWwpIHtcclxuICAgIHJldHVybiBuZXcgVk5vZGUodW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgU3RyaW5nKHZhbCkpO1xyXG59XHJcbi8vIG9wdGltaXplZCBzaGFsbG93IGNsb25lXHJcbi8vIHVzZWQgZm9yIHN0YXRpYyBub2RlcyBhbmQgc2xvdCBub2RlcyBiZWNhdXNlIHRoZXkgbWF5IGJlIHJldXNlZCBhY3Jvc3NcclxuLy8gbXVsdGlwbGUgcmVuZGVycywgY2xvbmluZyB0aGVtIGF2b2lkcyBlcnJvcnMgd2hlbiBET00gbWFuaXB1bGF0aW9ucyByZWx5XHJcbi8vIG9uIHRoZWlyIGVsbSByZWZlcmVuY2UuXHJcbmZ1bmN0aW9uIGNsb25lVk5vZGUodm5vZGUpIHtcclxuICAgIHZhciBjbG9uZWQgPSBuZXcgVk5vZGUodm5vZGUudGFnLCB2bm9kZS5kYXRhLCBcclxuICAgIC8vICM3OTc1XHJcbiAgICAvLyBjbG9uZSBjaGlsZHJlbiBhcnJheSB0byBhdm9pZCBtdXRhdGluZyBvcmlnaW5hbCBpbiBjYXNlIG9mIGNsb25pbmdcclxuICAgIC8vIGEgY2hpbGQuXHJcbiAgICB2bm9kZS5jaGlsZHJlbiAmJiB2bm9kZS5jaGlsZHJlbi5zbGljZSgpLCB2bm9kZS50ZXh0LCB2bm9kZS5lbG0sIHZub2RlLmNvbnRleHQsIHZub2RlLmNvbXBvbmVudE9wdGlvbnMsIHZub2RlLmFzeW5jRmFjdG9yeSk7XHJcbiAgICBjbG9uZWQubnMgPSB2bm9kZS5ucztcclxuICAgIGNsb25lZC5pc1N0YXRpYyA9IHZub2RlLmlzU3RhdGljO1xyXG4gICAgY2xvbmVkLmtleSA9IHZub2RlLmtleTtcclxuICAgIGNsb25lZC5pc0NvbW1lbnQgPSB2bm9kZS5pc0NvbW1lbnQ7XHJcbiAgICBjbG9uZWQuZm5Db250ZXh0ID0gdm5vZGUuZm5Db250ZXh0O1xyXG4gICAgY2xvbmVkLmZuT3B0aW9ucyA9IHZub2RlLmZuT3B0aW9ucztcclxuICAgIGNsb25lZC5mblNjb3BlSWQgPSB2bm9kZS5mblNjb3BlSWQ7XHJcbiAgICBjbG9uZWQuYXN5bmNNZXRhID0gdm5vZGUuYXN5bmNNZXRhO1xyXG4gICAgY2xvbmVkLmlzQ2xvbmVkID0gdHJ1ZTtcclxuICAgIHJldHVybiBjbG9uZWQ7XHJcbn1cblxuLyogbm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoIFByb3h5ICovXHJcbnZhciBpbml0UHJveHk7XHJcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICB2YXIgYWxsb3dlZEdsb2JhbHNfMSA9IG1ha2VNYXAoJ0luZmluaXR5LHVuZGVmaW5lZCxOYU4saXNGaW5pdGUsaXNOYU4sJyArXHJcbiAgICAgICAgJ3BhcnNlRmxvYXQscGFyc2VJbnQsZGVjb2RlVVJJLGRlY29kZVVSSUNvbXBvbmVudCxlbmNvZGVVUkksZW5jb2RlVVJJQ29tcG9uZW50LCcgK1xyXG4gICAgICAgICdNYXRoLE51bWJlcixEYXRlLEFycmF5LE9iamVjdCxCb29sZWFuLFN0cmluZyxSZWdFeHAsTWFwLFNldCxKU09OLEludGwsQmlnSW50LCcgK1xyXG4gICAgICAgICdyZXF1aXJlJyAvLyBmb3IgV2VicGFjay9Ccm93c2VyaWZ5XHJcbiAgICApO1xyXG4gICAgdmFyIHdhcm5Ob25QcmVzZW50XzEgPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcclxuICAgICAgICB3YXJuJDIoXCJQcm9wZXJ0eSBvciBtZXRob2QgXFxcIlwiLmNvbmNhdChrZXksIFwiXFxcIiBpcyBub3QgZGVmaW5lZCBvbiB0aGUgaW5zdGFuY2UgYnV0IFwiKSArXHJcbiAgICAgICAgICAgICdyZWZlcmVuY2VkIGR1cmluZyByZW5kZXIuIE1ha2Ugc3VyZSB0aGF0IHRoaXMgcHJvcGVydHkgaXMgcmVhY3RpdmUsICcgK1xyXG4gICAgICAgICAgICAnZWl0aGVyIGluIHRoZSBkYXRhIG9wdGlvbiwgb3IgZm9yIGNsYXNzLWJhc2VkIGNvbXBvbmVudHMsIGJ5ICcgK1xyXG4gICAgICAgICAgICAnaW5pdGlhbGl6aW5nIHRoZSBwcm9wZXJ0eS4gJyArXHJcbiAgICAgICAgICAgICdTZWU6IGh0dHBzOi8vdnVlanMub3JnL3YyL2d1aWRlL3JlYWN0aXZpdHkuaHRtbCNEZWNsYXJpbmctUmVhY3RpdmUtUHJvcGVydGllcy4nLCB0YXJnZXQpO1xyXG4gICAgfTtcclxuICAgIHZhciB3YXJuUmVzZXJ2ZWRQcmVmaXhfMSA9IGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xyXG4gICAgICAgIHdhcm4kMihcIlByb3BlcnR5IFxcXCJcIi5jb25jYXQoa2V5LCBcIlxcXCIgbXVzdCBiZSBhY2Nlc3NlZCB3aXRoIFxcXCIkZGF0YS5cIikuY29uY2F0KGtleSwgXCJcXFwiIGJlY2F1c2UgXCIpICtcclxuICAgICAgICAgICAgJ3Byb3BlcnRpZXMgc3RhcnRpbmcgd2l0aCBcIiRcIiBvciBcIl9cIiBhcmUgbm90IHByb3hpZWQgaW4gdGhlIFZ1ZSBpbnN0YW5jZSB0byAnICtcclxuICAgICAgICAgICAgJ3ByZXZlbnQgY29uZmxpY3RzIHdpdGggVnVlIGludGVybmFscy4gJyArXHJcbiAgICAgICAgICAgICdTZWU6IGh0dHBzOi8vdnVlanMub3JnL3YyL2FwaS8jZGF0YScsIHRhcmdldCk7XHJcbiAgICB9O1xyXG4gICAgdmFyIGhhc1Byb3h5XzEgPSB0eXBlb2YgUHJveHkgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFByb3h5KTtcclxuICAgIGlmIChoYXNQcm94eV8xKSB7XHJcbiAgICAgICAgdmFyIGlzQnVpbHRJbk1vZGlmaWVyXzEgPSBtYWtlTWFwKCdzdG9wLHByZXZlbnQsc2VsZixjdHJsLHNoaWZ0LGFsdCxtZXRhLGV4YWN0Jyk7XHJcbiAgICAgICAgY29uZmlnLmtleUNvZGVzID0gbmV3IFByb3h5KGNvbmZpZy5rZXlDb2Rlcywge1xyXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0YXJnZXQsIGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc0J1aWx0SW5Nb2RpZmllcl8xKGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuJDIoXCJBdm9pZCBvdmVyd3JpdGluZyBidWlsdC1pbiBtb2RpZmllciBpbiBjb25maWcua2V5Q29kZXM6IC5cIi5jb25jYXQoa2V5KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdmFyIGhhc0hhbmRsZXJfMSA9IHtcclxuICAgICAgICBoYXM6IGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xyXG4gICAgICAgICAgICB2YXIgaGFzID0ga2V5IGluIHRhcmdldDtcclxuICAgICAgICAgICAgdmFyIGlzQWxsb3dlZCA9IGFsbG93ZWRHbG9iYWxzXzEoa2V5KSB8fFxyXG4gICAgICAgICAgICAgICAgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmXHJcbiAgICAgICAgICAgICAgICAgICAga2V5LmNoYXJBdCgwKSA9PT0gJ18nICYmXHJcbiAgICAgICAgICAgICAgICAgICAgIShrZXkgaW4gdGFyZ2V0LiRkYXRhKSk7XHJcbiAgICAgICAgICAgIGlmICghaGFzICYmICFpc0FsbG93ZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChrZXkgaW4gdGFyZ2V0LiRkYXRhKVxyXG4gICAgICAgICAgICAgICAgICAgIHdhcm5SZXNlcnZlZFByZWZpeF8xKHRhcmdldCwga2V5KTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB3YXJuTm9uUHJlc2VudF8xKHRhcmdldCwga2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gaGFzIHx8ICFpc0FsbG93ZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHZhciBnZXRIYW5kbGVyXzEgPSB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmICEoa2V5IGluIHRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChrZXkgaW4gdGFyZ2V0LiRkYXRhKVxyXG4gICAgICAgICAgICAgICAgICAgIHdhcm5SZXNlcnZlZFByZWZpeF8xKHRhcmdldCwga2V5KTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB3YXJuTm9uUHJlc2VudF8xKHRhcmdldCwga2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0W2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGluaXRQcm94eSA9IGZ1bmN0aW9uIGluaXRQcm94eSh2bSkge1xyXG4gICAgICAgIGlmIChoYXNQcm94eV8xKSB7XHJcbiAgICAgICAgICAgIC8vIGRldGVybWluZSB3aGljaCBwcm94eSBoYW5kbGVyIHRvIHVzZVxyXG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xyXG4gICAgICAgICAgICB2YXIgaGFuZGxlcnMgPSBvcHRpb25zLnJlbmRlciAmJiBvcHRpb25zLnJlbmRlci5fd2l0aFN0cmlwcGVkID8gZ2V0SGFuZGxlcl8xIDogaGFzSGFuZGxlcl8xO1xyXG4gICAgICAgICAgICB2bS5fcmVuZGVyUHJveHkgPSBuZXcgUHJveHkodm0sIGhhbmRsZXJzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZtLl9yZW5kZXJQcm94eSA9IHZtO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblxyXG52YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59O1xuXG52YXIgdWlkJDIgPSAwO1xyXG4vKipcclxuICogQSBkZXAgaXMgYW4gb2JzZXJ2YWJsZSB0aGF0IGNhbiBoYXZlIG11bHRpcGxlXHJcbiAqIGRpcmVjdGl2ZXMgc3Vic2NyaWJpbmcgdG8gaXQuXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxudmFyIERlcCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIERlcCgpIHtcclxuICAgICAgICB0aGlzLmlkID0gdWlkJDIrKztcclxuICAgICAgICB0aGlzLnN1YnMgPSBbXTtcclxuICAgIH1cclxuICAgIERlcC5wcm90b3R5cGUuYWRkU3ViID0gZnVuY3Rpb24gKHN1Yikge1xyXG4gICAgICAgIHRoaXMuc3Vicy5wdXNoKHN1Yik7XHJcbiAgICB9O1xyXG4gICAgRGVwLnByb3RvdHlwZS5yZW1vdmVTdWIgPSBmdW5jdGlvbiAoc3ViKSB7XHJcbiAgICAgICAgcmVtb3ZlJDIodGhpcy5zdWJzLCBzdWIpO1xyXG4gICAgfTtcclxuICAgIERlcC5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gKGluZm8pIHtcclxuICAgICAgICBpZiAoRGVwLnRhcmdldCkge1xyXG4gICAgICAgICAgICBEZXAudGFyZ2V0LmFkZERlcCh0aGlzKTtcclxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaW5mbyAmJiBEZXAudGFyZ2V0Lm9uVHJhY2spIHtcclxuICAgICAgICAgICAgICAgIERlcC50YXJnZXQub25UcmFjayhfX2Fzc2lnbih7IGVmZmVjdDogRGVwLnRhcmdldCB9LCBpbmZvKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRGVwLnByb3RvdHlwZS5ub3RpZnkgPSBmdW5jdGlvbiAoaW5mbykge1xyXG4gICAgICAgIC8vIHN0YWJpbGl6ZSB0aGUgc3Vic2NyaWJlciBsaXN0IGZpcnN0XHJcbiAgICAgICAgdmFyIHN1YnMgPSB0aGlzLnN1YnMuc2xpY2UoKTtcclxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhY29uZmlnLmFzeW5jKSB7XHJcbiAgICAgICAgICAgIC8vIHN1YnMgYXJlbid0IHNvcnRlZCBpbiBzY2hlZHVsZXIgaWYgbm90IHJ1bm5pbmcgYXN5bmNcclxuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBzb3J0IHRoZW0gbm93IHRvIG1ha2Ugc3VyZSB0aGV5IGZpcmUgaW4gY29ycmVjdFxyXG4gICAgICAgICAgICAvLyBvcmRlclxyXG4gICAgICAgICAgICBzdWJzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuaWQgLSBiLmlkOyB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdWJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpbmZvKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3ViID0gc3Vic1tpXTtcclxuICAgICAgICAgICAgICAgIHN1Yi5vblRyaWdnZXIgJiZcclxuICAgICAgICAgICAgICAgICAgICBzdWIub25UcmlnZ2VyKF9fYXNzaWduKHsgZWZmZWN0OiBzdWJzW2ldIH0sIGluZm8pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzdWJzW2ldLnVwZGF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gRGVwO1xyXG59KCkpO1xyXG4vLyBUaGUgY3VycmVudCB0YXJnZXQgd2F0Y2hlciBiZWluZyBldmFsdWF0ZWQuXHJcbi8vIFRoaXMgaXMgZ2xvYmFsbHkgdW5pcXVlIGJlY2F1c2Ugb25seSBvbmUgd2F0Y2hlclxyXG4vLyBjYW4gYmUgZXZhbHVhdGVkIGF0IGEgdGltZS5cclxuRGVwLnRhcmdldCA9IG51bGw7XHJcbnZhciB0YXJnZXRTdGFjayA9IFtdO1xyXG5mdW5jdGlvbiBwdXNoVGFyZ2V0KHRhcmdldCkge1xyXG4gICAgdGFyZ2V0U3RhY2sucHVzaCh0YXJnZXQpO1xyXG4gICAgRGVwLnRhcmdldCA9IHRhcmdldDtcclxufVxyXG5mdW5jdGlvbiBwb3BUYXJnZXQoKSB7XHJcbiAgICB0YXJnZXRTdGFjay5wb3AoKTtcclxuICAgIERlcC50YXJnZXQgPSB0YXJnZXRTdGFja1t0YXJnZXRTdGFjay5sZW5ndGggLSAxXTtcclxufVxuXG4vKlxyXG4gKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGhcclxuICogZHluYW1pY2FsbHkgYWNjZXNzaW5nIG1ldGhvZHMgb24gQXJyYXkgcHJvdG90eXBlXHJcbiAqL1xyXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcclxudmFyIGFycmF5TWV0aG9kcyA9IE9iamVjdC5jcmVhdGUoYXJyYXlQcm90byk7XHJcbnZhciBtZXRob2RzVG9QYXRjaCA9IFtcclxuICAgICdwdXNoJyxcclxuICAgICdwb3AnLFxyXG4gICAgJ3NoaWZ0JyxcclxuICAgICd1bnNoaWZ0JyxcclxuICAgICdzcGxpY2UnLFxyXG4gICAgJ3NvcnQnLFxyXG4gICAgJ3JldmVyc2UnXHJcbl07XHJcbi8qKlxyXG4gKiBJbnRlcmNlcHQgbXV0YXRpbmcgbWV0aG9kcyBhbmQgZW1pdCBldmVudHNcclxuICovXHJcbm1ldGhvZHNUb1BhdGNoLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xyXG4gICAgLy8gY2FjaGUgb3JpZ2luYWwgbWV0aG9kXHJcbiAgICB2YXIgb3JpZ2luYWwgPSBhcnJheVByb3RvW21ldGhvZF07XHJcbiAgICBkZWYoYXJyYXlNZXRob2RzLCBtZXRob2QsIGZ1bmN0aW9uIG11dGF0b3IoKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByZXN1bHQgPSBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcclxuICAgICAgICB2YXIgb2IgPSB0aGlzLl9fb2JfXztcclxuICAgICAgICB2YXIgaW5zZXJ0ZWQ7XHJcbiAgICAgICAgc3dpdGNoIChtZXRob2QpIHtcclxuICAgICAgICAgICAgY2FzZSAncHVzaCc6XHJcbiAgICAgICAgICAgIGNhc2UgJ3Vuc2hpZnQnOlxyXG4gICAgICAgICAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ3NwbGljZSc6XHJcbiAgICAgICAgICAgICAgICBpbnNlcnRlZCA9IGFyZ3Muc2xpY2UoMik7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGluc2VydGVkKVxyXG4gICAgICAgICAgICBvYi5vYnNlcnZlQXJyYXkoaW5zZXJ0ZWQpO1xyXG4gICAgICAgIC8vIG5vdGlmeSBjaGFuZ2VcclxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgICBvYi5kZXAubm90aWZ5KHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXkgbXV0YXRpb25cIiAvKiBUcmlnZ2VyT3BUeXBlcy5BUlJBWV9NVVRBVElPTiAqLyxcclxuICAgICAgICAgICAgICAgIHRhcmdldDogdGhpcyxcclxuICAgICAgICAgICAgICAgIGtleTogbWV0aG9kXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgb2IuZGVwLm5vdGlmeSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfSk7XHJcbn0pO1xuXG52YXIgYXJyYXlLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXJyYXlNZXRob2RzKTtcclxudmFyIE5PX0lOSUlUSUFMX1ZBTFVFID0ge307XHJcbi8qKlxyXG4gKiBJbiBzb21lIGNhc2VzIHdlIG1heSB3YW50IHRvIGRpc2FibGUgb2JzZXJ2YXRpb24gaW5zaWRlIGEgY29tcG9uZW50J3NcclxuICogdXBkYXRlIGNvbXB1dGF0aW9uLlxyXG4gKi9cclxudmFyIHNob3VsZE9ic2VydmUgPSB0cnVlO1xyXG5mdW5jdGlvbiB0b2dnbGVPYnNlcnZpbmcodmFsdWUpIHtcclxuICAgIHNob3VsZE9ic2VydmUgPSB2YWx1ZTtcclxufVxyXG4vLyBzc3IgbW9jayBkZXBcclxudmFyIG1vY2tEZXAgPSB7XHJcbiAgICBub3RpZnk6IG5vb3AsXHJcbiAgICBkZXBlbmQ6IG5vb3AsXHJcbiAgICBhZGRTdWI6IG5vb3AsXHJcbiAgICByZW1vdmVTdWI6IG5vb3BcclxufTtcclxuLyoqXHJcbiAqIE9ic2VydmVyIGNsYXNzIHRoYXQgaXMgYXR0YWNoZWQgdG8gZWFjaCBvYnNlcnZlZFxyXG4gKiBvYmplY3QuIE9uY2UgYXR0YWNoZWQsIHRoZSBvYnNlcnZlciBjb252ZXJ0cyB0aGUgdGFyZ2V0XHJcbiAqIG9iamVjdCdzIHByb3BlcnR5IGtleXMgaW50byBnZXR0ZXIvc2V0dGVycyB0aGF0XHJcbiAqIGNvbGxlY3QgZGVwZW5kZW5jaWVzIGFuZCBkaXNwYXRjaCB1cGRhdGVzLlxyXG4gKi9cclxudmFyIE9ic2VydmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gT2JzZXJ2ZXIodmFsdWUsIHNoYWxsb3csIG1vY2spIHtcclxuICAgICAgICBpZiAoc2hhbGxvdyA9PT0gdm9pZCAwKSB7IHNoYWxsb3cgPSBmYWxzZTsgfVxyXG4gICAgICAgIGlmIChtb2NrID09PSB2b2lkIDApIHsgbW9jayA9IGZhbHNlOyB9XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuc2hhbGxvdyA9IHNoYWxsb3c7XHJcbiAgICAgICAgdGhpcy5tb2NrID0gbW9jaztcclxuICAgICAgICAvLyB0aGlzLnZhbHVlID0gdmFsdWVcclxuICAgICAgICB0aGlzLmRlcCA9IG1vY2sgPyBtb2NrRGVwIDogbmV3IERlcCgpO1xyXG4gICAgICAgIHRoaXMudm1Db3VudCA9IDA7XHJcbiAgICAgICAgZGVmKHZhbHVlLCAnX19vYl9fJywgdGhpcyk7XHJcbiAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIGlmICghbW9jaykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGhhc1Byb3RvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuX19wcm90b19fID0gYXJyYXlNZXRob2RzO1xyXG4gICAgICAgICAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tcHJvdG8gKi9cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXJyYXlLZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gYXJyYXlLZXlzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWYodmFsdWUsIGtleSwgYXJyYXlNZXRob2RzW2tleV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXNoYWxsb3cpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub2JzZXJ2ZUFycmF5KHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFdhbGsgdGhyb3VnaCBhbGwgcHJvcGVydGllcyBhbmQgY29udmVydCB0aGVtIGludG9cclxuICAgICAgICAgICAgICogZ2V0dGVyL3NldHRlcnMuIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZCB3aGVuXHJcbiAgICAgICAgICAgICAqIHZhbHVlIHR5cGUgaXMgT2JqZWN0LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XHJcbiAgICAgICAgICAgICAgICBkZWZpbmVSZWFjdGl2ZSh2YWx1ZSwga2V5LCBOT19JTklJVElBTF9WQUxVRSwgdW5kZWZpbmVkLCBzaGFsbG93LCBtb2NrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT2JzZXJ2ZSBhIGxpc3Qgb2YgQXJyYXkgaXRlbXMuXHJcbiAgICAgKi9cclxuICAgIE9ic2VydmVyLnByb3RvdHlwZS5vYnNlcnZlQXJyYXkgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICBvYnNlcnZlKHZhbHVlW2ldLCBmYWxzZSwgdGhpcy5tb2NrKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE9ic2VydmVyO1xyXG59KCkpO1xyXG4vLyBoZWxwZXJzXHJcbi8qKlxyXG4gKiBBdHRlbXB0IHRvIGNyZWF0ZSBhbiBvYnNlcnZlciBpbnN0YW5jZSBmb3IgYSB2YWx1ZSxcclxuICogcmV0dXJucyB0aGUgbmV3IG9ic2VydmVyIGlmIHN1Y2Nlc3NmdWxseSBvYnNlcnZlZCxcclxuICogb3IgdGhlIGV4aXN0aW5nIG9ic2VydmVyIGlmIHRoZSB2YWx1ZSBhbHJlYWR5IGhhcyBvbmUuXHJcbiAqL1xyXG5mdW5jdGlvbiBvYnNlcnZlKHZhbHVlLCBzaGFsbG93LCBzc3JNb2NrUmVhY3Rpdml0eSkge1xyXG4gICAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNSZWYodmFsdWUpIHx8IHZhbHVlIGluc3RhbmNlb2YgVk5vZGUpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB2YXIgb2I7XHJcbiAgICBpZiAoaGFzT3duKHZhbHVlLCAnX19vYl9fJykgJiYgdmFsdWUuX19vYl9fIGluc3RhbmNlb2YgT2JzZXJ2ZXIpIHtcclxuICAgICAgICBvYiA9IHZhbHVlLl9fb2JfXztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHNob3VsZE9ic2VydmUgJiZcclxuICAgICAgICAoc3NyTW9ja1JlYWN0aXZpdHkgfHwgIWlzU2VydmVyUmVuZGVyaW5nKCkpICYmXHJcbiAgICAgICAgKGlzQXJyYXkodmFsdWUpIHx8IGlzUGxhaW5PYmplY3QodmFsdWUpKSAmJlxyXG4gICAgICAgIE9iamVjdC5pc0V4dGVuc2libGUodmFsdWUpICYmXHJcbiAgICAgICAgIXZhbHVlLl9fdl9za2lwIC8qIFJlYWN0aXZlRmxhZ3MuU0tJUCAqLykge1xyXG4gICAgICAgIG9iID0gbmV3IE9ic2VydmVyKHZhbHVlLCBzaGFsbG93LCBzc3JNb2NrUmVhY3Rpdml0eSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb2I7XHJcbn1cclxuLyoqXHJcbiAqIERlZmluZSBhIHJlYWN0aXZlIHByb3BlcnR5IG9uIGFuIE9iamVjdC5cclxuICovXHJcbmZ1bmN0aW9uIGRlZmluZVJlYWN0aXZlKG9iaiwga2V5LCB2YWwsIGN1c3RvbVNldHRlciwgc2hhbGxvdywgbW9jaykge1xyXG4gICAgdmFyIGRlcCA9IG5ldyBEZXAoKTtcclxuICAgIHZhciBwcm9wZXJ0eSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpO1xyXG4gICAgaWYgKHByb3BlcnR5ICYmIHByb3BlcnR5LmNvbmZpZ3VyYWJsZSA9PT0gZmFsc2UpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICAvLyBjYXRlciBmb3IgcHJlLWRlZmluZWQgZ2V0dGVyL3NldHRlcnNcclxuICAgIHZhciBnZXR0ZXIgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5nZXQ7XHJcbiAgICB2YXIgc2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuc2V0O1xyXG4gICAgaWYgKCghZ2V0dGVyIHx8IHNldHRlcikgJiZcclxuICAgICAgICAodmFsID09PSBOT19JTklJVElBTF9WQUxVRSB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSkge1xyXG4gICAgICAgIHZhbCA9IG9ialtrZXldO1xyXG4gICAgfVxyXG4gICAgdmFyIGNoaWxkT2IgPSAhc2hhbGxvdyAmJiBvYnNlcnZlKHZhbCwgZmFsc2UsIG1vY2spO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiByZWFjdGl2ZUdldHRlcigpIHtcclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcclxuICAgICAgICAgICAgaWYgKERlcC50YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVwLmRlcGVuZCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogb2JqLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImdldFwiIC8qIFRyYWNrT3BUeXBlcy5HRVQgKi8sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleToga2V5XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBkZXAuZGVwZW5kKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRPYikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkT2IuZGVwLmRlcGVuZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXBlbmRBcnJheSh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBpc1JlZih2YWx1ZSkgJiYgIXNoYWxsb3cgPyB2YWx1ZS52YWx1ZSA6IHZhbHVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiByZWFjdGl2ZVNldHRlcihuZXdWYWwpIHtcclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcclxuICAgICAgICAgICAgaWYgKCFoYXNDaGFuZ2VkKHZhbHVlLCBuZXdWYWwpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY3VzdG9tU2V0dGVyKSB7XHJcbiAgICAgICAgICAgICAgICBjdXN0b21TZXR0ZXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc2V0dGVyKSB7XHJcbiAgICAgICAgICAgICAgICBzZXR0ZXIuY2FsbChvYmosIG5ld1ZhbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZ2V0dGVyKSB7XHJcbiAgICAgICAgICAgICAgICAvLyAjNzk4MTogZm9yIGFjY2Vzc29yIHByb3BlcnRpZXMgd2l0aG91dCBzZXR0ZXJcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghc2hhbGxvdyAmJiBpc1JlZih2YWx1ZSkgJiYgIWlzUmVmKG5ld1ZhbCkpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlLnZhbHVlID0gbmV3VmFsO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFsID0gbmV3VmFsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNoaWxkT2IgPSAhc2hhbGxvdyAmJiBvYnNlcnZlKG5ld1ZhbCwgZmFsc2UsIG1vY2spO1xyXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgZGVwLm5vdGlmeSh7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzZXRcIiAvKiBUcmlnZ2VyT3BUeXBlcy5TRVQgKi8sXHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBvYmosXHJcbiAgICAgICAgICAgICAgICAgICAga2V5OiBrZXksXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWU6IG5ld1ZhbCxcclxuICAgICAgICAgICAgICAgICAgICBvbGRWYWx1ZTogdmFsdWVcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZGVwLm5vdGlmeSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gZGVwO1xyXG59XHJcbmZ1bmN0aW9uIHNldCh0YXJnZXQsIGtleSwgdmFsKSB7XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAoaXNVbmRlZih0YXJnZXQpIHx8IGlzUHJpbWl0aXZlKHRhcmdldCkpKSB7XHJcbiAgICAgICAgd2FybiQyKFwiQ2Fubm90IHNldCByZWFjdGl2ZSBwcm9wZXJ0eSBvbiB1bmRlZmluZWQsIG51bGwsIG9yIHByaW1pdGl2ZSB2YWx1ZTogXCIuY29uY2F0KHRhcmdldCkpO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzUmVhZG9ubHkodGFyZ2V0KSkge1xyXG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybiQyKFwiU2V0IG9wZXJhdGlvbiBvbiBrZXkgXFxcIlwiLmNvbmNhdChrZXksIFwiXFxcIiBmYWlsZWQ6IHRhcmdldCBpcyByZWFkb25seS5cIikpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHZhciBvYiA9IHRhcmdldC5fX29iX187XHJcbiAgICBpZiAoaXNBcnJheSh0YXJnZXQpICYmIGlzVmFsaWRBcnJheUluZGV4KGtleSkpIHtcclxuICAgICAgICB0YXJnZXQubGVuZ3RoID0gTWF0aC5tYXgodGFyZ2V0Lmxlbmd0aCwga2V5KTtcclxuICAgICAgICB0YXJnZXQuc3BsaWNlKGtleSwgMSwgdmFsKTtcclxuICAgICAgICAvLyB3aGVuIG1vY2tpbmcgZm9yIFNTUiwgYXJyYXkgbWV0aG9kcyBhcmUgbm90IGhpamFja2VkXHJcbiAgICAgICAgaWYgKG9iICYmICFvYi5zaGFsbG93ICYmIG9iLm1vY2spIHtcclxuICAgICAgICAgICAgb2JzZXJ2ZSh2YWwsIGZhbHNlLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbDtcclxuICAgIH1cclxuICAgIGlmIChrZXkgaW4gdGFyZ2V0ICYmICEoa2V5IGluIE9iamVjdC5wcm90b3R5cGUpKSB7XHJcbiAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWw7XHJcbiAgICAgICAgcmV0dXJuIHZhbDtcclxuICAgIH1cclxuICAgIGlmICh0YXJnZXQuX2lzVnVlIHx8IChvYiAmJiBvYi52bUNvdW50KSkge1xyXG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcclxuICAgICAgICAgICAgd2FybiQyKCdBdm9pZCBhZGRpbmcgcmVhY3RpdmUgcHJvcGVydGllcyB0byBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcclxuICAgICAgICAgICAgICAgICdhdCBydW50aW1lIC0gZGVjbGFyZSBpdCB1cGZyb250IGluIHRoZSBkYXRhIG9wdGlvbi4nKTtcclxuICAgICAgICByZXR1cm4gdmFsO1xyXG4gICAgfVxyXG4gICAgaWYgKCFvYikge1xyXG4gICAgICAgIHRhcmdldFtrZXldID0gdmFsO1xyXG4gICAgICAgIHJldHVybiB2YWw7XHJcbiAgICB9XHJcbiAgICBkZWZpbmVSZWFjdGl2ZShvYi52YWx1ZSwga2V5LCB2YWwsIHVuZGVmaW5lZCwgb2Iuc2hhbGxvdywgb2IubW9jayk7XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgIG9iLmRlcC5ub3RpZnkoe1xyXG4gICAgICAgICAgICB0eXBlOiBcImFkZFwiIC8qIFRyaWdnZXJPcFR5cGVzLkFERCAqLyxcclxuICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXHJcbiAgICAgICAgICAgIGtleToga2V5LFxyXG4gICAgICAgICAgICBuZXdWYWx1ZTogdmFsLFxyXG4gICAgICAgICAgICBvbGRWYWx1ZTogdW5kZWZpbmVkXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBvYi5kZXAubm90aWZ5KCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsO1xyXG59XHJcbmZ1bmN0aW9uIGRlbCh0YXJnZXQsIGtleSkge1xyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgKGlzVW5kZWYodGFyZ2V0KSB8fCBpc1ByaW1pdGl2ZSh0YXJnZXQpKSkge1xyXG4gICAgICAgIHdhcm4kMihcIkNhbm5vdCBkZWxldGUgcmVhY3RpdmUgcHJvcGVydHkgb24gdW5kZWZpbmVkLCBudWxsLCBvciBwcmltaXRpdmUgdmFsdWU6IFwiLmNvbmNhdCh0YXJnZXQpKTtcclxuICAgIH1cclxuICAgIGlmIChpc0FycmF5KHRhcmdldCkgJiYgaXNWYWxpZEFycmF5SW5kZXgoa2V5KSkge1xyXG4gICAgICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB2YXIgb2IgPSB0YXJnZXQuX19vYl9fO1xyXG4gICAgaWYgKHRhcmdldC5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XHJcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxyXG4gICAgICAgICAgICB3YXJuJDIoJ0F2b2lkIGRlbGV0aW5nIHByb3BlcnRpZXMgb24gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXHJcbiAgICAgICAgICAgICAgICAnLSBqdXN0IHNldCBpdCB0byBudWxsLicpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmIChpc1JlYWRvbmx5KHRhcmdldCkpIHtcclxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXHJcbiAgICAgICAgICAgIHdhcm4kMihcIkRlbGV0ZSBvcGVyYXRpb24gb24ga2V5IFxcXCJcIi5jb25jYXQoa2V5LCBcIlxcXCIgZmFpbGVkOiB0YXJnZXQgaXMgcmVhZG9ubHkuXCIpKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoIWhhc093bih0YXJnZXQsIGtleSkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBkZWxldGUgdGFyZ2V0W2tleV07XHJcbiAgICBpZiAoIW9iKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICBvYi5kZXAubm90aWZ5KHtcclxuICAgICAgICAgICAgdHlwZTogXCJkZWxldGVcIiAvKiBUcmlnZ2VyT3BUeXBlcy5ERUxFVEUgKi8sXHJcbiAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxyXG4gICAgICAgICAgICBrZXk6IGtleVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgb2IuZGVwLm5vdGlmeSgpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDb2xsZWN0IGRlcGVuZGVuY2llcyBvbiBhcnJheSBlbGVtZW50cyB3aGVuIHRoZSBhcnJheSBpcyB0b3VjaGVkLCBzaW5jZVxyXG4gKiB3ZSBjYW5ub3QgaW50ZXJjZXB0IGFycmF5IGVsZW1lbnQgYWNjZXNzIGxpa2UgcHJvcGVydHkgZ2V0dGVycy5cclxuICovXHJcbmZ1bmN0aW9uIGRlcGVuZEFycmF5KHZhbHVlKSB7XHJcbiAgICBmb3IgKHZhciBlID0gdm9pZCAwLCBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIGUgPSB2YWx1ZVtpXTtcclxuICAgICAgICBpZiAoZSAmJiBlLl9fb2JfXykge1xyXG4gICAgICAgICAgICBlLl9fb2JfXy5kZXAuZGVwZW5kKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0FycmF5KGUpKSB7XHJcbiAgICAgICAgICAgIGRlcGVuZEFycmF5KGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5mdW5jdGlvbiByZWFjdGl2ZSh0YXJnZXQpIHtcclxuICAgIG1ha2VSZWFjdGl2ZSh0YXJnZXQsIGZhbHNlKTtcclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybiBhIHNoYWxsb3dseS1yZWFjdGl2ZSBjb3B5IG9mIHRoZSBvcmlnaW5hbCBvYmplY3QsIHdoZXJlIG9ubHkgdGhlIHJvb3RcclxuICogbGV2ZWwgcHJvcGVydGllcyBhcmUgcmVhY3RpdmUuIEl0IGFsc28gZG9lcyBub3QgYXV0by11bndyYXAgcmVmcyAoZXZlbiBhdCB0aGVcclxuICogcm9vdCBsZXZlbCkuXHJcbiAqL1xyXG5mdW5jdGlvbiBzaGFsbG93UmVhY3RpdmUodGFyZ2V0KSB7XHJcbiAgICBtYWtlUmVhY3RpdmUodGFyZ2V0LCB0cnVlKTtcclxuICAgIGRlZih0YXJnZXQsIFwiX192X2lzU2hhbGxvd1wiIC8qIFJlYWN0aXZlRmxhZ3MuSVNfU0hBTExPVyAqLywgdHJ1ZSk7XHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG59XHJcbmZ1bmN0aW9uIG1ha2VSZWFjdGl2ZSh0YXJnZXQsIHNoYWxsb3cpIHtcclxuICAgIC8vIGlmIHRyeWluZyB0byBvYnNlcnZlIGEgcmVhZG9ubHkgcHJveHksIHJldHVybiB0aGUgcmVhZG9ubHkgdmVyc2lvbi5cclxuICAgIGlmICghaXNSZWFkb25seSh0YXJnZXQpKSB7XHJcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgICAgaWYgKGlzQXJyYXkodGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgd2FybiQyKFwiQXZvaWQgdXNpbmcgQXJyYXkgYXMgcm9vdCB2YWx1ZSBmb3IgXCIuY29uY2F0KHNoYWxsb3cgPyBcInNoYWxsb3dSZWFjdGl2ZSgpXCIgOiBcInJlYWN0aXZlKClcIiwgXCIgYXMgaXQgY2Fubm90IGJlIHRyYWNrZWQgaW4gd2F0Y2goKSBvciB3YXRjaEVmZmVjdCgpLiBVc2UgXCIpLmNvbmNhdChzaGFsbG93ID8gXCJzaGFsbG93UmVmKClcIiA6IFwicmVmKClcIiwgXCIgaW5zdGVhZC4gVGhpcyBpcyBhIFZ1ZS0yLW9ubHkgbGltaXRhdGlvbi5cIikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBleGlzdGluZ09iID0gdGFyZ2V0ICYmIHRhcmdldC5fX29iX187XHJcbiAgICAgICAgICAgIGlmIChleGlzdGluZ09iICYmIGV4aXN0aW5nT2Iuc2hhbGxvdyAhPT0gc2hhbGxvdykge1xyXG4gICAgICAgICAgICAgICAgd2FybiQyKFwiVGFyZ2V0IGlzIGFscmVhZHkgYSBcIi5jb25jYXQoZXhpc3RpbmdPYi5zaGFsbG93ID8gXCJcIiA6IFwibm9uLVwiLCBcInNoYWxsb3cgcmVhY3RpdmUgb2JqZWN0LCBhbmQgY2Fubm90IGJlIGNvbnZlcnRlZCB0byBcIikuY29uY2F0KHNoYWxsb3cgPyBcIlwiIDogXCJub24tXCIsIFwic2hhbGxvdy5cIikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvYiA9IG9ic2VydmUodGFyZ2V0LCBzaGFsbG93LCBpc1NlcnZlclJlbmRlcmluZygpIC8qIHNzciBtb2NrIHJlYWN0aXZpdHkgKi8pO1xyXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFvYikge1xyXG4gICAgICAgICAgICBpZiAodGFyZ2V0ID09IG51bGwgfHwgaXNQcmltaXRpdmUodGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgd2FybiQyKFwidmFsdWUgY2Fubm90IGJlIG1hZGUgcmVhY3RpdmU6IFwiLmNvbmNhdChTdHJpbmcodGFyZ2V0KSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpc0NvbGxlY3Rpb25UeXBlKHRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4kMihcIlZ1ZSAyIGRvZXMgbm90IHN1cHBvcnQgcmVhY3RpdmUgY29sbGVjdGlvbiB0eXBlcyBzdWNoIGFzIE1hcCBvciBTZXQuXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGlzUmVhY3RpdmUodmFsdWUpIHtcclxuICAgIGlmIChpc1JlYWRvbmx5KHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiBpc1JlYWN0aXZlKHZhbHVlW1wiX192X3Jhd1wiIC8qIFJlYWN0aXZlRmxhZ3MuUkFXICovXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX19vYl9fKTtcclxufVxyXG5mdW5jdGlvbiBpc1NoYWxsb3codmFsdWUpIHtcclxuICAgIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5fX3ZfaXNTaGFsbG93KTtcclxufVxyXG5mdW5jdGlvbiBpc1JlYWRvbmx5KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX192X2lzUmVhZG9ubHkpO1xyXG59XHJcbmZ1bmN0aW9uIGlzUHJveHkodmFsdWUpIHtcclxuICAgIHJldHVybiBpc1JlYWN0aXZlKHZhbHVlKSB8fCBpc1JlYWRvbmx5KHZhbHVlKTtcclxufVxyXG5mdW5jdGlvbiB0b1JhdyhvYnNlcnZlZCkge1xyXG4gICAgdmFyIHJhdyA9IG9ic2VydmVkICYmIG9ic2VydmVkW1wiX192X3Jhd1wiIC8qIFJlYWN0aXZlRmxhZ3MuUkFXICovXTtcclxuICAgIHJldHVybiByYXcgPyB0b1JhdyhyYXcpIDogb2JzZXJ2ZWQ7XHJcbn1cclxuZnVuY3Rpb24gbWFya1Jhdyh2YWx1ZSkge1xyXG4gICAgZGVmKHZhbHVlLCBcIl9fdl9za2lwXCIgLyogUmVhY3RpdmVGbGFncy5TS0lQICovLCB0cnVlKTtcclxuICAgIHJldHVybiB2YWx1ZTtcclxufVxyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0NvbGxlY3Rpb25UeXBlKHZhbHVlKSB7XHJcbiAgICB2YXIgdHlwZSA9IHRvUmF3VHlwZSh2YWx1ZSk7XHJcbiAgICByZXR1cm4gKHR5cGUgPT09ICdNYXAnIHx8IHR5cGUgPT09ICdXZWFrTWFwJyB8fCB0eXBlID09PSAnU2V0JyB8fCB0eXBlID09PSAnV2Vha1NldCcpO1xyXG59XG5cbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbnZhciBSZWZGbGFnID0gXCJfX3ZfaXNSZWZcIjtcclxuZnVuY3Rpb24gaXNSZWYocikge1xyXG4gICAgcmV0dXJuICEhKHIgJiYgci5fX3ZfaXNSZWYgPT09IHRydWUpO1xyXG59XHJcbmZ1bmN0aW9uIHJlZiQxKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gY3JlYXRlUmVmKHZhbHVlLCBmYWxzZSk7XHJcbn1cclxuZnVuY3Rpb24gc2hhbGxvd1JlZih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIGNyZWF0ZVJlZih2YWx1ZSwgdHJ1ZSk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlUmVmKHJhd1ZhbHVlLCBzaGFsbG93KSB7XHJcbiAgICBpZiAoaXNSZWYocmF3VmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIHJhd1ZhbHVlO1xyXG4gICAgfVxyXG4gICAgdmFyIHJlZiA9IHt9O1xyXG4gICAgZGVmKHJlZiwgUmVmRmxhZywgdHJ1ZSk7XHJcbiAgICBkZWYocmVmLCBcIl9fdl9pc1NoYWxsb3dcIiAvKiBSZWFjdGl2ZUZsYWdzLklTX1NIQUxMT1cgKi8sIHNoYWxsb3cpO1xyXG4gICAgZGVmKHJlZiwgJ2RlcCcsIGRlZmluZVJlYWN0aXZlKHJlZiwgJ3ZhbHVlJywgcmF3VmFsdWUsIG51bGwsIHNoYWxsb3csIGlzU2VydmVyUmVuZGVyaW5nKCkpKTtcclxuICAgIHJldHVybiByZWY7XHJcbn1cclxuZnVuY3Rpb24gdHJpZ2dlclJlZihyZWYpIHtcclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFyZWYuZGVwKSB7XHJcbiAgICAgICAgd2FybiQyKFwicmVjZWl2ZWQgb2JqZWN0IGlzIG5vdCBhIHRyaWdnZXJhYmxlIHJlZi5cIik7XHJcbiAgICB9XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgIHJlZi5kZXAgJiZcclxuICAgICAgICAgICAgcmVmLmRlcC5ub3RpZnkoe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJzZXRcIiAvKiBUcmlnZ2VyT3BUeXBlcy5TRVQgKi8sXHJcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHJlZixcclxuICAgICAgICAgICAgICAgIGtleTogJ3ZhbHVlJ1xyXG4gICAgICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJlZi5kZXAgJiYgcmVmLmRlcC5ub3RpZnkoKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB1bnJlZihyZWYpIHtcclxuICAgIHJldHVybiBpc1JlZihyZWYpID8gcmVmLnZhbHVlIDogcmVmO1xyXG59XHJcbmZ1bmN0aW9uIHByb3h5UmVmcyhvYmplY3RXaXRoUmVmcykge1xyXG4gICAgaWYgKGlzUmVhY3RpdmUob2JqZWN0V2l0aFJlZnMpKSB7XHJcbiAgICAgICAgcmV0dXJuIG9iamVjdFdpdGhSZWZzO1xyXG4gICAgfVxyXG4gICAgdmFyIHByb3h5ID0ge307XHJcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdFdpdGhSZWZzKTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHByb3h5V2l0aFJlZlVud3JhcChwcm94eSwgb2JqZWN0V2l0aFJlZnMsIGtleXNbaV0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByb3h5O1xyXG59XHJcbmZ1bmN0aW9uIHByb3h5V2l0aFJlZlVud3JhcCh0YXJnZXQsIHNvdXJjZSwga2V5KSB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHtcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHZhbCA9IHNvdXJjZVtrZXldO1xyXG4gICAgICAgICAgICBpZiAoaXNSZWYodmFsKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbC52YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBvYiA9IHZhbCAmJiB2YWwuX19vYl9fO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9iKVxyXG4gICAgICAgICAgICAgICAgICAgIG9iLmRlcC5kZXBlbmQoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciBvbGRWYWx1ZSA9IHNvdXJjZVtrZXldO1xyXG4gICAgICAgICAgICBpZiAoaXNSZWYob2xkVmFsdWUpICYmICFpc1JlZih2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIG9sZFZhbHVlLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzb3VyY2Vba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gY3VzdG9tUmVmKGZhY3RvcnkpIHtcclxuICAgIHZhciBkZXAgPSBuZXcgRGVwKCk7XHJcbiAgICB2YXIgX2EgPSBmYWN0b3J5KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgICBkZXAuZGVwZW5kKHtcclxuICAgICAgICAgICAgICAgIHRhcmdldDogcmVmLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJnZXRcIiAvKiBUcmFja09wVHlwZXMuR0VUICovLFxyXG4gICAgICAgICAgICAgICAga2V5OiAndmFsdWUnXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZGVwLmRlcGVuZCgpO1xyXG4gICAgICAgIH1cclxuICAgIH0sIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgICBkZXAubm90aWZ5KHtcclxuICAgICAgICAgICAgICAgIHRhcmdldDogcmVmLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJzZXRcIiAvKiBUcmlnZ2VyT3BUeXBlcy5TRVQgKi8sXHJcbiAgICAgICAgICAgICAgICBrZXk6ICd2YWx1ZSdcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkZXAubm90aWZ5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSksIGdldCA9IF9hLmdldCwgc2V0ID0gX2Euc2V0O1xyXG4gICAgdmFyIHJlZiA9IHtcclxuICAgICAgICBnZXQgdmFsdWUoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnZXQoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldCB2YWx1ZShuZXdWYWwpIHtcclxuICAgICAgICAgICAgc2V0KG5ld1ZhbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGRlZihyZWYsIFJlZkZsYWcsIHRydWUpO1xyXG4gICAgcmV0dXJuIHJlZjtcclxufVxyXG5mdW5jdGlvbiB0b1JlZnMob2JqZWN0KSB7XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhaXNSZWFjdGl2ZShvYmplY3QpKSB7XHJcbiAgICAgICAgd2FybiQyKFwidG9SZWZzKCkgZXhwZWN0cyBhIHJlYWN0aXZlIG9iamVjdCBidXQgcmVjZWl2ZWQgYSBwbGFpbiBvbmUuXCIpO1xyXG4gICAgfVxyXG4gICAgdmFyIHJldCA9IGlzQXJyYXkob2JqZWN0KSA/IG5ldyBBcnJheShvYmplY3QubGVuZ3RoKSA6IHt9O1xyXG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xyXG4gICAgICAgIHJldFtrZXldID0gdG9SZWYob2JqZWN0LCBrZXkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJldDtcclxufVxyXG5mdW5jdGlvbiB0b1JlZihvYmplY3QsIGtleSwgZGVmYXVsdFZhbHVlKSB7XHJcbiAgICB2YXIgdmFsID0gb2JqZWN0W2tleV07XHJcbiAgICBpZiAoaXNSZWYodmFsKSkge1xyXG4gICAgICAgIHJldHVybiB2YWw7XHJcbiAgICB9XHJcbiAgICB2YXIgcmVmID0ge1xyXG4gICAgICAgIGdldCB2YWx1ZSgpIHtcclxuICAgICAgICAgICAgdmFyIHZhbCA9IG9iamVjdFtrZXldO1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsID09PSB1bmRlZmluZWQgPyBkZWZhdWx0VmFsdWUgOiB2YWw7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQgdmFsdWUobmV3VmFsKSB7XHJcbiAgICAgICAgICAgIG9iamVjdFtrZXldID0gbmV3VmFsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBkZWYocmVmLCBSZWZGbGFnLCB0cnVlKTtcclxuICAgIHJldHVybiByZWY7XHJcbn1cblxudmFyIHJhd1RvUmVhZG9ubHlGbGFnID0gXCJfX3ZfcmF3VG9SZWFkb25seVwiO1xyXG52YXIgcmF3VG9TaGFsbG93UmVhZG9ubHlGbGFnID0gXCJfX3ZfcmF3VG9TaGFsbG93UmVhZG9ubHlcIjtcclxuZnVuY3Rpb24gcmVhZG9ubHkodGFyZ2V0KSB7XHJcbiAgICByZXR1cm4gY3JlYXRlUmVhZG9ubHkodGFyZ2V0LCBmYWxzZSk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlUmVhZG9ubHkodGFyZ2V0LCBzaGFsbG93KSB7XHJcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QodGFyZ2V0KSkge1xyXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICAgIGlmIChpc0FycmF5KHRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4kMihcIlZ1ZSAyIGRvZXMgbm90IHN1cHBvcnQgcmVhZG9ubHkgYXJyYXlzLlwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc0NvbGxlY3Rpb25UeXBlKHRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4kMihcIlZ1ZSAyIGRvZXMgbm90IHN1cHBvcnQgcmVhZG9ubHkgY29sbGVjdGlvbiB0eXBlcyBzdWNoIGFzIE1hcCBvciBTZXQuXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgd2FybiQyKFwidmFsdWUgY2Fubm90IGJlIG1hZGUgcmVhZG9ubHk6IFwiLmNvbmNhdCh0eXBlb2YgdGFyZ2V0KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgIH1cclxuICAgIC8vIGFscmVhZHkgYSByZWFkb25seSBvYmplY3RcclxuICAgIGlmIChpc1JlYWRvbmx5KHRhcmdldCkpIHtcclxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgfVxyXG4gICAgLy8gYWxyZWFkeSBoYXMgYSByZWFkb25seSBwcm94eVxyXG4gICAgdmFyIGV4aXN0aW5nRmxhZyA9IHNoYWxsb3cgPyByYXdUb1NoYWxsb3dSZWFkb25seUZsYWcgOiByYXdUb1JlYWRvbmx5RmxhZztcclxuICAgIHZhciBleGlzdGluZ1Byb3h5ID0gdGFyZ2V0W2V4aXN0aW5nRmxhZ107XHJcbiAgICBpZiAoZXhpc3RpbmdQcm94eSkge1xyXG4gICAgICAgIHJldHVybiBleGlzdGluZ1Byb3h5O1xyXG4gICAgfVxyXG4gICAgdmFyIHByb3h5ID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0KSk7XHJcbiAgICBkZWYodGFyZ2V0LCBleGlzdGluZ0ZsYWcsIHByb3h5KTtcclxuICAgIGRlZihwcm94eSwgXCJfX3ZfaXNSZWFkb25seVwiIC8qIFJlYWN0aXZlRmxhZ3MuSVNfUkVBRE9OTFkgKi8sIHRydWUpO1xyXG4gICAgZGVmKHByb3h5LCBcIl9fdl9yYXdcIiAvKiBSZWFjdGl2ZUZsYWdzLlJBVyAqLywgdGFyZ2V0KTtcclxuICAgIGlmIChpc1JlZih0YXJnZXQpKSB7XHJcbiAgICAgICAgZGVmKHByb3h5LCBSZWZGbGFnLCB0cnVlKTtcclxuICAgIH1cclxuICAgIGlmIChzaGFsbG93IHx8IGlzU2hhbGxvdyh0YXJnZXQpKSB7XHJcbiAgICAgICAgZGVmKHByb3h5LCBcIl9fdl9pc1NoYWxsb3dcIiAvKiBSZWFjdGl2ZUZsYWdzLklTX1NIQUxMT1cgKi8sIHRydWUpO1xyXG4gICAgfVxyXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh0YXJnZXQpO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgZGVmaW5lUmVhZG9ubHlQcm9wZXJ0eShwcm94eSwgdGFyZ2V0LCBrZXlzW2ldLCBzaGFsbG93KTtcclxuICAgIH1cclxuICAgIHJldHVybiBwcm94eTtcclxufVxyXG5mdW5jdGlvbiBkZWZpbmVSZWFkb25seVByb3BlcnR5KHByb3h5LCB0YXJnZXQsIGtleSwgc2hhbGxvdykge1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3h5LCBrZXksIHtcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHZhbCA9IHRhcmdldFtrZXldO1xyXG4gICAgICAgICAgICByZXR1cm4gc2hhbGxvdyB8fCAhaXNQbGFpbk9iamVjdCh2YWwpID8gdmFsIDogcmVhZG9ubHkodmFsKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXHJcbiAgICAgICAgICAgICAgICB3YXJuJDIoXCJTZXQgb3BlcmF0aW9uIG9uIGtleSBcXFwiXCIuY29uY2F0KGtleSwgXCJcXFwiIGZhaWxlZDogdGFyZ2V0IGlzIHJlYWRvbmx5LlwiKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYSByZWFjdGl2ZS1jb3B5IG9mIHRoZSBvcmlnaW5hbCBvYmplY3QsIHdoZXJlIG9ubHkgdGhlIHJvb3QgbGV2ZWxcclxuICogcHJvcGVydGllcyBhcmUgcmVhZG9ubHksIGFuZCBkb2VzIE5PVCB1bndyYXAgcmVmcyBub3IgcmVjdXJzaXZlbHkgY29udmVydFxyXG4gKiByZXR1cm5lZCBwcm9wZXJ0aWVzLlxyXG4gKiBUaGlzIGlzIHVzZWQgZm9yIGNyZWF0aW5nIHRoZSBwcm9wcyBwcm94eSBvYmplY3QgZm9yIHN0YXRlZnVsIGNvbXBvbmVudHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBzaGFsbG93UmVhZG9ubHkodGFyZ2V0KSB7XHJcbiAgICByZXR1cm4gY3JlYXRlUmVhZG9ubHkodGFyZ2V0LCB0cnVlKTtcclxufVxuXG5mdW5jdGlvbiBjb21wdXRlZChnZXR0ZXJPck9wdGlvbnMsIGRlYnVnT3B0aW9ucykge1xyXG4gICAgdmFyIGdldHRlcjtcclxuICAgIHZhciBzZXR0ZXI7XHJcbiAgICB2YXIgb25seUdldHRlciA9IGlzRnVuY3Rpb24oZ2V0dGVyT3JPcHRpb25zKTtcclxuICAgIGlmIChvbmx5R2V0dGVyKSB7XHJcbiAgICAgICAgZ2V0dGVyID0gZ2V0dGVyT3JPcHRpb25zO1xyXG4gICAgICAgIHNldHRlciA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbidcclxuICAgICAgICAgICAgPyBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuJDIoJ1dyaXRlIG9wZXJhdGlvbiBmYWlsZWQ6IGNvbXB1dGVkIHZhbHVlIGlzIHJlYWRvbmx5Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgOiBub29wO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZ2V0dGVyID0gZ2V0dGVyT3JPcHRpb25zLmdldDtcclxuICAgICAgICBzZXR0ZXIgPSBnZXR0ZXJPck9wdGlvbnMuc2V0O1xyXG4gICAgfVxyXG4gICAgdmFyIHdhdGNoZXIgPSBpc1NlcnZlclJlbmRlcmluZygpXHJcbiAgICAgICAgPyBudWxsXHJcbiAgICAgICAgOiBuZXcgV2F0Y2hlcihjdXJyZW50SW5zdGFuY2UsIGdldHRlciwgbm9vcCwgeyBsYXp5OiB0cnVlIH0pO1xyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2F0Y2hlciAmJiBkZWJ1Z09wdGlvbnMpIHtcclxuICAgICAgICB3YXRjaGVyLm9uVHJhY2sgPSBkZWJ1Z09wdGlvbnMub25UcmFjaztcclxuICAgICAgICB3YXRjaGVyLm9uVHJpZ2dlciA9IGRlYnVnT3B0aW9ucy5vblRyaWdnZXI7XHJcbiAgICB9XHJcbiAgICB2YXIgcmVmID0ge1xyXG4gICAgICAgIC8vIHNvbWUgbGlicyByZWx5IG9uIHRoZSBwcmVzZW5jZSBlZmZlY3QgZm9yIGNoZWNraW5nIGNvbXB1dGVkIHJlZnNcclxuICAgICAgICAvLyBmcm9tIG5vcm1hbCByZWZzLCBidXQgdGhlIGltcGxlbWVudGF0aW9uIGRvZXNuJ3QgbWF0dGVyXHJcbiAgICAgICAgZWZmZWN0OiB3YXRjaGVyLFxyXG4gICAgICAgIGdldCB2YWx1ZSgpIHtcclxuICAgICAgICAgICAgaWYgKHdhdGNoZXIpIHtcclxuICAgICAgICAgICAgICAgIGlmICh3YXRjaGVyLmRpcnR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2F0Y2hlci5ldmFsdWF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKERlcC50YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBEZXAudGFyZ2V0Lm9uVHJhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgRGVwLnRhcmdldC5vblRyYWNrKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVmZmVjdDogRGVwLnRhcmdldCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogcmVmLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJnZXRcIiAvKiBUcmFja09wVHlwZXMuR0VUICovLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiAndmFsdWUnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB3YXRjaGVyLmRlcGVuZCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHdhdGNoZXIudmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0dGVyKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldCB2YWx1ZShuZXdWYWwpIHtcclxuICAgICAgICAgICAgc2V0dGVyKG5ld1ZhbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGRlZihyZWYsIFJlZkZsYWcsIHRydWUpO1xyXG4gICAgZGVmKHJlZiwgXCJfX3ZfaXNSZWFkb25seVwiIC8qIFJlYWN0aXZlRmxhZ3MuSVNfUkVBRE9OTFkgKi8sIG9ubHlHZXR0ZXIpO1xyXG4gICAgcmV0dXJuIHJlZjtcclxufVxuXG52YXIgbWFyaztcclxudmFyIG1lYXN1cmU7XHJcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICB2YXIgcGVyZl8xID0gaW5Ccm93c2VyICYmIHdpbmRvdy5wZXJmb3JtYW5jZTtcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKHBlcmZfMSAmJlxyXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICBwZXJmXzEubWFyayAmJlxyXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICBwZXJmXzEubWVhc3VyZSAmJlxyXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICBwZXJmXzEuY2xlYXJNYXJrcyAmJlxyXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICBwZXJmXzEuY2xlYXJNZWFzdXJlcykge1xyXG4gICAgICAgIG1hcmsgPSBmdW5jdGlvbiAodGFnKSB7IHJldHVybiBwZXJmXzEubWFyayh0YWcpOyB9O1xyXG4gICAgICAgIG1lYXN1cmUgPSBmdW5jdGlvbiAobmFtZSwgc3RhcnRUYWcsIGVuZFRhZykge1xyXG4gICAgICAgICAgICBwZXJmXzEubWVhc3VyZShuYW1lLCBzdGFydFRhZywgZW5kVGFnKTtcclxuICAgICAgICAgICAgcGVyZl8xLmNsZWFyTWFya3Moc3RhcnRUYWcpO1xyXG4gICAgICAgICAgICBwZXJmXzEuY2xlYXJNYXJrcyhlbmRUYWcpO1xyXG4gICAgICAgICAgICAvLyBwZXJmLmNsZWFyTWVhc3VyZXMobmFtZSlcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XG5cbnZhciBub3JtYWxpemVFdmVudCA9IGNhY2hlZChmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgdmFyIHBhc3NpdmUgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJyYnO1xyXG4gICAgbmFtZSA9IHBhc3NpdmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcclxuICAgIHZhciBvbmNlID0gbmFtZS5jaGFyQXQoMCkgPT09ICd+JzsgLy8gUHJlZml4ZWQgbGFzdCwgY2hlY2tlZCBmaXJzdFxyXG4gICAgbmFtZSA9IG9uY2UgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcclxuICAgIHZhciBjYXB0dXJlID0gbmFtZS5jaGFyQXQoMCkgPT09ICchJztcclxuICAgIG5hbWUgPSBjYXB0dXJlID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG5hbWU6IG5hbWUsXHJcbiAgICAgICAgb25jZTogb25jZSxcclxuICAgICAgICBjYXB0dXJlOiBjYXB0dXJlLFxyXG4gICAgICAgIHBhc3NpdmU6IHBhc3NpdmVcclxuICAgIH07XHJcbn0pO1xyXG5mdW5jdGlvbiBjcmVhdGVGbkludm9rZXIoZm5zLCB2bSkge1xyXG4gICAgZnVuY3Rpb24gaW52b2tlcigpIHtcclxuICAgICAgICB2YXIgZm5zID0gaW52b2tlci5mbnM7XHJcbiAgICAgICAgaWYgKGlzQXJyYXkoZm5zKSkge1xyXG4gICAgICAgICAgICB2YXIgY2xvbmVkID0gZm5zLnNsaWNlKCk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xvbmVkLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhjbG9uZWRbaV0sIG51bGwsIGFyZ3VtZW50cywgdm0sIFwidi1vbiBoYW5kbGVyXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyByZXR1cm4gaGFuZGxlciByZXR1cm4gdmFsdWUgZm9yIHNpbmdsZSBoYW5kbGVyc1xyXG4gICAgICAgICAgICByZXR1cm4gaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoZm5zLCBudWxsLCBhcmd1bWVudHMsIHZtLCBcInYtb24gaGFuZGxlclwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpbnZva2VyLmZucyA9IGZucztcclxuICAgIHJldHVybiBpbnZva2VyO1xyXG59XHJcbmZ1bmN0aW9uIHVwZGF0ZUxpc3RlbmVycyhvbiwgb2xkT24sIGFkZCwgcmVtb3ZlLCBjcmVhdGVPbmNlSGFuZGxlciwgdm0pIHtcclxuICAgIHZhciBuYW1lLCBjdXIsIG9sZCwgZXZlbnQ7XHJcbiAgICBmb3IgKG5hbWUgaW4gb24pIHtcclxuICAgICAgICBjdXIgPSBvbltuYW1lXTtcclxuICAgICAgICBvbGQgPSBvbGRPbltuYW1lXTtcclxuICAgICAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xyXG4gICAgICAgIGlmIChpc1VuZGVmKGN1cikpIHtcclxuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxyXG4gICAgICAgICAgICAgICAgd2FybiQyKFwiSW52YWxpZCBoYW5kbGVyIGZvciBldmVudCBcXFwiXCIuY29uY2F0KGV2ZW50Lm5hbWUsIFwiXFxcIjogZ290IFwiKSArIFN0cmluZyhjdXIpLCB2bSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzVW5kZWYob2xkKSkge1xyXG4gICAgICAgICAgICBpZiAoaXNVbmRlZihjdXIuZm5zKSkge1xyXG4gICAgICAgICAgICAgICAgY3VyID0gb25bbmFtZV0gPSBjcmVhdGVGbkludm9rZXIoY3VyLCB2bSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlzVHJ1ZShldmVudC5vbmNlKSkge1xyXG4gICAgICAgICAgICAgICAgY3VyID0gb25bbmFtZV0gPSBjcmVhdGVPbmNlSGFuZGxlcihldmVudC5uYW1lLCBjdXIsIGV2ZW50LmNhcHR1cmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFkZChldmVudC5uYW1lLCBjdXIsIGV2ZW50LmNhcHR1cmUsIGV2ZW50LnBhc3NpdmUsIGV2ZW50LnBhcmFtcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGN1ciAhPT0gb2xkKSB7XHJcbiAgICAgICAgICAgIG9sZC5mbnMgPSBjdXI7XHJcbiAgICAgICAgICAgIG9uW25hbWVdID0gb2xkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZvciAobmFtZSBpbiBvbGRPbikge1xyXG4gICAgICAgIGlmIChpc1VuZGVmKG9uW25hbWVdKSkge1xyXG4gICAgICAgICAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xyXG4gICAgICAgICAgICByZW1vdmUoZXZlbnQubmFtZSwgb2xkT25bbmFtZV0sIGV2ZW50LmNhcHR1cmUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5mdW5jdGlvbiBtZXJnZVZOb2RlSG9vayhkZWYsIGhvb2tLZXksIGhvb2spIHtcclxuICAgIGlmIChkZWYgaW5zdGFuY2VvZiBWTm9kZSkge1xyXG4gICAgICAgIGRlZiA9IGRlZi5kYXRhLmhvb2sgfHwgKGRlZi5kYXRhLmhvb2sgPSB7fSk7XHJcbiAgICB9XHJcbiAgICB2YXIgaW52b2tlcjtcclxuICAgIHZhciBvbGRIb29rID0gZGVmW2hvb2tLZXldO1xyXG4gICAgZnVuY3Rpb24gd3JhcHBlZEhvb2soKSB7XHJcbiAgICAgICAgaG9vay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIC8vIGltcG9ydGFudDogcmVtb3ZlIG1lcmdlZCBob29rIHRvIGVuc3VyZSBpdCdzIGNhbGxlZCBvbmx5IG9uY2VcclxuICAgICAgICAvLyBhbmQgcHJldmVudCBtZW1vcnkgbGVha1xyXG4gICAgICAgIHJlbW92ZSQyKGludm9rZXIuZm5zLCB3cmFwcGVkSG9vayk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNVbmRlZihvbGRIb29rKSkge1xyXG4gICAgICAgIC8vIG5vIGV4aXN0aW5nIGhvb2tcclxuICAgICAgICBpbnZva2VyID0gY3JlYXRlRm5JbnZva2VyKFt3cmFwcGVkSG9va10pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgaWYgKGlzRGVmKG9sZEhvb2suZm5zKSAmJiBpc1RydWUob2xkSG9vay5tZXJnZWQpKSB7XHJcbiAgICAgICAgICAgIC8vIGFscmVhZHkgYSBtZXJnZWQgaW52b2tlclxyXG4gICAgICAgICAgICBpbnZva2VyID0gb2xkSG9vaztcclxuICAgICAgICAgICAgaW52b2tlci5mbnMucHVzaCh3cmFwcGVkSG9vayk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBleGlzdGluZyBwbGFpbiBob29rXHJcbiAgICAgICAgICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW29sZEhvb2ssIHdyYXBwZWRIb29rXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaW52b2tlci5tZXJnZWQgPSB0cnVlO1xyXG4gICAgZGVmW2hvb2tLZXldID0gaW52b2tlcjtcclxufVxuXG5mdW5jdGlvbiBleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhKGRhdGEsIEN0b3IsIHRhZykge1xyXG4gICAgLy8gd2UgYXJlIG9ubHkgZXh0cmFjdGluZyByYXcgdmFsdWVzIGhlcmUuXHJcbiAgICAvLyB2YWxpZGF0aW9uIGFuZCBkZWZhdWx0IHZhbHVlcyBhcmUgaGFuZGxlZCBpbiB0aGUgY2hpbGRcclxuICAgIC8vIGNvbXBvbmVudCBpdHNlbGYuXHJcbiAgICB2YXIgcHJvcE9wdGlvbnMgPSBDdG9yLm9wdGlvbnMucHJvcHM7XHJcbiAgICBpZiAoaXNVbmRlZihwcm9wT3B0aW9ucykpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB2YXIgcmVzID0ge307XHJcbiAgICB2YXIgYXR0cnMgPSBkYXRhLmF0dHJzLCBwcm9wcyA9IGRhdGEucHJvcHM7XHJcbiAgICBpZiAoaXNEZWYoYXR0cnMpIHx8IGlzRGVmKHByb3BzKSkge1xyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wT3B0aW9ucykge1xyXG4gICAgICAgICAgICB2YXIgYWx0S2V5ID0gaHlwaGVuYXRlKGtleSk7XHJcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIga2V5SW5Mb3dlckNhc2UgPSBrZXkudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgICAgIGlmIChrZXkgIT09IGtleUluTG93ZXJDYXNlICYmIGF0dHJzICYmIGhhc093bihhdHRycywga2V5SW5Mb3dlckNhc2UpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGlwKFwiUHJvcCBcXFwiXCIuY29uY2F0KGtleUluTG93ZXJDYXNlLCBcIlxcXCIgaXMgcGFzc2VkIHRvIGNvbXBvbmVudCBcIikgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlwiLmNvbmNhdChmb3JtYXRDb21wb25lbnROYW1lKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHRhZyBpcyBzdHJpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnIHx8IEN0b3IpLCBcIiwgYnV0IHRoZSBkZWNsYXJlZCBwcm9wIG5hbWUgaXNcIikgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBcXFwiXCIuY29uY2F0KGtleSwgXCJcXFwiLiBcIikgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcIk5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIGNhbWVsQ2FzZWQgXCIgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcInByb3BzIG5lZWQgdG8gdXNlIHRoZWlyIGtlYmFiLWNhc2UgZXF1aXZhbGVudHMgd2hlbiB1c2luZyBpbi1ET00gXCIgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcInRlbXBsYXRlcy4gWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiLmNvbmNhdChhbHRLZXksIFwiXFxcIiBpbnN0ZWFkIG9mIFxcXCJcIikuY29uY2F0KGtleSwgXCJcXFwiLlwiKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2hlY2tQcm9wKHJlcywgcHJvcHMsIGtleSwgYWx0S2V5LCB0cnVlKSB8fFxyXG4gICAgICAgICAgICAgICAgY2hlY2tQcm9wKHJlcywgYXR0cnMsIGtleSwgYWx0S2V5LCBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG5mdW5jdGlvbiBjaGVja1Byb3AocmVzLCBoYXNoLCBrZXksIGFsdEtleSwgcHJlc2VydmUpIHtcclxuICAgIGlmIChpc0RlZihoYXNoKSkge1xyXG4gICAgICAgIGlmIChoYXNPd24oaGFzaCwga2V5KSkge1xyXG4gICAgICAgICAgICByZXNba2V5XSA9IGhhc2hba2V5XTtcclxuICAgICAgICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGhhc2hba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaGFzT3duKGhhc2gsIGFsdEtleSkpIHtcclxuICAgICAgICAgICAgcmVzW2tleV0gPSBoYXNoW2FsdEtleV07XHJcbiAgICAgICAgICAgIGlmICghcHJlc2VydmUpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBoYXNoW2FsdEtleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XG5cbi8vIFRoZSB0ZW1wbGF0ZSBjb21waWxlciBhdHRlbXB0cyB0byBtaW5pbWl6ZSB0aGUgbmVlZCBmb3Igbm9ybWFsaXphdGlvbiBieVxyXG4vLyBzdGF0aWNhbGx5IGFuYWx5emluZyB0aGUgdGVtcGxhdGUgYXQgY29tcGlsZSB0aW1lLlxyXG4vL1xyXG4vLyBGb3IgcGxhaW4gSFRNTCBtYXJrdXAsIG5vcm1hbGl6YXRpb24gY2FuIGJlIGNvbXBsZXRlbHkgc2tpcHBlZCBiZWNhdXNlIHRoZVxyXG4vLyBnZW5lcmF0ZWQgcmVuZGVyIGZ1bmN0aW9uIGlzIGd1YXJhbnRlZWQgdG8gcmV0dXJuIEFycmF5PFZOb2RlPi4gVGhlcmUgYXJlXHJcbi8vIHR3byBjYXNlcyB3aGVyZSBleHRyYSBub3JtYWxpemF0aW9uIGlzIG5lZWRlZDpcclxuLy8gMS4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29tcG9uZW50cyAtIGJlY2F1c2UgYSBmdW5jdGlvbmFsIGNvbXBvbmVudFxyXG4vLyBtYXkgcmV0dXJuIGFuIEFycmF5IGluc3RlYWQgb2YgYSBzaW5nbGUgcm9vdC4gSW4gdGhpcyBjYXNlLCBqdXN0IGEgc2ltcGxlXHJcbi8vIG5vcm1hbGl6YXRpb24gaXMgbmVlZGVkIC0gaWYgYW55IGNoaWxkIGlzIGFuIEFycmF5LCB3ZSBmbGF0dGVuIHRoZSB3aG9sZVxyXG4vLyB0aGluZyB3aXRoIEFycmF5LnByb3RvdHlwZS5jb25jYXQuIEl0IGlzIGd1YXJhbnRlZWQgdG8gYmUgb25seSAxLWxldmVsIGRlZXBcclxuLy8gYmVjYXVzZSBmdW5jdGlvbmFsIGNvbXBvbmVudHMgYWxyZWFkeSBub3JtYWxpemUgdGhlaXIgb3duIGNoaWxkcmVuLlxyXG5mdW5jdGlvbiBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbikge1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChpc0FycmF5KGNoaWxkcmVuW2ldKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgY2hpbGRyZW4pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBjaGlsZHJlbjtcclxufVxyXG4vLyAyLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb25zdHJ1Y3RzIHRoYXQgYWx3YXlzIGdlbmVyYXRlZCBuZXN0ZWQgQXJyYXlzLFxyXG4vLyBlLmcuIDx0ZW1wbGF0ZT4sIDxzbG90Piwgdi1mb3IsIG9yIHdoZW4gdGhlIGNoaWxkcmVuIGlzIHByb3ZpZGVkIGJ5IHVzZXJcclxuLy8gd2l0aCBoYW5kLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucyAvIEpTWC4gSW4gc3VjaCBjYXNlcyBhIGZ1bGwgbm9ybWFsaXphdGlvblxyXG4vLyBpcyBuZWVkZWQgdG8gY2F0ZXIgdG8gYWxsIHBvc3NpYmxlIHR5cGVzIG9mIGNoaWxkcmVuIHZhbHVlcy5cclxuZnVuY3Rpb24gbm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pIHtcclxuICAgIHJldHVybiBpc1ByaW1pdGl2ZShjaGlsZHJlbilcclxuICAgICAgICA/IFtjcmVhdGVUZXh0Vk5vZGUoY2hpbGRyZW4pXVxyXG4gICAgICAgIDogaXNBcnJheShjaGlsZHJlbilcclxuICAgICAgICAgICAgPyBub3JtYWxpemVBcnJheUNoaWxkcmVuKGNoaWxkcmVuKVxyXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcclxufVxyXG5mdW5jdGlvbiBpc1RleHROb2RlKG5vZGUpIHtcclxuICAgIHJldHVybiBpc0RlZihub2RlKSAmJiBpc0RlZihub2RlLnRleHQpICYmIGlzRmFsc2Uobm9kZS5pc0NvbW1lbnQpO1xyXG59XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4oY2hpbGRyZW4sIG5lc3RlZEluZGV4KSB7XHJcbiAgICB2YXIgcmVzID0gW107XHJcbiAgICB2YXIgaSwgYywgbGFzdEluZGV4LCBsYXN0O1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgYyA9IGNoaWxkcmVuW2ldO1xyXG4gICAgICAgIGlmIChpc1VuZGVmKGMpIHx8IHR5cGVvZiBjID09PSAnYm9vbGVhbicpXHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIGxhc3RJbmRleCA9IHJlcy5sZW5ndGggLSAxO1xyXG4gICAgICAgIGxhc3QgPSByZXNbbGFzdEluZGV4XTtcclxuICAgICAgICAvLyAgbmVzdGVkXHJcbiAgICAgICAgaWYgKGlzQXJyYXkoYykpIHtcclxuICAgICAgICAgICAgaWYgKGMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgYyA9IG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4oYywgXCJcIi5jb25jYXQobmVzdGVkSW5kZXggfHwgJycsIFwiX1wiKS5jb25jYXQoaSkpO1xyXG4gICAgICAgICAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzVGV4dE5vZGUoY1swXSkgJiYgaXNUZXh0Tm9kZShsYXN0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIGNbMF0udGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYy5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVzLnB1c2guYXBwbHkocmVzLCBjKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc1ByaW1pdGl2ZShjKSkge1xyXG4gICAgICAgICAgICBpZiAoaXNUZXh0Tm9kZShsYXN0KSkge1xyXG4gICAgICAgICAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xyXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIFNTUiBoeWRyYXRpb24gYmVjYXVzZSB0ZXh0IG5vZGVzIGFyZVxyXG4gICAgICAgICAgICAgICAgLy8gZXNzZW50aWFsbHkgbWVyZ2VkIHdoZW4gcmVuZGVyZWQgdG8gSFRNTCBzdHJpbmdzXHJcbiAgICAgICAgICAgICAgICByZXNbbGFzdEluZGV4XSA9IGNyZWF0ZVRleHRWTm9kZShsYXN0LnRleHQgKyBjKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjICE9PSAnJykge1xyXG4gICAgICAgICAgICAgICAgLy8gY29udmVydCBwcmltaXRpdmUgdG8gdm5vZGVcclxuICAgICAgICAgICAgICAgIHJlcy5wdXNoKGNyZWF0ZVRleHRWTm9kZShjKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChpc1RleHROb2RlKGMpICYmIGlzVGV4dE5vZGUobGFzdCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcclxuICAgICAgICAgICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIGMudGV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IGtleSBmb3IgbmVzdGVkIGFycmF5IGNoaWxkcmVuIChsaWtlbHkgZ2VuZXJhdGVkIGJ5IHYtZm9yKVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzVHJ1ZShjaGlsZHJlbi5faXNWTGlzdCkgJiZcclxuICAgICAgICAgICAgICAgICAgICBpc0RlZihjLnRhZykgJiZcclxuICAgICAgICAgICAgICAgICAgICBpc1VuZGVmKGMua2V5KSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGlzRGVmKG5lc3RlZEluZGV4KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGMua2V5ID0gXCJfX3ZsaXN0XCIuY29uY2F0KG5lc3RlZEluZGV4LCBcIl9cIikuY29uY2F0KGksIFwiX19cIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXMucHVzaChjKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXM7XHJcbn1cblxudmFyIFNJTVBMRV9OT1JNQUxJWkUgPSAxO1xyXG52YXIgQUxXQVlTX05PUk1BTElaRSA9IDI7XHJcbi8vIHdyYXBwZXIgZnVuY3Rpb24gZm9yIHByb3ZpZGluZyBhIG1vcmUgZmxleGlibGUgaW50ZXJmYWNlXHJcbi8vIHdpdGhvdXQgZ2V0dGluZyB5ZWxsZWQgYXQgYnkgZmxvd1xyXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50JDEoY29udGV4dCwgdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUsIGFsd2F5c05vcm1hbGl6ZSkge1xyXG4gICAgaWYgKGlzQXJyYXkoZGF0YSkgfHwgaXNQcmltaXRpdmUoZGF0YSkpIHtcclxuICAgICAgICBub3JtYWxpemF0aW9uVHlwZSA9IGNoaWxkcmVuO1xyXG4gICAgICAgIGNoaWxkcmVuID0gZGF0YTtcclxuICAgICAgICBkYXRhID0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzVHJ1ZShhbHdheXNOb3JtYWxpemUpKSB7XHJcbiAgICAgICAgbm9ybWFsaXphdGlvblR5cGUgPSBBTFdBWVNfTk9STUFMSVpFO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9jcmVhdGVFbGVtZW50KGNvbnRleHQsIHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlKTtcclxufVxyXG5mdW5jdGlvbiBfY3JlYXRlRWxlbWVudChjb250ZXh0LCB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSkge1xyXG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEuX19vYl9fKSkge1xyXG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcclxuICAgICAgICAgICAgd2FybiQyKFwiQXZvaWQgdXNpbmcgb2JzZXJ2ZWQgZGF0YSBvYmplY3QgYXMgdm5vZGUgZGF0YTogXCIuY29uY2F0KEpTT04uc3RyaW5naWZ5KGRhdGEpLCBcIlxcblwiKSArICdBbHdheXMgY3JlYXRlIGZyZXNoIHZub2RlIGRhdGEgb2JqZWN0cyBpbiBlYWNoIHJlbmRlciEnLCBjb250ZXh0KTtcclxuICAgICAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpO1xyXG4gICAgfVxyXG4gICAgLy8gb2JqZWN0IHN5bnRheCBpbiB2LWJpbmRcclxuICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZihkYXRhLmlzKSkge1xyXG4gICAgICAgIHRhZyA9IGRhdGEuaXM7XHJcbiAgICB9XHJcbiAgICBpZiAoIXRhZykge1xyXG4gICAgICAgIC8vIGluIGNhc2Ugb2YgY29tcG9uZW50IDppcyBzZXQgdG8gZmFsc3kgdmFsdWVcclxuICAgICAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpO1xyXG4gICAgfVxyXG4gICAgLy8gd2FybiBhZ2FpbnN0IG5vbi1wcmltaXRpdmUga2V5XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc0RlZihkYXRhKSAmJiBpc0RlZihkYXRhLmtleSkgJiYgIWlzUHJpbWl0aXZlKGRhdGEua2V5KSkge1xyXG4gICAgICAgIHdhcm4kMignQXZvaWQgdXNpbmcgbm9uLXByaW1pdGl2ZSB2YWx1ZSBhcyBrZXksICcgK1xyXG4gICAgICAgICAgICAndXNlIHN0cmluZy9udW1iZXIgdmFsdWUgaW5zdGVhZC4nLCBjb250ZXh0KTtcclxuICAgIH1cclxuICAgIC8vIHN1cHBvcnQgc2luZ2xlIGZ1bmN0aW9uIGNoaWxkcmVuIGFzIGRlZmF1bHQgc2NvcGVkIHNsb3RcclxuICAgIGlmIChpc0FycmF5KGNoaWxkcmVuKSAmJiBpc0Z1bmN0aW9uKGNoaWxkcmVuWzBdKSkge1xyXG4gICAgICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xyXG4gICAgICAgIGRhdGEuc2NvcGVkU2xvdHMgPSB7IGRlZmF1bHQ6IGNoaWxkcmVuWzBdIH07XHJcbiAgICAgICAgY2hpbGRyZW4ubGVuZ3RoID0gMDtcclxuICAgIH1cclxuICAgIGlmIChub3JtYWxpemF0aW9uVHlwZSA9PT0gQUxXQVlTX05PUk1BTElaRSkge1xyXG4gICAgICAgIGNoaWxkcmVuID0gbm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IFNJTVBMRV9OT1JNQUxJWkUpIHtcclxuICAgICAgICBjaGlsZHJlbiA9IHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcclxuICAgIH1cclxuICAgIHZhciB2bm9kZSwgbnM7XHJcbiAgICBpZiAodHlwZW9mIHRhZyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICB2YXIgQ3RvciA9IHZvaWQgMDtcclxuICAgICAgICBucyA9IChjb250ZXh0LiR2bm9kZSAmJiBjb250ZXh0LiR2bm9kZS5ucykgfHwgY29uZmlnLmdldFRhZ05hbWVzcGFjZSh0YWcpO1xyXG4gICAgICAgIGlmIChjb25maWcuaXNSZXNlcnZlZFRhZyh0YWcpKSB7XHJcbiAgICAgICAgICAgIC8vIHBsYXRmb3JtIGJ1aWx0LWluIGVsZW1lbnRzXHJcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXHJcbiAgICAgICAgICAgICAgICBpc0RlZihkYXRhKSAmJlxyXG4gICAgICAgICAgICAgICAgaXNEZWYoZGF0YS5uYXRpdmVPbikgJiZcclxuICAgICAgICAgICAgICAgIGRhdGEudGFnICE9PSAnY29tcG9uZW50Jykge1xyXG4gICAgICAgICAgICAgICAgd2FybiQyKFwiVGhlIC5uYXRpdmUgbW9kaWZpZXIgZm9yIHYtb24gaXMgb25seSB2YWxpZCBvbiBjb21wb25lbnRzIGJ1dCBpdCB3YXMgdXNlZCBvbiA8XCIuY29uY2F0KHRhZywgXCI+LlwiKSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoY29uZmlnLnBhcnNlUGxhdGZvcm1UYWdOYW1lKHRhZyksIGRhdGEsIGNoaWxkcmVuLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCghZGF0YSB8fCAhZGF0YS5wcmUpICYmXHJcbiAgICAgICAgICAgIGlzRGVmKChDdG9yID0gcmVzb2x2ZUFzc2V0KGNvbnRleHQuJG9wdGlvbnMsICdjb21wb25lbnRzJywgdGFnKSkpKSB7XHJcbiAgICAgICAgICAgIC8vIGNvbXBvbmVudFxyXG4gICAgICAgICAgICB2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudChDdG9yLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbiwgdGFnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHVua25vd24gb3IgdW5saXN0ZWQgbmFtZXNwYWNlZCBlbGVtZW50c1xyXG4gICAgICAgICAgICAvLyBjaGVjayBhdCBydW50aW1lIGJlY2F1c2UgaXQgbWF5IGdldCBhc3NpZ25lZCBhIG5hbWVzcGFjZSB3aGVuIGl0c1xyXG4gICAgICAgICAgICAvLyBwYXJlbnQgbm9ybWFsaXplcyBjaGlsZHJlblxyXG4gICAgICAgICAgICB2bm9kZSA9IG5ldyBWTm9kZSh0YWcsIGRhdGEsIGNoaWxkcmVuLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gZGlyZWN0IGNvbXBvbmVudCBvcHRpb25zIC8gY29uc3RydWN0b3JcclxuICAgICAgICB2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudCh0YWcsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKTtcclxuICAgIH1cclxuICAgIGlmIChpc0FycmF5KHZub2RlKSkge1xyXG4gICAgICAgIHJldHVybiB2bm9kZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzRGVmKHZub2RlKSkge1xyXG4gICAgICAgIGlmIChpc0RlZihucykpXHJcbiAgICAgICAgICAgIGFwcGx5TlModm5vZGUsIG5zKTtcclxuICAgICAgICBpZiAoaXNEZWYoZGF0YSkpXHJcbiAgICAgICAgICAgIHJlZ2lzdGVyRGVlcEJpbmRpbmdzKGRhdGEpO1xyXG4gICAgICAgIHJldHVybiB2bm9kZTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gYXBwbHlOUyh2bm9kZSwgbnMsIGZvcmNlKSB7XHJcbiAgICB2bm9kZS5ucyA9IG5zO1xyXG4gICAgaWYgKHZub2RlLnRhZyA9PT0gJ2ZvcmVpZ25PYmplY3QnKSB7XHJcbiAgICAgICAgLy8gdXNlIGRlZmF1bHQgbmFtZXNwYWNlIGluc2lkZSBmb3JlaWduT2JqZWN0XHJcbiAgICAgICAgbnMgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgZm9yY2UgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzRGVmKHZub2RlLmNoaWxkcmVuKSkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IHZub2RlLmNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICBpZiAoaXNEZWYoY2hpbGQudGFnKSAmJlxyXG4gICAgICAgICAgICAgICAgKGlzVW5kZWYoY2hpbGQubnMpIHx8IChpc1RydWUoZm9yY2UpICYmIGNoaWxkLnRhZyAhPT0gJ3N2ZycpKSkge1xyXG4gICAgICAgICAgICAgICAgYXBwbHlOUyhjaGlsZCwgbnMsIGZvcmNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vLyByZWYgIzUzMThcclxuLy8gbmVjZXNzYXJ5IHRvIGVuc3VyZSBwYXJlbnQgcmUtcmVuZGVyIHdoZW4gZGVlcCBiaW5kaW5ncyBsaWtlIDpzdHlsZSBhbmRcclxuLy8gOmNsYXNzIGFyZSB1c2VkIG9uIHNsb3Qgbm9kZXNcclxuZnVuY3Rpb24gcmVnaXN0ZXJEZWVwQmluZGluZ3MoZGF0YSkge1xyXG4gICAgaWYgKGlzT2JqZWN0KGRhdGEuc3R5bGUpKSB7XHJcbiAgICAgICAgdHJhdmVyc2UoZGF0YS5zdHlsZSk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNPYmplY3QoZGF0YS5jbGFzcykpIHtcclxuICAgICAgICB0cmF2ZXJzZShkYXRhLmNsYXNzKTtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyB2LWZvciBsaXN0cy5cclxuICovXHJcbmZ1bmN0aW9uIHJlbmRlckxpc3QodmFsLCByZW5kZXIpIHtcclxuICAgIHZhciByZXQgPSBudWxsLCBpLCBsLCBrZXlzLCBrZXk7XHJcbiAgICBpZiAoaXNBcnJheSh2YWwpIHx8IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgcmV0ID0gbmV3IEFycmF5KHZhbC5sZW5ndGgpO1xyXG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSB2YWwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxbaV0sIGkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgcmV0ID0gbmV3IEFycmF5KHZhbCk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHZhbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHJldFtpXSA9IHJlbmRlcihpICsgMSwgaSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNPYmplY3QodmFsKSkge1xyXG4gICAgICAgIGlmIChoYXNTeW1ib2wgJiYgdmFsW1N5bWJvbC5pdGVyYXRvcl0pIHtcclxuICAgICAgICAgICAgcmV0ID0gW107XHJcbiAgICAgICAgICAgIHZhciBpdGVyYXRvciA9IHZhbFtTeW1ib2wuaXRlcmF0b3JdKCk7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XHJcbiAgICAgICAgICAgIHdoaWxlICghcmVzdWx0LmRvbmUpIHtcclxuICAgICAgICAgICAgICAgIHJldC5wdXNoKHJlbmRlcihyZXN1bHQudmFsdWUsIHJldC5sZW5ndGgpKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XHJcbiAgICAgICAgICAgIHJldCA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAga2V5ID0ga2V5c1tpXTtcclxuICAgICAgICAgICAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxba2V5XSwga2V5LCBpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghaXNEZWYocmV0KSkge1xyXG4gICAgICAgIHJldCA9IFtdO1xyXG4gICAgfVxyXG4gICAgcmV0Ll9pc1ZMaXN0ID0gdHJ1ZTtcclxuICAgIHJldHVybiByZXQ7XHJcbn1cblxuLyoqXHJcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgPHNsb3Q+XHJcbiAqL1xyXG5mdW5jdGlvbiByZW5kZXJTbG90KG5hbWUsIGZhbGxiYWNrUmVuZGVyLCBwcm9wcywgYmluZE9iamVjdCkge1xyXG4gICAgdmFyIHNjb3BlZFNsb3RGbiA9IHRoaXMuJHNjb3BlZFNsb3RzW25hbWVdO1xyXG4gICAgdmFyIG5vZGVzO1xyXG4gICAgaWYgKHNjb3BlZFNsb3RGbikge1xyXG4gICAgICAgIC8vIHNjb3BlZCBzbG90XHJcbiAgICAgICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcclxuICAgICAgICBpZiAoYmluZE9iamVjdCkge1xyXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhaXNPYmplY3QoYmluZE9iamVjdCkpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4kMignc2xvdCB2LWJpbmQgd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCcsIHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHByb3BzID0gZXh0ZW5kKGV4dGVuZCh7fSwgYmluZE9iamVjdCksIHByb3BzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbm9kZXMgPVxyXG4gICAgICAgICAgICBzY29wZWRTbG90Rm4ocHJvcHMpIHx8XHJcbiAgICAgICAgICAgICAgICAoaXNGdW5jdGlvbihmYWxsYmFja1JlbmRlcikgPyBmYWxsYmFja1JlbmRlcigpIDogZmFsbGJhY2tSZW5kZXIpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgbm9kZXMgPVxyXG4gICAgICAgICAgICB0aGlzLiRzbG90c1tuYW1lXSB8fFxyXG4gICAgICAgICAgICAgICAgKGlzRnVuY3Rpb24oZmFsbGJhY2tSZW5kZXIpID8gZmFsbGJhY2tSZW5kZXIoKSA6IGZhbGxiYWNrUmVuZGVyKTtcclxuICAgIH1cclxuICAgIHZhciB0YXJnZXQgPSBwcm9wcyAmJiBwcm9wcy5zbG90O1xyXG4gICAgaWYgKHRhcmdldCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScsIHsgc2xvdDogdGFyZ2V0IH0sIG5vZGVzKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBub2RlcztcclxuICAgIH1cclxufVxuXG4vKipcclxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlc29sdmluZyBmaWx0ZXJzXHJcbiAqL1xyXG5mdW5jdGlvbiByZXNvbHZlRmlsdGVyKGlkKSB7XHJcbiAgICByZXR1cm4gcmVzb2x2ZUFzc2V0KHRoaXMuJG9wdGlvbnMsICdmaWx0ZXJzJywgaWQsIHRydWUpIHx8IGlkZW50aXR5O1xyXG59XG5cbmZ1bmN0aW9uIGlzS2V5Tm90TWF0Y2goZXhwZWN0LCBhY3R1YWwpIHtcclxuICAgIGlmIChpc0FycmF5KGV4cGVjdCkpIHtcclxuICAgICAgICByZXR1cm4gZXhwZWN0LmluZGV4T2YoYWN0dWFsKSA9PT0gLTE7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gZXhwZWN0ICE9PSBhY3R1YWw7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciBjaGVja2luZyBrZXlDb2RlcyBmcm9tIGNvbmZpZy5cclxuICogZXhwb3NlZCBhcyBWdWUucHJvdG90eXBlLl9rXHJcbiAqIHBhc3NpbmcgaW4gZXZlbnRLZXlOYW1lIGFzIGxhc3QgYXJndW1lbnQgc2VwYXJhdGVseSBmb3IgYmFja3dhcmRzIGNvbXBhdFxyXG4gKi9cclxuZnVuY3Rpb24gY2hlY2tLZXlDb2RlcyhldmVudEtleUNvZGUsIGtleSwgYnVpbHRJbktleUNvZGUsIGV2ZW50S2V5TmFtZSwgYnVpbHRJbktleU5hbWUpIHtcclxuICAgIHZhciBtYXBwZWRLZXlDb2RlID0gY29uZmlnLmtleUNvZGVzW2tleV0gfHwgYnVpbHRJbktleUNvZGU7XHJcbiAgICBpZiAoYnVpbHRJbktleU5hbWUgJiYgZXZlbnRLZXlOYW1lICYmICFjb25maWcua2V5Q29kZXNba2V5XSkge1xyXG4gICAgICAgIHJldHVybiBpc0tleU5vdE1hdGNoKGJ1aWx0SW5LZXlOYW1lLCBldmVudEtleU5hbWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobWFwcGVkS2V5Q29kZSkge1xyXG4gICAgICAgIHJldHVybiBpc0tleU5vdE1hdGNoKG1hcHBlZEtleUNvZGUsIGV2ZW50S2V5Q29kZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChldmVudEtleU5hbWUpIHtcclxuICAgICAgICByZXR1cm4gaHlwaGVuYXRlKGV2ZW50S2V5TmFtZSkgIT09IGtleTtcclxuICAgIH1cclxuICAgIHJldHVybiBldmVudEtleUNvZGUgPT09IHVuZGVmaW5lZDtcclxufVxuXG4vKipcclxuICogUnVudGltZSBoZWxwZXIgZm9yIG1lcmdpbmcgdi1iaW5kPVwib2JqZWN0XCIgaW50byBhIFZOb2RlJ3MgZGF0YS5cclxuICovXHJcbmZ1bmN0aW9uIGJpbmRPYmplY3RQcm9wcyhkYXRhLCB0YWcsIHZhbHVlLCBhc1Byb3AsIGlzU3luYykge1xyXG4gICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxyXG4gICAgICAgICAgICAgICAgd2FybiQyKCd2LWJpbmQgd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCBvciBBcnJheSB2YWx1ZScsIHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRvT2JqZWN0KHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgaGFzaCA9IHZvaWQgMDtcclxuICAgICAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSAnY2xhc3MnIHx8IGtleSA9PT0gJ3N0eWxlJyB8fCBpc1Jlc2VydmVkQXR0cmlidXRlKGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBoYXNoID0gZGF0YTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gZGF0YS5hdHRycyAmJiBkYXRhLmF0dHJzLnR5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzaCA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzUHJvcCB8fCBjb25maWcubXVzdFVzZVByb3AodGFnLCB0eXBlLCBrZXkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGRhdGEuZG9tUHJvcHMgfHwgKGRhdGEuZG9tUHJvcHMgPSB7fSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZGF0YS5hdHRycyB8fCAoZGF0YS5hdHRycyA9IHt9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBjYW1lbGl6ZWRLZXkgPSBjYW1lbGl6ZShrZXkpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGh5cGhlbmF0ZWRLZXkgPSBoeXBoZW5hdGUoa2V5KTtcclxuICAgICAgICAgICAgICAgIGlmICghKGNhbWVsaXplZEtleSBpbiBoYXNoKSAmJiAhKGh5cGhlbmF0ZWRLZXkgaW4gaGFzaCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBoYXNoW2tleV0gPSB2YWx1ZVtrZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1N5bmMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9uID0gZGF0YS5vbiB8fCAoZGF0YS5vbiA9IHt9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25bXCJ1cGRhdGU6XCIuY29uY2F0KGtleSldID0gZnVuY3Rpb24gKCRldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVba2V5XSA9ICRldmVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgX2xvb3BfMShrZXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRhdGE7XHJcbn1cblxuLyoqXHJcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgc3RhdGljIHRyZWVzLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVuZGVyU3RhdGljKGluZGV4LCBpc0luRm9yKSB7XHJcbiAgICB2YXIgY2FjaGVkID0gdGhpcy5fc3RhdGljVHJlZXMgfHwgKHRoaXMuX3N0YXRpY1RyZWVzID0gW10pO1xyXG4gICAgdmFyIHRyZWUgPSBjYWNoZWRbaW5kZXhdO1xyXG4gICAgLy8gaWYgaGFzIGFscmVhZHktcmVuZGVyZWQgc3RhdGljIHRyZWUgYW5kIG5vdCBpbnNpZGUgdi1mb3IsXHJcbiAgICAvLyB3ZSBjYW4gcmV1c2UgdGhlIHNhbWUgdHJlZS5cclxuICAgIGlmICh0cmVlICYmICFpc0luRm9yKSB7XHJcbiAgICAgICAgcmV0dXJuIHRyZWU7XHJcbiAgICB9XHJcbiAgICAvLyBvdGhlcndpc2UsIHJlbmRlciBhIGZyZXNoIHRyZWUuXHJcbiAgICB0cmVlID0gY2FjaGVkW2luZGV4XSA9IHRoaXMuJG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zW2luZGV4XS5jYWxsKHRoaXMuX3JlbmRlclByb3h5LCB0aGlzLl9jLCB0aGlzIC8vIGZvciByZW5kZXIgZm5zIGdlbmVyYXRlZCBmb3IgZnVuY3Rpb25hbCBjb21wb25lbnQgdGVtcGxhdGVzXHJcbiAgICApO1xyXG4gICAgbWFya1N0YXRpYyQxKHRyZWUsIFwiX19zdGF0aWNfX1wiLmNvbmNhdChpbmRleCksIGZhbHNlKTtcclxuICAgIHJldHVybiB0cmVlO1xyXG59XHJcbi8qKlxyXG4gKiBSdW50aW1lIGhlbHBlciBmb3Igdi1vbmNlLlxyXG4gKiBFZmZlY3RpdmVseSBpdCBtZWFucyBtYXJraW5nIHRoZSBub2RlIGFzIHN0YXRpYyB3aXRoIGEgdW5pcXVlIGtleS5cclxuICovXHJcbmZ1bmN0aW9uIG1hcmtPbmNlKHRyZWUsIGluZGV4LCBrZXkpIHtcclxuICAgIG1hcmtTdGF0aWMkMSh0cmVlLCBcIl9fb25jZV9fXCIuY29uY2F0KGluZGV4KS5jb25jYXQoa2V5ID8gXCJfXCIuY29uY2F0KGtleSkgOiBcIlwiKSwgdHJ1ZSk7XHJcbiAgICByZXR1cm4gdHJlZTtcclxufVxyXG5mdW5jdGlvbiBtYXJrU3RhdGljJDEodHJlZSwga2V5LCBpc09uY2UpIHtcclxuICAgIGlmIChpc0FycmF5KHRyZWUpKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0cmVlW2ldICYmIHR5cGVvZiB0cmVlW2ldICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgbWFya1N0YXRpY05vZGUodHJlZVtpXSwgXCJcIi5jb25jYXQoa2V5LCBcIl9cIikuY29uY2F0KGkpLCBpc09uY2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgbWFya1N0YXRpY05vZGUodHJlZSwga2V5LCBpc09uY2UpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIG1hcmtTdGF0aWNOb2RlKG5vZGUsIGtleSwgaXNPbmNlKSB7XHJcbiAgICBub2RlLmlzU3RhdGljID0gdHJ1ZTtcclxuICAgIG5vZGUua2V5ID0ga2V5O1xyXG4gICAgbm9kZS5pc09uY2UgPSBpc09uY2U7XHJcbn1cblxuZnVuY3Rpb24gYmluZE9iamVjdExpc3RlbmVycyhkYXRhLCB2YWx1ZSkge1xyXG4gICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKCFpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xyXG4gICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4kMigndi1vbiB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0IHZhbHVlJywgdGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgb24gPSAoZGF0YS5vbiA9IGRhdGEub24gPyBleHRlbmQoe30sIGRhdGEub24pIDoge30pO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBleGlzdGluZyA9IG9uW2tleV07XHJcbiAgICAgICAgICAgICAgICB2YXIgb3VycyA9IHZhbHVlW2tleV07XHJcbiAgICAgICAgICAgICAgICBvbltrZXldID0gZXhpc3RpbmcgPyBbXS5jb25jYXQoZXhpc3RpbmcsIG91cnMpIDogb3VycztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBkYXRhO1xyXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVTY29wZWRTbG90cyhmbnMsIHJlcywgXHJcbi8vIHRoZSBmb2xsb3dpbmcgYXJlIGFkZGVkIGluIDIuNlxyXG5oYXNEeW5hbWljS2V5cywgY29udGVudEhhc2hLZXkpIHtcclxuICAgIHJlcyA9IHJlcyB8fCB7ICRzdGFibGU6ICFoYXNEeW5hbWljS2V5cyB9O1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgc2xvdCA9IGZuc1tpXTtcclxuICAgICAgICBpZiAoaXNBcnJheShzbG90KSkge1xyXG4gICAgICAgICAgICByZXNvbHZlU2NvcGVkU2xvdHMoc2xvdCwgcmVzLCBoYXNEeW5hbWljS2V5cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHNsb3QpIHtcclxuICAgICAgICAgICAgLy8gbWFya2VyIGZvciByZXZlcnNlIHByb3h5aW5nIHYtc2xvdCB3aXRob3V0IHNjb3BlIG9uIHRoaXMuJHNsb3RzXHJcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgICAgICAgICAgaWYgKHNsb3QucHJveHkpIHtcclxuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgICAgICAgICAgICAgIHNsb3QuZm4ucHJveHkgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc1tzbG90LmtleV0gPSBzbG90LmZuO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChjb250ZW50SGFzaEtleSkge1xyXG4gICAgICAgIHJlcy4ka2V5ID0gY29udGVudEhhc2hLZXk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XG5cbi8vIGhlbHBlciB0byBwcm9jZXNzIGR5bmFtaWMga2V5cyBmb3IgZHluYW1pYyBhcmd1bWVudHMgaW4gdi1iaW5kIGFuZCB2LW9uLlxyXG5mdW5jdGlvbiBiaW5kRHluYW1pY0tleXMoYmFzZU9iaiwgdmFsdWVzKSB7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkgKz0gMikge1xyXG4gICAgICAgIHZhciBrZXkgPSB2YWx1ZXNbaV07XHJcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmIGtleSkge1xyXG4gICAgICAgICAgICBiYXNlT2JqW3ZhbHVlc1tpXV0gPSB2YWx1ZXNbaSArIDFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGtleSAhPT0gJycgJiYga2V5ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIC8vIG51bGwgaXMgYSBzcGVjaWFsIHZhbHVlIGZvciBleHBsaWNpdGx5IHJlbW92aW5nIGEgYmluZGluZ1xyXG4gICAgICAgICAgICB3YXJuJDIoXCJJbnZhbGlkIHZhbHVlIGZvciBkeW5hbWljIGRpcmVjdGl2ZSBhcmd1bWVudCAoZXhwZWN0ZWQgc3RyaW5nIG9yIG51bGwpOiBcIi5jb25jYXQoa2V5KSwgdGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGJhc2VPYmo7XHJcbn1cclxuLy8gaGVscGVyIHRvIGR5bmFtaWNhbGx5IGFwcGVuZCBtb2RpZmllciBydW50aW1lIG1hcmtlcnMgdG8gZXZlbnQgbmFtZXMuXHJcbi8vIGVuc3VyZSBvbmx5IGFwcGVuZCB3aGVuIHZhbHVlIGlzIGFscmVhZHkgc3RyaW5nLCBvdGhlcndpc2UgaXQgd2lsbCBiZSBjYXN0XHJcbi8vIHRvIHN0cmluZyBhbmQgY2F1c2UgdGhlIHR5cGUgY2hlY2sgdG8gbWlzcy5cclxuZnVuY3Rpb24gcHJlcGVuZE1vZGlmaWVyKHZhbHVlLCBzeW1ib2wpIHtcclxuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gc3ltYm9sICsgdmFsdWUgOiB2YWx1ZTtcclxufVxuXG5mdW5jdGlvbiBpbnN0YWxsUmVuZGVySGVscGVycyh0YXJnZXQpIHtcclxuICAgIHRhcmdldC5fbyA9IG1hcmtPbmNlO1xyXG4gICAgdGFyZ2V0Ll9uID0gdG9OdW1iZXI7XHJcbiAgICB0YXJnZXQuX3MgPSB0b1N0cmluZztcclxuICAgIHRhcmdldC5fbCA9IHJlbmRlckxpc3Q7XHJcbiAgICB0YXJnZXQuX3QgPSByZW5kZXJTbG90O1xyXG4gICAgdGFyZ2V0Ll9xID0gbG9vc2VFcXVhbDtcclxuICAgIHRhcmdldC5faSA9IGxvb3NlSW5kZXhPZjtcclxuICAgIHRhcmdldC5fbSA9IHJlbmRlclN0YXRpYztcclxuICAgIHRhcmdldC5fZiA9IHJlc29sdmVGaWx0ZXI7XHJcbiAgICB0YXJnZXQuX2sgPSBjaGVja0tleUNvZGVzO1xyXG4gICAgdGFyZ2V0Ll9iID0gYmluZE9iamVjdFByb3BzO1xyXG4gICAgdGFyZ2V0Ll92ID0gY3JlYXRlVGV4dFZOb2RlO1xyXG4gICAgdGFyZ2V0Ll9lID0gY3JlYXRlRW1wdHlWTm9kZTtcclxuICAgIHRhcmdldC5fdSA9IHJlc29sdmVTY29wZWRTbG90cztcclxuICAgIHRhcmdldC5fZyA9IGJpbmRPYmplY3RMaXN0ZW5lcnM7XHJcbiAgICB0YXJnZXQuX2QgPSBiaW5kRHluYW1pY0tleXM7XHJcbiAgICB0YXJnZXQuX3AgPSBwcmVwZW5kTW9kaWZpZXI7XHJcbn1cblxuLyoqXHJcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgcmF3IGNoaWxkcmVuIFZOb2RlcyBpbnRvIGEgc2xvdCBvYmplY3QuXHJcbiAqL1xyXG5mdW5jdGlvbiByZXNvbHZlU2xvdHMoY2hpbGRyZW4sIGNvbnRleHQpIHtcclxuICAgIGlmICghY2hpbGRyZW4gfHwgIWNoaWxkcmVuLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiB7fTtcclxuICAgIH1cclxuICAgIHZhciBzbG90cyA9IHt9O1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcclxuICAgICAgICB2YXIgZGF0YSA9IGNoaWxkLmRhdGE7XHJcbiAgICAgICAgLy8gcmVtb3ZlIHNsb3QgYXR0cmlidXRlIGlmIHRoZSBub2RlIGlzIHJlc29sdmVkIGFzIGEgVnVlIHNsb3Qgbm9kZVxyXG4gICAgICAgIGlmIChkYXRhICYmIGRhdGEuYXR0cnMgJiYgZGF0YS5hdHRycy5zbG90KSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBkYXRhLmF0dHJzLnNsb3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIG5hbWVkIHNsb3RzIHNob3VsZCBvbmx5IGJlIHJlc3BlY3RlZCBpZiB0aGUgdm5vZGUgd2FzIHJlbmRlcmVkIGluIHRoZVxyXG4gICAgICAgIC8vIHNhbWUgY29udGV4dC5cclxuICAgICAgICBpZiAoKGNoaWxkLmNvbnRleHQgPT09IGNvbnRleHQgfHwgY2hpbGQuZm5Db250ZXh0ID09PSBjb250ZXh0KSAmJlxyXG4gICAgICAgICAgICBkYXRhICYmXHJcbiAgICAgICAgICAgIGRhdGEuc2xvdCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHZhciBuYW1lXzEgPSBkYXRhLnNsb3Q7XHJcbiAgICAgICAgICAgIHZhciBzbG90ID0gc2xvdHNbbmFtZV8xXSB8fCAoc2xvdHNbbmFtZV8xXSA9IFtdKTtcclxuICAgICAgICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xyXG4gICAgICAgICAgICAgICAgc2xvdC5wdXNoLmFwcGx5KHNsb3QsIGNoaWxkLmNoaWxkcmVuIHx8IFtdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNsb3QucHVzaChjaGlsZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIChzbG90cy5kZWZhdWx0IHx8IChzbG90cy5kZWZhdWx0ID0gW10pKS5wdXNoKGNoaWxkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBpZ25vcmUgc2xvdHMgdGhhdCBjb250YWlucyBvbmx5IHdoaXRlc3BhY2VcclxuICAgIGZvciAodmFyIG5hbWVfMiBpbiBzbG90cykge1xyXG4gICAgICAgIGlmIChzbG90c1tuYW1lXzJdLmV2ZXJ5KGlzV2hpdGVzcGFjZSkpIHtcclxuICAgICAgICAgICAgZGVsZXRlIHNsb3RzW25hbWVfMl07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNsb3RzO1xyXG59XHJcbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZShub2RlKSB7XHJcbiAgICByZXR1cm4gKG5vZGUuaXNDb21tZW50ICYmICFub2RlLmFzeW5jRmFjdG9yeSkgfHwgbm9kZS50ZXh0ID09PSAnICc7XHJcbn1cblxuZnVuY3Rpb24gaXNBc3luY1BsYWNlaG9sZGVyKG5vZGUpIHtcclxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3Igbm90IHJlYWxseSBib29sZWFuIHR5cGVcclxuICAgIHJldHVybiBub2RlLmlzQ29tbWVudCAmJiBub2RlLmFzeW5jRmFjdG9yeTtcclxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVTY29wZWRTbG90cyhvd25lclZtLCBzY29wZWRTbG90cywgbm9ybWFsU2xvdHMsIHByZXZTY29wZWRTbG90cykge1xyXG4gICAgdmFyIHJlcztcclxuICAgIHZhciBoYXNOb3JtYWxTbG90cyA9IE9iamVjdC5rZXlzKG5vcm1hbFNsb3RzKS5sZW5ndGggPiAwO1xyXG4gICAgdmFyIGlzU3RhYmxlID0gc2NvcGVkU2xvdHMgPyAhIXNjb3BlZFNsb3RzLiRzdGFibGUgOiAhaGFzTm9ybWFsU2xvdHM7XHJcbiAgICB2YXIga2V5ID0gc2NvcGVkU2xvdHMgJiYgc2NvcGVkU2xvdHMuJGtleTtcclxuICAgIGlmICghc2NvcGVkU2xvdHMpIHtcclxuICAgICAgICByZXMgPSB7fTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHNjb3BlZFNsb3RzLl9ub3JtYWxpemVkKSB7XHJcbiAgICAgICAgLy8gZmFzdCBwYXRoIDE6IGNoaWxkIGNvbXBvbmVudCByZS1yZW5kZXIgb25seSwgcGFyZW50IGRpZCBub3QgY2hhbmdlXHJcbiAgICAgICAgcmV0dXJuIHNjb3BlZFNsb3RzLl9ub3JtYWxpemVkO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNTdGFibGUgJiZcclxuICAgICAgICBwcmV2U2NvcGVkU2xvdHMgJiZcclxuICAgICAgICBwcmV2U2NvcGVkU2xvdHMgIT09IGVtcHR5T2JqZWN0ICYmXHJcbiAgICAgICAga2V5ID09PSBwcmV2U2NvcGVkU2xvdHMuJGtleSAmJlxyXG4gICAgICAgICFoYXNOb3JtYWxTbG90cyAmJlxyXG4gICAgICAgICFwcmV2U2NvcGVkU2xvdHMuJGhhc05vcm1hbCkge1xyXG4gICAgICAgIC8vIGZhc3QgcGF0aCAyOiBzdGFibGUgc2NvcGVkIHNsb3RzIHcvIG5vIG5vcm1hbCBzbG90cyB0byBwcm94eSxcclxuICAgICAgICAvLyBvbmx5IG5lZWQgdG8gbm9ybWFsaXplIG9uY2VcclxuICAgICAgICByZXR1cm4gcHJldlNjb3BlZFNsb3RzO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmVzID0ge307XHJcbiAgICAgICAgZm9yICh2YXIga2V5XzEgaW4gc2NvcGVkU2xvdHMpIHtcclxuICAgICAgICAgICAgaWYgKHNjb3BlZFNsb3RzW2tleV8xXSAmJiBrZXlfMVswXSAhPT0gJyQnKSB7XHJcbiAgICAgICAgICAgICAgICByZXNba2V5XzFdID0gbm9ybWFsaXplU2NvcGVkU2xvdChvd25lclZtLCBub3JtYWxTbG90cywga2V5XzEsIHNjb3BlZFNsb3RzW2tleV8xXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBleHBvc2Ugbm9ybWFsIHNsb3RzIG9uIHNjb3BlZFNsb3RzXHJcbiAgICBmb3IgKHZhciBrZXlfMiBpbiBub3JtYWxTbG90cykge1xyXG4gICAgICAgIGlmICghKGtleV8yIGluIHJlcykpIHtcclxuICAgICAgICAgICAgcmVzW2tleV8yXSA9IHByb3h5Tm9ybWFsU2xvdChub3JtYWxTbG90cywga2V5XzIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIGF2b3JpYXogc2VlbXMgdG8gbW9jayBhIG5vbi1leHRlbnNpYmxlICRzY29wZWRTbG90cyBvYmplY3RcclxuICAgIC8vIGFuZCB3aGVuIHRoYXQgaXMgcGFzc2VkIGRvd24gdGhpcyB3b3VsZCBjYXVzZSBhbiBlcnJvclxyXG4gICAgaWYgKHNjb3BlZFNsb3RzICYmIE9iamVjdC5pc0V4dGVuc2libGUoc2NvcGVkU2xvdHMpKSB7XHJcbiAgICAgICAgc2NvcGVkU2xvdHMuX25vcm1hbGl6ZWQgPSByZXM7XHJcbiAgICB9XHJcbiAgICBkZWYocmVzLCAnJHN0YWJsZScsIGlzU3RhYmxlKTtcclxuICAgIGRlZihyZXMsICcka2V5Jywga2V5KTtcclxuICAgIGRlZihyZXMsICckaGFzTm9ybWFsJywgaGFzTm9ybWFsU2xvdHMpO1xyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG5mdW5jdGlvbiBub3JtYWxpemVTY29wZWRTbG90KHZtLCBub3JtYWxTbG90cywga2V5LCBmbikge1xyXG4gICAgdmFyIG5vcm1hbGl6ZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGN1ciA9IGN1cnJlbnRJbnN0YW5jZTtcclxuICAgICAgICBzZXRDdXJyZW50SW5zdGFuY2Uodm0pO1xyXG4gICAgICAgIHZhciByZXMgPSBhcmd1bWVudHMubGVuZ3RoID8gZm4uYXBwbHkobnVsbCwgYXJndW1lbnRzKSA6IGZuKHt9KTtcclxuICAgICAgICByZXMgPVxyXG4gICAgICAgICAgICByZXMgJiYgdHlwZW9mIHJlcyA9PT0gJ29iamVjdCcgJiYgIWlzQXJyYXkocmVzKVxyXG4gICAgICAgICAgICAgICAgPyBbcmVzXSAvLyBzaW5nbGUgdm5vZGVcclxuICAgICAgICAgICAgICAgIDogbm9ybWFsaXplQ2hpbGRyZW4ocmVzKTtcclxuICAgICAgICB2YXIgdm5vZGUgPSByZXMgJiYgcmVzWzBdO1xyXG4gICAgICAgIHNldEN1cnJlbnRJbnN0YW5jZShjdXIpO1xyXG4gICAgICAgIHJldHVybiByZXMgJiZcclxuICAgICAgICAgICAgKCF2bm9kZSB8fFxyXG4gICAgICAgICAgICAgICAgKHJlcy5sZW5ndGggPT09IDEgJiYgdm5vZGUuaXNDb21tZW50ICYmICFpc0FzeW5jUGxhY2Vob2xkZXIodm5vZGUpKSkgLy8gIzk2NTgsICMxMDM5MVxyXG4gICAgICAgICAgICA/IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICA6IHJlcztcclxuICAgIH07XHJcbiAgICAvLyB0aGlzIGlzIGEgc2xvdCB1c2luZyB0aGUgbmV3IHYtc2xvdCBzeW50YXggd2l0aG91dCBzY29wZS4gYWx0aG91Z2ggaXQgaXNcclxuICAgIC8vIGNvbXBpbGVkIGFzIGEgc2NvcGVkIHNsb3QsIHJlbmRlciBmbiB1c2VycyB3b3VsZCBleHBlY3QgaXQgdG8gYmUgcHJlc2VudFxyXG4gICAgLy8gb24gdGhpcy4kc2xvdHMgYmVjYXVzZSB0aGUgdXNhZ2UgaXMgc2VtYW50aWNhbGx5IGEgbm9ybWFsIHNsb3QuXHJcbiAgICBpZiAoZm4ucHJveHkpIHtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobm9ybWFsU2xvdHMsIGtleSwge1xyXG4gICAgICAgICAgICBnZXQ6IG5vcm1hbGl6ZWQsXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XHJcbn1cclxuZnVuY3Rpb24gcHJveHlOb3JtYWxTbG90KHNsb3RzLCBrZXkpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBzbG90c1trZXldOyB9O1xyXG59XG5cbmZ1bmN0aW9uIGluaXRTZXR1cCh2bSkge1xyXG4gICAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcclxuICAgIHZhciBzZXR1cCA9IG9wdGlvbnMuc2V0dXA7XHJcbiAgICBpZiAoc2V0dXApIHtcclxuICAgICAgICB2YXIgY3R4ID0gKHZtLl9zZXR1cENvbnRleHQgPSBjcmVhdGVTZXR1cENvbnRleHQodm0pKTtcclxuICAgICAgICBzZXRDdXJyZW50SW5zdGFuY2Uodm0pO1xyXG4gICAgICAgIHB1c2hUYXJnZXQoKTtcclxuICAgICAgICB2YXIgc2V0dXBSZXN1bHQgPSBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhzZXR1cCwgbnVsbCwgW3ZtLl9wcm9wcyB8fCBzaGFsbG93UmVhY3RpdmUoe30pLCBjdHhdLCB2bSwgXCJzZXR1cFwiKTtcclxuICAgICAgICBwb3BUYXJnZXQoKTtcclxuICAgICAgICBzZXRDdXJyZW50SW5zdGFuY2UoKTtcclxuICAgICAgICBpZiAoaXNGdW5jdGlvbihzZXR1cFJlc3VsdCkpIHtcclxuICAgICAgICAgICAgLy8gcmVuZGVyIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICAgICAgb3B0aW9ucy5yZW5kZXIgPSBzZXR1cFJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNPYmplY3Qoc2V0dXBSZXN1bHQpKSB7XHJcbiAgICAgICAgICAgIC8vIGJpbmRpbmdzXHJcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHNldHVwUmVzdWx0IGluc3RhbmNlb2YgVk5vZGUpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4kMihcInNldHVwKCkgc2hvdWxkIG5vdCByZXR1cm4gVk5vZGVzIGRpcmVjdGx5IC0gXCIgK1xyXG4gICAgICAgICAgICAgICAgICAgIFwicmV0dXJuIGEgcmVuZGVyIGZ1bmN0aW9uIGluc3RlYWQuXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZtLl9zZXR1cFN0YXRlID0gc2V0dXBSZXN1bHQ7XHJcbiAgICAgICAgICAgIC8vIF9fc2ZjIGluZGljYXRlcyBjb21waWxlZCBiaW5kaW5ncyBmcm9tIDxzY3JpcHQgc2V0dXA+XHJcbiAgICAgICAgICAgIGlmICghc2V0dXBSZXN1bHQuX19zZmMpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBzZXR1cFJlc3VsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNSZXNlcnZlZChrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3h5V2l0aFJlZlVud3JhcCh2bSwgc2V0dXBSZXN1bHQsIGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybiQyKFwiQXZvaWQgdXNpbmcgdmFyaWFibGVzIHRoYXQgc3RhcnQgd2l0aCBfIG9yICQgaW4gc2V0dXAoKS5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gZXhwb3NlZCBmb3IgY29tcGlsZWQgcmVuZGVyIGZuXHJcbiAgICAgICAgICAgICAgICB2YXIgcHJveHkgPSAodm0uX3NldHVwUHJveHkgPSB7fSk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gc2V0dXBSZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ICE9PSAnX19zZmMnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3h5V2l0aFJlZlVud3JhcChwcm94eSwgc2V0dXBSZXN1bHQsIGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgc2V0dXBSZXN1bHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB3YXJuJDIoXCJzZXR1cCgpIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0LiBSZWNlaXZlZDogXCIuY29uY2F0KHNldHVwUmVzdWx0ID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIHNldHVwUmVzdWx0KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVNldHVwQ29udGV4dCh2bSkge1xyXG4gICAgdmFyIGV4cG9zZUNhbGxlZCA9IGZhbHNlO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBnZXQgYXR0cnMoKSB7XHJcbiAgICAgICAgICAgIGlmICghdm0uX2F0dHJzUHJveHkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwcm94eSA9ICh2bS5fYXR0cnNQcm94eSA9IHt9KTtcclxuICAgICAgICAgICAgICAgIGRlZihwcm94eSwgJ192X2F0dHJfcHJveHknLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIHN5bmNTZXR1cFByb3h5KHByb3h5LCB2bS4kYXR0cnMsIGVtcHR5T2JqZWN0LCB2bSwgJyRhdHRycycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB2bS5fYXR0cnNQcm94eTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldCBsaXN0ZW5lcnMoKSB7XHJcbiAgICAgICAgICAgIGlmICghdm0uX2xpc3RlbmVyc1Byb3h5KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJveHkgPSAodm0uX2xpc3RlbmVyc1Byb3h5ID0ge30pO1xyXG4gICAgICAgICAgICAgICAgc3luY1NldHVwUHJveHkocHJveHksIHZtLiRsaXN0ZW5lcnMsIGVtcHR5T2JqZWN0LCB2bSwgJyRsaXN0ZW5lcnMnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdm0uX2xpc3RlbmVyc1Byb3h5O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0IHNsb3RzKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gaW5pdFNsb3RzUHJveHkodm0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW1pdDogYmluZCQxKHZtLiRlbWl0LCB2bSksXHJcbiAgICAgICAgZXhwb3NlOiBmdW5jdGlvbiAoZXhwb3NlZCkge1xyXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGV4cG9zZUNhbGxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4kMihcImV4cG9zZSgpIHNob3VsZCBiZSBjYWxsZWQgb25seSBvbmNlIHBlciBzZXR1cCgpLlwiLCB2bSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBleHBvc2VDYWxsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChleHBvc2VkKSB7XHJcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhleHBvc2VkKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJveHlXaXRoUmVmVW53cmFwKHZtLCBleHBvc2VkLCBrZXkpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIHN5bmNTZXR1cFByb3h5KHRvLCBmcm9tLCBwcmV2LCBpbnN0YW5jZSwgdHlwZSkge1xyXG4gICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcclxuICAgIGZvciAodmFyIGtleSBpbiBmcm9tKSB7XHJcbiAgICAgICAgaWYgKCEoa2V5IGluIHRvKSkge1xyXG4gICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgZGVmaW5lUHJveHlBdHRyKHRvLCBrZXksIGluc3RhbmNlLCB0eXBlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZnJvbVtrZXldICE9PSBwcmV2W2tleV0pIHtcclxuICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZm9yICh2YXIga2V5IGluIHRvKSB7XHJcbiAgICAgICAgaWYgKCEoa2V5IGluIGZyb20pKSB7XHJcbiAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBkZWxldGUgdG9ba2V5XTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY2hhbmdlZDtcclxufVxyXG5mdW5jdGlvbiBkZWZpbmVQcm94eUF0dHIocHJveHksIGtleSwgaW5zdGFuY2UsIHR5cGUpIHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm94eSwga2V5LCB7XHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZVt0eXBlXVtrZXldO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGluaXRTbG90c1Byb3h5KHZtKSB7XHJcbiAgICBpZiAoIXZtLl9zbG90c1Byb3h5KSB7XHJcbiAgICAgICAgc3luY1NldHVwU2xvdHMoKHZtLl9zbG90c1Byb3h5ID0ge30pLCB2bS4kc2NvcGVkU2xvdHMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZtLl9zbG90c1Byb3h5O1xyXG59XHJcbmZ1bmN0aW9uIHN5bmNTZXR1cFNsb3RzKHRvLCBmcm9tKSB7XHJcbiAgICBmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xyXG4gICAgICAgIHRvW2tleV0gPSBmcm9tW2tleV07XHJcbiAgICB9XHJcbiAgICBmb3IgKHZhciBrZXkgaW4gdG8pIHtcclxuICAgICAgICBpZiAoIShrZXkgaW4gZnJvbSkpIHtcclxuICAgICAgICAgICAgZGVsZXRlIHRvW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWwgdXNlIG1hbnVhbCB0eXBlIGRlZiBiZWNhdXNlIHB1YmxpYyBzZXR1cCBjb250ZXh0IHR5cGUgcmVsaWVzIG9uXHJcbiAqIGxlZ2FjeSBWTm9kZSB0eXBlc1xyXG4gKi9cclxuZnVuY3Rpb24gdXNlU2xvdHMoKSB7XHJcbiAgICByZXR1cm4gZ2V0Q29udGV4dCgpLnNsb3RzO1xyXG59XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWwgdXNlIG1hbnVhbCB0eXBlIGRlZiBiZWNhdXNlIHB1YmxpYyBzZXR1cCBjb250ZXh0IHR5cGUgcmVsaWVzIG9uXHJcbiAqIGxlZ2FjeSBWTm9kZSB0eXBlc1xyXG4gKi9cclxuZnVuY3Rpb24gdXNlQXR0cnMoKSB7XHJcbiAgICByZXR1cm4gZ2V0Q29udGV4dCgpLmF0dHJzO1xyXG59XHJcbi8qKlxyXG4gKiBWdWUgMiBvbmx5XHJcbiAqIEBpbnRlcm5hbCB1c2UgbWFudWFsIHR5cGUgZGVmIGJlY2F1c2UgcHVibGljIHNldHVwIGNvbnRleHQgdHlwZSByZWxpZXMgb25cclxuICogbGVnYWN5IFZOb2RlIHR5cGVzXHJcbiAqL1xyXG5mdW5jdGlvbiB1c2VMaXN0ZW5lcnMoKSB7XHJcbiAgICByZXR1cm4gZ2V0Q29udGV4dCgpLmxpc3RlbmVycztcclxufVxyXG5mdW5jdGlvbiBnZXRDb250ZXh0KCkge1xyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWN1cnJlbnRJbnN0YW5jZSkge1xyXG4gICAgICAgIHdhcm4kMihcInVzZUNvbnRleHQoKSBjYWxsZWQgd2l0aG91dCBhY3RpdmUgaW5zdGFuY2UuXCIpO1xyXG4gICAgfVxyXG4gICAgdmFyIHZtID0gY3VycmVudEluc3RhbmNlO1xyXG4gICAgcmV0dXJuIHZtLl9zZXR1cENvbnRleHQgfHwgKHZtLl9zZXR1cENvbnRleHQgPSBjcmVhdGVTZXR1cENvbnRleHQodm0pKTtcclxufVxyXG4vKipcclxuICogUnVudGltZSBoZWxwZXIgZm9yIG1lcmdpbmcgZGVmYXVsdCBkZWNsYXJhdGlvbnMuIEltcG9ydGVkIGJ5IGNvbXBpbGVkIGNvZGVcclxuICogb25seS5cclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBtZXJnZURlZmF1bHRzKHJhdywgZGVmYXVsdHMpIHtcclxuICAgIHZhciBwcm9wcyA9IGlzQXJyYXkocmF3KVxyXG4gICAgICAgID8gcmF3LnJlZHVjZShmdW5jdGlvbiAobm9ybWFsaXplZCwgcCkgeyByZXR1cm4gKChub3JtYWxpemVkW3BdID0ge30pLCBub3JtYWxpemVkKTsgfSwge30pXHJcbiAgICAgICAgOiByYXc7XHJcbiAgICBmb3IgKHZhciBrZXkgaW4gZGVmYXVsdHMpIHtcclxuICAgICAgICB2YXIgb3B0ID0gcHJvcHNba2V5XTtcclxuICAgICAgICBpZiAob3B0KSB7XHJcbiAgICAgICAgICAgIGlmIChpc0FycmF5KG9wdCkgfHwgaXNGdW5jdGlvbihvcHQpKSB7XHJcbiAgICAgICAgICAgICAgICBwcm9wc1trZXldID0geyB0eXBlOiBvcHQsIGRlZmF1bHQ6IGRlZmF1bHRzW2tleV0gfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG9wdC5kZWZhdWx0ID0gZGVmYXVsdHNba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChvcHQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcHJvcHNba2V5XSA9IHsgZGVmYXVsdDogZGVmYXVsdHNba2V5XSB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHdhcm4kMihcInByb3BzIGRlZmF1bHQga2V5IFxcXCJcIi5jb25jYXQoa2V5LCBcIlxcXCIgaGFzIG5vIGNvcnJlc3BvbmRpbmcgZGVjbGFyYXRpb24uXCIpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJvcHM7XHJcbn1cblxuZnVuY3Rpb24gaW5pdFJlbmRlcih2bSkge1xyXG4gICAgdm0uX3Zub2RlID0gbnVsbDsgLy8gdGhlIHJvb3Qgb2YgdGhlIGNoaWxkIHRyZWVcclxuICAgIHZtLl9zdGF0aWNUcmVlcyA9IG51bGw7IC8vIHYtb25jZSBjYWNoZWQgdHJlZXNcclxuICAgIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XHJcbiAgICB2YXIgcGFyZW50Vm5vZGUgPSAodm0uJHZub2RlID0gb3B0aW9ucy5fcGFyZW50Vm5vZGUpOyAvLyB0aGUgcGxhY2Vob2xkZXIgbm9kZSBpbiBwYXJlbnQgdHJlZVxyXG4gICAgdmFyIHJlbmRlckNvbnRleHQgPSBwYXJlbnRWbm9kZSAmJiBwYXJlbnRWbm9kZS5jb250ZXh0O1xyXG4gICAgdm0uJHNsb3RzID0gcmVzb2x2ZVNsb3RzKG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuLCByZW5kZXJDb250ZXh0KTtcclxuICAgIHZtLiRzY29wZWRTbG90cyA9IHBhcmVudFZub2RlXHJcbiAgICAgICAgPyBub3JtYWxpemVTY29wZWRTbG90cyh2bS4kcGFyZW50LCBwYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzLCB2bS4kc2xvdHMpXHJcbiAgICAgICAgOiBlbXB0eU9iamVjdDtcclxuICAgIC8vIGJpbmQgdGhlIGNyZWF0ZUVsZW1lbnQgZm4gdG8gdGhpcyBpbnN0YW5jZVxyXG4gICAgLy8gc28gdGhhdCB3ZSBnZXQgcHJvcGVyIHJlbmRlciBjb250ZXh0IGluc2lkZSBpdC5cclxuICAgIC8vIGFyZ3Mgb3JkZXI6IHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlLCBhbHdheXNOb3JtYWxpemVcclxuICAgIC8vIGludGVybmFsIHZlcnNpb24gaXMgdXNlZCBieSByZW5kZXIgZnVuY3Rpb25zIGNvbXBpbGVkIGZyb20gdGVtcGxhdGVzXHJcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXHJcbiAgICB2bS5fYyA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50JDEodm0sIGEsIGIsIGMsIGQsIGZhbHNlKTsgfTtcclxuICAgIC8vIG5vcm1hbGl6YXRpb24gaXMgYWx3YXlzIGFwcGxpZWQgZm9yIHRoZSBwdWJsaWMgdmVyc2lvbiwgdXNlZCBpblxyXG4gICAgLy8gdXNlci13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMuXHJcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXHJcbiAgICB2bS4kY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50JDEodm0sIGEsIGIsIGMsIGQsIHRydWUpOyB9O1xyXG4gICAgLy8gJGF0dHJzICYgJGxpc3RlbmVycyBhcmUgZXhwb3NlZCBmb3IgZWFzaWVyIEhPQyBjcmVhdGlvbi5cclxuICAgIC8vIHRoZXkgbmVlZCB0byBiZSByZWFjdGl2ZSBzbyB0aGF0IEhPQ3MgdXNpbmcgdGhlbSBhcmUgYWx3YXlzIHVwZGF0ZWRcclxuICAgIHZhciBwYXJlbnREYXRhID0gcGFyZW50Vm5vZGUgJiYgcGFyZW50Vm5vZGUuZGF0YTtcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgIGRlZmluZVJlYWN0aXZlKHZtLCAnJGF0dHJzJywgKHBhcmVudERhdGEgJiYgcGFyZW50RGF0YS5hdHRycykgfHwgZW1wdHlPYmplY3QsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCAmJiB3YXJuJDIoXCIkYXR0cnMgaXMgcmVhZG9ubHkuXCIsIHZtKTtcclxuICAgICAgICB9LCB0cnVlKTtcclxuICAgICAgICBkZWZpbmVSZWFjdGl2ZSh2bSwgJyRsaXN0ZW5lcnMnLCBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3QsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCAmJiB3YXJuJDIoXCIkbGlzdGVuZXJzIGlzIHJlYWRvbmx5LlwiLCB2bSk7XHJcbiAgICAgICAgfSwgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBkZWZpbmVSZWFjdGl2ZSh2bSwgJyRhdHRycycsIChwYXJlbnREYXRhICYmIHBhcmVudERhdGEuYXR0cnMpIHx8IGVtcHR5T2JqZWN0LCBudWxsLCB0cnVlKTtcclxuICAgICAgICBkZWZpbmVSZWFjdGl2ZSh2bSwgJyRsaXN0ZW5lcnMnLCBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3QsIG51bGwsIHRydWUpO1xyXG4gICAgfVxyXG59XHJcbnZhciBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgPSBudWxsO1xyXG5mdW5jdGlvbiByZW5kZXJNaXhpbihWdWUpIHtcclxuICAgIC8vIGluc3RhbGwgcnVudGltZSBjb252ZW5pZW5jZSBoZWxwZXJzXHJcbiAgICBpbnN0YWxsUmVuZGVySGVscGVycyhWdWUucHJvdG90eXBlKTtcclxuICAgIFZ1ZS5wcm90b3R5cGUuJG5leHRUaWNrID0gZnVuY3Rpb24gKGZuKSB7XHJcbiAgICAgICAgcmV0dXJuIG5leHRUaWNrKGZuLCB0aGlzKTtcclxuICAgIH07XHJcbiAgICBWdWUucHJvdG90eXBlLl9yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHZtID0gdGhpcztcclxuICAgICAgICB2YXIgX2EgPSB2bS4kb3B0aW9ucywgcmVuZGVyID0gX2EucmVuZGVyLCBfcGFyZW50Vm5vZGUgPSBfYS5fcGFyZW50Vm5vZGU7XHJcbiAgICAgICAgaWYgKF9wYXJlbnRWbm9kZSAmJiB2bS5faXNNb3VudGVkKSB7XHJcbiAgICAgICAgICAgIHZtLiRzY29wZWRTbG90cyA9IG5vcm1hbGl6ZVNjb3BlZFNsb3RzKHZtLiRwYXJlbnQsIF9wYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzLCB2bS4kc2xvdHMsIHZtLiRzY29wZWRTbG90cyk7XHJcbiAgICAgICAgICAgIGlmICh2bS5fc2xvdHNQcm94eSkge1xyXG4gICAgICAgICAgICAgICAgc3luY1NldHVwU2xvdHModm0uX3Nsb3RzUHJveHksIHZtLiRzY29wZWRTbG90cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gc2V0IHBhcmVudCB2bm9kZS4gdGhpcyBhbGxvd3MgcmVuZGVyIGZ1bmN0aW9ucyB0byBoYXZlIGFjY2Vzc1xyXG4gICAgICAgIC8vIHRvIHRoZSBkYXRhIG9uIHRoZSBwbGFjZWhvbGRlciBub2RlLlxyXG4gICAgICAgIHZtLiR2bm9kZSA9IF9wYXJlbnRWbm9kZTtcclxuICAgICAgICAvLyByZW5kZXIgc2VsZlxyXG4gICAgICAgIHZhciB2bm9kZTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAvLyBUaGVyZSdzIG5vIG5lZWQgdG8gbWFpbnRhaW4gYSBzdGFjayBiZWNhdXNlIGFsbCByZW5kZXIgZm5zIGFyZSBjYWxsZWRcclxuICAgICAgICAgICAgLy8gc2VwYXJhdGVseSBmcm9tIG9uZSBhbm90aGVyLiBOZXN0ZWQgY29tcG9uZW50J3MgcmVuZGVyIGZucyBhcmUgY2FsbGVkXHJcbiAgICAgICAgICAgIC8vIHdoZW4gcGFyZW50IGNvbXBvbmVudCBpcyBwYXRjaGVkLlxyXG4gICAgICAgICAgICBzZXRDdXJyZW50SW5zdGFuY2Uodm0pO1xyXG4gICAgICAgICAgICBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgPSB2bTtcclxuICAgICAgICAgICAgdm5vZGUgPSByZW5kZXIuY2FsbCh2bS5fcmVuZGVyUHJveHksIHZtLiRjcmVhdGVFbGVtZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwicmVuZGVyXCIpO1xyXG4gICAgICAgICAgICAvLyByZXR1cm4gZXJyb3IgcmVuZGVyIHJlc3VsdCxcclxuICAgICAgICAgICAgLy8gb3IgcHJldmlvdXMgdm5vZGUgdG8gcHJldmVudCByZW5kZXIgZXJyb3IgY2F1c2luZyBibGFuayBjb21wb25lbnRcclxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cclxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdm0uJG9wdGlvbnMucmVuZGVyRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdm5vZGUgPSB2bS4kb3B0aW9ucy5yZW5kZXJFcnJvci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQsIGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJyZW5kZXJFcnJvclwiKTtcclxuICAgICAgICAgICAgICAgICAgICB2bm9kZSA9IHZtLl92bm9kZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZub2RlID0gdm0uX3Zub2RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgPSBudWxsO1xyXG4gICAgICAgICAgICBzZXRDdXJyZW50SW5zdGFuY2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaWYgdGhlIHJldHVybmVkIGFycmF5IGNvbnRhaW5zIG9ubHkgYSBzaW5nbGUgbm9kZSwgYWxsb3cgaXRcclxuICAgICAgICBpZiAoaXNBcnJheSh2bm9kZSkgJiYgdm5vZGUubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgIHZub2RlID0gdm5vZGVbMF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHJldHVybiBlbXB0eSB2bm9kZSBpbiBjYXNlIHRoZSByZW5kZXIgZnVuY3Rpb24gZXJyb3JlZCBvdXRcclxuICAgICAgICBpZiAoISh2bm9kZSBpbnN0YW5jZW9mIFZOb2RlKSkge1xyXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc0FycmF5KHZub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgd2FybiQyKCdNdWx0aXBsZSByb290IG5vZGVzIHJldHVybmVkIGZyb20gcmVuZGVyIGZ1bmN0aW9uLiBSZW5kZXIgZnVuY3Rpb24gJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJ3Nob3VsZCByZXR1cm4gYSBzaW5nbGUgcm9vdCBub2RlLicsIHZtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2bm9kZSA9IGNyZWF0ZUVtcHR5Vk5vZGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gc2V0IHBhcmVudFxyXG4gICAgICAgIHZub2RlLnBhcmVudCA9IF9wYXJlbnRWbm9kZTtcclxuICAgICAgICByZXR1cm4gdm5vZGU7XHJcbiAgICB9O1xyXG59XG5cbmZ1bmN0aW9uIGVuc3VyZUN0b3IoY29tcCwgYmFzZSkge1xyXG4gICAgaWYgKGNvbXAuX19lc01vZHVsZSB8fCAoaGFzU3ltYm9sICYmIGNvbXBbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ01vZHVsZScpKSB7XHJcbiAgICAgICAgY29tcCA9IGNvbXAuZGVmYXVsdDtcclxuICAgIH1cclxuICAgIHJldHVybiBpc09iamVjdChjb21wKSA/IGJhc2UuZXh0ZW5kKGNvbXApIDogY29tcDtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVBc3luY1BsYWNlaG9sZGVyKGZhY3RvcnksIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuLCB0YWcpIHtcclxuICAgIHZhciBub2RlID0gY3JlYXRlRW1wdHlWTm9kZSgpO1xyXG4gICAgbm9kZS5hc3luY0ZhY3RvcnkgPSBmYWN0b3J5O1xyXG4gICAgbm9kZS5hc3luY01ldGEgPSB7IGRhdGE6IGRhdGEsIGNvbnRleHQ6IGNvbnRleHQsIGNoaWxkcmVuOiBjaGlsZHJlbiwgdGFnOiB0YWcgfTtcclxuICAgIHJldHVybiBub2RlO1xyXG59XHJcbmZ1bmN0aW9uIHJlc29sdmVBc3luY0NvbXBvbmVudChmYWN0b3J5LCBiYXNlQ3Rvcikge1xyXG4gICAgaWYgKGlzVHJ1ZShmYWN0b3J5LmVycm9yKSAmJiBpc0RlZihmYWN0b3J5LmVycm9yQ29tcCkpIHtcclxuICAgICAgICByZXR1cm4gZmFjdG9yeS5lcnJvckNvbXA7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNEZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcclxuICAgICAgICByZXR1cm4gZmFjdG9yeS5yZXNvbHZlZDtcclxuICAgIH1cclxuICAgIHZhciBvd25lciA9IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcclxuICAgIGlmIChvd25lciAmJiBpc0RlZihmYWN0b3J5Lm93bmVycykgJiYgZmFjdG9yeS5vd25lcnMuaW5kZXhPZihvd25lcikgPT09IC0xKSB7XHJcbiAgICAgICAgLy8gYWxyZWFkeSBwZW5kaW5nXHJcbiAgICAgICAgZmFjdG9yeS5vd25lcnMucHVzaChvd25lcik7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNUcnVlKGZhY3RvcnkubG9hZGluZykgJiYgaXNEZWYoZmFjdG9yeS5sb2FkaW5nQ29tcCkpIHtcclxuICAgICAgICByZXR1cm4gZmFjdG9yeS5sb2FkaW5nQ29tcDtcclxuICAgIH1cclxuICAgIGlmIChvd25lciAmJiAhaXNEZWYoZmFjdG9yeS5vd25lcnMpKSB7XHJcbiAgICAgICAgdmFyIG93bmVyc18xID0gKGZhY3Rvcnkub3duZXJzID0gW293bmVyXSk7XHJcbiAgICAgICAgdmFyIHN5bmNfMSA9IHRydWU7XHJcbiAgICAgICAgdmFyIHRpbWVyTG9hZGluZ18xID0gbnVsbDtcclxuICAgICAgICB2YXIgdGltZXJUaW1lb3V0XzEgPSBudWxsO1xyXG4gICAgICAgIG93bmVyLiRvbignaG9vazpkZXN0cm95ZWQnLCBmdW5jdGlvbiAoKSB7IHJldHVybiByZW1vdmUkMihvd25lcnNfMSwgb3duZXIpOyB9KTtcclxuICAgICAgICB2YXIgZm9yY2VSZW5kZXJfMSA9IGZ1bmN0aW9uIChyZW5kZXJDb21wbGV0ZWQpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvd25lcnNfMS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIG93bmVyc18xW2ldLiRmb3JjZVVwZGF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChyZW5kZXJDb21wbGV0ZWQpIHtcclxuICAgICAgICAgICAgICAgIG93bmVyc18xLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAodGltZXJMb2FkaW5nXzEgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXJMb2FkaW5nXzEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVyTG9hZGluZ18xID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0aW1lclRpbWVvdXRfMSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lclRpbWVvdXRfMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGltZXJUaW1lb3V0XzEgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgcmVzb2x2ZSA9IG9uY2UoZnVuY3Rpb24gKHJlcykge1xyXG4gICAgICAgICAgICAvLyBjYWNoZSByZXNvbHZlZFxyXG4gICAgICAgICAgICBmYWN0b3J5LnJlc29sdmVkID0gZW5zdXJlQ3RvcihyZXMsIGJhc2VDdG9yKTtcclxuICAgICAgICAgICAgLy8gaW52b2tlIGNhbGxiYWNrcyBvbmx5IGlmIHRoaXMgaXMgbm90IGEgc3luY2hyb25vdXMgcmVzb2x2ZVxyXG4gICAgICAgICAgICAvLyAoYXN5bmMgcmVzb2x2ZXMgYXJlIHNoaW1tZWQgYXMgc3luY2hyb25vdXMgZHVyaW5nIFNTUilcclxuICAgICAgICAgICAgaWYgKCFzeW5jXzEpIHtcclxuICAgICAgICAgICAgICAgIGZvcmNlUmVuZGVyXzEodHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvd25lcnNfMS5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdmFyIHJlamVjdF8xID0gb25jZShmdW5jdGlvbiAocmVhc29uKSB7XHJcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcclxuICAgICAgICAgICAgICAgIHdhcm4kMihcIkZhaWxlZCB0byByZXNvbHZlIGFzeW5jIGNvbXBvbmVudDogXCIuY29uY2F0KFN0cmluZyhmYWN0b3J5KSkgK1xyXG4gICAgICAgICAgICAgICAgICAgIChyZWFzb24gPyBcIlxcblJlYXNvbjogXCIuY29uY2F0KHJlYXNvbikgOiAnJykpO1xyXG4gICAgICAgICAgICBpZiAoaXNEZWYoZmFjdG9yeS5lcnJvckNvbXApKSB7XHJcbiAgICAgICAgICAgICAgICBmYWN0b3J5LmVycm9yID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGZvcmNlUmVuZGVyXzEodHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgcmVzXzEgPSBmYWN0b3J5KHJlc29sdmUsIHJlamVjdF8xKTtcclxuICAgICAgICBpZiAoaXNPYmplY3QocmVzXzEpKSB7XHJcbiAgICAgICAgICAgIGlmIChpc1Byb21pc2UocmVzXzEpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyAoKSA9PiBQcm9taXNlXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc18xLnRoZW4ocmVzb2x2ZSwgcmVqZWN0XzEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzUHJvbWlzZShyZXNfMS5jb21wb25lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXNfMS5jb21wb25lbnQudGhlbihyZXNvbHZlLCByZWplY3RfMSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWYocmVzXzEuZXJyb3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmFjdG9yeS5lcnJvckNvbXAgPSBlbnN1cmVDdG9yKHJlc18xLmVycm9yLCBiYXNlQ3Rvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWYocmVzXzEubG9hZGluZykpIHtcclxuICAgICAgICAgICAgICAgICAgICBmYWN0b3J5LmxvYWRpbmdDb21wID0gZW5zdXJlQ3RvcihyZXNfMS5sb2FkaW5nLCBiYXNlQ3Rvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc18xLmRlbGF5ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhY3RvcnkubG9hZGluZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIE5vZGVKUyB0aW1lb3V0IHR5cGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZXJMb2FkaW5nXzEgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVyTG9hZGluZ18xID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpICYmIGlzVW5kZWYoZmFjdG9yeS5lcnJvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWN0b3J5LmxvYWRpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcmNlUmVuZGVyXzEoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCByZXNfMS5kZWxheSB8fCAyMDApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpc0RlZihyZXNfMS50aW1lb3V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgTm9kZUpTIHRpbWVvdXQgdHlwZVxyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVyVGltZW91dF8xID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVyVGltZW91dF8xID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdF8xKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBcInRpbWVvdXQgKFwiLmNvbmNhdChyZXNfMS50aW1lb3V0LCBcIm1zKVwiKSA6IG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgcmVzXzEudGltZW91dCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgc3luY18xID0gZmFsc2U7XHJcbiAgICAgICAgLy8gcmV0dXJuIGluIGNhc2UgcmVzb2x2ZWQgc3luY2hyb25vdXNseVxyXG4gICAgICAgIHJldHVybiBmYWN0b3J5LmxvYWRpbmcgPyBmYWN0b3J5LmxvYWRpbmdDb21wIDogZmFjdG9yeS5yZXNvbHZlZDtcclxuICAgIH1cclxufVxuXG5mdW5jdGlvbiBnZXRGaXJzdENvbXBvbmVudENoaWxkKGNoaWxkcmVuKSB7XHJcbiAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBjID0gY2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgIGlmIChpc0RlZihjKSAmJiAoaXNEZWYoYy5jb21wb25lbnRPcHRpb25zKSB8fCBpc0FzeW5jUGxhY2Vob2xkZXIoYykpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5mdW5jdGlvbiBpbml0RXZlbnRzKHZtKSB7XHJcbiAgICB2bS5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgIHZtLl9oYXNIb29rRXZlbnQgPSBmYWxzZTtcclxuICAgIC8vIGluaXQgcGFyZW50IGF0dGFjaGVkIGV2ZW50c1xyXG4gICAgdmFyIGxpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XHJcbiAgICBpZiAobGlzdGVuZXJzKSB7XHJcbiAgICAgICAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMpO1xyXG4gICAgfVxyXG59XHJcbnZhciB0YXJnZXQkMTtcclxuZnVuY3Rpb24gYWRkJDEoZXZlbnQsIGZuKSB7XHJcbiAgICB0YXJnZXQkMS4kb24oZXZlbnQsIGZuKTtcclxufVxyXG5mdW5jdGlvbiByZW1vdmUkMShldmVudCwgZm4pIHtcclxuICAgIHRhcmdldCQxLiRvZmYoZXZlbnQsIGZuKTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVPbmNlSGFuZGxlciQxKGV2ZW50LCBmbikge1xyXG4gICAgdmFyIF90YXJnZXQgPSB0YXJnZXQkMTtcclxuICAgIHJldHVybiBmdW5jdGlvbiBvbmNlSGFuZGxlcigpIHtcclxuICAgICAgICB2YXIgcmVzID0gZm4uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcclxuICAgICAgICBpZiAocmVzICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIF90YXJnZXQuJG9mZihldmVudCwgb25jZUhhbmRsZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMsIG9sZExpc3RlbmVycykge1xyXG4gICAgdGFyZ2V0JDEgPSB2bTtcclxuICAgIHVwZGF0ZUxpc3RlbmVycyhsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyB8fCB7fSwgYWRkJDEsIHJlbW92ZSQxLCBjcmVhdGVPbmNlSGFuZGxlciQxLCB2bSk7XHJcbiAgICB0YXJnZXQkMSA9IHVuZGVmaW5lZDtcclxufVxyXG5mdW5jdGlvbiBldmVudHNNaXhpbihWdWUpIHtcclxuICAgIHZhciBob29rUkUgPSAvXmhvb2s6LztcclxuICAgIFZ1ZS5wcm90b3R5cGUuJG9uID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xyXG4gICAgICAgIHZhciB2bSA9IHRoaXM7XHJcbiAgICAgICAgaWYgKGlzQXJyYXkoZXZlbnQpKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2bS4kb24oZXZlbnRbaV0sIGZuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgKHZtLl9ldmVudHNbZXZlbnRdIHx8ICh2bS5fZXZlbnRzW2V2ZW50XSA9IFtdKSkucHVzaChmbik7XHJcbiAgICAgICAgICAgIC8vIG9wdGltaXplIGhvb2s6ZXZlbnQgY29zdCBieSB1c2luZyBhIGJvb2xlYW4gZmxhZyBtYXJrZWQgYXQgcmVnaXN0cmF0aW9uXHJcbiAgICAgICAgICAgIC8vIGluc3RlYWQgb2YgYSBoYXNoIGxvb2t1cFxyXG4gICAgICAgICAgICBpZiAoaG9va1JFLnRlc3QoZXZlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICB2bS5faGFzSG9va0V2ZW50ID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdm07XHJcbiAgICB9O1xyXG4gICAgVnVlLnByb3RvdHlwZS4kb25jZSA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcclxuICAgICAgICB2YXIgdm0gPSB0aGlzO1xyXG4gICAgICAgIGZ1bmN0aW9uIG9uKCkge1xyXG4gICAgICAgICAgICB2bS4kb2ZmKGV2ZW50LCBvbik7XHJcbiAgICAgICAgICAgIGZuLmFwcGx5KHZtLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvbi5mbiA9IGZuO1xyXG4gICAgICAgIHZtLiRvbihldmVudCwgb24pO1xyXG4gICAgICAgIHJldHVybiB2bTtcclxuICAgIH07XHJcbiAgICBWdWUucHJvdG90eXBlLiRvZmYgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XHJcbiAgICAgICAgdmFyIHZtID0gdGhpcztcclxuICAgICAgICAvLyBhbGxcclxuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICAgICAgICAgIHJldHVybiB2bTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYXJyYXkgb2YgZXZlbnRzXHJcbiAgICAgICAgaWYgKGlzQXJyYXkoZXZlbnQpKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGlfMSA9IDAsIGwgPSBldmVudC5sZW5ndGg7IGlfMSA8IGw7IGlfMSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2bS4kb2ZmKGV2ZW50W2lfMV0sIGZuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdm07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHNwZWNpZmljIGV2ZW50XHJcbiAgICAgICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xyXG4gICAgICAgIGlmICghY2JzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2bTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFmbikge1xyXG4gICAgICAgICAgICB2bS5fZXZlbnRzW2V2ZW50XSA9IG51bGw7XHJcbiAgICAgICAgICAgIHJldHVybiB2bTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gc3BlY2lmaWMgaGFuZGxlclxyXG4gICAgICAgIHZhciBjYjtcclxuICAgICAgICB2YXIgaSA9IGNicy5sZW5ndGg7XHJcbiAgICAgICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgICAgICBjYiA9IGNic1tpXTtcclxuICAgICAgICAgICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcclxuICAgICAgICAgICAgICAgIGNicy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdm07XHJcbiAgICB9O1xyXG4gICAgVnVlLnByb3RvdHlwZS4kZW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgIHZhciB2bSA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgICAgdmFyIGxvd2VyQ2FzZUV2ZW50ID0gZXZlbnQudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgaWYgKGxvd2VyQ2FzZUV2ZW50ICE9PSBldmVudCAmJiB2bS5fZXZlbnRzW2xvd2VyQ2FzZUV2ZW50XSkge1xyXG4gICAgICAgICAgICAgICAgdGlwKFwiRXZlbnQgXFxcIlwiLmNvbmNhdChsb3dlckNhc2VFdmVudCwgXCJcXFwiIGlzIGVtaXR0ZWQgaW4gY29tcG9uZW50IFwiKSArXHJcbiAgICAgICAgICAgICAgICAgICAgXCJcIi5jb25jYXQoZm9ybWF0Q29tcG9uZW50TmFtZSh2bSksIFwiIGJ1dCB0aGUgaGFuZGxlciBpcyByZWdpc3RlcmVkIGZvciBcXFwiXCIpLmNvbmNhdChldmVudCwgXCJcXFwiLiBcIikgK1xyXG4gICAgICAgICAgICAgICAgICAgIFwiTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgeW91IGNhbm5vdCB1c2UgXCIgK1xyXG4gICAgICAgICAgICAgICAgICAgIFwidi1vbiB0byBsaXN0ZW4gdG8gY2FtZWxDYXNlIGV2ZW50cyB3aGVuIHVzaW5nIGluLURPTSB0ZW1wbGF0ZXMuIFwiICtcclxuICAgICAgICAgICAgICAgICAgICBcIllvdSBzaG91bGQgcHJvYmFibHkgdXNlIFxcXCJcIi5jb25jYXQoaHlwaGVuYXRlKGV2ZW50KSwgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiKS5jb25jYXQoZXZlbnQsIFwiXFxcIi5cIikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcclxuICAgICAgICBpZiAoY2JzKSB7XHJcbiAgICAgICAgICAgIGNicyA9IGNicy5sZW5ndGggPiAxID8gdG9BcnJheShjYnMpIDogY2JzO1xyXG4gICAgICAgICAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcclxuICAgICAgICAgICAgdmFyIGluZm8gPSBcImV2ZW50IGhhbmRsZXIgZm9yIFxcXCJcIi5jb25jYXQoZXZlbnQsIFwiXFxcIlwiKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjYnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhjYnNbaV0sIHZtLCBhcmdzLCB2bSwgaW5mbyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZtO1xyXG4gICAgfTtcclxufVxuXG52YXIgYWN0aXZlSW5zdGFuY2UgPSBudWxsO1xyXG52YXIgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gZmFsc2U7XHJcbmZ1bmN0aW9uIHNldEFjdGl2ZUluc3RhbmNlKHZtKSB7XHJcbiAgICB2YXIgcHJldkFjdGl2ZUluc3RhbmNlID0gYWN0aXZlSW5zdGFuY2U7XHJcbiAgICBhY3RpdmVJbnN0YW5jZSA9IHZtO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBhY3RpdmVJbnN0YW5jZSA9IHByZXZBY3RpdmVJbnN0YW5jZTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gaW5pdExpZmVjeWNsZSh2bSkge1xyXG4gICAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcclxuICAgIC8vIGxvY2F0ZSBmaXJzdCBub24tYWJzdHJhY3QgcGFyZW50XHJcbiAgICB2YXIgcGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XHJcbiAgICBpZiAocGFyZW50ICYmICFvcHRpb25zLmFic3RyYWN0KSB7XHJcbiAgICAgICAgd2hpbGUgKHBhcmVudC4kb3B0aW9ucy5hYnN0cmFjdCAmJiBwYXJlbnQuJHBhcmVudCkge1xyXG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQuJHBhcmVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcGFyZW50LiRjaGlsZHJlbi5wdXNoKHZtKTtcclxuICAgIH1cclxuICAgIHZtLiRwYXJlbnQgPSBwYXJlbnQ7XHJcbiAgICB2bS4kcm9vdCA9IHBhcmVudCA/IHBhcmVudC4kcm9vdCA6IHZtO1xyXG4gICAgdm0uJGNoaWxkcmVuID0gW107XHJcbiAgICB2bS4kcmVmcyA9IHt9O1xyXG4gICAgdm0uX3Byb3ZpZGVkID0gcGFyZW50ID8gcGFyZW50Ll9wcm92aWRlZCA6IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICB2bS5fd2F0Y2hlciA9IG51bGw7XHJcbiAgICB2bS5faW5hY3RpdmUgPSBudWxsO1xyXG4gICAgdm0uX2RpcmVjdEluYWN0aXZlID0gZmFsc2U7XHJcbiAgICB2bS5faXNNb3VudGVkID0gZmFsc2U7XHJcbiAgICB2bS5faXNEZXN0cm95ZWQgPSBmYWxzZTtcclxuICAgIHZtLl9pc0JlaW5nRGVzdHJveWVkID0gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gbGlmZWN5Y2xlTWl4aW4oVnVlKSB7XHJcbiAgICBWdWUucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAodm5vZGUsIGh5ZHJhdGluZykge1xyXG4gICAgICAgIHZhciB2bSA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHByZXZFbCA9IHZtLiRlbDtcclxuICAgICAgICB2YXIgcHJldlZub2RlID0gdm0uX3Zub2RlO1xyXG4gICAgICAgIHZhciByZXN0b3JlQWN0aXZlSW5zdGFuY2UgPSBzZXRBY3RpdmVJbnN0YW5jZSh2bSk7XHJcbiAgICAgICAgdm0uX3Zub2RlID0gdm5vZGU7XHJcbiAgICAgICAgLy8gVnVlLnByb3RvdHlwZS5fX3BhdGNoX18gaXMgaW5qZWN0ZWQgaW4gZW50cnkgcG9pbnRzXHJcbiAgICAgICAgLy8gYmFzZWQgb24gdGhlIHJlbmRlcmluZyBiYWNrZW5kIHVzZWQuXHJcbiAgICAgICAgaWYgKCFwcmV2Vm5vZGUpIHtcclxuICAgICAgICAgICAgLy8gaW5pdGlhbCByZW5kZXJcclxuICAgICAgICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKHZtLiRlbCwgdm5vZGUsIGh5ZHJhdGluZywgZmFsc2UgLyogcmVtb3ZlT25seSAqLyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyB1cGRhdGVzXHJcbiAgICAgICAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyhwcmV2Vm5vZGUsIHZub2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzdG9yZUFjdGl2ZUluc3RhbmNlKCk7XHJcbiAgICAgICAgLy8gdXBkYXRlIF9fdnVlX18gcmVmZXJlbmNlXHJcbiAgICAgICAgaWYgKHByZXZFbCkge1xyXG4gICAgICAgICAgICBwcmV2RWwuX192dWVfXyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2bS4kZWwpIHtcclxuICAgICAgICAgICAgdm0uJGVsLl9fdnVlX18gPSB2bTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaWYgcGFyZW50IGlzIGFuIEhPQywgdXBkYXRlIGl0cyAkZWwgYXMgd2VsbFxyXG4gICAgICAgIGlmICh2bS4kdm5vZGUgJiYgdm0uJHBhcmVudCAmJiB2bS4kdm5vZGUgPT09IHZtLiRwYXJlbnQuX3Zub2RlKSB7XHJcbiAgICAgICAgICAgIHZtLiRwYXJlbnQuJGVsID0gdm0uJGVsO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB1cGRhdGVkIGhvb2sgaXMgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIgdG8gZW5zdXJlIHRoYXQgY2hpbGRyZW4gYXJlXHJcbiAgICAgICAgLy8gdXBkYXRlZCBpbiBhIHBhcmVudCdzIHVwZGF0ZWQgaG9vay5cclxuICAgIH07XHJcbiAgICBWdWUucHJvdG90eXBlLiRmb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdm0gPSB0aGlzO1xyXG4gICAgICAgIGlmICh2bS5fd2F0Y2hlcikge1xyXG4gICAgICAgICAgICB2bS5fd2F0Y2hlci51cGRhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVnVlLnByb3RvdHlwZS4kZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdm0gPSB0aGlzO1xyXG4gICAgICAgIGlmICh2bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhbGxIb29rJDEodm0sICdiZWZvcmVEZXN0cm95Jyk7XHJcbiAgICAgICAgdm0uX2lzQmVpbmdEZXN0cm95ZWQgPSB0cnVlO1xyXG4gICAgICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gcGFyZW50XHJcbiAgICAgICAgdmFyIHBhcmVudCA9IHZtLiRwYXJlbnQ7XHJcbiAgICAgICAgaWYgKHBhcmVudCAmJiAhcGFyZW50Ll9pc0JlaW5nRGVzdHJveWVkICYmICF2bS4kb3B0aW9ucy5hYnN0cmFjdCkge1xyXG4gICAgICAgICAgICByZW1vdmUkMihwYXJlbnQuJGNoaWxkcmVuLCB2bSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHRlYXJkb3duIHNjb3BlLiB0aGlzIGluY2x1ZGVzIGJvdGggdGhlIHJlbmRlciB3YXRjaGVyIGFuZCBvdGhlclxyXG4gICAgICAgIC8vIHdhdGNoZXJzIGNyZWF0ZWRcclxuICAgICAgICB2bS5fc2NvcGUuc3RvcCgpO1xyXG4gICAgICAgIC8vIHJlbW92ZSByZWZlcmVuY2UgZnJvbSBkYXRhIG9iXHJcbiAgICAgICAgLy8gZnJvemVuIG9iamVjdCBtYXkgbm90IGhhdmUgb2JzZXJ2ZXIuXHJcbiAgICAgICAgaWYgKHZtLl9kYXRhLl9fb2JfXykge1xyXG4gICAgICAgICAgICB2bS5fZGF0YS5fX29iX18udm1Db3VudC0tO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjYWxsIHRoZSBsYXN0IGhvb2suLi5cclxuICAgICAgICB2bS5faXNEZXN0cm95ZWQgPSB0cnVlO1xyXG4gICAgICAgIC8vIGludm9rZSBkZXN0cm95IGhvb2tzIG9uIGN1cnJlbnQgcmVuZGVyZWQgdHJlZVxyXG4gICAgICAgIHZtLl9fcGF0Y2hfXyh2bS5fdm5vZGUsIG51bGwpO1xyXG4gICAgICAgIC8vIGZpcmUgZGVzdHJveWVkIGhvb2tcclxuICAgICAgICBjYWxsSG9vayQxKHZtLCAnZGVzdHJveWVkJyk7XHJcbiAgICAgICAgLy8gdHVybiBvZmYgYWxsIGluc3RhbmNlIGxpc3RlbmVycy5cclxuICAgICAgICB2bS4kb2ZmKCk7XHJcbiAgICAgICAgLy8gcmVtb3ZlIF9fdnVlX18gcmVmZXJlbmNlXHJcbiAgICAgICAgaWYgKHZtLiRlbCkge1xyXG4gICAgICAgICAgICB2bS4kZWwuX192dWVfXyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHJlbGVhc2UgY2lyY3VsYXIgcmVmZXJlbmNlICgjNjc1OSlcclxuICAgICAgICBpZiAodm0uJHZub2RlKSB7XHJcbiAgICAgICAgICAgIHZtLiR2bm9kZS5wYXJlbnQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gbW91bnRDb21wb25lbnQodm0sIGVsLCBoeWRyYXRpbmcpIHtcclxuICAgIHZtLiRlbCA9IGVsO1xyXG4gICAgaWYgKCF2bS4kb3B0aW9ucy5yZW5kZXIpIHtcclxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGludmFsaWQgdHlwZVxyXG4gICAgICAgIHZtLiRvcHRpb25zLnJlbmRlciA9IGNyZWF0ZUVtcHR5Vk5vZGU7XHJcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgICAgIGlmICgodm0uJG9wdGlvbnMudGVtcGxhdGUgJiYgdm0uJG9wdGlvbnMudGVtcGxhdGUuY2hhckF0KDApICE9PSAnIycpIHx8XHJcbiAgICAgICAgICAgICAgICB2bS4kb3B0aW9ucy5lbCB8fFxyXG4gICAgICAgICAgICAgICAgZWwpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4kMignWW91IGFyZSB1c2luZyB0aGUgcnVudGltZS1vbmx5IGJ1aWxkIG9mIFZ1ZSB3aGVyZSB0aGUgdGVtcGxhdGUgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJ2NvbXBpbGVyIGlzIG5vdCBhdmFpbGFibGUuIEVpdGhlciBwcmUtY29tcGlsZSB0aGUgdGVtcGxhdGVzIGludG8gJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJ3JlbmRlciBmdW5jdGlvbnMsIG9yIHVzZSB0aGUgY29tcGlsZXItaW5jbHVkZWQgYnVpbGQuJywgdm0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgd2FybiQyKCdGYWlsZWQgdG8gbW91bnQgY29tcG9uZW50OiB0ZW1wbGF0ZSBvciByZW5kZXIgZnVuY3Rpb24gbm90IGRlZmluZWQuJywgdm0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2FsbEhvb2skMSh2bSwgJ2JlZm9yZU1vdW50Jyk7XHJcbiAgICB2YXIgdXBkYXRlQ29tcG9uZW50O1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xyXG4gICAgICAgIHVwZGF0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIG5hbWUgPSB2bS5fbmFtZTtcclxuICAgICAgICAgICAgdmFyIGlkID0gdm0uX3VpZDtcclxuICAgICAgICAgICAgdmFyIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1zdGFydDpcIi5jb25jYXQoaWQpO1xyXG4gICAgICAgICAgICB2YXIgZW5kVGFnID0gXCJ2dWUtcGVyZi1lbmQ6XCIuY29uY2F0KGlkKTtcclxuICAgICAgICAgICAgbWFyayhzdGFydFRhZyk7XHJcbiAgICAgICAgICAgIHZhciB2bm9kZSA9IHZtLl9yZW5kZXIoKTtcclxuICAgICAgICAgICAgbWFyayhlbmRUYWcpO1xyXG4gICAgICAgICAgICBtZWFzdXJlKFwidnVlIFwiLmNvbmNhdChuYW1lLCBcIiByZW5kZXJcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xyXG4gICAgICAgICAgICBtYXJrKHN0YXJ0VGFnKTtcclxuICAgICAgICAgICAgdm0uX3VwZGF0ZSh2bm9kZSwgaHlkcmF0aW5nKTtcclxuICAgICAgICAgICAgbWFyayhlbmRUYWcpO1xyXG4gICAgICAgICAgICBtZWFzdXJlKFwidnVlIFwiLmNvbmNhdChuYW1lLCBcIiBwYXRjaFwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHVwZGF0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdm0uX3VwZGF0ZSh2bS5fcmVuZGVyKCksIGh5ZHJhdGluZyk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHZhciB3YXRjaGVyT3B0aW9ucyA9IHtcclxuICAgICAgICBiZWZvcmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHZtLl9pc01vdW50ZWQgJiYgIXZtLl9pc0Rlc3Ryb3llZCkge1xyXG4gICAgICAgICAgICAgICAgY2FsbEhvb2skMSh2bSwgJ2JlZm9yZVVwZGF0ZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgd2F0Y2hlck9wdGlvbnMub25UcmFjayA9IGZ1bmN0aW9uIChlKSB7IHJldHVybiBjYWxsSG9vayQxKHZtLCAncmVuZGVyVHJhY2tlZCcsIFtlXSk7IH07XHJcbiAgICAgICAgd2F0Y2hlck9wdGlvbnMub25UcmlnZ2VyID0gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGNhbGxIb29rJDEodm0sICdyZW5kZXJUcmlnZ2VyZWQnLCBbZV0pOyB9O1xyXG4gICAgfVxyXG4gICAgLy8gd2Ugc2V0IHRoaXMgdG8gdm0uX3dhdGNoZXIgaW5zaWRlIHRoZSB3YXRjaGVyJ3MgY29uc3RydWN0b3JcclxuICAgIC8vIHNpbmNlIHRoZSB3YXRjaGVyJ3MgaW5pdGlhbCBwYXRjaCBtYXkgY2FsbCAkZm9yY2VVcGRhdGUgKGUuZy4gaW5zaWRlIGNoaWxkXHJcbiAgICAvLyBjb21wb25lbnQncyBtb3VudGVkIGhvb2spLCB3aGljaCByZWxpZXMgb24gdm0uX3dhdGNoZXIgYmVpbmcgYWxyZWFkeSBkZWZpbmVkXHJcbiAgICBuZXcgV2F0Y2hlcih2bSwgdXBkYXRlQ29tcG9uZW50LCBub29wLCB3YXRjaGVyT3B0aW9ucywgdHJ1ZSAvKiBpc1JlbmRlcldhdGNoZXIgKi8pO1xyXG4gICAgaHlkcmF0aW5nID0gZmFsc2U7XHJcbiAgICAvLyBmbHVzaCBidWZmZXIgZm9yIGZsdXNoOiBcInByZVwiIHdhdGNoZXJzIHF1ZXVlZCBpbiBzZXR1cCgpXHJcbiAgICB2YXIgcHJlV2F0Y2hlcnMgPSB2bS5fcHJlV2F0Y2hlcnM7XHJcbiAgICBpZiAocHJlV2F0Y2hlcnMpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByZVdhdGNoZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHByZVdhdGNoZXJzW2ldLnJ1bigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIG1hbnVhbGx5IG1vdW50ZWQgaW5zdGFuY2UsIGNhbGwgbW91bnRlZCBvbiBzZWxmXHJcbiAgICAvLyBtb3VudGVkIGlzIGNhbGxlZCBmb3IgcmVuZGVyLWNyZWF0ZWQgY2hpbGQgY29tcG9uZW50cyBpbiBpdHMgaW5zZXJ0ZWQgaG9va1xyXG4gICAgaWYgKHZtLiR2bm9kZSA9PSBudWxsKSB7XHJcbiAgICAgICAgdm0uX2lzTW91bnRlZCA9IHRydWU7XHJcbiAgICAgICAgY2FsbEhvb2skMSh2bSwgJ21vdW50ZWQnKTtcclxuICAgIH1cclxuICAgIHJldHVybiB2bTtcclxufVxyXG5mdW5jdGlvbiB1cGRhdGVDaGlsZENvbXBvbmVudCh2bSwgcHJvcHNEYXRhLCBsaXN0ZW5lcnMsIHBhcmVudFZub2RlLCByZW5kZXJDaGlsZHJlbikge1xyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgY29tcG9uZW50IGhhcyBzbG90IGNoaWxkcmVuXHJcbiAgICAvLyB3ZSBuZWVkIHRvIGRvIHRoaXMgYmVmb3JlIG92ZXJ3cml0aW5nICRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbi5cclxuICAgIC8vIGNoZWNrIGlmIHRoZXJlIGFyZSBkeW5hbWljIHNjb3BlZFNsb3RzIChoYW5kLXdyaXR0ZW4gb3IgY29tcGlsZWQgYnV0IHdpdGhcclxuICAgIC8vIGR5bmFtaWMgc2xvdCBuYW1lcykuIFN0YXRpYyBzY29wZWQgc2xvdHMgY29tcGlsZWQgZnJvbSB0ZW1wbGF0ZSBoYXMgdGhlXHJcbiAgICAvLyBcIiRzdGFibGVcIiBtYXJrZXIuXHJcbiAgICB2YXIgbmV3U2NvcGVkU2xvdHMgPSBwYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzO1xyXG4gICAgdmFyIG9sZFNjb3BlZFNsb3RzID0gdm0uJHNjb3BlZFNsb3RzO1xyXG4gICAgdmFyIGhhc0R5bmFtaWNTY29wZWRTbG90ID0gISEoKG5ld1Njb3BlZFNsb3RzICYmICFuZXdTY29wZWRTbG90cy4kc3RhYmxlKSB8fFxyXG4gICAgICAgIChvbGRTY29wZWRTbG90cyAhPT0gZW1wdHlPYmplY3QgJiYgIW9sZFNjb3BlZFNsb3RzLiRzdGFibGUpIHx8XHJcbiAgICAgICAgKG5ld1Njb3BlZFNsb3RzICYmIHZtLiRzY29wZWRTbG90cy4ka2V5ICE9PSBuZXdTY29wZWRTbG90cy4ka2V5KSB8fFxyXG4gICAgICAgICghbmV3U2NvcGVkU2xvdHMgJiYgdm0uJHNjb3BlZFNsb3RzLiRrZXkpKTtcclxuICAgIC8vIEFueSBzdGF0aWMgc2xvdCBjaGlsZHJlbiBmcm9tIHRoZSBwYXJlbnQgbWF5IGhhdmUgY2hhbmdlZCBkdXJpbmcgcGFyZW50J3NcclxuICAgIC8vIHVwZGF0ZS4gRHluYW1pYyBzY29wZWQgc2xvdHMgbWF5IGFsc28gaGF2ZSBjaGFuZ2VkLiBJbiBzdWNoIGNhc2VzLCBhIGZvcmNlZFxyXG4gICAgLy8gdXBkYXRlIGlzIG5lY2Vzc2FyeSB0byBlbnN1cmUgY29ycmVjdG5lc3MuXHJcbiAgICB2YXIgbmVlZHNGb3JjZVVwZGF0ZSA9ICEhKHJlbmRlckNoaWxkcmVuIHx8IC8vIGhhcyBuZXcgc3RhdGljIHNsb3RzXHJcbiAgICAgICAgdm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuIHx8IC8vIGhhcyBvbGQgc3RhdGljIHNsb3RzXHJcbiAgICAgICAgaGFzRHluYW1pY1Njb3BlZFNsb3QpO1xyXG4gICAgdmFyIHByZXZWTm9kZSA9IHZtLiR2bm9kZTtcclxuICAgIHZtLiRvcHRpb25zLl9wYXJlbnRWbm9kZSA9IHBhcmVudFZub2RlO1xyXG4gICAgdm0uJHZub2RlID0gcGFyZW50Vm5vZGU7IC8vIHVwZGF0ZSB2bSdzIHBsYWNlaG9sZGVyIG5vZGUgd2l0aG91dCByZS1yZW5kZXJcclxuICAgIGlmICh2bS5fdm5vZGUpIHtcclxuICAgICAgICAvLyB1cGRhdGUgY2hpbGQgdHJlZSdzIHBhcmVudFxyXG4gICAgICAgIHZtLl92bm9kZS5wYXJlbnQgPSBwYXJlbnRWbm9kZTtcclxuICAgIH1cclxuICAgIHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiA9IHJlbmRlckNoaWxkcmVuO1xyXG4gICAgLy8gdXBkYXRlICRhdHRycyBhbmQgJGxpc3RlbmVycyBoYXNoXHJcbiAgICAvLyB0aGVzZSBhcmUgYWxzbyByZWFjdGl2ZSBzbyB0aGV5IG1heSB0cmlnZ2VyIGNoaWxkIHVwZGF0ZSBpZiB0aGUgY2hpbGRcclxuICAgIC8vIHVzZWQgdGhlbSBkdXJpbmcgcmVuZGVyXHJcbiAgICB2YXIgYXR0cnMgPSBwYXJlbnRWbm9kZS5kYXRhLmF0dHJzIHx8IGVtcHR5T2JqZWN0O1xyXG4gICAgaWYgKHZtLl9hdHRyc1Byb3h5KSB7XHJcbiAgICAgICAgLy8gZm9yY2UgdXBkYXRlIGlmIGF0dHJzIGFyZSBhY2Nlc3NlZCBhbmQgaGFzIGNoYW5nZWQgc2luY2UgaXQgbWF5IGJlXHJcbiAgICAgICAgLy8gcGFzc2VkIHRvIGEgY2hpbGQgY29tcG9uZW50LlxyXG4gICAgICAgIGlmIChzeW5jU2V0dXBQcm94eSh2bS5fYXR0cnNQcm94eSwgYXR0cnMsIChwcmV2Vk5vZGUuZGF0YSAmJiBwcmV2Vk5vZGUuZGF0YS5hdHRycykgfHwgZW1wdHlPYmplY3QsIHZtLCAnJGF0dHJzJykpIHtcclxuICAgICAgICAgICAgbmVlZHNGb3JjZVVwZGF0ZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdm0uJGF0dHJzID0gYXR0cnM7XHJcbiAgICAvLyB1cGRhdGUgbGlzdGVuZXJzXHJcbiAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3Q7XHJcbiAgICB2YXIgcHJldkxpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XHJcbiAgICBpZiAodm0uX2xpc3RlbmVyc1Byb3h5KSB7XHJcbiAgICAgICAgc3luY1NldHVwUHJveHkodm0uX2xpc3RlbmVyc1Byb3h5LCBsaXN0ZW5lcnMsIHByZXZMaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3QsIHZtLCAnJGxpc3RlbmVycycpO1xyXG4gICAgfVxyXG4gICAgdm0uJGxpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XHJcbiAgICB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycywgcHJldkxpc3RlbmVycyk7XHJcbiAgICAvLyB1cGRhdGUgcHJvcHNcclxuICAgIGlmIChwcm9wc0RhdGEgJiYgdm0uJG9wdGlvbnMucHJvcHMpIHtcclxuICAgICAgICB0b2dnbGVPYnNlcnZpbmcoZmFsc2UpO1xyXG4gICAgICAgIHZhciBwcm9wcyA9IHZtLl9wcm9wcztcclxuICAgICAgICB2YXIgcHJvcEtleXMgPSB2bS4kb3B0aW9ucy5fcHJvcEtleXMgfHwgW107XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wS2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIga2V5ID0gcHJvcEtleXNbaV07XHJcbiAgICAgICAgICAgIHZhciBwcm9wT3B0aW9ucyA9IHZtLiRvcHRpb25zLnByb3BzOyAvLyB3dGYgZmxvdz9cclxuICAgICAgICAgICAgcHJvcHNba2V5XSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BPcHRpb25zLCBwcm9wc0RhdGEsIHZtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xyXG4gICAgICAgIC8vIGtlZXAgYSBjb3B5IG9mIHJhdyBwcm9wc0RhdGFcclxuICAgICAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgPSBwcm9wc0RhdGE7XHJcbiAgICB9XHJcbiAgICAvLyByZXNvbHZlIHNsb3RzICsgZm9yY2UgdXBkYXRlIGlmIGhhcyBjaGlsZHJlblxyXG4gICAgaWYgKG5lZWRzRm9yY2VVcGRhdGUpIHtcclxuICAgICAgICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHMocmVuZGVyQ2hpbGRyZW4sIHBhcmVudFZub2RlLmNvbnRleHQpO1xyXG4gICAgICAgIHZtLiRmb3JjZVVwZGF0ZSgpO1xyXG4gICAgfVxyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSBmYWxzZTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpc0luSW5hY3RpdmVUcmVlKHZtKSB7XHJcbiAgICB3aGlsZSAodm0gJiYgKHZtID0gdm0uJHBhcmVudCkpIHtcclxuICAgICAgICBpZiAodm0uX2luYWN0aXZlKVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLCBkaXJlY3QpIHtcclxuICAgIGlmIChkaXJlY3QpIHtcclxuICAgICAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHZtLl9kaXJlY3RJbmFjdGl2ZSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICh2bS5faW5hY3RpdmUgfHwgdm0uX2luYWN0aXZlID09PSBudWxsKSB7XHJcbiAgICAgICAgdm0uX2luYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bS4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bS4kY2hpbGRyZW5baV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYWxsSG9vayQxKHZtLCAnYWN0aXZhdGVkJyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLCBkaXJlY3QpIHtcclxuICAgIGlmIChkaXJlY3QpIHtcclxuICAgICAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCF2bS5faW5hY3RpdmUpIHtcclxuICAgICAgICB2bS5faW5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm0uJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bS4kY2hpbGRyZW5baV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYWxsSG9vayQxKHZtLCAnZGVhY3RpdmF0ZWQnKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjYWxsSG9vayQxKHZtLCBob29rLCBhcmdzLCBzZXRDb250ZXh0KSB7XHJcbiAgICBpZiAoc2V0Q29udGV4dCA9PT0gdm9pZCAwKSB7IHNldENvbnRleHQgPSB0cnVlOyB9XHJcbiAgICAvLyAjNzU3MyBkaXNhYmxlIGRlcCBjb2xsZWN0aW9uIHdoZW4gaW52b2tpbmcgbGlmZWN5Y2xlIGhvb2tzXHJcbiAgICBwdXNoVGFyZ2V0KCk7XHJcbiAgICB2YXIgcHJldiA9IGN1cnJlbnRJbnN0YW5jZTtcclxuICAgIHNldENvbnRleHQgJiYgc2V0Q3VycmVudEluc3RhbmNlKHZtKTtcclxuICAgIHZhciBoYW5kbGVycyA9IHZtLiRvcHRpb25zW2hvb2tdO1xyXG4gICAgdmFyIGluZm8gPSBcIlwiLmNvbmNhdChob29rLCBcIiBob29rXCIpO1xyXG4gICAgaWYgKGhhbmRsZXJzKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSBoYW5kbGVycy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcclxuICAgICAgICAgICAgaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoaGFuZGxlcnNbaV0sIHZtLCBhcmdzIHx8IG51bGwsIHZtLCBpbmZvKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAodm0uX2hhc0hvb2tFdmVudCkge1xyXG4gICAgICAgIHZtLiRlbWl0KCdob29rOicgKyBob29rKTtcclxuICAgIH1cclxuICAgIHNldENvbnRleHQgJiYgc2V0Q3VycmVudEluc3RhbmNlKHByZXYpO1xyXG4gICAgcG9wVGFyZ2V0KCk7XHJcbn1cblxudmFyIE1BWF9VUERBVEVfQ09VTlQgPSAxMDA7XHJcbnZhciBxdWV1ZSA9IFtdO1xyXG52YXIgYWN0aXZhdGVkQ2hpbGRyZW4gPSBbXTtcclxudmFyIGhhcyA9IHt9O1xyXG52YXIgY2lyY3VsYXIgPSB7fTtcclxudmFyIHdhaXRpbmcgPSBmYWxzZTtcclxudmFyIGZsdXNoaW5nID0gZmFsc2U7XHJcbnZhciBpbmRleCQxID0gMDtcclxuLyoqXHJcbiAqIFJlc2V0IHRoZSBzY2hlZHVsZXIncyBzdGF0ZS5cclxuICovXHJcbmZ1bmN0aW9uIHJlc2V0U2NoZWR1bGVyU3RhdGUoKSB7XHJcbiAgICBpbmRleCQxID0gcXVldWUubGVuZ3RoID0gYWN0aXZhdGVkQ2hpbGRyZW4ubGVuZ3RoID0gMDtcclxuICAgIGhhcyA9IHt9O1xyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICBjaXJjdWxhciA9IHt9O1xyXG4gICAgfVxyXG4gICAgd2FpdGluZyA9IGZsdXNoaW5nID0gZmFsc2U7XHJcbn1cclxuLy8gQXN5bmMgZWRnZSBjYXNlICM2NTY2IHJlcXVpcmVzIHNhdmluZyB0aGUgdGltZXN0YW1wIHdoZW4gZXZlbnQgbGlzdGVuZXJzIGFyZVxyXG4vLyBhdHRhY2hlZC4gSG93ZXZlciwgY2FsbGluZyBwZXJmb3JtYW5jZS5ub3coKSBoYXMgYSBwZXJmIG92ZXJoZWFkIGVzcGVjaWFsbHlcclxuLy8gaWYgdGhlIHBhZ2UgaGFzIHRob3VzYW5kcyBvZiBldmVudCBsaXN0ZW5lcnMuIEluc3RlYWQsIHdlIHRha2UgYSB0aW1lc3RhbXBcclxuLy8gZXZlcnkgdGltZSB0aGUgc2NoZWR1bGVyIGZsdXNoZXMgYW5kIHVzZSB0aGF0IGZvciBhbGwgZXZlbnQgbGlzdGVuZXJzXHJcbi8vIGF0dGFjaGVkIGR1cmluZyB0aGF0IGZsdXNoLlxyXG52YXIgY3VycmVudEZsdXNoVGltZXN0YW1wID0gMDtcclxuLy8gQXN5bmMgZWRnZSBjYXNlIGZpeCByZXF1aXJlcyBzdG9yaW5nIGFuIGV2ZW50IGxpc3RlbmVyJ3MgYXR0YWNoIHRpbWVzdGFtcC5cclxudmFyIGdldE5vdyA9IERhdGUubm93O1xyXG4vLyBEZXRlcm1pbmUgd2hhdCBldmVudCB0aW1lc3RhbXAgdGhlIGJyb3dzZXIgaXMgdXNpbmcuIEFubm95aW5nbHksIHRoZVxyXG4vLyB0aW1lc3RhbXAgY2FuIGVpdGhlciBiZSBoaS1yZXMgKHJlbGF0aXZlIHRvIHBhZ2UgbG9hZCkgb3IgbG93LXJlc1xyXG4vLyAocmVsYXRpdmUgdG8gVU5JWCBlcG9jaCksIHNvIGluIG9yZGVyIHRvIGNvbXBhcmUgdGltZSB3ZSBoYXZlIHRvIHVzZSB0aGVcclxuLy8gc2FtZSB0aW1lc3RhbXAgdHlwZSB3aGVuIHNhdmluZyB0aGUgZmx1c2ggdGltZXN0YW1wLlxyXG4vLyBBbGwgSUUgdmVyc2lvbnMgdXNlIGxvdy1yZXMgZXZlbnQgdGltZXN0YW1wcywgYW5kIGhhdmUgcHJvYmxlbWF0aWMgY2xvY2tcclxuLy8gaW1wbGVtZW50YXRpb25zICgjOTYzMilcclxuaWYgKGluQnJvd3NlciAmJiAhaXNJRSkge1xyXG4gICAgdmFyIHBlcmZvcm1hbmNlXzEgPSB3aW5kb3cucGVyZm9ybWFuY2U7XHJcbiAgICBpZiAocGVyZm9ybWFuY2VfMSAmJlxyXG4gICAgICAgIHR5cGVvZiBwZXJmb3JtYW5jZV8xLm5vdyA9PT0gJ2Z1bmN0aW9uJyAmJlxyXG4gICAgICAgIGdldE5vdygpID4gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50JykudGltZVN0YW1wKSB7XHJcbiAgICAgICAgLy8gaWYgdGhlIGV2ZW50IHRpbWVzdGFtcCwgYWx0aG91Z2ggZXZhbHVhdGVkIEFGVEVSIHRoZSBEYXRlLm5vdygpLCBpc1xyXG4gICAgICAgIC8vIHNtYWxsZXIgdGhhbiBpdCwgaXQgbWVhbnMgdGhlIGV2ZW50IGlzIHVzaW5nIGEgaGktcmVzIHRpbWVzdGFtcCxcclxuICAgICAgICAvLyBhbmQgd2UgbmVlZCB0byB1c2UgdGhlIGhpLXJlcyB2ZXJzaW9uIGZvciBldmVudCBsaXN0ZW5lciB0aW1lc3RhbXBzIGFzXHJcbiAgICAgICAgLy8gd2VsbC5cclxuICAgICAgICBnZXROb3cgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBwZXJmb3JtYW5jZV8xLm5vdygpOyB9O1xyXG4gICAgfVxyXG59XHJcbnZhciBzb3J0Q29tcGFyZUZuID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgIGlmIChhLnBvc3QpIHtcclxuICAgICAgICBpZiAoIWIucG9zdClcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChiLnBvc3QpIHtcclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYS5pZCAtIGIuaWQ7XHJcbn07XHJcbi8qKlxyXG4gKiBGbHVzaCBib3RoIHF1ZXVlcyBhbmQgcnVuIHRoZSB3YXRjaGVycy5cclxuICovXHJcbmZ1bmN0aW9uIGZsdXNoU2NoZWR1bGVyUXVldWUoKSB7XHJcbiAgICBjdXJyZW50Rmx1c2hUaW1lc3RhbXAgPSBnZXROb3coKTtcclxuICAgIGZsdXNoaW5nID0gdHJ1ZTtcclxuICAgIHZhciB3YXRjaGVyLCBpZDtcclxuICAgIC8vIFNvcnQgcXVldWUgYmVmb3JlIGZsdXNoLlxyXG4gICAgLy8gVGhpcyBlbnN1cmVzIHRoYXQ6XHJcbiAgICAvLyAxLiBDb21wb25lbnRzIGFyZSB1cGRhdGVkIGZyb20gcGFyZW50IHRvIGNoaWxkLiAoYmVjYXVzZSBwYXJlbnQgaXMgYWx3YXlzXHJcbiAgICAvLyAgICBjcmVhdGVkIGJlZm9yZSB0aGUgY2hpbGQpXHJcbiAgICAvLyAyLiBBIGNvbXBvbmVudCdzIHVzZXIgd2F0Y2hlcnMgYXJlIHJ1biBiZWZvcmUgaXRzIHJlbmRlciB3YXRjaGVyIChiZWNhdXNlXHJcbiAgICAvLyAgICB1c2VyIHdhdGNoZXJzIGFyZSBjcmVhdGVkIGJlZm9yZSB0aGUgcmVuZGVyIHdhdGNoZXIpXHJcbiAgICAvLyAzLiBJZiBhIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQgZHVyaW5nIGEgcGFyZW50IGNvbXBvbmVudCdzIHdhdGNoZXIgcnVuLFxyXG4gICAgLy8gICAgaXRzIHdhdGNoZXJzIGNhbiBiZSBza2lwcGVkLlxyXG4gICAgcXVldWUuc29ydChzb3J0Q29tcGFyZUZuKTtcclxuICAgIC8vIGRvIG5vdCBjYWNoZSBsZW5ndGggYmVjYXVzZSBtb3JlIHdhdGNoZXJzIG1pZ2h0IGJlIHB1c2hlZFxyXG4gICAgLy8gYXMgd2UgcnVuIGV4aXN0aW5nIHdhdGNoZXJzXHJcbiAgICBmb3IgKGluZGV4JDEgPSAwOyBpbmRleCQxIDwgcXVldWUubGVuZ3RoOyBpbmRleCQxKyspIHtcclxuICAgICAgICB3YXRjaGVyID0gcXVldWVbaW5kZXgkMV07XHJcbiAgICAgICAgaWYgKHdhdGNoZXIuYmVmb3JlKSB7XHJcbiAgICAgICAgICAgIHdhdGNoZXIuYmVmb3JlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlkID0gd2F0Y2hlci5pZDtcclxuICAgICAgICBoYXNbaWRdID0gbnVsbDtcclxuICAgICAgICB3YXRjaGVyLnJ1bigpO1xyXG4gICAgICAgIC8vIGluIGRldiBidWlsZCwgY2hlY2sgYW5kIHN0b3AgY2lyY3VsYXIgdXBkYXRlcy5cclxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBoYXNbaWRdICE9IG51bGwpIHtcclxuICAgICAgICAgICAgY2lyY3VsYXJbaWRdID0gKGNpcmN1bGFyW2lkXSB8fCAwKSArIDE7XHJcbiAgICAgICAgICAgIGlmIChjaXJjdWxhcltpZF0gPiBNQVhfVVBEQVRFX0NPVU5UKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuJDIoJ1lvdSBtYXkgaGF2ZSBhbiBpbmZpbml0ZSB1cGRhdGUgbG9vcCAnICtcclxuICAgICAgICAgICAgICAgICAgICAod2F0Y2hlci51c2VyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gXCJpbiB3YXRjaGVyIHdpdGggZXhwcmVzc2lvbiBcXFwiXCIuY29uY2F0KHdhdGNoZXIuZXhwcmVzc2lvbiwgXCJcXFwiXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogXCJpbiBhIGNvbXBvbmVudCByZW5kZXIgZnVuY3Rpb24uXCIpLCB3YXRjaGVyLnZtKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8ga2VlcCBjb3BpZXMgb2YgcG9zdCBxdWV1ZXMgYmVmb3JlIHJlc2V0dGluZyBzdGF0ZVxyXG4gICAgdmFyIGFjdGl2YXRlZFF1ZXVlID0gYWN0aXZhdGVkQ2hpbGRyZW4uc2xpY2UoKTtcclxuICAgIHZhciB1cGRhdGVkUXVldWUgPSBxdWV1ZS5zbGljZSgpO1xyXG4gICAgcmVzZXRTY2hlZHVsZXJTdGF0ZSgpO1xyXG4gICAgLy8gY2FsbCBjb21wb25lbnQgdXBkYXRlZCBhbmQgYWN0aXZhdGVkIGhvb2tzXHJcbiAgICBjYWxsQWN0aXZhdGVkSG9va3MoYWN0aXZhdGVkUXVldWUpO1xyXG4gICAgY2FsbFVwZGF0ZWRIb29rcyh1cGRhdGVkUXVldWUpO1xyXG4gICAgLy8gZGV2dG9vbCBob29rXHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIGlmIChkZXZ0b29scyAmJiBjb25maWcuZGV2dG9vbHMpIHtcclxuICAgICAgICBkZXZ0b29scy5lbWl0KCdmbHVzaCcpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNhbGxVcGRhdGVkSG9va3MocXVldWUpIHtcclxuICAgIHZhciBpID0gcXVldWUubGVuZ3RoO1xyXG4gICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgIHZhciB3YXRjaGVyID0gcXVldWVbaV07XHJcbiAgICAgICAgdmFyIHZtID0gd2F0Y2hlci52bTtcclxuICAgICAgICBpZiAodm0gJiYgdm0uX3dhdGNoZXIgPT09IHdhdGNoZXIgJiYgdm0uX2lzTW91bnRlZCAmJiAhdm0uX2lzRGVzdHJveWVkKSB7XHJcbiAgICAgICAgICAgIGNhbGxIb29rJDEodm0sICd1cGRhdGVkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBRdWV1ZSBhIGtlcHQtYWxpdmUgY29tcG9uZW50IHRoYXQgd2FzIGFjdGl2YXRlZCBkdXJpbmcgcGF0Y2guXHJcbiAqIFRoZSBxdWV1ZSB3aWxsIGJlIHByb2Nlc3NlZCBhZnRlciB0aGUgZW50aXJlIHRyZWUgaGFzIGJlZW4gcGF0Y2hlZC5cclxuICovXHJcbmZ1bmN0aW9uIHF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50KHZtKSB7XHJcbiAgICAvLyBzZXR0aW5nIF9pbmFjdGl2ZSB0byBmYWxzZSBoZXJlIHNvIHRoYXQgYSByZW5kZXIgZnVuY3Rpb24gY2FuXHJcbiAgICAvLyByZWx5IG9uIGNoZWNraW5nIHdoZXRoZXIgaXQncyBpbiBhbiBpbmFjdGl2ZSB0cmVlIChlLmcuIHJvdXRlci12aWV3KVxyXG4gICAgdm0uX2luYWN0aXZlID0gZmFsc2U7XHJcbiAgICBhY3RpdmF0ZWRDaGlsZHJlbi5wdXNoKHZtKTtcclxufVxyXG5mdW5jdGlvbiBjYWxsQWN0aXZhdGVkSG9va3MocXVldWUpIHtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBxdWV1ZVtpXS5faW5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQocXVldWVbaV0sIHRydWUgLyogdHJ1ZSAqLyk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFB1c2ggYSB3YXRjaGVyIGludG8gdGhlIHdhdGNoZXIgcXVldWUuXHJcbiAqIEpvYnMgd2l0aCBkdXBsaWNhdGUgSURzIHdpbGwgYmUgc2tpcHBlZCB1bmxlc3MgaXQnc1xyXG4gKiBwdXNoZWQgd2hlbiB0aGUgcXVldWUgaXMgYmVpbmcgZmx1c2hlZC5cclxuICovXHJcbmZ1bmN0aW9uIHF1ZXVlV2F0Y2hlcih3YXRjaGVyKSB7XHJcbiAgICB2YXIgaWQgPSB3YXRjaGVyLmlkO1xyXG4gICAgaWYgKGhhc1tpZF0gIT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICh3YXRjaGVyID09PSBEZXAudGFyZ2V0ICYmIHdhdGNoZXIubm9SZWN1cnNlKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaGFzW2lkXSA9IHRydWU7XHJcbiAgICBpZiAoIWZsdXNoaW5nKSB7XHJcbiAgICAgICAgcXVldWUucHVzaCh3YXRjaGVyKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIGlmIGFscmVhZHkgZmx1c2hpbmcsIHNwbGljZSB0aGUgd2F0Y2hlciBiYXNlZCBvbiBpdHMgaWRcclxuICAgICAgICAvLyBpZiBhbHJlYWR5IHBhc3QgaXRzIGlkLCBpdCB3aWxsIGJlIHJ1biBuZXh0IGltbWVkaWF0ZWx5LlxyXG4gICAgICAgIHZhciBpID0gcXVldWUubGVuZ3RoIC0gMTtcclxuICAgICAgICB3aGlsZSAoaSA+IGluZGV4JDEgJiYgcXVldWVbaV0uaWQgPiB3YXRjaGVyLmlkKSB7XHJcbiAgICAgICAgICAgIGktLTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcXVldWUuc3BsaWNlKGkgKyAxLCAwLCB3YXRjaGVyKTtcclxuICAgIH1cclxuICAgIC8vIHF1ZXVlIHRoZSBmbHVzaFxyXG4gICAgaWYgKCF3YWl0aW5nKSB7XHJcbiAgICAgICAgd2FpdGluZyA9IHRydWU7XHJcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWNvbmZpZy5hc3luYykge1xyXG4gICAgICAgICAgICBmbHVzaFNjaGVkdWxlclF1ZXVlKCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbmV4dFRpY2soZmx1c2hTY2hlZHVsZXJRdWV1ZSk7XHJcbiAgICB9XHJcbn1cblxudmFyIFdBVENIRVIgPSBcIndhdGNoZXJcIjtcclxudmFyIFdBVENIRVJfQ0IgPSBcIlwiLmNvbmNhdChXQVRDSEVSLCBcIiBjYWxsYmFja1wiKTtcclxudmFyIFdBVENIRVJfR0VUVEVSID0gXCJcIi5jb25jYXQoV0FUQ0hFUiwgXCIgZ2V0dGVyXCIpO1xyXG52YXIgV0FUQ0hFUl9DTEVBTlVQID0gXCJcIi5jb25jYXQoV0FUQ0hFUiwgXCIgY2xlYW51cFwiKTtcclxuLy8gU2ltcGxlIGVmZmVjdC5cclxuZnVuY3Rpb24gd2F0Y2hFZmZlY3QoZWZmZWN0LCBvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gZG9XYXRjaChlZmZlY3QsIG51bGwsIG9wdGlvbnMpO1xyXG59XHJcbmZ1bmN0aW9uIHdhdGNoUG9zdEVmZmVjdChlZmZlY3QsIG9wdGlvbnMpIHtcclxuICAgIHJldHVybiBkb1dhdGNoKGVmZmVjdCwgbnVsbCwgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbidcclxuICAgICAgICA/IF9fYXNzaWduKF9fYXNzaWduKHt9LCBvcHRpb25zKSwgeyBmbHVzaDogJ3Bvc3QnIH0pIDogeyBmbHVzaDogJ3Bvc3QnIH0pKTtcclxufVxyXG5mdW5jdGlvbiB3YXRjaFN5bmNFZmZlY3QoZWZmZWN0LCBvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gZG9XYXRjaChlZmZlY3QsIG51bGwsIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nXHJcbiAgICAgICAgPyBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgb3B0aW9ucyksIHsgZmx1c2g6ICdzeW5jJyB9KSA6IHsgZmx1c2g6ICdzeW5jJyB9KSk7XHJcbn1cclxuLy8gaW5pdGlhbCB2YWx1ZSBmb3Igd2F0Y2hlcnMgdG8gdHJpZ2dlciBvbiB1bmRlZmluZWQgaW5pdGlhbCB2YWx1ZXNcclxudmFyIElOSVRJQUxfV0FUQ0hFUl9WQUxVRSA9IHt9O1xyXG4vLyBpbXBsZW1lbnRhdGlvblxyXG5mdW5jdGlvbiB3YXRjaChzb3VyY2UsIGNiLCBvcHRpb25zKSB7XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICB3YXJuJDIoXCJgd2F0Y2goZm4sIG9wdGlvbnM/KWAgc2lnbmF0dXJlIGhhcyBiZWVuIG1vdmVkIHRvIGEgc2VwYXJhdGUgQVBJLiBcIiArXHJcbiAgICAgICAgICAgIFwiVXNlIGB3YXRjaEVmZmVjdChmbiwgb3B0aW9ucz8pYCBpbnN0ZWFkLiBgd2F0Y2hgIG5vdyBvbmx5IFwiICtcclxuICAgICAgICAgICAgXCJzdXBwb3J0cyBgd2F0Y2goc291cmNlLCBjYiwgb3B0aW9ucz8pIHNpZ25hdHVyZS5cIik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZG9XYXRjaChzb3VyY2UsIGNiLCBvcHRpb25zKTtcclxufVxyXG5mdW5jdGlvbiBkb1dhdGNoKHNvdXJjZSwgY2IsIF9hKSB7XHJcbiAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8gZW1wdHlPYmplY3QgOiBfYSwgaW1tZWRpYXRlID0gX2IuaW1tZWRpYXRlLCBkZWVwID0gX2IuZGVlcCwgX2MgPSBfYi5mbHVzaCwgZmx1c2ggPSBfYyA9PT0gdm9pZCAwID8gJ3ByZScgOiBfYywgb25UcmFjayA9IF9iLm9uVHJhY2ssIG9uVHJpZ2dlciA9IF9iLm9uVHJpZ2dlcjtcclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFjYikge1xyXG4gICAgICAgIGlmIChpbW1lZGlhdGUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB3YXJuJDIoXCJ3YXRjaCgpIFxcXCJpbW1lZGlhdGVcXFwiIG9wdGlvbiBpcyBvbmx5IHJlc3BlY3RlZCB3aGVuIHVzaW5nIHRoZSBcIiArXHJcbiAgICAgICAgICAgICAgICBcIndhdGNoKHNvdXJjZSwgY2FsbGJhY2ssIG9wdGlvbnM/KSBzaWduYXR1cmUuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGVlcCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHdhcm4kMihcIndhdGNoKCkgXFxcImRlZXBcXFwiIG9wdGlvbiBpcyBvbmx5IHJlc3BlY3RlZCB3aGVuIHVzaW5nIHRoZSBcIiArXHJcbiAgICAgICAgICAgICAgICBcIndhdGNoKHNvdXJjZSwgY2FsbGJhY2ssIG9wdGlvbnM/KSBzaWduYXR1cmUuXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHZhciB3YXJuSW52YWxpZFNvdXJjZSA9IGZ1bmN0aW9uIChzKSB7XHJcbiAgICAgICAgd2FybiQyKFwiSW52YWxpZCB3YXRjaCBzb3VyY2U6IFwiLmNvbmNhdChzLCBcIi4gQSB3YXRjaCBzb3VyY2UgY2FuIG9ubHkgYmUgYSBnZXR0ZXIvZWZmZWN0IFwiKSArXHJcbiAgICAgICAgICAgIFwiZnVuY3Rpb24sIGEgcmVmLCBhIHJlYWN0aXZlIG9iamVjdCwgb3IgYW4gYXJyYXkgb2YgdGhlc2UgdHlwZXMuXCIpO1xyXG4gICAgfTtcclxuICAgIHZhciBpbnN0YW5jZSA9IGN1cnJlbnRJbnN0YW5jZTtcclxuICAgIHZhciBjYWxsID0gZnVuY3Rpb24gKGZuLCB0eXBlLCBhcmdzKSB7XHJcbiAgICAgICAgaWYgKGFyZ3MgPT09IHZvaWQgMCkgeyBhcmdzID0gbnVsbDsgfVxyXG4gICAgICAgIHJldHVybiBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhmbiwgbnVsbCwgYXJncywgaW5zdGFuY2UsIHR5cGUpO1xyXG4gICAgfTtcclxuICAgIHZhciBnZXR0ZXI7XHJcbiAgICB2YXIgZm9yY2VUcmlnZ2VyID0gZmFsc2U7XHJcbiAgICB2YXIgaXNNdWx0aVNvdXJjZSA9IGZhbHNlO1xyXG4gICAgaWYgKGlzUmVmKHNvdXJjZSkpIHtcclxuICAgICAgICBnZXR0ZXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBzb3VyY2UudmFsdWU7IH07XHJcbiAgICAgICAgZm9yY2VUcmlnZ2VyID0gaXNTaGFsbG93KHNvdXJjZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc1JlYWN0aXZlKHNvdXJjZSkpIHtcclxuICAgICAgICBnZXR0ZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHNvdXJjZS5fX29iX18uZGVwLmRlcGVuZCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gc291cmNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgZGVlcCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0FycmF5KHNvdXJjZSkpIHtcclxuICAgICAgICBpc011bHRpU291cmNlID0gdHJ1ZTtcclxuICAgICAgICBmb3JjZVRyaWdnZXIgPSBzb3VyY2Uuc29tZShmdW5jdGlvbiAocykgeyByZXR1cm4gaXNSZWFjdGl2ZShzKSB8fCBpc1NoYWxsb3cocyk7IH0pO1xyXG4gICAgICAgIGdldHRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5tYXAoZnVuY3Rpb24gKHMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc1JlZihzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNSZWFjdGl2ZShzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cmF2ZXJzZShzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24ocykpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbChzLCBXQVRDSEVSX0dFVFRFUik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm5JbnZhbGlkU291cmNlKHMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNGdW5jdGlvbihzb3VyY2UpKSB7XHJcbiAgICAgICAgaWYgKGNiKSB7XHJcbiAgICAgICAgICAgIC8vIGdldHRlciB3aXRoIGNiXHJcbiAgICAgICAgICAgIGdldHRlciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhbGwoc291cmNlLCBXQVRDSEVSX0dFVFRFUik7IH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBubyBjYiAtPiBzaW1wbGUgZWZmZWN0XHJcbiAgICAgICAgICAgIGdldHRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZSAmJiBpbnN0YW5jZS5faXNEZXN0cm95ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY2xlYW51cCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsZWFudXAoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsKHNvdXJjZSwgV0FUQ0hFUiwgW29uQ2xlYW51cF0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGdldHRlciA9IG5vb3A7XHJcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuSW52YWxpZFNvdXJjZShzb3VyY2UpO1xyXG4gICAgfVxyXG4gICAgaWYgKGNiICYmIGRlZXApIHtcclxuICAgICAgICB2YXIgYmFzZUdldHRlcl8xID0gZ2V0dGVyO1xyXG4gICAgICAgIGdldHRlciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRyYXZlcnNlKGJhc2VHZXR0ZXJfMSgpKTsgfTtcclxuICAgIH1cclxuICAgIHZhciBjbGVhbnVwO1xyXG4gICAgdmFyIG9uQ2xlYW51cCA9IGZ1bmN0aW9uIChmbikge1xyXG4gICAgICAgIGNsZWFudXAgPSB3YXRjaGVyLm9uU3RvcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY2FsbChmbiwgV0FUQ0hFUl9DTEVBTlVQKTtcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIC8vIGluIFNTUiB0aGVyZSBpcyBubyBuZWVkIHRvIHNldHVwIGFuIGFjdHVhbCBlZmZlY3QsIGFuZCBpdCBzaG91bGQgYmUgbm9vcFxyXG4gICAgLy8gdW5sZXNzIGl0J3MgZWFnZXJcclxuICAgIGlmIChpc1NlcnZlclJlbmRlcmluZygpKSB7XHJcbiAgICAgICAgLy8gd2Ugd2lsbCBhbHNvIG5vdCBjYWxsIHRoZSBpbnZhbGlkYXRlIGNhbGxiYWNrICgrIHJ1bm5lciBpcyBub3Qgc2V0IHVwKVxyXG4gICAgICAgIG9uQ2xlYW51cCA9IG5vb3A7XHJcbiAgICAgICAgaWYgKCFjYikge1xyXG4gICAgICAgICAgICBnZXR0ZXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaW1tZWRpYXRlKSB7XHJcbiAgICAgICAgICAgIGNhbGwoY2IsIFdBVENIRVJfQ0IsIFtcclxuICAgICAgICAgICAgICAgIGdldHRlcigpLFxyXG4gICAgICAgICAgICAgICAgaXNNdWx0aVNvdXJjZSA/IFtdIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgb25DbGVhbnVwXHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbm9vcDtcclxuICAgIH1cclxuICAgIHZhciB3YXRjaGVyID0gbmV3IFdhdGNoZXIoY3VycmVudEluc3RhbmNlLCBnZXR0ZXIsIG5vb3AsIHtcclxuICAgICAgICBsYXp5OiB0cnVlXHJcbiAgICB9KTtcclxuICAgIHdhdGNoZXIubm9SZWN1cnNlID0gIWNiO1xyXG4gICAgdmFyIG9sZFZhbHVlID0gaXNNdWx0aVNvdXJjZSA/IFtdIDogSU5JVElBTF9XQVRDSEVSX1ZBTFVFO1xyXG4gICAgLy8gb3ZlcndyaXRlIGRlZmF1bHQgcnVuXHJcbiAgICB3YXRjaGVyLnJ1biA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXdhdGNoZXIuYWN0aXZlICYmXHJcbiAgICAgICAgICAgICEoZmx1c2ggPT09ICdwcmUnICYmIGluc3RhbmNlICYmIGluc3RhbmNlLl9pc0JlaW5nRGVzdHJveWVkKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjYikge1xyXG4gICAgICAgICAgICAvLyB3YXRjaChzb3VyY2UsIGNiKVxyXG4gICAgICAgICAgICB2YXIgbmV3VmFsdWUgPSB3YXRjaGVyLmdldCgpO1xyXG4gICAgICAgICAgICBpZiAoZGVlcCB8fFxyXG4gICAgICAgICAgICAgICAgZm9yY2VUcmlnZ2VyIHx8XHJcbiAgICAgICAgICAgICAgICAoaXNNdWx0aVNvdXJjZVxyXG4gICAgICAgICAgICAgICAgICAgID8gbmV3VmFsdWUuc29tZShmdW5jdGlvbiAodiwgaSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFzQ2hhbmdlZCh2LCBvbGRWYWx1ZVtpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICA6IGhhc0NoYW5nZWQobmV3VmFsdWUsIG9sZFZhbHVlKSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIGNsZWFudXAgYmVmb3JlIHJ1bm5pbmcgY2IgYWdhaW5cclxuICAgICAgICAgICAgICAgIGlmIChjbGVhbnVwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xlYW51cCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2FsbChjYiwgV0FUQ0hFUl9DQiwgW1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHBhc3MgdW5kZWZpbmVkIGFzIHRoZSBvbGQgdmFsdWUgd2hlbiBpdCdzIGNoYW5nZWQgZm9yIHRoZSBmaXJzdCB0aW1lXHJcbiAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWUgPT09IElOSVRJQUxfV0FUQ0hFUl9WQUxVRSA/IHVuZGVmaW5lZCA6IG9sZFZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xlYW51cFxyXG4gICAgICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZSA9IG5ld1ZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyB3YXRjaEVmZmVjdFxyXG4gICAgICAgICAgICB3YXRjaGVyLmdldCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBpZiAoZmx1c2ggPT09ICdzeW5jJykge1xyXG4gICAgICAgIHdhdGNoZXIudXBkYXRlID0gd2F0Y2hlci5ydW47XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChmbHVzaCA9PT0gJ3Bvc3QnKSB7XHJcbiAgICAgICAgd2F0Y2hlci5wb3N0ID0gdHJ1ZTtcclxuICAgICAgICB3YXRjaGVyLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHF1ZXVlV2F0Y2hlcih3YXRjaGVyKTsgfTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIHByZVxyXG4gICAgICAgIHdhdGNoZXIudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoaW5zdGFuY2UgJiYgaW5zdGFuY2UgPT09IGN1cnJlbnRJbnN0YW5jZSAmJiAhaW5zdGFuY2UuX2lzTW91bnRlZCkge1xyXG4gICAgICAgICAgICAgICAgLy8gcHJlLXdhdGNoZXIgdHJpZ2dlcmVkIGJlZm9yZVxyXG4gICAgICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IGluc3RhbmNlLl9wcmVXYXRjaGVycyB8fCAoaW5zdGFuY2UuX3ByZVdhdGNoZXJzID0gW10pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGJ1ZmZlci5pbmRleE9mKHdhdGNoZXIpIDwgMClcclxuICAgICAgICAgICAgICAgICAgICBidWZmZXIucHVzaCh3YXRjaGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHF1ZXVlV2F0Y2hlcih3YXRjaGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgIHdhdGNoZXIub25UcmFjayA9IG9uVHJhY2s7XHJcbiAgICAgICAgd2F0Y2hlci5vblRyaWdnZXIgPSBvblRyaWdnZXI7XHJcbiAgICB9XHJcbiAgICAvLyBpbml0aWFsIHJ1blxyXG4gICAgaWYgKGNiKSB7XHJcbiAgICAgICAgaWYgKGltbWVkaWF0ZSkge1xyXG4gICAgICAgICAgICB3YXRjaGVyLnJ1bigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgb2xkVmFsdWUgPSB3YXRjaGVyLmdldCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGZsdXNoID09PSAncG9zdCcgJiYgaW5zdGFuY2UpIHtcclxuICAgICAgICBpbnN0YW5jZS4kb25jZSgnaG9vazptb3VudGVkJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gd2F0Y2hlci5nZXQoKTsgfSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB3YXRjaGVyLmdldCgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB3YXRjaGVyLnRlYXJkb3duKCk7XHJcbiAgICB9O1xyXG59XG5cbnZhciBhY3RpdmVFZmZlY3RTY29wZTtcclxudmFyIEVmZmVjdFNjb3BlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRWZmZWN0U2NvcGUoZGV0YWNoZWQpIHtcclxuICAgICAgICBpZiAoZGV0YWNoZWQgPT09IHZvaWQgMCkgeyBkZXRhY2hlZCA9IGZhbHNlOyB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGludGVybmFsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZWZmZWN0cyA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY2xlYW51cHMgPSBbXTtcclxuICAgICAgICBpZiAoIWRldGFjaGVkICYmIGFjdGl2ZUVmZmVjdFNjb3BlKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gYWN0aXZlRWZmZWN0U2NvcGU7XHJcbiAgICAgICAgICAgIHRoaXMuaW5kZXggPVxyXG4gICAgICAgICAgICAgICAgKGFjdGl2ZUVmZmVjdFNjb3BlLnNjb3BlcyB8fCAoYWN0aXZlRWZmZWN0U2NvcGUuc2NvcGVzID0gW10pKS5wdXNoKHRoaXMpIC0gMTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBFZmZlY3RTY29wZS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKGZuKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlKSB7XHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50RWZmZWN0U2NvcGUgPSBhY3RpdmVFZmZlY3RTY29wZTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGFjdGl2ZUVmZmVjdFNjb3BlID0gdGhpcztcclxuICAgICAgICAgICAgICAgIHJldHVybiBmbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgICAgYWN0aXZlRWZmZWN0U2NvcGUgPSBjdXJyZW50RWZmZWN0U2NvcGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgICB3YXJuJDIoXCJjYW5ub3QgcnVuIGFuIGluYWN0aXZlIGVmZmVjdCBzY29wZS5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gbm9uLWRldGFjaGVkIHNjb3Blc1xyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIEVmZmVjdFNjb3BlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBhY3RpdmVFZmZlY3RTY29wZSA9IHRoaXM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBub24tZGV0YWNoZWQgc2NvcGVzXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgRWZmZWN0U2NvcGUucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBhY3RpdmVFZmZlY3RTY29wZSA9IHRoaXMucGFyZW50O1xyXG4gICAgfTtcclxuICAgIEVmZmVjdFNjb3BlLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKGZyb21QYXJlbnQpIHtcclxuICAgICAgICBpZiAodGhpcy5hY3RpdmUpIHtcclxuICAgICAgICAgICAgdmFyIGkgPSB2b2lkIDAsIGwgPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLmVmZmVjdHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVmZmVjdHNbaV0udGVhcmRvd24oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gdGhpcy5jbGVhbnVwcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2xlYW51cHNbaV0oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5zY29wZXMpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLnNjb3Blcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjb3Blc1tpXS5zdG9wKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIG5lc3RlZCBzY29wZSwgZGVyZWZlcmVuY2UgZnJvbSBwYXJlbnQgdG8gYXZvaWQgbWVtb3J5IGxlYWtzXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudCAmJiAhZnJvbVBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgLy8gb3B0aW1pemVkIE8oMSkgcmVtb3ZhbFxyXG4gICAgICAgICAgICAgICAgdmFyIGxhc3QgPSB0aGlzLnBhcmVudC5zY29wZXMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAobGFzdCAmJiBsYXN0ICE9PSB0aGlzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuc2NvcGVzW3RoaXMuaW5kZXhdID0gbGFzdDtcclxuICAgICAgICAgICAgICAgICAgICBsYXN0LmluZGV4ID0gdGhpcy5pbmRleDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gRWZmZWN0U2NvcGU7XHJcbn0oKSk7XHJcbmZ1bmN0aW9uIGVmZmVjdFNjb3BlKGRldGFjaGVkKSB7XHJcbiAgICByZXR1cm4gbmV3IEVmZmVjdFNjb3BlKGRldGFjaGVkKTtcclxufVxyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiByZWNvcmRFZmZlY3RTY29wZShlZmZlY3QsIHNjb3BlKSB7XHJcbiAgICBpZiAoc2NvcGUgPT09IHZvaWQgMCkgeyBzY29wZSA9IGFjdGl2ZUVmZmVjdFNjb3BlOyB9XHJcbiAgICBpZiAoc2NvcGUgJiYgc2NvcGUuYWN0aXZlKSB7XHJcbiAgICAgICAgc2NvcGUuZWZmZWN0cy5wdXNoKGVmZmVjdCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0Q3VycmVudFNjb3BlKCkge1xyXG4gICAgcmV0dXJuIGFjdGl2ZUVmZmVjdFNjb3BlO1xyXG59XHJcbmZ1bmN0aW9uIG9uU2NvcGVEaXNwb3NlKGZuKSB7XHJcbiAgICBpZiAoYWN0aXZlRWZmZWN0U2NvcGUpIHtcclxuICAgICAgICBhY3RpdmVFZmZlY3RTY29wZS5jbGVhbnVwcy5wdXNoKGZuKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICB3YXJuJDIoXCJvblNjb3BlRGlzcG9zZSgpIGlzIGNhbGxlZCB3aGVuIHRoZXJlIGlzIG5vIGFjdGl2ZSBlZmZlY3Qgc2NvcGVcIiArXHJcbiAgICAgICAgICAgIFwiIHRvIGJlIGFzc29jaWF0ZWQgd2l0aC5cIik7XHJcbiAgICB9XHJcbn1cblxuZnVuY3Rpb24gcHJvdmlkZShrZXksIHZhbHVlKSB7XHJcbiAgICBpZiAoIWN1cnJlbnRJbnN0YW5jZSkge1xyXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHdhcm4kMihcInByb3ZpZGUoKSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSBzZXR1cCgpLlwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBUUyBkb2Vzbid0IGFsbG93IHN5bWJvbCBhcyBpbmRleCB0eXBlXHJcbiAgICAgICAgcmVzb2x2ZVByb3ZpZGVkKGN1cnJlbnRJbnN0YW5jZSlba2V5XSA9IHZhbHVlO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHJlc29sdmVQcm92aWRlZCh2bSkge1xyXG4gICAgLy8gYnkgZGVmYXVsdCBhbiBpbnN0YW5jZSBpbmhlcml0cyBpdHMgcGFyZW50J3MgcHJvdmlkZXMgb2JqZWN0XHJcbiAgICAvLyBidXQgd2hlbiBpdCBuZWVkcyB0byBwcm92aWRlIHZhbHVlcyBvZiBpdHMgb3duLCBpdCBjcmVhdGVzIGl0c1xyXG4gICAgLy8gb3duIHByb3ZpZGVzIG9iamVjdCB1c2luZyBwYXJlbnQgcHJvdmlkZXMgb2JqZWN0IGFzIHByb3RvdHlwZS5cclxuICAgIC8vIHRoaXMgd2F5IGluIGBpbmplY3RgIHdlIGNhbiBzaW1wbHkgbG9vayB1cCBpbmplY3Rpb25zIGZyb20gZGlyZWN0XHJcbiAgICAvLyBwYXJlbnQgYW5kIGxldCB0aGUgcHJvdG90eXBlIGNoYWluIGRvIHRoZSB3b3JrLlxyXG4gICAgdmFyIGV4aXN0aW5nID0gdm0uX3Byb3ZpZGVkO1xyXG4gICAgdmFyIHBhcmVudFByb3ZpZGVzID0gdm0uJHBhcmVudCAmJiB2bS4kcGFyZW50Ll9wcm92aWRlZDtcclxuICAgIGlmIChwYXJlbnRQcm92aWRlcyA9PT0gZXhpc3RpbmcpIHtcclxuICAgICAgICByZXR1cm4gKHZtLl9wcm92aWRlZCA9IE9iamVjdC5jcmVhdGUocGFyZW50UHJvdmlkZXMpKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBleGlzdGluZztcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpbmplY3Qoa2V5LCBkZWZhdWx0VmFsdWUsIHRyZWF0RGVmYXVsdEFzRmFjdG9yeSkge1xyXG4gICAgaWYgKHRyZWF0RGVmYXVsdEFzRmFjdG9yeSA9PT0gdm9pZCAwKSB7IHRyZWF0RGVmYXVsdEFzRmFjdG9yeSA9IGZhbHNlOyB9XHJcbiAgICAvLyBmYWxsYmFjayB0byBgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlYCBzbyB0aGF0IHRoaXMgY2FuIGJlIGNhbGxlZCBpblxyXG4gICAgLy8gYSBmdW5jdGlvbmFsIGNvbXBvbmVudFxyXG4gICAgdmFyIGluc3RhbmNlID0gY3VycmVudEluc3RhbmNlO1xyXG4gICAgaWYgKGluc3RhbmNlKSB7XHJcbiAgICAgICAgLy8gIzI0MDBcclxuICAgICAgICAvLyB0byBzdXBwb3J0IGBhcHAudXNlYCBwbHVnaW5zLFxyXG4gICAgICAgIC8vIGZhbGxiYWNrIHRvIGFwcENvbnRleHQncyBgcHJvdmlkZXNgIGlmIHRoZSBpbnN0YW5jZSBpcyBhdCByb290XHJcbiAgICAgICAgdmFyIHByb3ZpZGVzID0gaW5zdGFuY2UuJHBhcmVudCAmJiBpbnN0YW5jZS4kcGFyZW50Ll9wcm92aWRlZDtcclxuICAgICAgICBpZiAocHJvdmlkZXMgJiYga2V5IGluIHByb3ZpZGVzKSB7XHJcbiAgICAgICAgICAgIC8vIFRTIGRvZXNuJ3QgYWxsb3cgc3ltYm9sIGFzIGluZGV4IHR5cGVcclxuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVzW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cmVhdERlZmF1bHRBc0ZhY3RvcnkgJiYgaXNGdW5jdGlvbihkZWZhdWx0VmFsdWUpXHJcbiAgICAgICAgICAgICAgICA/IGRlZmF1bHRWYWx1ZS5jYWxsKGluc3RhbmNlKVxyXG4gICAgICAgICAgICAgICAgOiBkZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgICAgd2FybiQyKFwiaW5qZWN0aW9uIFxcXCJcIi5jb25jYXQoU3RyaW5nKGtleSksIFwiXFxcIiBub3QgZm91bmQuXCIpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgd2FybiQyKFwiaW5qZWN0KCkgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgc2V0dXAoKSBvciBmdW5jdGlvbmFsIGNvbXBvbmVudHMuXCIpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAaW50ZXJuYWwgdGhpcyBmdW5jdGlvbiBuZWVkcyBtYW51YWwgcHVibGljIHR5cGUgZGVjbGFyYXRpb24gYmVjYXVzZSBpdCByZWxpZXNcclxuICogb24gcHJldmlvdXNseSBtYW51YWxseSBhdXRob3JlZCB0eXBlcyBmcm9tIFZ1ZSAyXHJcbiAqL1xyXG5mdW5jdGlvbiBoKHR5cGUsIHByb3BzLCBjaGlsZHJlbikge1xyXG4gICAgaWYgKCFjdXJyZW50SW5zdGFuY2UpIHtcclxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXHJcbiAgICAgICAgICAgIHdhcm4kMihcImdsb2JhbGx5IGltcG9ydGVkIGgoKSBjYW4gb25seSBiZSBpbnZva2VkIHdoZW4gdGhlcmUgaXMgYW4gYWN0aXZlIFwiICtcclxuICAgICAgICAgICAgICAgIFwiY29tcG9uZW50IGluc3RhbmNlLCBlLmcuIHN5bmNocm9ub3VzbHkgaW4gYSBjb21wb25lbnQncyByZW5kZXIgb3Igc2V0dXAgZnVuY3Rpb24uXCIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQkMShjdXJyZW50SW5zdGFuY2UsIHR5cGUsIHByb3BzLCBjaGlsZHJlbiwgMiwgdHJ1ZSk7XHJcbn1cblxuZnVuY3Rpb24gaGFuZGxlRXJyb3IoZXJyLCB2bSwgaW5mbykge1xyXG4gICAgLy8gRGVhY3RpdmF0ZSBkZXBzIHRyYWNraW5nIHdoaWxlIHByb2Nlc3NpbmcgZXJyb3IgaGFuZGxlciB0byBhdm9pZCBwb3NzaWJsZSBpbmZpbml0ZSByZW5kZXJpbmcuXHJcbiAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWV4L2lzc3Vlcy8xNTA1XHJcbiAgICBwdXNoVGFyZ2V0KCk7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGlmICh2bSkge1xyXG4gICAgICAgICAgICB2YXIgY3VyID0gdm07XHJcbiAgICAgICAgICAgIHdoaWxlICgoY3VyID0gY3VyLiRwYXJlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaG9va3MgPSBjdXIuJG9wdGlvbnMuZXJyb3JDYXB0dXJlZDtcclxuICAgICAgICAgICAgICAgIGlmIChob29rcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYXB0dXJlID0gaG9va3NbaV0uY2FsbChjdXIsIGVyciwgdm0sIGluZm8pID09PSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYXB0dXJlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2xvYmFsSGFuZGxlRXJyb3IoZSwgY3VyLCAnZXJyb3JDYXB0dXJlZCBob29rJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZ2xvYmFsSGFuZGxlRXJyb3IoZXJyLCB2bSwgaW5mbyk7XHJcbiAgICB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICBwb3BUYXJnZXQoKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhoYW5kbGVyLCBjb250ZXh0LCBhcmdzLCB2bSwgaW5mbykge1xyXG4gICAgdmFyIHJlcztcclxuICAgIHRyeSB7XHJcbiAgICAgICAgcmVzID0gYXJncyA/IGhhbmRsZXIuYXBwbHkoY29udGV4dCwgYXJncykgOiBoYW5kbGVyLmNhbGwoY29udGV4dCk7XHJcbiAgICAgICAgaWYgKHJlcyAmJiAhcmVzLl9pc1Z1ZSAmJiBpc1Byb21pc2UocmVzKSAmJiAhcmVzLl9oYW5kbGVkKSB7XHJcbiAgICAgICAgICAgIHJlcy5jYXRjaChmdW5jdGlvbiAoZSkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZSwgdm0sIGluZm8gKyBcIiAoUHJvbWlzZS9hc3luYylcIik7IH0pO1xyXG4gICAgICAgICAgICByZXMuX2hhbmRsZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIGluZm8pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG5mdW5jdGlvbiBnbG9iYWxIYW5kbGVFcnJvcihlcnIsIHZtLCBpbmZvKSB7XHJcbiAgICBpZiAoY29uZmlnLmVycm9ySGFuZGxlcikge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb25maWcuZXJyb3JIYW5kbGVyLmNhbGwobnVsbCwgZXJyLCB2bSwgaW5mbyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIC8vIGlmIHRoZSB1c2VyIGludGVudGlvbmFsbHkgdGhyb3dzIHRoZSBvcmlnaW5hbCBlcnJvciBpbiB0aGUgaGFuZGxlcixcclxuICAgICAgICAgICAgLy8gZG8gbm90IGxvZyBpdCB0d2ljZVxyXG4gICAgICAgICAgICBpZiAoZSAhPT0gZXJyKSB7XHJcbiAgICAgICAgICAgICAgICBsb2dFcnJvcihlLCBudWxsLCAnY29uZmlnLmVycm9ySGFuZGxlcicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbG9nRXJyb3IoZXJyLCB2bSwgaW5mbyk7XHJcbn1cclxuZnVuY3Rpb24gbG9nRXJyb3IoZXJyLCB2bSwgaW5mbykge1xyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICB3YXJuJDIoXCJFcnJvciBpbiBcIi5jb25jYXQoaW5mbywgXCI6IFxcXCJcIikuY29uY2F0KGVyci50b1N0cmluZygpLCBcIlxcXCJcIiksIHZtKTtcclxuICAgIH1cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXHJcbiAgICBpZiAoaW5Ccm93c2VyICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHRocm93IGVycjtcclxuICAgIH1cclxufVxuXG4vKiBnbG9iYWxzIE11dGF0aW9uT2JzZXJ2ZXIgKi9cclxudmFyIGlzVXNpbmdNaWNyb1Rhc2sgPSBmYWxzZTtcclxudmFyIGNhbGxiYWNrcyA9IFtdO1xyXG52YXIgcGVuZGluZyA9IGZhbHNlO1xyXG5mdW5jdGlvbiBmbHVzaENhbGxiYWNrcygpIHtcclxuICAgIHBlbmRpbmcgPSBmYWxzZTtcclxuICAgIHZhciBjb3BpZXMgPSBjYWxsYmFja3Muc2xpY2UoMCk7XHJcbiAgICBjYWxsYmFja3MubGVuZ3RoID0gMDtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29waWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29waWVzW2ldKCk7XHJcbiAgICB9XHJcbn1cclxuLy8gSGVyZSB3ZSBoYXZlIGFzeW5jIGRlZmVycmluZyB3cmFwcGVycyB1c2luZyBtaWNyb3Rhc2tzLlxyXG4vLyBJbiAyLjUgd2UgdXNlZCAobWFjcm8pIHRhc2tzIChpbiBjb21iaW5hdGlvbiB3aXRoIG1pY3JvdGFza3MpLlxyXG4vLyBIb3dldmVyLCBpdCBoYXMgc3VidGxlIHByb2JsZW1zIHdoZW4gc3RhdGUgaXMgY2hhbmdlZCByaWdodCBiZWZvcmUgcmVwYWludFxyXG4vLyAoZS5nLiAjNjgxMywgb3V0LWluIHRyYW5zaXRpb25zKS5cclxuLy8gQWxzbywgdXNpbmcgKG1hY3JvKSB0YXNrcyBpbiBldmVudCBoYW5kbGVyIHdvdWxkIGNhdXNlIHNvbWUgd2VpcmQgYmVoYXZpb3JzXHJcbi8vIHRoYXQgY2Fubm90IGJlIGNpcmN1bXZlbnRlZCAoZS5nLiAjNzEwOSwgIzcxNTMsICM3NTQ2LCAjNzgzNCwgIzgxMDkpLlxyXG4vLyBTbyB3ZSBub3cgdXNlIG1pY3JvdGFza3MgZXZlcnl3aGVyZSwgYWdhaW4uXHJcbi8vIEEgbWFqb3IgZHJhd2JhY2sgb2YgdGhpcyB0cmFkZW9mZiBpcyB0aGF0IHRoZXJlIGFyZSBzb21lIHNjZW5hcmlvc1xyXG4vLyB3aGVyZSBtaWNyb3Rhc2tzIGhhdmUgdG9vIGhpZ2ggYSBwcmlvcml0eSBhbmQgZmlyZSBpbiBiZXR3ZWVuIHN1cHBvc2VkbHlcclxuLy8gc2VxdWVudGlhbCBldmVudHMgKGUuZy4gIzQ1MjEsICM2NjkwLCB3aGljaCBoYXZlIHdvcmthcm91bmRzKVxyXG4vLyBvciBldmVuIGJldHdlZW4gYnViYmxpbmcgb2YgdGhlIHNhbWUgZXZlbnQgKCM2NTY2KS5cclxudmFyIHRpbWVyRnVuYztcclxuLy8gVGhlIG5leHRUaWNrIGJlaGF2aW9yIGxldmVyYWdlcyB0aGUgbWljcm90YXNrIHF1ZXVlLCB3aGljaCBjYW4gYmUgYWNjZXNzZWRcclxuLy8gdmlhIGVpdGhlciBuYXRpdmUgUHJvbWlzZS50aGVuIG9yIE11dGF0aW9uT2JzZXJ2ZXIuXHJcbi8vIE11dGF0aW9uT2JzZXJ2ZXIgaGFzIHdpZGVyIHN1cHBvcnQsIGhvd2V2ZXIgaXQgaXMgc2VyaW91c2x5IGJ1Z2dlZCBpblxyXG4vLyBVSVdlYlZpZXcgaW4gaU9TID49IDkuMy4zIHdoZW4gdHJpZ2dlcmVkIGluIHRvdWNoIGV2ZW50IGhhbmRsZXJzLiBJdFxyXG4vLyBjb21wbGV0ZWx5IHN0b3BzIHdvcmtpbmcgYWZ0ZXIgdHJpZ2dlcmluZyBhIGZldyB0aW1lcy4uLiBzbywgaWYgbmF0aXZlXHJcbi8vIFByb21pc2UgaXMgYXZhaWxhYmxlLCB3ZSB3aWxsIHVzZSBpdDpcclxuLyogaXN0YW5idWwgaWdub3JlIG5leHQsICRmbG93LWRpc2FibGUtbGluZSAqL1xyXG5pZiAodHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFByb21pc2UpKSB7XHJcbiAgICB2YXIgcF8xID0gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcF8xLnRoZW4oZmx1c2hDYWxsYmFja3MpO1xyXG4gICAgICAgIC8vIEluIHByb2JsZW1hdGljIFVJV2ViVmlld3MsIFByb21pc2UudGhlbiBkb2Vzbid0IGNvbXBsZXRlbHkgYnJlYWssIGJ1dFxyXG4gICAgICAgIC8vIGl0IGNhbiBnZXQgc3R1Y2sgaW4gYSB3ZWlyZCBzdGF0ZSB3aGVyZSBjYWxsYmFja3MgYXJlIHB1c2hlZCBpbnRvIHRoZVxyXG4gICAgICAgIC8vIG1pY3JvdGFzayBxdWV1ZSBidXQgdGhlIHF1ZXVlIGlzbid0IGJlaW5nIGZsdXNoZWQsIHVudGlsIHRoZSBicm93c2VyXHJcbiAgICAgICAgLy8gbmVlZHMgdG8gZG8gc29tZSBvdGhlciB3b3JrLCBlLmcuIGhhbmRsZSBhIHRpbWVyLiBUaGVyZWZvcmUgd2UgY2FuXHJcbiAgICAgICAgLy8gXCJmb3JjZVwiIHRoZSBtaWNyb3Rhc2sgcXVldWUgdG8gYmUgZmx1c2hlZCBieSBhZGRpbmcgYW4gZW1wdHkgdGltZXIuXHJcbiAgICAgICAgaWYgKGlzSU9TKVxyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KG5vb3ApO1xyXG4gICAgfTtcclxuICAgIGlzVXNpbmdNaWNyb1Rhc2sgPSB0cnVlO1xyXG59XHJcbmVsc2UgaWYgKCFpc0lFICYmXHJcbiAgICB0eXBlb2YgTXV0YXRpb25PYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgIChpc05hdGl2ZShNdXRhdGlvbk9ic2VydmVyKSB8fFxyXG4gICAgICAgIC8vIFBoYW50b21KUyBhbmQgaU9TIDcueFxyXG4gICAgICAgIE11dGF0aW9uT2JzZXJ2ZXIudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgTXV0YXRpb25PYnNlcnZlckNvbnN0cnVjdG9yXScpKSB7XHJcbiAgICAvLyBVc2UgTXV0YXRpb25PYnNlcnZlciB3aGVyZSBuYXRpdmUgUHJvbWlzZSBpcyBub3QgYXZhaWxhYmxlLFxyXG4gICAgLy8gZS5nLiBQaGFudG9tSlMsIGlPUzcsIEFuZHJvaWQgNC40XHJcbiAgICAvLyAoIzY0NjYgTXV0YXRpb25PYnNlcnZlciBpcyB1bnJlbGlhYmxlIGluIElFMTEpXHJcbiAgICB2YXIgY291bnRlcl8xID0gMTtcclxuICAgIHZhciBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGZsdXNoQ2FsbGJhY2tzKTtcclxuICAgIHZhciB0ZXh0Tm9kZV8xID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKGNvdW50ZXJfMSkpO1xyXG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZSh0ZXh0Tm9kZV8xLCB7XHJcbiAgICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY291bnRlcl8xID0gKGNvdW50ZXJfMSArIDEpICUgMjtcclxuICAgICAgICB0ZXh0Tm9kZV8xLmRhdGEgPSBTdHJpbmcoY291bnRlcl8xKTtcclxuICAgIH07XHJcbiAgICBpc1VzaW5nTWljcm9UYXNrID0gdHJ1ZTtcclxufVxyXG5lbHNlIGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShzZXRJbW1lZGlhdGUpKSB7XHJcbiAgICAvLyBGYWxsYmFjayB0byBzZXRJbW1lZGlhdGUuXHJcbiAgICAvLyBUZWNobmljYWxseSBpdCBsZXZlcmFnZXMgdGhlIChtYWNybykgdGFzayBxdWV1ZSxcclxuICAgIC8vIGJ1dCBpdCBpcyBzdGlsbCBhIGJldHRlciBjaG9pY2UgdGhhbiBzZXRUaW1lb3V0LlxyXG4gICAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHNldEltbWVkaWF0ZShmbHVzaENhbGxiYWNrcyk7XHJcbiAgICB9O1xyXG59XHJcbmVsc2Uge1xyXG4gICAgLy8gRmFsbGJhY2sgdG8gc2V0VGltZW91dC5cclxuICAgIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBzZXRUaW1lb3V0KGZsdXNoQ2FsbGJhY2tzLCAwKTtcclxuICAgIH07XHJcbn1cclxuLyoqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gbmV4dFRpY2soY2IsIGN0eCkge1xyXG4gICAgdmFyIF9yZXNvbHZlO1xyXG4gICAgY2FsbGJhY2tzLnB1c2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChjYikge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgY2IuY2FsbChjdHgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcihlLCBjdHgsICduZXh0VGljaycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKF9yZXNvbHZlKSB7XHJcbiAgICAgICAgICAgIF9yZXNvbHZlKGN0eCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBpZiAoIXBlbmRpbmcpIHtcclxuICAgICAgICBwZW5kaW5nID0gdHJ1ZTtcclxuICAgICAgICB0aW1lckZ1bmMoKTtcclxuICAgIH1cclxuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxyXG4gICAgaWYgKCFjYiAmJiB0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcclxuICAgICAgICAgICAgX3Jlc29sdmUgPSByZXNvbHZlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XG5cbmZ1bmN0aW9uIHVzZUNzc01vZHVsZShuYW1lKSB7XHJcbiAgICBpZiAobmFtZSA9PT0gdm9pZCAwKSB7IG5hbWUgPSAnJHN0eWxlJzsgfVxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cclxuICAgIHtcclxuICAgICAgICBpZiAoIWN1cnJlbnRJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4kMihcInVzZUNzc01vZHVsZSBtdXN0IGJlIGNhbGxlZCBpbnNpZGUgc2V0dXAoKVwiKTtcclxuICAgICAgICAgICAgcmV0dXJuIGVtcHR5T2JqZWN0O1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbW9kID0gY3VycmVudEluc3RhbmNlW25hbWVdO1xyXG4gICAgICAgIGlmICghbW9kKSB7XHJcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcclxuICAgICAgICAgICAgICAgIHdhcm4kMihcIkN1cnJlbnQgaW5zdGFuY2UgZG9lcyBub3QgaGF2ZSBDU1MgbW9kdWxlIG5hbWVkIFxcXCJcIi5jb25jYXQobmFtZSwgXCJcXFwiLlwiKSk7XHJcbiAgICAgICAgICAgIHJldHVybiBlbXB0eU9iamVjdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1vZDtcclxuICAgIH1cclxufVxuXG4vKipcclxuICogUnVudGltZSBoZWxwZXIgZm9yIFNGQydzIENTUyB2YXJpYWJsZSBpbmplY3Rpb24gZmVhdHVyZS5cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHVzZUNzc1ZhcnMoZ2V0dGVyKSB7XHJcbiAgICBpZiAoIWluQnJvd3NlciAmJiAhZmFsc2UpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgdmFyIGluc3RhbmNlID0gY3VycmVudEluc3RhbmNlO1xyXG4gICAgaWYgKCFpbnN0YW5jZSkge1xyXG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcclxuICAgICAgICAgICAgd2FybiQyKFwidXNlQ3NzVmFycyBpcyBjYWxsZWQgd2l0aG91dCBjdXJyZW50IGFjdGl2ZSBjb21wb25lbnQgaW5zdGFuY2UuXCIpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHdhdGNoUG9zdEVmZmVjdChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGVsID0gaW5zdGFuY2UuJGVsO1xyXG4gICAgICAgIHZhciB2YXJzID0gZ2V0dGVyKGluc3RhbmNlLCBpbnN0YW5jZS5fc2V0dXBQcm94eSk7XHJcbiAgICAgICAgaWYgKGVsICYmIGVsLm5vZGVUeXBlID09PSAxKSB7XHJcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IGVsLnN0eWxlO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gdmFycykge1xyXG4gICAgICAgICAgICAgICAgc3R5bGUuc2V0UHJvcGVydHkoXCItLVwiLmNvbmNhdChrZXkpLCB2YXJzW2tleV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cblxuLyoqXHJcbiAqIHYzLWNvbXBhdGlibGUgYXN5bmMgY29tcG9uZW50IEFQSS5cclxuICogQGludGVybmFsIHRoZSB0eXBlIGlzIG1hbnVhbGx5IGRlY2xhcmVkIGluIDxyb290Pi90eXBlcy92My1kZWZpbmUtYXN5bmMtY29tcG9uZW50LmQudHNcclxuICogYmVjYXVzZSBpdCByZWxpZXMgb24gZXhpc3RpbmcgbWFudWFsIHR5cGVzXHJcbiAqL1xyXG5mdW5jdGlvbiBkZWZpbmVBc3luY0NvbXBvbmVudChzb3VyY2UpIHtcclxuICAgIGlmIChpc0Z1bmN0aW9uKHNvdXJjZSkpIHtcclxuICAgICAgICBzb3VyY2UgPSB7IGxvYWRlcjogc291cmNlIH07XHJcbiAgICB9XHJcbiAgICB2YXIgbG9hZGVyID0gc291cmNlLmxvYWRlciwgbG9hZGluZ0NvbXBvbmVudCA9IHNvdXJjZS5sb2FkaW5nQ29tcG9uZW50LCBlcnJvckNvbXBvbmVudCA9IHNvdXJjZS5lcnJvckNvbXBvbmVudCwgX2EgPSBzb3VyY2UuZGVsYXksIGRlbGF5ID0gX2EgPT09IHZvaWQgMCA/IDIwMCA6IF9hLCB0aW1lb3V0ID0gc291cmNlLnRpbWVvdXQsIC8vIHVuZGVmaW5lZCA9IG5ldmVyIHRpbWVzIG91dFxyXG4gICAgX2IgPSBzb3VyY2Uuc3VzcGVuc2libGUsIC8vIHVuZGVmaW5lZCA9IG5ldmVyIHRpbWVzIG91dFxyXG4gICAgc3VzcGVuc2libGUgPSBfYiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYiwgLy8gaW4gVnVlIDMgZGVmYXVsdCBpcyB0cnVlXHJcbiAgICB1c2VyT25FcnJvciA9IHNvdXJjZS5vbkVycm9yO1xyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgc3VzcGVuc2libGUpIHtcclxuICAgICAgICB3YXJuJDIoXCJUaGUgc3VzcGVuc2libGJlIG9wdGlvbiBmb3IgYXN5bmMgY29tcG9uZW50cyBpcyBub3Qgc3VwcG9ydGVkIGluIFZ1ZTIuIEl0IGlzIGlnbm9yZWQuXCIpO1xyXG4gICAgfVxyXG4gICAgdmFyIHBlbmRpbmdSZXF1ZXN0ID0gbnVsbDtcclxuICAgIHZhciByZXRyaWVzID0gMDtcclxuICAgIHZhciByZXRyeSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXRyaWVzKys7XHJcbiAgICAgICAgcGVuZGluZ1JlcXVlc3QgPSBudWxsO1xyXG4gICAgICAgIHJldHVybiBsb2FkKCk7XHJcbiAgICB9O1xyXG4gICAgdmFyIGxvYWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHRoaXNSZXF1ZXN0O1xyXG4gICAgICAgIHJldHVybiAocGVuZGluZ1JlcXVlc3QgfHxcclxuICAgICAgICAgICAgKHRoaXNSZXF1ZXN0ID0gcGVuZGluZ1JlcXVlc3QgPVxyXG4gICAgICAgICAgICAgICAgbG9hZGVyKClcclxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIGVyciA9IGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyIDogbmV3IEVycm9yKFN0cmluZyhlcnIpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodXNlck9uRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1c2VyUmV0cnkgPSBmdW5jdGlvbiAoKSB7IHJldHVybiByZXNvbHZlKHJldHJ5KCkpOyB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVzZXJGYWlsID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVqZWN0KGVycik7IH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VyT25FcnJvcihlcnIsIHVzZXJSZXRyeSwgdXNlckZhaWwsIHJldHJpZXMgKyAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoY29tcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzUmVxdWVzdCAhPT0gcGVuZGluZ1JlcXVlc3QgJiYgcGVuZGluZ1JlcXVlc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBlbmRpbmdSZXF1ZXN0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhY29tcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuJDIoXCJBc3luYyBjb21wb25lbnQgbG9hZGVyIHJlc29sdmVkIHRvIHVuZGVmaW5lZC4gXCIgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJJZiB5b3UgYXJlIHVzaW5nIHJldHJ5KCksIG1ha2Ugc3VyZSB0byByZXR1cm4gaXRzIHJldHVybiB2YWx1ZS5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGludGVyb3AgbW9kdWxlIGRlZmF1bHRcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcCAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoY29tcC5fX2VzTW9kdWxlIHx8IGNvbXBbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ01vZHVsZScpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXAgPSBjb21wLmRlZmF1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbXAgJiYgIWlzT2JqZWN0KGNvbXApICYmICFpc0Z1bmN0aW9uKGNvbXApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYXN5bmMgY29tcG9uZW50IGxvYWQgcmVzdWx0OiBcIi5jb25jYXQoY29tcCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tcDtcclxuICAgICAgICAgICAgICAgIH0pKSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY29tcG9uZW50ID0gbG9hZCgpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGNvbXBvbmVudDogY29tcG9uZW50LFxyXG4gICAgICAgICAgICBkZWxheTogZGVsYXksXHJcbiAgICAgICAgICAgIHRpbWVvdXQ6IHRpbWVvdXQsXHJcbiAgICAgICAgICAgIGVycm9yOiBlcnJvckNvbXBvbmVudCxcclxuICAgICAgICAgICAgbG9hZGluZzogbG9hZGluZ0NvbXBvbmVudFxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpZmVDeWNsZShob29rTmFtZSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChmbiwgdGFyZ2V0KSB7XHJcbiAgICAgICAgaWYgKHRhcmdldCA9PT0gdm9pZCAwKSB7IHRhcmdldCA9IGN1cnJlbnRJbnN0YW5jZTsgfVxyXG4gICAgICAgIGlmICghdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcclxuICAgICAgICAgICAgICAgIHdhcm4kMihcIlwiLmNvbmNhdChmb3JtYXROYW1lKGhvb2tOYW1lKSwgXCIgaXMgY2FsbGVkIHdoZW4gdGhlcmUgaXMgbm8gYWN0aXZlIGNvbXBvbmVudCBpbnN0YW5jZSB0byBiZSBcIikgK1xyXG4gICAgICAgICAgICAgICAgICAgIFwiYXNzb2NpYXRlZCB3aXRoLiBcIiArXHJcbiAgICAgICAgICAgICAgICAgICAgXCJMaWZlY3ljbGUgaW5qZWN0aW9uIEFQSXMgY2FuIG9ubHkgYmUgdXNlZCBkdXJpbmcgZXhlY3V0aW9uIG9mIHNldHVwKCkuXCIpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpbmplY3RIb29rKHRhcmdldCwgaG9va05hbWUsIGZuKTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gZm9ybWF0TmFtZShuYW1lKSB7XHJcbiAgICBpZiAobmFtZSA9PT0gJ2JlZm9yZURlc3Ryb3knKSB7XHJcbiAgICAgICAgbmFtZSA9ICdiZWZvcmVVbm1vdW50JztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG5hbWUgPT09ICdkZXN0cm95ZWQnKSB7XHJcbiAgICAgICAgbmFtZSA9ICd1bm1vdW50ZWQnO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFwib25cIi5jb25jYXQobmFtZVswXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKSk7XHJcbn1cclxuZnVuY3Rpb24gaW5qZWN0SG9vayhpbnN0YW5jZSwgaG9va05hbWUsIGZuKSB7XHJcbiAgICB2YXIgb3B0aW9ucyA9IGluc3RhbmNlLiRvcHRpb25zO1xyXG4gICAgb3B0aW9uc1tob29rTmFtZV0gPSBtZXJnZUxpZmVjeWNsZUhvb2sob3B0aW9uc1tob29rTmFtZV0sIGZuKTtcclxufVxyXG52YXIgb25CZWZvcmVNb3VudCA9IGNyZWF0ZUxpZmVDeWNsZSgnYmVmb3JlTW91bnQnKTtcclxudmFyIG9uTW91bnRlZCA9IGNyZWF0ZUxpZmVDeWNsZSgnbW91bnRlZCcpO1xyXG52YXIgb25CZWZvcmVVcGRhdGUgPSBjcmVhdGVMaWZlQ3ljbGUoJ2JlZm9yZVVwZGF0ZScpO1xyXG52YXIgb25VcGRhdGVkID0gY3JlYXRlTGlmZUN5Y2xlKCd1cGRhdGVkJyk7XHJcbnZhciBvbkJlZm9yZVVubW91bnQgPSBjcmVhdGVMaWZlQ3ljbGUoJ2JlZm9yZURlc3Ryb3knKTtcclxudmFyIG9uVW5tb3VudGVkID0gY3JlYXRlTGlmZUN5Y2xlKCdkZXN0cm95ZWQnKTtcclxudmFyIG9uRXJyb3JDYXB0dXJlZCA9IGNyZWF0ZUxpZmVDeWNsZSgnZXJyb3JDYXB0dXJlZCcpO1xyXG52YXIgb25BY3RpdmF0ZWQgPSBjcmVhdGVMaWZlQ3ljbGUoJ2FjdGl2YXRlZCcpO1xyXG52YXIgb25EZWFjdGl2YXRlZCA9IGNyZWF0ZUxpZmVDeWNsZSgnZGVhY3RpdmF0ZWQnKTtcclxudmFyIG9uU2VydmVyUHJlZmV0Y2ggPSBjcmVhdGVMaWZlQ3ljbGUoJ3NlcnZlclByZWZldGNoJyk7XHJcbnZhciBvblJlbmRlclRyYWNrZWQgPSBjcmVhdGVMaWZlQ3ljbGUoJ3JlbmRlclRyYWNrZWQnKTtcclxudmFyIG9uUmVuZGVyVHJpZ2dlcmVkID0gY3JlYXRlTGlmZUN5Y2xlKCdyZW5kZXJUcmlnZ2VyZWQnKTtcblxuLyoqXHJcbiAqIE5vdGU6IGFsc28gdXBkYXRlIGRpc3QvdnVlLnJ1bnRpbWUubWpzIHdoZW4gYWRkaW5nIG5ldyBleHBvcnRzIHRvIHRoaXMgZmlsZS5cclxuICovXHJcbnZhciB2ZXJzaW9uID0gJzIuNy44JztcclxuLyoqXHJcbiAqIEBpbnRlcm5hbCB0eXBlIGlzIG1hbnVhbGx5IGRlY2xhcmVkIGluIDxyb290Pi90eXBlcy92My1kZWZpbmUtY29tcG9uZW50LmQudHNcclxuICovXHJcbmZ1bmN0aW9uIGRlZmluZUNvbXBvbmVudChvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gb3B0aW9ucztcclxufVxuXG52YXIgc2Vlbk9iamVjdHMgPSBuZXcgX1NldCgpO1xyXG4vKipcclxuICogUmVjdXJzaXZlbHkgdHJhdmVyc2UgYW4gb2JqZWN0IHRvIGV2b2tlIGFsbCBjb252ZXJ0ZWRcclxuICogZ2V0dGVycywgc28gdGhhdCBldmVyeSBuZXN0ZWQgcHJvcGVydHkgaW5zaWRlIHRoZSBvYmplY3RcclxuICogaXMgY29sbGVjdGVkIGFzIGEgXCJkZWVwXCIgZGVwZW5kZW5jeS5cclxuICovXHJcbmZ1bmN0aW9uIHRyYXZlcnNlKHZhbCkge1xyXG4gICAgX3RyYXZlcnNlKHZhbCwgc2Vlbk9iamVjdHMpO1xyXG4gICAgc2Vlbk9iamVjdHMuY2xlYXIoKTtcclxuICAgIHJldHVybiB2YWw7XHJcbn1cclxuZnVuY3Rpb24gX3RyYXZlcnNlKHZhbCwgc2Vlbikge1xyXG4gICAgdmFyIGksIGtleXM7XHJcbiAgICB2YXIgaXNBID0gaXNBcnJheSh2YWwpO1xyXG4gICAgaWYgKCghaXNBICYmICFpc09iamVjdCh2YWwpKSB8fFxyXG4gICAgICAgIE9iamVjdC5pc0Zyb3plbih2YWwpIHx8XHJcbiAgICAgICAgdmFsIGluc3RhbmNlb2YgVk5vZGUpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAodmFsLl9fb2JfXykge1xyXG4gICAgICAgIHZhciBkZXBJZCA9IHZhbC5fX29iX18uZGVwLmlkO1xyXG4gICAgICAgIGlmIChzZWVuLmhhcyhkZXBJZCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZWVuLmFkZChkZXBJZCk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNBKSB7XHJcbiAgICAgICAgaSA9IHZhbC5sZW5ndGg7XHJcbiAgICAgICAgd2hpbGUgKGktLSlcclxuICAgICAgICAgICAgX3RyYXZlcnNlKHZhbFtpXSwgc2Vlbik7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc1JlZih2YWwpKSB7XHJcbiAgICAgICAgX3RyYXZlcnNlKHZhbC52YWx1ZSwgc2Vlbik7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcclxuICAgICAgICBpID0ga2V5cy5sZW5ndGg7XHJcbiAgICAgICAgd2hpbGUgKGktLSlcclxuICAgICAgICAgICAgX3RyYXZlcnNlKHZhbFtrZXlzW2ldXSwgc2Vlbik7XHJcbiAgICB9XHJcbn1cblxudmFyIHVpZCQxID0gMDtcclxuLyoqXHJcbiAqIEEgd2F0Y2hlciBwYXJzZXMgYW4gZXhwcmVzc2lvbiwgY29sbGVjdHMgZGVwZW5kZW5jaWVzLFxyXG4gKiBhbmQgZmlyZXMgY2FsbGJhY2sgd2hlbiB0aGUgZXhwcmVzc2lvbiB2YWx1ZSBjaGFuZ2VzLlxyXG4gKiBUaGlzIGlzIHVzZWQgZm9yIGJvdGggdGhlICR3YXRjaCgpIGFwaSBhbmQgZGlyZWN0aXZlcy5cclxuICogQGludGVybmFsXHJcbiAqL1xyXG52YXIgV2F0Y2hlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zLCBpc1JlbmRlcldhdGNoZXIpIHtcclxuICAgICAgICByZWNvcmRFZmZlY3RTY29wZSh0aGlzLCBhY3RpdmVFZmZlY3RTY29wZSB8fCAodm0gPyB2bS5fc2NvcGUgOiB1bmRlZmluZWQpKTtcclxuICAgICAgICBpZiAoKHRoaXMudm0gPSB2bSkpIHtcclxuICAgICAgICAgICAgaWYgKGlzUmVuZGVyV2F0Y2hlcikge1xyXG4gICAgICAgICAgICAgICAgdm0uX3dhdGNoZXIgPSB0aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIG9wdGlvbnNcclxuICAgICAgICBpZiAob3B0aW9ucykge1xyXG4gICAgICAgICAgICB0aGlzLmRlZXAgPSAhIW9wdGlvbnMuZGVlcDtcclxuICAgICAgICAgICAgdGhpcy51c2VyID0gISFvcHRpb25zLnVzZXI7XHJcbiAgICAgICAgICAgIHRoaXMubGF6eSA9ICEhb3B0aW9ucy5sYXp5O1xyXG4gICAgICAgICAgICB0aGlzLnN5bmMgPSAhIW9wdGlvbnMuc3luYztcclxuICAgICAgICAgICAgdGhpcy5iZWZvcmUgPSBvcHRpb25zLmJlZm9yZTtcclxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub25UcmFjayA9IG9wdGlvbnMub25UcmFjaztcclxuICAgICAgICAgICAgICAgIHRoaXMub25UcmlnZ2VyID0gb3B0aW9ucy5vblRyaWdnZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGVlcCA9IHRoaXMudXNlciA9IHRoaXMubGF6eSA9IHRoaXMuc3luYyA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNiID0gY2I7XHJcbiAgICAgICAgdGhpcy5pZCA9ICsrdWlkJDE7IC8vIHVpZCBmb3IgYmF0Y2hpbmdcclxuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5wb3N0ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRoaXMubGF6eTsgLy8gZm9yIGxhenkgd2F0Y2hlcnNcclxuICAgICAgICB0aGlzLmRlcHMgPSBbXTtcclxuICAgICAgICB0aGlzLm5ld0RlcHMgPSBbXTtcclxuICAgICAgICB0aGlzLmRlcElkcyA9IG5ldyBfU2V0KCk7XHJcbiAgICAgICAgdGhpcy5uZXdEZXBJZHMgPSBuZXcgX1NldCgpO1xyXG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBleHBPckZuLnRvU3RyaW5nKCkgOiAnJztcclxuICAgICAgICAvLyBwYXJzZSBleHByZXNzaW9uIGZvciBnZXR0ZXJcclxuICAgICAgICBpZiAoaXNGdW5jdGlvbihleHBPckZuKSkge1xyXG4gICAgICAgICAgICB0aGlzLmdldHRlciA9IGV4cE9yRm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmdldHRlciA9IHBhcnNlUGF0aChleHBPckZuKTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmdldHRlcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nZXR0ZXIgPSBub29wO1xyXG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4kMihcIkZhaWxlZCB3YXRjaGluZyBwYXRoOiBcXFwiXCIuY29uY2F0KGV4cE9yRm4sIFwiXFxcIiBcIikgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnV2F0Y2hlciBvbmx5IGFjY2VwdHMgc2ltcGxlIGRvdC1kZWxpbWl0ZWQgcGF0aHMuICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnRm9yIGZ1bGwgY29udHJvbCwgdXNlIGEgZnVuY3Rpb24gaW5zdGVhZC4nLCB2bSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMubGF6eSA/IHVuZGVmaW5lZCA6IHRoaXMuZ2V0KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEV2YWx1YXRlIHRoZSBnZXR0ZXIsIGFuZCByZS1jb2xsZWN0IGRlcGVuZGVuY2llcy5cclxuICAgICAqL1xyXG4gICAgV2F0Y2hlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHB1c2hUYXJnZXQodGhpcyk7XHJcbiAgICAgICAgdmFyIHZhbHVlO1xyXG4gICAgICAgIHZhciB2bSA9IHRoaXMudm07XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmdldHRlci5jYWxsKHZtLCB2bSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnVzZXIpIHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcImdldHRlciBmb3Igd2F0Y2hlciBcXFwiXCIuY29uY2F0KHRoaXMuZXhwcmVzc2lvbiwgXCJcXFwiXCIpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgIC8vIFwidG91Y2hcIiBldmVyeSBwcm9wZXJ0eSBzbyB0aGV5IGFyZSBhbGwgdHJhY2tlZCBhc1xyXG4gICAgICAgICAgICAvLyBkZXBlbmRlbmNpZXMgZm9yIGRlZXAgd2F0Y2hpbmdcclxuICAgICAgICAgICAgaWYgKHRoaXMuZGVlcCkge1xyXG4gICAgICAgICAgICAgICAgdHJhdmVyc2UodmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHBvcFRhcmdldCgpO1xyXG4gICAgICAgICAgICB0aGlzLmNsZWFudXBEZXBzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhIGRlcGVuZGVuY3kgdG8gdGhpcyBkaXJlY3RpdmUuXHJcbiAgICAgKi9cclxuICAgIFdhdGNoZXIucHJvdG90eXBlLmFkZERlcCA9IGZ1bmN0aW9uIChkZXApIHtcclxuICAgICAgICB2YXIgaWQgPSBkZXAuaWQ7XHJcbiAgICAgICAgaWYgKCF0aGlzLm5ld0RlcElkcy5oYXMoaWQpKSB7XHJcbiAgICAgICAgICAgIHRoaXMubmV3RGVwSWRzLmFkZChpZCk7XHJcbiAgICAgICAgICAgIHRoaXMubmV3RGVwcy5wdXNoKGRlcCk7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5kZXBJZHMuaGFzKGlkKSkge1xyXG4gICAgICAgICAgICAgICAgZGVwLmFkZFN1Yih0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENsZWFuIHVwIGZvciBkZXBlbmRlbmN5IGNvbGxlY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIFdhdGNoZXIucHJvdG90eXBlLmNsZWFudXBEZXBzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcclxuICAgICAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgICAgIHZhciBkZXAgPSB0aGlzLmRlcHNbaV07XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5uZXdEZXBJZHMuaGFzKGRlcC5pZCkpIHtcclxuICAgICAgICAgICAgICAgIGRlcC5yZW1vdmVTdWIodGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHRtcCA9IHRoaXMuZGVwSWRzO1xyXG4gICAgICAgIHRoaXMuZGVwSWRzID0gdGhpcy5uZXdEZXBJZHM7XHJcbiAgICAgICAgdGhpcy5uZXdEZXBJZHMgPSB0bXA7XHJcbiAgICAgICAgdGhpcy5uZXdEZXBJZHMuY2xlYXIoKTtcclxuICAgICAgICB0bXAgPSB0aGlzLmRlcHM7XHJcbiAgICAgICAgdGhpcy5kZXBzID0gdGhpcy5uZXdEZXBzO1xyXG4gICAgICAgIHRoaXMubmV3RGVwcyA9IHRtcDtcclxuICAgICAgICB0aGlzLm5ld0RlcHMubGVuZ3RoID0gMDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFN1YnNjcmliZXIgaW50ZXJmYWNlLlxyXG4gICAgICogV2lsbCBiZSBjYWxsZWQgd2hlbiBhIGRlcGVuZGVuY3kgY2hhbmdlcy5cclxuICAgICAqL1xyXG4gICAgV2F0Y2hlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXHJcbiAgICAgICAgaWYgKHRoaXMubGF6eSkge1xyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5zeW5jKSB7XHJcbiAgICAgICAgICAgIHRoaXMucnVuKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBxdWV1ZVdhdGNoZXIodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU2NoZWR1bGVyIGpvYiBpbnRlcmZhY2UuXHJcbiAgICAgKiBXaWxsIGJlIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyLlxyXG4gICAgICovXHJcbiAgICBXYXRjaGVyLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlKSB7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KCk7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy52YWx1ZSB8fFxyXG4gICAgICAgICAgICAgICAgLy8gRGVlcCB3YXRjaGVycyBhbmQgd2F0Y2hlcnMgb24gT2JqZWN0L0FycmF5cyBzaG91bGQgZmlyZSBldmVuXHJcbiAgICAgICAgICAgICAgICAvLyB3aGVuIHRoZSB2YWx1ZSBpcyB0aGUgc2FtZSwgYmVjYXVzZSB0aGUgdmFsdWUgbWF5XHJcbiAgICAgICAgICAgICAgICAvLyBoYXZlIG11dGF0ZWQuXHJcbiAgICAgICAgICAgICAgICBpc09iamVjdCh2YWx1ZSkgfHxcclxuICAgICAgICAgICAgICAgIHRoaXMuZGVlcCkge1xyXG4gICAgICAgICAgICAgICAgLy8gc2V0IG5ldyB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgdmFyIG9sZFZhbHVlID0gdGhpcy52YWx1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnVzZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5mbyA9IFwiY2FsbGJhY2sgZm9yIHdhdGNoZXIgXFxcIlwiLmNvbmNhdCh0aGlzLmV4cHJlc3Npb24sIFwiXFxcIlwiKTtcclxuICAgICAgICAgICAgICAgICAgICBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyh0aGlzLmNiLCB0aGlzLnZtLCBbdmFsdWUsIG9sZFZhbHVlXSwgdGhpcy52bSwgaW5mbyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEV2YWx1YXRlIHRoZSB2YWx1ZSBvZiB0aGUgd2F0Y2hlci5cclxuICAgICAqIFRoaXMgb25seSBnZXRzIGNhbGxlZCBmb3IgbGF6eSB3YXRjaGVycy5cclxuICAgICAqL1xyXG4gICAgV2F0Y2hlci5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuZ2V0KCk7XHJcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRGVwZW5kIG9uIGFsbCBkZXBzIGNvbGxlY3RlZCBieSB0aGlzIHdhdGNoZXIuXHJcbiAgICAgKi9cclxuICAgIFdhdGNoZXIucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XHJcbiAgICAgICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgICAgICB0aGlzLmRlcHNbaV0uZGVwZW5kKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlIHNlbGYgZnJvbSBhbGwgZGVwZW5kZW5jaWVzJyBzdWJzY3JpYmVyIGxpc3QuXHJcbiAgICAgKi9cclxuICAgIFdhdGNoZXIucHJvdG90eXBlLnRlYXJkb3duID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnZtICYmICF0aGlzLnZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XHJcbiAgICAgICAgICAgIHJlbW92ZSQyKHRoaXMudm0uX3Njb3BlLmVmZmVjdHMsIHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5hY3RpdmUpIHtcclxuICAgICAgICAgICAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xyXG4gICAgICAgICAgICB3aGlsZSAoaS0tKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlcHNbaV0ucmVtb3ZlU3ViKHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9uU3RvcCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vblN0b3AoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gV2F0Y2hlcjtcclxufSgpKTtcblxudmFyIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbiA9IHtcclxuICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICBnZXQ6IG5vb3AsXHJcbiAgICBzZXQ6IG5vb3BcclxufTtcclxuZnVuY3Rpb24gcHJveHkodGFyZ2V0LCBzb3VyY2VLZXksIGtleSkge1xyXG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IGZ1bmN0aW9uIHByb3h5R2V0dGVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzW3NvdXJjZUtleV1ba2V5XTtcclxuICAgIH07XHJcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gZnVuY3Rpb24gcHJveHlTZXR0ZXIodmFsKSB7XHJcbiAgICAgICAgdGhpc1tzb3VyY2VLZXldW2tleV0gPSB2YWw7XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24pO1xyXG59XHJcbmZ1bmN0aW9uIGluaXRTdGF0ZSh2bSkge1xyXG4gICAgdmFyIG9wdHMgPSB2bS4kb3B0aW9ucztcclxuICAgIGlmIChvcHRzLnByb3BzKVxyXG4gICAgICAgIGluaXRQcm9wcyQxKHZtLCBvcHRzLnByb3BzKTtcclxuICAgIC8vIENvbXBvc2l0aW9uIEFQSVxyXG4gICAgaW5pdFNldHVwKHZtKTtcclxuICAgIGlmIChvcHRzLm1ldGhvZHMpXHJcbiAgICAgICAgaW5pdE1ldGhvZHModm0sIG9wdHMubWV0aG9kcyk7XHJcbiAgICBpZiAob3B0cy5kYXRhKSB7XHJcbiAgICAgICAgaW5pdERhdGEodm0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdmFyIG9iID0gb2JzZXJ2ZSgodm0uX2RhdGEgPSB7fSkpO1xyXG4gICAgICAgIG9iICYmIG9iLnZtQ291bnQrKztcclxuICAgIH1cclxuICAgIGlmIChvcHRzLmNvbXB1dGVkKVxyXG4gICAgICAgIGluaXRDb21wdXRlZCQxKHZtLCBvcHRzLmNvbXB1dGVkKTtcclxuICAgIGlmIChvcHRzLndhdGNoICYmIG9wdHMud2F0Y2ggIT09IG5hdGl2ZVdhdGNoKSB7XHJcbiAgICAgICAgaW5pdFdhdGNoKHZtLCBvcHRzLndhdGNoKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpbml0UHJvcHMkMSh2bSwgcHJvcHNPcHRpb25zKSB7XHJcbiAgICB2YXIgcHJvcHNEYXRhID0gdm0uJG9wdGlvbnMucHJvcHNEYXRhIHx8IHt9O1xyXG4gICAgdmFyIHByb3BzID0gKHZtLl9wcm9wcyA9IHNoYWxsb3dSZWFjdGl2ZSh7fSkpO1xyXG4gICAgLy8gY2FjaGUgcHJvcCBrZXlzIHNvIHRoYXQgZnV0dXJlIHByb3BzIHVwZGF0ZXMgY2FuIGl0ZXJhdGUgdXNpbmcgQXJyYXlcclxuICAgIC8vIGluc3RlYWQgb2YgZHluYW1pYyBvYmplY3Qga2V5IGVudW1lcmF0aW9uLlxyXG4gICAgdmFyIGtleXMgPSAodm0uJG9wdGlvbnMuX3Byb3BLZXlzID0gW10pO1xyXG4gICAgdmFyIGlzUm9vdCA9ICF2bS4kcGFyZW50O1xyXG4gICAgLy8gcm9vdCBpbnN0YW5jZSBwcm9wcyBzaG91bGQgYmUgY29udmVydGVkXHJcbiAgICBpZiAoIWlzUm9vdCkge1xyXG4gICAgICAgIHRvZ2dsZU9ic2VydmluZyhmYWxzZSk7XHJcbiAgICB9XHJcbiAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICBrZXlzLnB1c2goa2V5KTtcclxuICAgICAgICB2YXIgdmFsdWUgPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wc09wdGlvbnMsIHByb3BzRGF0YSwgdm0pO1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXHJcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgICAgdmFyIGh5cGhlbmF0ZWRLZXkgPSBoeXBoZW5hdGUoa2V5KTtcclxuICAgICAgICAgICAgaWYgKGlzUmVzZXJ2ZWRBdHRyaWJ1dGUoaHlwaGVuYXRlZEtleSkgfHxcclxuICAgICAgICAgICAgICAgIGNvbmZpZy5pc1Jlc2VydmVkQXR0cihoeXBoZW5hdGVkS2V5KSkge1xyXG4gICAgICAgICAgICAgICAgd2FybiQyKFwiXFxcIlwiLmNvbmNhdChoeXBoZW5hdGVkS2V5LCBcIlxcXCIgaXMgYSByZXNlcnZlZCBhdHRyaWJ1dGUgYW5kIGNhbm5vdCBiZSB1c2VkIGFzIGNvbXBvbmVudCBwcm9wLlwiKSwgdm0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRlZmluZVJlYWN0aXZlKHByb3BzLCBrZXksIHZhbHVlLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzUm9vdCAmJiAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybiQyKFwiQXZvaWQgbXV0YXRpbmcgYSBwcm9wIGRpcmVjdGx5IHNpbmNlIHRoZSB2YWx1ZSB3aWxsIGJlIFwiICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcGFyZW50IGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiSW5zdGVhZCwgdXNlIGEgZGF0YSBvciBjb21wdXRlZCBwcm9wZXJ0eSBiYXNlZCBvbiB0aGUgcHJvcCdzIFwiICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ2YWx1ZS4gUHJvcCBiZWluZyBtdXRhdGVkOiBcXFwiXCIuY29uY2F0KGtleSwgXCJcXFwiXCIpLCB2bSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZGVmaW5lUmVhY3RpdmUocHJvcHMsIGtleSwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBzdGF0aWMgcHJvcHMgYXJlIGFscmVhZHkgcHJveGllZCBvbiB0aGUgY29tcG9uZW50J3MgcHJvdG90eXBlXHJcbiAgICAgICAgLy8gZHVyaW5nIFZ1ZS5leHRlbmQoKS4gV2Ugb25seSBuZWVkIHRvIHByb3h5IHByb3BzIGRlZmluZWQgYXRcclxuICAgICAgICAvLyBpbnN0YW50aWF0aW9uIGhlcmUuXHJcbiAgICAgICAgaWYgKCEoa2V5IGluIHZtKSkge1xyXG4gICAgICAgICAgICBwcm94eSh2bSwgXCJfcHJvcHNcIiwga2V5KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgZm9yICh2YXIga2V5IGluIHByb3BzT3B0aW9ucykge1xyXG4gICAgICAgIF9sb29wXzEoa2V5KTtcclxuICAgIH1cclxuICAgIHRvZ2dsZU9ic2VydmluZyh0cnVlKTtcclxufVxyXG5mdW5jdGlvbiBpbml0RGF0YSh2bSkge1xyXG4gICAgdmFyIGRhdGEgPSB2bS4kb3B0aW9ucy5kYXRhO1xyXG4gICAgZGF0YSA9IHZtLl9kYXRhID0gaXNGdW5jdGlvbihkYXRhKSA/IGdldERhdGEoZGF0YSwgdm0pIDogZGF0YSB8fCB7fTtcclxuICAgIGlmICghaXNQbGFpbk9iamVjdChkYXRhKSkge1xyXG4gICAgICAgIGRhdGEgPSB7fTtcclxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXHJcbiAgICAgICAgICAgIHdhcm4kMignZGF0YSBmdW5jdGlvbnMgc2hvdWxkIHJldHVybiBhbiBvYmplY3Q6XFxuJyArXHJcbiAgICAgICAgICAgICAgICAnaHR0cHM6Ly92dWVqcy5vcmcvdjIvZ3VpZGUvY29tcG9uZW50cy5odG1sI2RhdGEtTXVzdC1CZS1hLUZ1bmN0aW9uJywgdm0pO1xyXG4gICAgfVxyXG4gICAgLy8gcHJveHkgZGF0YSBvbiBpbnN0YW5jZVxyXG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKTtcclxuICAgIHZhciBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xyXG4gICAgdmFyIG1ldGhvZHMgPSB2bS4kb3B0aW9ucy5tZXRob2RzO1xyXG4gICAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcclxuICAgIHdoaWxlIChpLS0pIHtcclxuICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcclxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgICBpZiAobWV0aG9kcyAmJiBoYXNPd24obWV0aG9kcywga2V5KSkge1xyXG4gICAgICAgICAgICAgICAgd2FybiQyKFwiTWV0aG9kIFxcXCJcIi5jb25jYXQoa2V5LCBcIlxcXCIgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkIGFzIGEgZGF0YSBwcm9wZXJ0eS5cIiksIHZtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXkpKSB7XHJcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcclxuICAgICAgICAgICAgICAgIHdhcm4kMihcIlRoZSBkYXRhIHByb3BlcnR5IFxcXCJcIi5jb25jYXQoa2V5LCBcIlxcXCIgaXMgYWxyZWFkeSBkZWNsYXJlZCBhcyBhIHByb3AuIFwiKSArXHJcbiAgICAgICAgICAgICAgICAgICAgXCJVc2UgcHJvcCBkZWZhdWx0IHZhbHVlIGluc3RlYWQuXCIsIHZtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIWlzUmVzZXJ2ZWQoa2V5KSkge1xyXG4gICAgICAgICAgICBwcm94eSh2bSwgXCJfZGF0YVwiLCBrZXkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIG9ic2VydmUgZGF0YVxyXG4gICAgdmFyIG9iID0gb2JzZXJ2ZShkYXRhKTtcclxuICAgIG9iICYmIG9iLnZtQ291bnQrKztcclxufVxyXG5mdW5jdGlvbiBnZXREYXRhKGRhdGEsIHZtKSB7XHJcbiAgICAvLyAjNzU3MyBkaXNhYmxlIGRlcCBjb2xsZWN0aW9uIHdoZW4gaW52b2tpbmcgZGF0YSBnZXR0ZXJzXHJcbiAgICBwdXNoVGFyZ2V0KCk7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiBkYXRhLmNhbGwodm0sIHZtKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwiZGF0YSgpXCIpO1xyXG4gICAgICAgIHJldHVybiB7fTtcclxuICAgIH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIHBvcFRhcmdldCgpO1xyXG4gICAgfVxyXG59XHJcbnZhciBjb21wdXRlZFdhdGNoZXJPcHRpb25zID0geyBsYXp5OiB0cnVlIH07XHJcbmZ1bmN0aW9uIGluaXRDb21wdXRlZCQxKHZtLCBjb21wdXRlZCkge1xyXG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXHJcbiAgICB2YXIgd2F0Y2hlcnMgPSAodm0uX2NvbXB1dGVkV2F0Y2hlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpKTtcclxuICAgIC8vIGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIGp1c3QgZ2V0dGVycyBkdXJpbmcgU1NSXHJcbiAgICB2YXIgaXNTU1IgPSBpc1NlcnZlclJlbmRlcmluZygpO1xyXG4gICAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XHJcbiAgICAgICAgdmFyIHVzZXJEZWYgPSBjb21wdXRlZFtrZXldO1xyXG4gICAgICAgIHZhciBnZXR0ZXIgPSBpc0Z1bmN0aW9uKHVzZXJEZWYpID8gdXNlckRlZiA6IHVzZXJEZWYuZ2V0O1xyXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGdldHRlciA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHdhcm4kMihcIkdldHRlciBpcyBtaXNzaW5nIGZvciBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIuY29uY2F0KGtleSwgXCJcXFwiLlwiKSwgdm0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWlzU1NSKSB7XHJcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBpbnRlcm5hbCB3YXRjaGVyIGZvciB0aGUgY29tcHV0ZWQgcHJvcGVydHkuXHJcbiAgICAgICAgICAgIHdhdGNoZXJzW2tleV0gPSBuZXcgV2F0Y2hlcih2bSwgZ2V0dGVyIHx8IG5vb3AsIG5vb3AsIGNvbXB1dGVkV2F0Y2hlck9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjb21wb25lbnQtZGVmaW5lZCBjb21wdXRlZCBwcm9wZXJ0aWVzIGFyZSBhbHJlYWR5IGRlZmluZWQgb24gdGhlXHJcbiAgICAgICAgLy8gY29tcG9uZW50IHByb3RvdHlwZS4gV2Ugb25seSBuZWVkIHRvIGRlZmluZSBjb21wdXRlZCBwcm9wZXJ0aWVzIGRlZmluZWRcclxuICAgICAgICAvLyBhdCBpbnN0YW50aWF0aW9uIGhlcmUuXHJcbiAgICAgICAgaWYgKCEoa2V5IGluIHZtKSkge1xyXG4gICAgICAgICAgICBkZWZpbmVDb21wdXRlZCh2bSwga2V5LCB1c2VyRGVmKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgICBpZiAoa2V5IGluIHZtLiRkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuJDIoXCJUaGUgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiLmNvbmNhdChrZXksIFwiXFxcIiBpcyBhbHJlYWR5IGRlZmluZWQgaW4gZGF0YS5cIiksIHZtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh2bS4kb3B0aW9ucy5wcm9wcyAmJiBrZXkgaW4gdm0uJG9wdGlvbnMucHJvcHMpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4kMihcIlRoZSBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIuY29uY2F0KGtleSwgXCJcXFwiIGlzIGFscmVhZHkgZGVmaW5lZCBhcyBhIHByb3AuXCIpLCB2bSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodm0uJG9wdGlvbnMubWV0aG9kcyAmJiBrZXkgaW4gdm0uJG9wdGlvbnMubWV0aG9kcykge1xyXG4gICAgICAgICAgICAgICAgd2FybiQyKFwiVGhlIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIi5jb25jYXQoa2V5LCBcIlxcXCIgaXMgYWxyZWFkeSBkZWZpbmVkIGFzIGEgbWV0aG9kLlwiKSwgdm0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGRlZmluZUNvbXB1dGVkKHRhcmdldCwga2V5LCB1c2VyRGVmKSB7XHJcbiAgICB2YXIgc2hvdWxkQ2FjaGUgPSAhaXNTZXJ2ZXJSZW5kZXJpbmcoKTtcclxuICAgIGlmIChpc0Z1bmN0aW9uKHVzZXJEZWYpKSB7XHJcbiAgICAgICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IHNob3VsZENhY2hlXHJcbiAgICAgICAgICAgID8gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIoa2V5KVxyXG4gICAgICAgICAgICA6IGNyZWF0ZUdldHRlckludm9rZXIodXNlckRlZik7XHJcbiAgICAgICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IG5vb3A7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gdXNlckRlZi5nZXRcclxuICAgICAgICAgICAgPyBzaG91bGRDYWNoZSAmJiB1c2VyRGVmLmNhY2hlICE9PSBmYWxzZVxyXG4gICAgICAgICAgICAgICAgPyBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpXHJcbiAgICAgICAgICAgICAgICA6IGNyZWF0ZUdldHRlckludm9rZXIodXNlckRlZi5nZXQpXHJcbiAgICAgICAgICAgIDogbm9vcDtcclxuICAgICAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gdXNlckRlZi5zZXQgfHwgbm9vcDtcclxuICAgIH1cclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPT09IG5vb3ApIHtcclxuICAgICAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB3YXJuJDIoXCJDb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIuY29uY2F0KGtleSwgXCJcXFwiIHdhcyBhc3NpZ25lZCB0byBidXQgaXQgaGFzIG5vIHNldHRlci5cIiksIHRoaXMpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIoa2V5KSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gY29tcHV0ZWRHZXR0ZXIoKSB7XHJcbiAgICAgICAgdmFyIHdhdGNoZXIgPSB0aGlzLl9jb21wdXRlZFdhdGNoZXJzICYmIHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnNba2V5XTtcclxuICAgICAgICBpZiAod2F0Y2hlcikge1xyXG4gICAgICAgICAgICBpZiAod2F0Y2hlci5kaXJ0eSkge1xyXG4gICAgICAgICAgICAgICAgd2F0Y2hlci5ldmFsdWF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChEZXAudGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBEZXAudGFyZ2V0Lm9uVHJhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICBEZXAudGFyZ2V0Lm9uVHJhY2soe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlZmZlY3Q6IERlcC50YXJnZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogdGhpcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJnZXRcIiAvKiBUcmFja09wVHlwZXMuR0VUICovLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IGtleVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgd2F0Y2hlci5kZXBlbmQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gd2F0Y2hlci52YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUdldHRlckludm9rZXIoZm4pIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiBjb21wdXRlZEdldHRlcigpIHtcclxuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCB0aGlzKTtcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gaW5pdE1ldGhvZHModm0sIG1ldGhvZHMpIHtcclxuICAgIHZhciBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xyXG4gICAgZm9yICh2YXIga2V5IGluIG1ldGhvZHMpIHtcclxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG1ldGhvZHNba2V5XSAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgd2FybiQyKFwiTWV0aG9kIFxcXCJcIi5jb25jYXQoa2V5LCBcIlxcXCIgaGFzIHR5cGUgXFxcIlwiKS5jb25jYXQodHlwZW9mIG1ldGhvZHNba2V5XSwgXCJcXFwiIGluIHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbi4gXCIpICtcclxuICAgICAgICAgICAgICAgICAgICBcIkRpZCB5b3UgcmVmZXJlbmNlIHRoZSBmdW5jdGlvbiBjb3JyZWN0bHk/XCIsIHZtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuJDIoXCJNZXRob2QgXFxcIlwiLmNvbmNhdChrZXksIFwiXFxcIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBwcm9wLlwiKSwgdm0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChrZXkgaW4gdm0gJiYgaXNSZXNlcnZlZChrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuJDIoXCJNZXRob2QgXFxcIlwiLmNvbmNhdChrZXksIFwiXFxcIiBjb25mbGljdHMgd2l0aCBhbiBleGlzdGluZyBWdWUgaW5zdGFuY2UgbWV0aG9kLiBcIikgK1xyXG4gICAgICAgICAgICAgICAgICAgIFwiQXZvaWQgZGVmaW5pbmcgY29tcG9uZW50IG1ldGhvZHMgdGhhdCBzdGFydCB3aXRoIF8gb3IgJC5cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdm1ba2V5XSA9IHR5cGVvZiBtZXRob2RzW2tleV0gIT09ICdmdW5jdGlvbicgPyBub29wIDogYmluZCQxKG1ldGhvZHNba2V5XSwgdm0pO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGluaXRXYXRjaCh2bSwgd2F0Y2gpIHtcclxuICAgIGZvciAodmFyIGtleSBpbiB3YXRjaCkge1xyXG4gICAgICAgIHZhciBoYW5kbGVyID0gd2F0Y2hba2V5XTtcclxuICAgICAgICBpZiAoaXNBcnJheShoYW5kbGVyKSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcltpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZVdhdGNoZXIodm0sIGV4cE9yRm4sIGhhbmRsZXIsIG9wdGlvbnMpIHtcclxuICAgIGlmIChpc1BsYWluT2JqZWN0KGhhbmRsZXIpKSB7XHJcbiAgICAgICAgb3B0aW9ucyA9IGhhbmRsZXI7XHJcbiAgICAgICAgaGFuZGxlciA9IGhhbmRsZXIuaGFuZGxlcjtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICBoYW5kbGVyID0gdm1baGFuZGxlcl07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdm0uJHdhdGNoKGV4cE9yRm4sIGhhbmRsZXIsIG9wdGlvbnMpO1xyXG59XHJcbmZ1bmN0aW9uIHN0YXRlTWl4aW4oVnVlKSB7XHJcbiAgICAvLyBmbG93IHNvbWVob3cgaGFzIHByb2JsZW1zIHdpdGggZGlyZWN0bHkgZGVjbGFyZWQgZGVmaW5pdGlvbiBvYmplY3RcclxuICAgIC8vIHdoZW4gdXNpbmcgT2JqZWN0LmRlZmluZVByb3BlcnR5LCBzbyB3ZSBoYXZlIHRvIHByb2NlZHVyYWxseSBidWlsZCB1cFxyXG4gICAgLy8gdGhlIG9iamVjdCBoZXJlLlxyXG4gICAgdmFyIGRhdGFEZWYgPSB7fTtcclxuICAgIGRhdGFEZWYuZ2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhO1xyXG4gICAgfTtcclxuICAgIHZhciBwcm9wc0RlZiA9IHt9O1xyXG4gICAgcHJvcHNEZWYuZ2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wcm9wcztcclxuICAgIH07XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgIGRhdGFEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB3YXJuJDIoJ0F2b2lkIHJlcGxhY2luZyBpbnN0YW5jZSByb290ICRkYXRhLiAnICtcclxuICAgICAgICAgICAgICAgICdVc2UgbmVzdGVkIGRhdGEgcHJvcGVydGllcyBpbnN0ZWFkLicsIHRoaXMpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcHJvcHNEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB3YXJuJDIoXCIkcHJvcHMgaXMgcmVhZG9ubHkuXCIsIHRoaXMpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRkYXRhJywgZGF0YURlZik7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRwcm9wcycsIHByb3BzRGVmKTtcclxuICAgIFZ1ZS5wcm90b3R5cGUuJHNldCA9IHNldDtcclxuICAgIFZ1ZS5wcm90b3R5cGUuJGRlbGV0ZSA9IGRlbDtcclxuICAgIFZ1ZS5wcm90b3R5cGUuJHdhdGNoID0gZnVuY3Rpb24gKGV4cE9yRm4sIGNiLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIHZtID0gdGhpcztcclxuICAgICAgICBpZiAoaXNQbGFpbk9iamVjdChjYikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICAgICAgb3B0aW9ucy51c2VyID0gdHJ1ZTtcclxuICAgICAgICB2YXIgd2F0Y2hlciA9IG5ldyBXYXRjaGVyKHZtLCBleHBPckZuLCBjYiwgb3B0aW9ucyk7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuaW1tZWRpYXRlKSB7XHJcbiAgICAgICAgICAgIHZhciBpbmZvID0gXCJjYWxsYmFjayBmb3IgaW1tZWRpYXRlIHdhdGNoZXIgXFxcIlwiLmNvbmNhdCh3YXRjaGVyLmV4cHJlc3Npb24sIFwiXFxcIlwiKTtcclxuICAgICAgICAgICAgcHVzaFRhcmdldCgpO1xyXG4gICAgICAgICAgICBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhjYiwgdm0sIFt3YXRjaGVyLnZhbHVlXSwgdm0sIGluZm8pO1xyXG4gICAgICAgICAgICBwb3BUYXJnZXQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHVud2F0Y2hGbigpIHtcclxuICAgICAgICAgICAgd2F0Y2hlci50ZWFyZG93bigpO1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG59XG5cbmZ1bmN0aW9uIGluaXRQcm92aWRlKHZtKSB7XHJcbiAgICB2YXIgcHJvdmlkZU9wdGlvbiA9IHZtLiRvcHRpb25zLnByb3ZpZGU7XHJcbiAgICBpZiAocHJvdmlkZU9wdGlvbikge1xyXG4gICAgICAgIHZhciBwcm92aWRlZCA9IGlzRnVuY3Rpb24ocHJvdmlkZU9wdGlvbilcclxuICAgICAgICAgICAgPyBwcm92aWRlT3B0aW9uLmNhbGwodm0pXHJcbiAgICAgICAgICAgIDogcHJvdmlkZU9wdGlvbjtcclxuICAgICAgICBpZiAoIWlzT2JqZWN0KHByb3ZpZGVkKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzb3VyY2UgPSByZXNvbHZlUHJvdmlkZWQodm0pO1xyXG4gICAgICAgIC8vIElFOSBkb2Vzbid0IHN1cHBvcnQgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgc28gd2UgaGF2ZSB0b1xyXG4gICAgICAgIC8vIGl0ZXJhdGUgdGhlIGtleXMgb3Vyc2VsdmVzLlxyXG4gICAgICAgIHZhciBrZXlzID0gaGFzU3ltYm9sID8gUmVmbGVjdC5vd25LZXlzKHByb3ZpZGVkKSA6IE9iamVjdC5rZXlzKHByb3ZpZGVkKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb3VyY2UsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm92aWRlZCwga2V5KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGluaXRJbmplY3Rpb25zKHZtKSB7XHJcbiAgICB2YXIgcmVzdWx0ID0gcmVzb2x2ZUluamVjdCh2bS4kb3B0aW9ucy5pbmplY3QsIHZtKTtcclxuICAgIGlmIChyZXN1bHQpIHtcclxuICAgICAgICB0b2dnbGVPYnNlcnZpbmcoZmFsc2UpO1xyXG4gICAgICAgIE9iamVjdC5rZXlzKHJlc3VsdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXHJcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICBkZWZpbmVSZWFjdGl2ZSh2bSwga2V5LCByZXN1bHRba2V5XSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4kMihcIkF2b2lkIG11dGF0aW5nIGFuIGluamVjdGVkIHZhbHVlIGRpcmVjdGx5IHNpbmNlIHRoZSBjaGFuZ2VzIHdpbGwgYmUgXCIgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcIm92ZXJ3cml0dGVuIHdoZW5ldmVyIHRoZSBwcm92aWRlZCBjb21wb25lbnQgcmUtcmVuZGVycy4gXCIgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcImluamVjdGlvbiBiZWluZyBtdXRhdGVkOiBcXFwiXCIuY29uY2F0KGtleSwgXCJcXFwiXCIpLCB2bSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRlZmluZVJlYWN0aXZlKHZtLCBrZXksIHJlc3VsdFtrZXldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRvZ2dsZU9ic2VydmluZyh0cnVlKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiByZXNvbHZlSW5qZWN0KGluamVjdCwgdm0pIHtcclxuICAgIGlmIChpbmplY3QpIHtcclxuICAgICAgICAvLyBpbmplY3QgaXMgOmFueSBiZWNhdXNlIGZsb3cgaXMgbm90IHNtYXJ0IGVub3VnaCB0byBmaWd1cmUgb3V0IGNhY2hlZFxyXG4gICAgICAgIHZhciByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgICAgIHZhciBrZXlzID0gaGFzU3ltYm9sID8gUmVmbGVjdC5vd25LZXlzKGluamVjdCkgOiBPYmplY3Qua2V5cyhpbmplY3QpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcclxuICAgICAgICAgICAgLy8gIzY1NzQgaW4gY2FzZSB0aGUgaW5qZWN0IG9iamVjdCBpcyBvYnNlcnZlZC4uLlxyXG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnX19vYl9fJylcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB2YXIgcHJvdmlkZUtleSA9IGluamVjdFtrZXldLmZyb207XHJcbiAgICAgICAgICAgIGlmIChwcm92aWRlS2V5IGluIHZtLl9wcm92aWRlZCkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2bS5fcHJvdmlkZWRbcHJvdmlkZUtleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoJ2RlZmF1bHQnIGluIGluamVjdFtrZXldKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJvdmlkZURlZmF1bHQgPSBpbmplY3Rba2V5XS5kZWZhdWx0O1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBpc0Z1bmN0aW9uKHByb3ZpZGVEZWZhdWx0KVxyXG4gICAgICAgICAgICAgICAgICAgID8gcHJvdmlkZURlZmF1bHQuY2FsbCh2bSlcclxuICAgICAgICAgICAgICAgICAgICA6IHByb3ZpZGVEZWZhdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4kMihcIkluamVjdGlvbiBcXFwiXCIuY29uY2F0KGtleSwgXCJcXFwiIG5vdCBmb3VuZFwiKSwgdm0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbn1cblxudmFyIHVpZCA9IDA7XHJcbmZ1bmN0aW9uIGluaXRNaXhpbiQxKFZ1ZSkge1xyXG4gICAgVnVlLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIHZtID0gdGhpcztcclxuICAgICAgICAvLyBhIHVpZFxyXG4gICAgICAgIHZtLl91aWQgPSB1aWQrKztcclxuICAgICAgICB2YXIgc3RhcnRUYWcsIGVuZFRhZztcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xyXG4gICAgICAgICAgICBzdGFydFRhZyA9IFwidnVlLXBlcmYtc3RhcnQ6XCIuY29uY2F0KHZtLl91aWQpO1xyXG4gICAgICAgICAgICBlbmRUYWcgPSBcInZ1ZS1wZXJmLWVuZDpcIi5jb25jYXQodm0uX3VpZCk7XHJcbiAgICAgICAgICAgIG1hcmsoc3RhcnRUYWcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBhIGZsYWcgdG8gbWFyayB0aGlzIGFzIGEgVnVlIGluc3RhbmNlIHdpdGhvdXQgaGF2aW5nIHRvIGRvIGluc3RhbmNlb2ZcclxuICAgICAgICAvLyBjaGVja1xyXG4gICAgICAgIHZtLl9pc1Z1ZSA9IHRydWU7XHJcbiAgICAgICAgLy8gYXZvaWQgaW5zdGFuY2VzIGZyb20gYmVpbmcgb2JzZXJ2ZWRcclxuICAgICAgICB2bS5fX3Zfc2tpcCA9IHRydWU7XHJcbiAgICAgICAgLy8gZWZmZWN0IHNjb3BlXHJcbiAgICAgICAgdm0uX3Njb3BlID0gbmV3IEVmZmVjdFNjb3BlKHRydWUgLyogZGV0YWNoZWQgKi8pO1xyXG4gICAgICAgIC8vIG1lcmdlIG9wdGlvbnNcclxuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLl9pc0NvbXBvbmVudCkge1xyXG4gICAgICAgICAgICAvLyBvcHRpbWl6ZSBpbnRlcm5hbCBjb21wb25lbnQgaW5zdGFudGlhdGlvblxyXG4gICAgICAgICAgICAvLyBzaW5jZSBkeW5hbWljIG9wdGlvbnMgbWVyZ2luZyBpcyBwcmV0dHkgc2xvdywgYW5kIG5vbmUgb2YgdGhlXHJcbiAgICAgICAgICAgIC8vIGludGVybmFsIGNvbXBvbmVudCBvcHRpb25zIG5lZWRzIHNwZWNpYWwgdHJlYXRtZW50LlxyXG4gICAgICAgICAgICBpbml0SW50ZXJuYWxDb21wb25lbnQodm0sIG9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdm0uJG9wdGlvbnMgPSBtZXJnZU9wdGlvbnMocmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyh2bS5jb25zdHJ1Y3RvciksIG9wdGlvbnMgfHwge30sIHZtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cclxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgICBpbml0UHJveHkodm0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGV4cG9zZSByZWFsIHNlbGZcclxuICAgICAgICB2bS5fc2VsZiA9IHZtO1xyXG4gICAgICAgIGluaXRMaWZlY3ljbGUodm0pO1xyXG4gICAgICAgIGluaXRFdmVudHModm0pO1xyXG4gICAgICAgIGluaXRSZW5kZXIodm0pO1xyXG4gICAgICAgIGNhbGxIb29rJDEodm0sICdiZWZvcmVDcmVhdGUnLCB1bmRlZmluZWQsIGZhbHNlIC8qIHNldENvbnRleHQgKi8pO1xyXG4gICAgICAgIGluaXRJbmplY3Rpb25zKHZtKTsgLy8gcmVzb2x2ZSBpbmplY3Rpb25zIGJlZm9yZSBkYXRhL3Byb3BzXHJcbiAgICAgICAgaW5pdFN0YXRlKHZtKTtcclxuICAgICAgICBpbml0UHJvdmlkZSh2bSk7IC8vIHJlc29sdmUgcHJvdmlkZSBhZnRlciBkYXRhL3Byb3BzXHJcbiAgICAgICAgY2FsbEhvb2skMSh2bSwgJ2NyZWF0ZWQnKTtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xyXG4gICAgICAgICAgICB2bS5fbmFtZSA9IGZvcm1hdENvbXBvbmVudE5hbWUodm0sIGZhbHNlKTtcclxuICAgICAgICAgICAgbWFyayhlbmRUYWcpO1xyXG4gICAgICAgICAgICBtZWFzdXJlKFwidnVlIFwiLmNvbmNhdCh2bS5fbmFtZSwgXCIgaW5pdFwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2bS4kb3B0aW9ucy5lbCkge1xyXG4gICAgICAgICAgICB2bS4kbW91bnQodm0uJG9wdGlvbnMuZWwpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gaW5pdEludGVybmFsQ29tcG9uZW50KHZtLCBvcHRpb25zKSB7XHJcbiAgICB2YXIgb3B0cyA9ICh2bS4kb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUodm0uY29uc3RydWN0b3Iub3B0aW9ucykpO1xyXG4gICAgLy8gZG9pbmcgdGhpcyBiZWNhdXNlIGl0J3MgZmFzdGVyIHRoYW4gZHluYW1pYyBlbnVtZXJhdGlvbi5cclxuICAgIHZhciBwYXJlbnRWbm9kZSA9IG9wdGlvbnMuX3BhcmVudFZub2RlO1xyXG4gICAgb3B0cy5wYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcclxuICAgIG9wdHMuX3BhcmVudFZub2RlID0gcGFyZW50Vm5vZGU7XHJcbiAgICB2YXIgdm5vZGVDb21wb25lbnRPcHRpb25zID0gcGFyZW50Vm5vZGUuY29tcG9uZW50T3B0aW9ucztcclxuICAgIG9wdHMucHJvcHNEYXRhID0gdm5vZGVDb21wb25lbnRPcHRpb25zLnByb3BzRGF0YTtcclxuICAgIG9wdHMuX3BhcmVudExpc3RlbmVycyA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy5saXN0ZW5lcnM7XHJcbiAgICBvcHRzLl9yZW5kZXJDaGlsZHJlbiA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy5jaGlsZHJlbjtcclxuICAgIG9wdHMuX2NvbXBvbmVudFRhZyA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy50YWc7XHJcbiAgICBpZiAob3B0aW9ucy5yZW5kZXIpIHtcclxuICAgICAgICBvcHRzLnJlbmRlciA9IG9wdGlvbnMucmVuZGVyO1xyXG4gICAgICAgIG9wdHMuc3RhdGljUmVuZGVyRm5zID0gb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnM7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yKSB7XHJcbiAgICB2YXIgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcclxuICAgIGlmIChDdG9yLnN1cGVyKSB7XHJcbiAgICAgICAgdmFyIHN1cGVyT3B0aW9ucyA9IHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMoQ3Rvci5zdXBlcik7XHJcbiAgICAgICAgdmFyIGNhY2hlZFN1cGVyT3B0aW9ucyA9IEN0b3Iuc3VwZXJPcHRpb25zO1xyXG4gICAgICAgIGlmIChzdXBlck9wdGlvbnMgIT09IGNhY2hlZFN1cGVyT3B0aW9ucykge1xyXG4gICAgICAgICAgICAvLyBzdXBlciBvcHRpb24gY2hhbmdlZCxcclxuICAgICAgICAgICAgLy8gbmVlZCB0byByZXNvbHZlIG5ldyBvcHRpb25zLlxyXG4gICAgICAgICAgICBDdG9yLnN1cGVyT3B0aW9ucyA9IHN1cGVyT3B0aW9ucztcclxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlcmUgYXJlIGFueSBsYXRlLW1vZGlmaWVkL2F0dGFjaGVkIG9wdGlvbnMgKCM0OTc2KVxyXG4gICAgICAgICAgICB2YXIgbW9kaWZpZWRPcHRpb25zID0gcmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyhDdG9yKTtcclxuICAgICAgICAgICAgLy8gdXBkYXRlIGJhc2UgZXh0ZW5kIG9wdGlvbnNcclxuICAgICAgICAgICAgaWYgKG1vZGlmaWVkT3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgZXh0ZW5kKEN0b3IuZXh0ZW5kT3B0aW9ucywgbW9kaWZpZWRPcHRpb25zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcHRpb25zID0gQ3Rvci5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHN1cGVyT3B0aW9ucywgQ3Rvci5leHRlbmRPcHRpb25zKTtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMubmFtZSkge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5jb21wb25lbnRzW29wdGlvbnMubmFtZV0gPSBDdG9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG9wdGlvbnM7XHJcbn1cclxuZnVuY3Rpb24gcmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyhDdG9yKSB7XHJcbiAgICB2YXIgbW9kaWZpZWQ7XHJcbiAgICB2YXIgbGF0ZXN0ID0gQ3Rvci5vcHRpb25zO1xyXG4gICAgdmFyIHNlYWxlZCA9IEN0b3Iuc2VhbGVkT3B0aW9ucztcclxuICAgIGZvciAodmFyIGtleSBpbiBsYXRlc3QpIHtcclxuICAgICAgICBpZiAobGF0ZXN0W2tleV0gIT09IHNlYWxlZFtrZXldKSB7XHJcbiAgICAgICAgICAgIGlmICghbW9kaWZpZWQpXHJcbiAgICAgICAgICAgICAgICBtb2RpZmllZCA9IHt9O1xyXG4gICAgICAgICAgICBtb2RpZmllZFtrZXldID0gbGF0ZXN0W2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1vZGlmaWVkO1xyXG59XG5cbmZ1bmN0aW9uIEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0KGRhdGEsIHByb3BzLCBjaGlsZHJlbiwgcGFyZW50LCBDdG9yKSB7XHJcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XHJcbiAgICAvLyBlbnN1cmUgdGhlIGNyZWF0ZUVsZW1lbnQgZnVuY3Rpb24gaW4gZnVuY3Rpb25hbCBjb21wb25lbnRzXHJcbiAgICAvLyBnZXRzIGEgdW5pcXVlIGNvbnRleHQgLSB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgY29ycmVjdCBuYW1lZCBzbG90IGNoZWNrXHJcbiAgICB2YXIgY29udGV4dFZtO1xyXG4gICAgaWYgKGhhc093bihwYXJlbnQsICdfdWlkJykpIHtcclxuICAgICAgICBjb250ZXh0Vm0gPSBPYmplY3QuY3JlYXRlKHBhcmVudCk7XHJcbiAgICAgICAgY29udGV4dFZtLl9vcmlnaW5hbCA9IHBhcmVudDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIHRoZSBjb250ZXh0IHZtIHBhc3NlZCBpbiBpcyBhIGZ1bmN0aW9uYWwgY29udGV4dCBhcyB3ZWxsLlxyXG4gICAgICAgIC8vIGluIHRoaXMgY2FzZSB3ZSB3YW50IHRvIG1ha2Ugc3VyZSB3ZSBhcmUgYWJsZSB0byBnZXQgYSBob2xkIHRvIHRoZVxyXG4gICAgICAgIC8vIHJlYWwgY29udGV4dCBpbnN0YW5jZS5cclxuICAgICAgICBjb250ZXh0Vm0gPSBwYXJlbnQ7XHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5fb3JpZ2luYWw7XHJcbiAgICB9XHJcbiAgICB2YXIgaXNDb21waWxlZCA9IGlzVHJ1ZShvcHRpb25zLl9jb21waWxlZCk7XHJcbiAgICB2YXIgbmVlZE5vcm1hbGl6YXRpb24gPSAhaXNDb21waWxlZDtcclxuICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgICB0aGlzLnByb3BzID0gcHJvcHM7XHJcbiAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XHJcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcclxuICAgIHRoaXMubGlzdGVuZXJzID0gZGF0YS5vbiB8fCBlbXB0eU9iamVjdDtcclxuICAgIHRoaXMuaW5qZWN0aW9ucyA9IHJlc29sdmVJbmplY3Qob3B0aW9ucy5pbmplY3QsIHBhcmVudCk7XHJcbiAgICB0aGlzLnNsb3RzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghX3RoaXMuJHNsb3RzKSB7XHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZVNjb3BlZFNsb3RzKHBhcmVudCwgZGF0YS5zY29wZWRTbG90cywgKF90aGlzLiRzbG90cyA9IHJlc29sdmVTbG90cyhjaGlsZHJlbiwgcGFyZW50KSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gX3RoaXMuJHNsb3RzO1xyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc2NvcGVkU2xvdHMnLCB7XHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZVNjb3BlZFNsb3RzKHBhcmVudCwgZGF0YS5zY29wZWRTbG90cywgdGhpcy5zbG90cygpKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIC8vIHN1cHBvcnQgZm9yIGNvbXBpbGVkIGZ1bmN0aW9uYWwgdGVtcGxhdGVcclxuICAgIGlmIChpc0NvbXBpbGVkKSB7XHJcbiAgICAgICAgLy8gZXhwb3NpbmcgJG9wdGlvbnMgZm9yIHJlbmRlclN0YXRpYygpXHJcbiAgICAgICAgdGhpcy4kb3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgICAgICAgLy8gcHJlLXJlc29sdmUgc2xvdHMgZm9yIHJlbmRlclNsb3QoKVxyXG4gICAgICAgIHRoaXMuJHNsb3RzID0gdGhpcy5zbG90cygpO1xyXG4gICAgICAgIHRoaXMuJHNjb3BlZFNsb3RzID0gbm9ybWFsaXplU2NvcGVkU2xvdHMocGFyZW50LCBkYXRhLnNjb3BlZFNsb3RzLCB0aGlzLiRzbG90cyk7XHJcbiAgICB9XHJcbiAgICBpZiAob3B0aW9ucy5fc2NvcGVJZCkge1xyXG4gICAgICAgIHRoaXMuX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkge1xyXG4gICAgICAgICAgICB2YXIgdm5vZGUgPSBjcmVhdGVFbGVtZW50JDEoY29udGV4dFZtLCBhLCBiLCBjLCBkLCBuZWVkTm9ybWFsaXphdGlvbik7XHJcbiAgICAgICAgICAgIGlmICh2bm9kZSAmJiAhaXNBcnJheSh2bm9kZSkpIHtcclxuICAgICAgICAgICAgICAgIHZub2RlLmZuU2NvcGVJZCA9IG9wdGlvbnMuX3Njb3BlSWQ7XHJcbiAgICAgICAgICAgICAgICB2bm9kZS5mbkNvbnRleHQgPSBwYXJlbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHZub2RlO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0aGlzLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQkMShjb250ZXh0Vm0sIGEsIGIsIGMsIGQsIG5lZWROb3JtYWxpemF0aW9uKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbmluc3RhbGxSZW5kZXJIZWxwZXJzKEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0LnByb3RvdHlwZSk7XHJcbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQoQ3RvciwgcHJvcHNEYXRhLCBkYXRhLCBjb250ZXh0Vm0sIGNoaWxkcmVuKSB7XHJcbiAgICB2YXIgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcclxuICAgIHZhciBwcm9wcyA9IHt9O1xyXG4gICAgdmFyIHByb3BPcHRpb25zID0gb3B0aW9ucy5wcm9wcztcclxuICAgIGlmIChpc0RlZihwcm9wT3B0aW9ucykpIHtcclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcE9wdGlvbnMpIHtcclxuICAgICAgICAgICAgcHJvcHNba2V5XSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BPcHRpb25zLCBwcm9wc0RhdGEgfHwgZW1wdHlPYmplY3QpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmIChpc0RlZihkYXRhLmF0dHJzKSlcclxuICAgICAgICAgICAgbWVyZ2VQcm9wcyhwcm9wcywgZGF0YS5hdHRycyk7XHJcbiAgICAgICAgaWYgKGlzRGVmKGRhdGEucHJvcHMpKVxyXG4gICAgICAgICAgICBtZXJnZVByb3BzKHByb3BzLCBkYXRhLnByb3BzKTtcclxuICAgIH1cclxuICAgIHZhciByZW5kZXJDb250ZXh0ID0gbmV3IEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0KGRhdGEsIHByb3BzLCBjaGlsZHJlbiwgY29udGV4dFZtLCBDdG9yKTtcclxuICAgIHZhciB2bm9kZSA9IG9wdGlvbnMucmVuZGVyLmNhbGwobnVsbCwgcmVuZGVyQ29udGV4dC5fYywgcmVuZGVyQ29udGV4dCk7XHJcbiAgICBpZiAodm5vZGUgaW5zdGFuY2VvZiBWTm9kZSkge1xyXG4gICAgICAgIHJldHVybiBjbG9uZUFuZE1hcmtGdW5jdGlvbmFsUmVzdWx0KHZub2RlLCBkYXRhLCByZW5kZXJDb250ZXh0LnBhcmVudCwgb3B0aW9ucywgcmVuZGVyQ29udGV4dCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0FycmF5KHZub2RlKSkge1xyXG4gICAgICAgIHZhciB2bm9kZXMgPSBub3JtYWxpemVDaGlsZHJlbih2bm9kZSkgfHwgW107XHJcbiAgICAgICAgdmFyIHJlcyA9IG5ldyBBcnJheSh2bm9kZXMubGVuZ3RoKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZub2Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICByZXNbaV0gPSBjbG9uZUFuZE1hcmtGdW5jdGlvbmFsUmVzdWx0KHZub2Rlc1tpXSwgZGF0YSwgcmVuZGVyQ29udGV4dC5wYXJlbnQsIG9wdGlvbnMsIHJlbmRlckNvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNsb25lQW5kTWFya0Z1bmN0aW9uYWxSZXN1bHQodm5vZGUsIGRhdGEsIGNvbnRleHRWbSwgb3B0aW9ucywgcmVuZGVyQ29udGV4dCkge1xyXG4gICAgLy8gIzc4MTcgY2xvbmUgbm9kZSBiZWZvcmUgc2V0dGluZyBmbkNvbnRleHQsIG90aGVyd2lzZSBpZiB0aGUgbm9kZSBpcyByZXVzZWRcclxuICAgIC8vIChlLmcuIGl0IHdhcyBmcm9tIGEgY2FjaGVkIG5vcm1hbCBzbG90KSB0aGUgZm5Db250ZXh0IGNhdXNlcyBuYW1lZCBzbG90c1xyXG4gICAgLy8gdGhhdCBzaG91bGQgbm90IGJlIG1hdGNoZWQgdG8gbWF0Y2guXHJcbiAgICB2YXIgY2xvbmUgPSBjbG9uZVZOb2RlKHZub2RlKTtcclxuICAgIGNsb25lLmZuQ29udGV4dCA9IGNvbnRleHRWbTtcclxuICAgIGNsb25lLmZuT3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgIChjbG9uZS5kZXZ0b29sc01ldGEgPSBjbG9uZS5kZXZ0b29sc01ldGEgfHwge30pLnJlbmRlckNvbnRleHQgPVxyXG4gICAgICAgICAgICByZW5kZXJDb250ZXh0O1xyXG4gICAgfVxyXG4gICAgaWYgKGRhdGEuc2xvdCkge1xyXG4gICAgICAgIChjbG9uZS5kYXRhIHx8IChjbG9uZS5kYXRhID0ge30pKS5zbG90ID0gZGF0YS5zbG90O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNsb25lO1xyXG59XHJcbmZ1bmN0aW9uIG1lcmdlUHJvcHModG8sIGZyb20pIHtcclxuICAgIGZvciAodmFyIGtleSBpbiBmcm9tKSB7XHJcbiAgICAgICAgdG9bY2FtZWxpemUoa2V5KV0gPSBmcm9tW2tleV07XHJcbiAgICB9XHJcbn1cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZShvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gb3B0aW9ucy5uYW1lIHx8IG9wdGlvbnMuX19uYW1lIHx8IG9wdGlvbnMuX2NvbXBvbmVudFRhZztcclxufVxyXG4vLyBpbmxpbmUgaG9va3MgdG8gYmUgaW52b2tlZCBvbiBjb21wb25lbnQgVk5vZGVzIGR1cmluZyBwYXRjaFxyXG52YXIgY29tcG9uZW50Vk5vZGVIb29rcyA9IHtcclxuICAgIGluaXQ6IGZ1bmN0aW9uICh2bm9kZSwgaHlkcmF0aW5nKSB7XHJcbiAgICAgICAgaWYgKHZub2RlLmNvbXBvbmVudEluc3RhbmNlICYmXHJcbiAgICAgICAgICAgICF2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5faXNEZXN0cm95ZWQgJiZcclxuICAgICAgICAgICAgdm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcclxuICAgICAgICAgICAgLy8ga2VwdC1hbGl2ZSBjb21wb25lbnRzLCB0cmVhdCBhcyBhIHBhdGNoXHJcbiAgICAgICAgICAgIHZhciBtb3VudGVkTm9kZSA9IHZub2RlOyAvLyB3b3JrIGFyb3VuZCBmbG93XHJcbiAgICAgICAgICAgIGNvbXBvbmVudFZOb2RlSG9va3MucHJlcGF0Y2gobW91bnRlZE5vZGUsIG1vdW50ZWROb2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBjaGlsZCA9ICh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUodm5vZGUsIGFjdGl2ZUluc3RhbmNlKSk7XHJcbiAgICAgICAgICAgIGNoaWxkLiRtb3VudChoeWRyYXRpbmcgPyB2bm9kZS5lbG0gOiB1bmRlZmluZWQsIGh5ZHJhdGluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHByZXBhdGNoOiBmdW5jdGlvbiAob2xkVm5vZGUsIHZub2RlKSB7XHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xyXG4gICAgICAgIHZhciBjaGlsZCA9ICh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlKTtcclxuICAgICAgICB1cGRhdGVDaGlsZENvbXBvbmVudChjaGlsZCwgb3B0aW9ucy5wcm9wc0RhdGEsIC8vIHVwZGF0ZWQgcHJvcHNcclxuICAgICAgICBvcHRpb25zLmxpc3RlbmVycywgLy8gdXBkYXRlZCBsaXN0ZW5lcnNcclxuICAgICAgICB2bm9kZSwgLy8gbmV3IHBhcmVudCB2bm9kZVxyXG4gICAgICAgIG9wdGlvbnMuY2hpbGRyZW4gLy8gbmV3IGNoaWxkcmVuXHJcbiAgICAgICAgKTtcclxuICAgIH0sXHJcbiAgICBpbnNlcnQ6IGZ1bmN0aW9uICh2bm9kZSkge1xyXG4gICAgICAgIHZhciBjb250ZXh0ID0gdm5vZGUuY29udGV4dCwgY29tcG9uZW50SW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZTtcclxuICAgICAgICBpZiAoIWNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQpIHtcclxuICAgICAgICAgICAgY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGNhbGxIb29rJDEoY29tcG9uZW50SW5zdGFuY2UsICdtb3VudGVkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xyXG4gICAgICAgICAgICBpZiAoY29udGV4dC5faXNNb3VudGVkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB2dWUtcm91dGVyIzEyMTJcclxuICAgICAgICAgICAgICAgIC8vIER1cmluZyB1cGRhdGVzLCBhIGtlcHQtYWxpdmUgY29tcG9uZW50J3MgY2hpbGQgY29tcG9uZW50cyBtYXlcclxuICAgICAgICAgICAgICAgIC8vIGNoYW5nZSwgc28gZGlyZWN0bHkgd2Fsa2luZyB0aGUgdHJlZSBoZXJlIG1heSBjYWxsIGFjdGl2YXRlZCBob29rc1xyXG4gICAgICAgICAgICAgICAgLy8gb24gaW5jb3JyZWN0IGNoaWxkcmVuLiBJbnN0ZWFkIHdlIHB1c2ggdGhlbSBpbnRvIGEgcXVldWUgd2hpY2ggd2lsbFxyXG4gICAgICAgICAgICAgICAgLy8gYmUgcHJvY2Vzc2VkIGFmdGVyIHRoZSB3aG9sZSBwYXRjaCBwcm9jZXNzIGVuZGVkLlxyXG4gICAgICAgICAgICAgICAgcXVldWVBY3RpdmF0ZWRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICh2bm9kZSkge1xyXG4gICAgICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xyXG4gICAgICAgIGlmICghY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkKSB7XHJcbiAgICAgICAgICAgIGlmICghdm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcclxuICAgICAgICAgICAgICAgIGNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UsIHRydWUgLyogZGlyZWN0ICovKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxudmFyIGhvb2tzVG9NZXJnZSA9IE9iamVjdC5rZXlzKGNvbXBvbmVudFZOb2RlSG9va3MpO1xyXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnQoQ3RvciwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4sIHRhZykge1xyXG4gICAgaWYgKGlzVW5kZWYoQ3RvcikpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB2YXIgYmFzZUN0b3IgPSBjb250ZXh0LiRvcHRpb25zLl9iYXNlO1xyXG4gICAgLy8gcGxhaW4gb3B0aW9ucyBvYmplY3Q6IHR1cm4gaXQgaW50byBhIGNvbnN0cnVjdG9yXHJcbiAgICBpZiAoaXNPYmplY3QoQ3RvcikpIHtcclxuICAgICAgICBDdG9yID0gYmFzZUN0b3IuZXh0ZW5kKEN0b3IpO1xyXG4gICAgfVxyXG4gICAgLy8gaWYgYXQgdGhpcyBzdGFnZSBpdCdzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIGFuIGFzeW5jIGNvbXBvbmVudCBmYWN0b3J5LFxyXG4gICAgLy8gcmVqZWN0LlxyXG4gICAgaWYgKHR5cGVvZiBDdG9yICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgICAgd2FybiQyKFwiSW52YWxpZCBDb21wb25lbnQgZGVmaW5pdGlvbjogXCIuY29uY2F0KFN0cmluZyhDdG9yKSksIGNvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICAvLyBhc3luYyBjb21wb25lbnRcclxuICAgIHZhciBhc3luY0ZhY3Rvcnk7XHJcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXHJcbiAgICBpZiAoaXNVbmRlZihDdG9yLmNpZCkpIHtcclxuICAgICAgICBhc3luY0ZhY3RvcnkgPSBDdG9yO1xyXG4gICAgICAgIEN0b3IgPSByZXNvbHZlQXN5bmNDb21wb25lbnQoYXN5bmNGYWN0b3J5LCBiYXNlQ3Rvcik7XHJcbiAgICAgICAgaWYgKEN0b3IgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAvLyByZXR1cm4gYSBwbGFjZWhvbGRlciBub2RlIGZvciBhc3luYyBjb21wb25lbnQsIHdoaWNoIGlzIHJlbmRlcmVkXHJcbiAgICAgICAgICAgIC8vIGFzIGEgY29tbWVudCBub2RlIGJ1dCBwcmVzZXJ2ZXMgYWxsIHRoZSByYXcgaW5mb3JtYXRpb24gZm9yIHRoZSBub2RlLlxyXG4gICAgICAgICAgICAvLyB0aGUgaW5mb3JtYXRpb24gd2lsbCBiZSB1c2VkIGZvciBhc3luYyBzZXJ2ZXItcmVuZGVyaW5nIGFuZCBoeWRyYXRpb24uXHJcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVBc3luY1BsYWNlaG9sZGVyKGFzeW5jRmFjdG9yeSwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4sIHRhZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZGF0YSA9IGRhdGEgfHwge307XHJcbiAgICAvLyByZXNvbHZlIGNvbnN0cnVjdG9yIG9wdGlvbnMgaW4gY2FzZSBnbG9iYWwgbWl4aW5zIGFyZSBhcHBsaWVkIGFmdGVyXHJcbiAgICAvLyBjb21wb25lbnQgY29uc3RydWN0b3IgY3JlYXRpb25cclxuICAgIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMoQ3Rvcik7XHJcbiAgICAvLyB0cmFuc2Zvcm0gY29tcG9uZW50IHYtbW9kZWwgZGF0YSBpbnRvIHByb3BzICYgZXZlbnRzXHJcbiAgICBpZiAoaXNEZWYoZGF0YS5tb2RlbCkpIHtcclxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXHJcbiAgICAgICAgdHJhbnNmb3JtTW9kZWwoQ3Rvci5vcHRpb25zLCBkYXRhKTtcclxuICAgIH1cclxuICAgIC8vIGV4dHJhY3QgcHJvcHNcclxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgIHZhciBwcm9wc0RhdGEgPSBleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhKGRhdGEsIEN0b3IsIHRhZyk7XHJcbiAgICAvLyBmdW5jdGlvbmFsIGNvbXBvbmVudFxyXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxyXG4gICAgaWYgKGlzVHJ1ZShDdG9yLm9wdGlvbnMuZnVuY3Rpb25hbCkpIHtcclxuICAgICAgICByZXR1cm4gY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudChDdG9yLCBwcm9wc0RhdGEsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKTtcclxuICAgIH1cclxuICAgIC8vIGV4dHJhY3QgbGlzdGVuZXJzLCBzaW5jZSB0aGVzZSBuZWVkcyB0byBiZSB0cmVhdGVkIGFzXHJcbiAgICAvLyBjaGlsZCBjb21wb25lbnQgbGlzdGVuZXJzIGluc3RlYWQgb2YgRE9NIGxpc3RlbmVyc1xyXG4gICAgdmFyIGxpc3RlbmVycyA9IGRhdGEub247XHJcbiAgICAvLyByZXBsYWNlIHdpdGggbGlzdGVuZXJzIHdpdGggLm5hdGl2ZSBtb2RpZmllclxyXG4gICAgLy8gc28gaXQgZ2V0cyBwcm9jZXNzZWQgZHVyaW5nIHBhcmVudCBjb21wb25lbnQgcGF0Y2guXHJcbiAgICBkYXRhLm9uID0gZGF0YS5uYXRpdmVPbjtcclxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgIGlmIChpc1RydWUoQ3Rvci5vcHRpb25zLmFic3RyYWN0KSkge1xyXG4gICAgICAgIC8vIGFic3RyYWN0IGNvbXBvbmVudHMgZG8gbm90IGtlZXAgYW55dGhpbmdcclxuICAgICAgICAvLyBvdGhlciB0aGFuIHByb3BzICYgbGlzdGVuZXJzICYgc2xvdFxyXG4gICAgICAgIC8vIHdvcmsgYXJvdW5kIGZsb3dcclxuICAgICAgICB2YXIgc2xvdCA9IGRhdGEuc2xvdDtcclxuICAgICAgICBkYXRhID0ge307XHJcbiAgICAgICAgaWYgKHNsb3QpIHtcclxuICAgICAgICAgICAgZGF0YS5zbG90ID0gc2xvdDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBpbnN0YWxsIGNvbXBvbmVudCBtYW5hZ2VtZW50IGhvb2tzIG9udG8gdGhlIHBsYWNlaG9sZGVyIG5vZGVcclxuICAgIGluc3RhbGxDb21wb25lbnRIb29rcyhkYXRhKTtcclxuICAgIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIHZub2RlXHJcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXHJcbiAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoQ3Rvci5vcHRpb25zKSB8fCB0YWc7XHJcbiAgICB2YXIgdm5vZGUgPSBuZXcgVk5vZGUoXHJcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXHJcbiAgICBcInZ1ZS1jb21wb25lbnQtXCIuY29uY2F0KEN0b3IuY2lkKS5jb25jYXQobmFtZSA/IFwiLVwiLmNvbmNhdChuYW1lKSA6ICcnKSwgZGF0YSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dCwgXHJcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXHJcbiAgICB7IEN0b3I6IEN0b3IsIHByb3BzRGF0YTogcHJvcHNEYXRhLCBsaXN0ZW5lcnM6IGxpc3RlbmVycywgdGFnOiB0YWcsIGNoaWxkcmVuOiBjaGlsZHJlbiB9LCBhc3luY0ZhY3RvcnkpO1xyXG4gICAgcmV0dXJuIHZub2RlO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUoXHJcbi8vIHdlIGtub3cgaXQncyBNb3VudGVkQ29tcG9uZW50Vk5vZGUgYnV0IGZsb3cgZG9lc24ndFxyXG52bm9kZSwgXHJcbi8vIGFjdGl2ZUluc3RhbmNlIGluIGxpZmVjeWNsZSBzdGF0ZVxyXG5wYXJlbnQpIHtcclxuICAgIHZhciBvcHRpb25zID0ge1xyXG4gICAgICAgIF9pc0NvbXBvbmVudDogdHJ1ZSxcclxuICAgICAgICBfcGFyZW50Vm5vZGU6IHZub2RlLFxyXG4gICAgICAgIHBhcmVudDogcGFyZW50XHJcbiAgICB9O1xyXG4gICAgLy8gY2hlY2sgaW5saW5lLXRlbXBsYXRlIHJlbmRlciBmdW5jdGlvbnNcclxuICAgIHZhciBpbmxpbmVUZW1wbGF0ZSA9IHZub2RlLmRhdGEuaW5saW5lVGVtcGxhdGU7XHJcbiAgICBpZiAoaXNEZWYoaW5saW5lVGVtcGxhdGUpKSB7XHJcbiAgICAgICAgb3B0aW9ucy5yZW5kZXIgPSBpbmxpbmVUZW1wbGF0ZS5yZW5kZXI7XHJcbiAgICAgICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBpbmxpbmVUZW1wbGF0ZS5zdGF0aWNSZW5kZXJGbnM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IHZub2RlLmNvbXBvbmVudE9wdGlvbnMuQ3RvcihvcHRpb25zKTtcclxufVxyXG5mdW5jdGlvbiBpbnN0YWxsQ29tcG9uZW50SG9va3MoZGF0YSkge1xyXG4gICAgdmFyIGhvb2tzID0gZGF0YS5ob29rIHx8IChkYXRhLmhvb2sgPSB7fSk7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzVG9NZXJnZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciBrZXkgPSBob29rc1RvTWVyZ2VbaV07XHJcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gaG9va3Nba2V5XTtcclxuICAgICAgICB2YXIgdG9NZXJnZSA9IGNvbXBvbmVudFZOb2RlSG9va3Nba2V5XTtcclxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXHJcbiAgICAgICAgaWYgKGV4aXN0aW5nICE9PSB0b01lcmdlICYmICEoZXhpc3RpbmcgJiYgZXhpc3RpbmcuX21lcmdlZCkpIHtcclxuICAgICAgICAgICAgaG9va3Nba2V5XSA9IGV4aXN0aW5nID8gbWVyZ2VIb29rKHRvTWVyZ2UsIGV4aXN0aW5nKSA6IHRvTWVyZ2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIG1lcmdlSG9vayhmMSwgZjIpIHtcclxuICAgIHZhciBtZXJnZWQgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgIC8vIGZsb3cgY29tcGxhaW5zIGFib3V0IGV4dHJhIGFyZ3Mgd2hpY2ggaXMgd2h5IHdlIHVzZSBhbnlcclxuICAgICAgICBmMShhLCBiKTtcclxuICAgICAgICBmMihhLCBiKTtcclxuICAgIH07XHJcbiAgICBtZXJnZWQuX21lcmdlZCA9IHRydWU7XHJcbiAgICByZXR1cm4gbWVyZ2VkO1xyXG59XHJcbi8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBpbmZvICh2YWx1ZSBhbmQgY2FsbGJhY2spIGludG9cclxuLy8gcHJvcCBhbmQgZXZlbnQgaGFuZGxlciByZXNwZWN0aXZlbHkuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybU1vZGVsKG9wdGlvbnMsIGRhdGEpIHtcclxuICAgIHZhciBwcm9wID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5wcm9wKSB8fCAndmFsdWUnO1xyXG4gICAgdmFyIGV2ZW50ID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5ldmVudCkgfHwgJ2lucHV0JztcclxuICAgIChkYXRhLmF0dHJzIHx8IChkYXRhLmF0dHJzID0ge30pKVtwcm9wXSA9IGRhdGEubW9kZWwudmFsdWU7XHJcbiAgICB2YXIgb24gPSBkYXRhLm9uIHx8IChkYXRhLm9uID0ge30pO1xyXG4gICAgdmFyIGV4aXN0aW5nID0gb25bZXZlbnRdO1xyXG4gICAgdmFyIGNhbGxiYWNrID0gZGF0YS5tb2RlbC5jYWxsYmFjaztcclxuICAgIGlmIChpc0RlZihleGlzdGluZykpIHtcclxuICAgICAgICBpZiAoaXNBcnJheShleGlzdGluZylcclxuICAgICAgICAgICAgPyBleGlzdGluZy5pbmRleE9mKGNhbGxiYWNrKSA9PT0gLTFcclxuICAgICAgICAgICAgOiBleGlzdGluZyAhPT0gY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgb25bZXZlbnRdID0gW2NhbGxiYWNrXS5jb25jYXQoZXhpc3RpbmcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIG9uW2V2ZW50XSA9IGNhbGxiYWNrO1xyXG4gICAgfVxyXG59XG5cbnZhciB3YXJuJDIgPSBub29wO1xyXG52YXIgdGlwID0gbm9vcDtcclxudmFyIGdlbmVyYXRlQ29tcG9uZW50VHJhY2U7IC8vIHdvcmsgYXJvdW5kIGZsb3cgY2hlY2tcclxudmFyIGZvcm1hdENvbXBvbmVudE5hbWU7XHJcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICB2YXIgaGFzQ29uc29sZV8xID0gdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnO1xyXG4gICAgdmFyIGNsYXNzaWZ5UkVfMSA9IC8oPzpefFstX10pKFxcdykvZztcclxuICAgIHZhciBjbGFzc2lmeV8xID0gZnVuY3Rpb24gKHN0cikge1xyXG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZShjbGFzc2lmeVJFXzEsIGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRvVXBwZXJDYXNlKCk7IH0pLnJlcGxhY2UoL1stX10vZywgJycpO1xyXG4gICAgfTtcclxuICAgIHdhcm4kMiA9IGZ1bmN0aW9uIChtc2csIHZtKSB7XHJcbiAgICAgICAgaWYgKHZtID09PSB2b2lkIDApIHsgdm0gPSBjdXJyZW50SW5zdGFuY2U7IH1cclxuICAgICAgICB2YXIgdHJhY2UgPSB2bSA/IGdlbmVyYXRlQ29tcG9uZW50VHJhY2Uodm0pIDogJyc7XHJcbiAgICAgICAgaWYgKGNvbmZpZy53YXJuSGFuZGxlcikge1xyXG4gICAgICAgICAgICBjb25maWcud2FybkhhbmRsZXIuY2FsbChudWxsLCBtc2csIHZtLCB0cmFjZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGhhc0NvbnNvbGVfMSAmJiAhY29uZmlnLnNpbGVudCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiW1Z1ZSB3YXJuXTogXCIuY29uY2F0KG1zZykuY29uY2F0KHRyYWNlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRpcCA9IGZ1bmN0aW9uIChtc2csIHZtKSB7XHJcbiAgICAgICAgaWYgKGhhc0NvbnNvbGVfMSAmJiAhY29uZmlnLnNpbGVudCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJbVnVlIHRpcF06IFwiLmNvbmNhdChtc2cpICsgKHZtID8gZ2VuZXJhdGVDb21wb25lbnRUcmFjZSh2bSkgOiAnJykpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBmb3JtYXRDb21wb25lbnROYW1lID0gZnVuY3Rpb24gKHZtLCBpbmNsdWRlRmlsZSkge1xyXG4gICAgICAgIGlmICh2bS4kcm9vdCA9PT0gdm0pIHtcclxuICAgICAgICAgICAgcmV0dXJuICc8Um9vdD4nO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgb3B0aW9ucyA9IGlzRnVuY3Rpb24odm0pICYmIHZtLmNpZCAhPSBudWxsXHJcbiAgICAgICAgICAgID8gdm0ub3B0aW9uc1xyXG4gICAgICAgICAgICA6IHZtLl9pc1Z1ZVxyXG4gICAgICAgICAgICAgICAgPyB2bS4kb3B0aW9ucyB8fCB2bS5jb25zdHJ1Y3Rvci5vcHRpb25zXHJcbiAgICAgICAgICAgICAgICA6IHZtO1xyXG4gICAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShvcHRpb25zKTtcclxuICAgICAgICB2YXIgZmlsZSA9IG9wdGlvbnMuX19maWxlO1xyXG4gICAgICAgIGlmICghbmFtZSAmJiBmaWxlKSB7XHJcbiAgICAgICAgICAgIHZhciBtYXRjaCA9IGZpbGUubWF0Y2goLyhbXi9cXFxcXSspXFwudnVlJC8pO1xyXG4gICAgICAgICAgICBuYW1lID0gbWF0Y2ggJiYgbWF0Y2hbMV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAoKG5hbWUgPyBcIjxcIi5jb25jYXQoY2xhc3NpZnlfMShuYW1lKSwgXCI+XCIpIDogXCI8QW5vbnltb3VzPlwiKSArXHJcbiAgICAgICAgICAgIChmaWxlICYmIGluY2x1ZGVGaWxlICE9PSBmYWxzZSA/IFwiIGF0IFwiLmNvbmNhdChmaWxlKSA6ICcnKSk7XHJcbiAgICB9O1xyXG4gICAgdmFyIHJlcGVhdF8xID0gZnVuY3Rpb24gKHN0ciwgbikge1xyXG4gICAgICAgIHZhciByZXMgPSAnJztcclxuICAgICAgICB3aGlsZSAobikge1xyXG4gICAgICAgICAgICBpZiAobiAlIDIgPT09IDEpXHJcbiAgICAgICAgICAgICAgICByZXMgKz0gc3RyO1xyXG4gICAgICAgICAgICBpZiAobiA+IDEpXHJcbiAgICAgICAgICAgICAgICBzdHIgKz0gc3RyO1xyXG4gICAgICAgICAgICBuID4+PSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfTtcclxuICAgIGdlbmVyYXRlQ29tcG9uZW50VHJhY2UgPSBmdW5jdGlvbiAodm0pIHtcclxuICAgICAgICBpZiAodm0uX2lzVnVlICYmIHZtLiRwYXJlbnQpIHtcclxuICAgICAgICAgICAgdmFyIHRyZWUgPSBbXTtcclxuICAgICAgICAgICAgdmFyIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XHJcbiAgICAgICAgICAgIHdoaWxlICh2bSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRyZWUubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsYXN0ID0gdHJlZVt0cmVlLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXN0LmNvbnN0cnVjdG9yID09PSB2bS5jb25zdHJ1Y3Rvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdm0gPSB2bS4kcGFyZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmVlW3RyZWUubGVuZ3RoIC0gMV0gPSBbbGFzdCwgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0cmVlLnB1c2godm0pO1xyXG4gICAgICAgICAgICAgICAgdm0gPSB2bS4kcGFyZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAoJ1xcblxcbmZvdW5kIGluXFxuXFxuJyArXHJcbiAgICAgICAgICAgICAgICB0cmVlXHJcbiAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAodm0sIGkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQoaSA9PT0gMCA/ICctLS0+ICcgOiByZXBlYXRfMSgnICcsIDUgKyBpICogMikpLmNvbmNhdChpc0FycmF5KHZtKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFwiXCIuY29uY2F0KGZvcm1hdENvbXBvbmVudE5hbWUodm1bMF0pLCBcIi4uLiAoXCIpLmNvbmNhdCh2bVsxXSwgXCIgcmVjdXJzaXZlIGNhbGxzKVwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGZvcm1hdENvbXBvbmVudE5hbWUodm0pKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmpvaW4oJ1xcbicpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBcIlxcblxcbihmb3VuZCBpbiBcIi5jb25jYXQoZm9ybWF0Q29tcG9uZW50TmFtZSh2bSksIFwiKVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XG5cbi8qKlxyXG4gKiBPcHRpb24gb3ZlcndyaXRpbmcgc3RyYXRlZ2llcyBhcmUgZnVuY3Rpb25zIHRoYXQgaGFuZGxlXHJcbiAqIGhvdyB0byBtZXJnZSBhIHBhcmVudCBvcHRpb24gdmFsdWUgYW5kIGEgY2hpbGQgb3B0aW9uXHJcbiAqIHZhbHVlIGludG8gdGhlIGZpbmFsIHZhbHVlLlxyXG4gKi9cclxudmFyIHN0cmF0cyA9IGNvbmZpZy5vcHRpb25NZXJnZVN0cmF0ZWdpZXM7XHJcbi8qKlxyXG4gKiBPcHRpb25zIHdpdGggcmVzdHJpY3Rpb25zXHJcbiAqL1xyXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgc3RyYXRzLmVsID0gc3RyYXRzLnByb3BzRGF0YSA9IGZ1bmN0aW9uIChwYXJlbnQsIGNoaWxkLCB2bSwga2V5KSB7XHJcbiAgICAgICAgaWYgKCF2bSkge1xyXG4gICAgICAgICAgICB3YXJuJDIoXCJvcHRpb24gXFxcIlwiLmNvbmNhdChrZXksIFwiXFxcIiBjYW4gb25seSBiZSB1c2VkIGR1cmluZyBpbnN0YW5jZSBcIikgK1xyXG4gICAgICAgICAgICAgICAgJ2NyZWF0aW9uIHdpdGggdGhlIGBuZXdgIGtleXdvcmQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkZWZhdWx0U3RyYXQocGFyZW50LCBjaGlsZCk7XHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBIZWxwZXIgdGhhdCByZWN1cnNpdmVseSBtZXJnZXMgdHdvIGRhdGEgb2JqZWN0cyB0b2dldGhlci5cclxuICovXHJcbmZ1bmN0aW9uIG1lcmdlRGF0YSh0bywgZnJvbSkge1xyXG4gICAgaWYgKCFmcm9tKVxyXG4gICAgICAgIHJldHVybiB0bztcclxuICAgIHZhciBrZXksIHRvVmFsLCBmcm9tVmFsO1xyXG4gICAgdmFyIGtleXMgPSBoYXNTeW1ib2xcclxuICAgICAgICA/IFJlZmxlY3Qub3duS2V5cyhmcm9tKVxyXG4gICAgICAgIDogT2JqZWN0LmtleXMoZnJvbSk7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBrZXkgPSBrZXlzW2ldO1xyXG4gICAgICAgIC8vIGluIGNhc2UgdGhlIG9iamVjdCBpcyBhbHJlYWR5IG9ic2VydmVkLi4uXHJcbiAgICAgICAgaWYgKGtleSA9PT0gJ19fb2JfXycpXHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIHRvVmFsID0gdG9ba2V5XTtcclxuICAgICAgICBmcm9tVmFsID0gZnJvbVtrZXldO1xyXG4gICAgICAgIGlmICghaGFzT3duKHRvLCBrZXkpKSB7XHJcbiAgICAgICAgICAgIHNldCh0bywga2V5LCBmcm9tVmFsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodG9WYWwgIT09IGZyb21WYWwgJiZcclxuICAgICAgICAgICAgaXNQbGFpbk9iamVjdCh0b1ZhbCkgJiZcclxuICAgICAgICAgICAgaXNQbGFpbk9iamVjdChmcm9tVmFsKSkge1xyXG4gICAgICAgICAgICBtZXJnZURhdGEodG9WYWwsIGZyb21WYWwpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0bztcclxufVxyXG4vKipcclxuICogRGF0YVxyXG4gKi9cclxuZnVuY3Rpb24gbWVyZ2VEYXRhT3JGbihwYXJlbnRWYWwsIGNoaWxkVmFsLCB2bSkge1xyXG4gICAgaWYgKCF2bSkge1xyXG4gICAgICAgIC8vIGluIGEgVnVlLmV4dGVuZCBtZXJnZSwgYm90aCBzaG91bGQgYmUgZnVuY3Rpb25zXHJcbiAgICAgICAgaWYgKCFjaGlsZFZhbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcGFyZW50VmFsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXBhcmVudFZhbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gY2hpbGRWYWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHdoZW4gcGFyZW50VmFsICYgY2hpbGRWYWwgYXJlIGJvdGggcHJlc2VudCxcclxuICAgICAgICAvLyB3ZSBuZWVkIHRvIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGVcclxuICAgICAgICAvLyBtZXJnZWQgcmVzdWx0IG9mIGJvdGggZnVuY3Rpb25zLi4uIG5vIG5lZWQgdG9cclxuICAgICAgICAvLyBjaGVjayBpZiBwYXJlbnRWYWwgaXMgYSBmdW5jdGlvbiBoZXJlIGJlY2F1c2VcclxuICAgICAgICAvLyBpdCBoYXMgdG8gYmUgYSBmdW5jdGlvbiB0byBwYXNzIHByZXZpb3VzIG1lcmdlcy5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkRGF0YUZuKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbWVyZ2VEYXRhKGlzRnVuY3Rpb24oY2hpbGRWYWwpID8gY2hpbGRWYWwuY2FsbCh0aGlzLCB0aGlzKSA6IGNoaWxkVmFsLCBpc0Z1bmN0aW9uKHBhcmVudFZhbCkgPyBwYXJlbnRWYWwuY2FsbCh0aGlzLCB0aGlzKSA6IHBhcmVudFZhbCk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWRJbnN0YW5jZURhdGFGbigpIHtcclxuICAgICAgICAgICAgLy8gaW5zdGFuY2UgbWVyZ2VcclxuICAgICAgICAgICAgdmFyIGluc3RhbmNlRGF0YSA9IGlzRnVuY3Rpb24oY2hpbGRWYWwpXHJcbiAgICAgICAgICAgICAgICA/IGNoaWxkVmFsLmNhbGwodm0sIHZtKVxyXG4gICAgICAgICAgICAgICAgOiBjaGlsZFZhbDtcclxuICAgICAgICAgICAgdmFyIGRlZmF1bHREYXRhID0gaXNGdW5jdGlvbihwYXJlbnRWYWwpXHJcbiAgICAgICAgICAgICAgICA/IHBhcmVudFZhbC5jYWxsKHZtLCB2bSlcclxuICAgICAgICAgICAgICAgIDogcGFyZW50VmFsO1xyXG4gICAgICAgICAgICBpZiAoaW5zdGFuY2VEYXRhKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVyZ2VEYXRhKGluc3RhbmNlRGF0YSwgZGVmYXVsdERhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHREYXRhO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5zdHJhdHMuZGF0YSA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsLCB2bSkge1xyXG4gICAgaWYgKCF2bSkge1xyXG4gICAgICAgIGlmIChjaGlsZFZhbCAmJiB0eXBlb2YgY2hpbGRWYWwgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxyXG4gICAgICAgICAgICAgICAgd2FybiQyKCdUaGUgXCJkYXRhXCIgb3B0aW9uIHNob3VsZCBiZSBhIGZ1bmN0aW9uICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICd0aGF0IHJldHVybnMgYSBwZXItaW5zdGFuY2UgdmFsdWUgaW4gY29tcG9uZW50ICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICdkZWZpbml0aW9ucy4nLCB2bSk7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRWYWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtZXJnZURhdGFPckZuKHBhcmVudFZhbCwgY2hpbGRWYWwpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1lcmdlRGF0YU9yRm4ocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0pO1xyXG59O1xyXG4vKipcclxuICogSG9va3MgYW5kIHByb3BzIGFyZSBtZXJnZWQgYXMgYXJyYXlzLlxyXG4gKi9cclxuZnVuY3Rpb24gbWVyZ2VMaWZlY3ljbGVIb29rKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcclxuICAgIHZhciByZXMgPSBjaGlsZFZhbFxyXG4gICAgICAgID8gcGFyZW50VmFsXHJcbiAgICAgICAgICAgID8gcGFyZW50VmFsLmNvbmNhdChjaGlsZFZhbClcclxuICAgICAgICAgICAgOiBpc0FycmF5KGNoaWxkVmFsKVxyXG4gICAgICAgICAgICAgICAgPyBjaGlsZFZhbFxyXG4gICAgICAgICAgICAgICAgOiBbY2hpbGRWYWxdXHJcbiAgICAgICAgOiBwYXJlbnRWYWw7XHJcbiAgICByZXR1cm4gcmVzID8gZGVkdXBlSG9va3MocmVzKSA6IHJlcztcclxufVxyXG5mdW5jdGlvbiBkZWR1cGVIb29rcyhob29rcykge1xyXG4gICAgdmFyIHJlcyA9IFtdO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChyZXMuaW5kZXhPZihob29rc1tpXSkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIHJlcy5wdXNoKGhvb2tzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcbkxJRkVDWUNMRV9IT09LUy5mb3JFYWNoKGZ1bmN0aW9uIChob29rKSB7XHJcbiAgICBzdHJhdHNbaG9va10gPSBtZXJnZUxpZmVjeWNsZUhvb2s7XHJcbn0pO1xyXG4vKipcclxuICogQXNzZXRzXHJcbiAqXHJcbiAqIFdoZW4gYSB2bSBpcyBwcmVzZW50IChpbnN0YW5jZSBjcmVhdGlvbiksIHdlIG5lZWQgdG8gZG9cclxuICogYSB0aHJlZS13YXkgbWVyZ2UgYmV0d2VlbiBjb25zdHJ1Y3RvciBvcHRpb25zLCBpbnN0YW5jZVxyXG4gKiBvcHRpb25zIGFuZCBwYXJlbnQgb3B0aW9ucy5cclxuICovXHJcbmZ1bmN0aW9uIG1lcmdlQXNzZXRzKHBhcmVudFZhbCwgY2hpbGRWYWwsIHZtLCBrZXkpIHtcclxuICAgIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKTtcclxuICAgIGlmIChjaGlsZFZhbCkge1xyXG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZChyZXMsIGNoaWxkVmFsKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbn1cclxuQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xyXG4gICAgc3RyYXRzW3R5cGUgKyAncyddID0gbWVyZ2VBc3NldHM7XHJcbn0pO1xyXG4vKipcclxuICogV2F0Y2hlcnMuXHJcbiAqXHJcbiAqIFdhdGNoZXJzIGhhc2hlcyBzaG91bGQgbm90IG92ZXJ3cml0ZSBvbmVcclxuICogYW5vdGhlciwgc28gd2UgbWVyZ2UgdGhlbSBhcyBhcnJheXMuXHJcbiAqL1xyXG5zdHJhdHMud2F0Y2ggPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0sIGtleSkge1xyXG4gICAgLy8gd29yayBhcm91bmQgRmlyZWZveCdzIE9iamVjdC5wcm90b3R5cGUud2F0Y2guLi5cclxuICAgIC8vQHRzLWV4cGVjdC1lcnJvciB3b3JrIGFyb3VuZFxyXG4gICAgaWYgKHBhcmVudFZhbCA9PT0gbmF0aXZlV2F0Y2gpXHJcbiAgICAgICAgcGFyZW50VmFsID0gdW5kZWZpbmVkO1xyXG4gICAgLy9AdHMtZXhwZWN0LWVycm9yIHdvcmsgYXJvdW5kXHJcbiAgICBpZiAoY2hpbGRWYWwgPT09IG5hdGl2ZVdhdGNoKVxyXG4gICAgICAgIGNoaWxkVmFsID0gdW5kZWZpbmVkO1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICBpZiAoIWNoaWxkVmFsKVxyXG4gICAgICAgIHJldHVybiBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKTtcclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XHJcbiAgICB9XHJcbiAgICBpZiAoIXBhcmVudFZhbClcclxuICAgICAgICByZXR1cm4gY2hpbGRWYWw7XHJcbiAgICB2YXIgcmV0ID0ge307XHJcbiAgICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xyXG4gICAgZm9yICh2YXIga2V5XzEgaW4gY2hpbGRWYWwpIHtcclxuICAgICAgICB2YXIgcGFyZW50XzEgPSByZXRba2V5XzFdO1xyXG4gICAgICAgIHZhciBjaGlsZCA9IGNoaWxkVmFsW2tleV8xXTtcclxuICAgICAgICBpZiAocGFyZW50XzEgJiYgIWlzQXJyYXkocGFyZW50XzEpKSB7XHJcbiAgICAgICAgICAgIHBhcmVudF8xID0gW3BhcmVudF8xXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0W2tleV8xXSA9IHBhcmVudF8xID8gcGFyZW50XzEuY29uY2F0KGNoaWxkKSA6IGlzQXJyYXkoY2hpbGQpID8gY2hpbGQgOiBbY2hpbGRdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJldDtcclxufTtcclxuLyoqXHJcbiAqIE90aGVyIG9iamVjdCBoYXNoZXMuXHJcbiAqL1xyXG5zdHJhdHMucHJvcHMgPVxyXG4gICAgc3RyYXRzLm1ldGhvZHMgPVxyXG4gICAgICAgIHN0cmF0cy5pbmplY3QgPVxyXG4gICAgICAgICAgICBzdHJhdHMuY29tcHV0ZWQgPVxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwsIHZtLCBrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRWYWwgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnRPYmplY3RUeXBlKGtleSwgY2hpbGRWYWwsIHZtKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJlbnRWYWwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZFZhbDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmV0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZFZhbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5kKHJldCwgY2hpbGRWYWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5zdHJhdHMucHJvdmlkZSA9IG1lcmdlRGF0YU9yRm47XHJcbi8qKlxyXG4gKiBEZWZhdWx0IHN0cmF0ZWd5LlxyXG4gKi9cclxudmFyIGRlZmF1bHRTdHJhdCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XHJcbiAgICByZXR1cm4gY2hpbGRWYWwgPT09IHVuZGVmaW5lZCA/IHBhcmVudFZhbCA6IGNoaWxkVmFsO1xyXG59O1xyXG4vKipcclxuICogVmFsaWRhdGUgY29tcG9uZW50IG5hbWVzXHJcbiAqL1xyXG5mdW5jdGlvbiBjaGVja0NvbXBvbmVudHMob3B0aW9ucykge1xyXG4gICAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMuY29tcG9uZW50cykge1xyXG4gICAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShrZXkpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHZhbGlkYXRlQ29tcG9uZW50TmFtZShuYW1lKSB7XHJcbiAgICBpZiAoIW5ldyBSZWdFeHAoXCJeW2EtekEtWl1bXFxcXC1cXFxcLjAtOV9cIi5jb25jYXQodW5pY29kZVJlZ0V4cC5zb3VyY2UsIFwiXSokXCIpKS50ZXN0KG5hbWUpKSB7XHJcbiAgICAgICAgd2FybiQyKCdJbnZhbGlkIGNvbXBvbmVudCBuYW1lOiBcIicgK1xyXG4gICAgICAgICAgICBuYW1lICtcclxuICAgICAgICAgICAgJ1wiLiBDb21wb25lbnQgbmFtZXMgJyArXHJcbiAgICAgICAgICAgICdzaG91bGQgY29uZm9ybSB0byB2YWxpZCBjdXN0b20gZWxlbWVudCBuYW1lIGluIGh0bWw1IHNwZWNpZmljYXRpb24uJyk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNCdWlsdEluVGFnKG5hbWUpIHx8IGNvbmZpZy5pc1Jlc2VydmVkVGFnKG5hbWUpKSB7XHJcbiAgICAgICAgd2FybiQyKCdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgK1xyXG4gICAgICAgICAgICAnaWQ6ICcgK1xyXG4gICAgICAgICAgICBuYW1lKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogRW5zdXJlIGFsbCBwcm9wcyBvcHRpb24gc3ludGF4IGFyZSBub3JtYWxpemVkIGludG8gdGhlXHJcbiAqIE9iamVjdC1iYXNlZCBmb3JtYXQuXHJcbiAqL1xyXG5mdW5jdGlvbiBub3JtYWxpemVQcm9wcyhvcHRpb25zLCB2bSkge1xyXG4gICAgdmFyIHByb3BzID0gb3B0aW9ucy5wcm9wcztcclxuICAgIGlmICghcHJvcHMpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgdmFyIHJlcyA9IHt9O1xyXG4gICAgdmFyIGksIHZhbCwgbmFtZTtcclxuICAgIGlmIChpc0FycmF5KHByb3BzKSkge1xyXG4gICAgICAgIGkgPSBwcm9wcy5sZW5ndGg7XHJcbiAgICAgICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgICAgICB2YWwgPSBwcm9wc1tpXTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICBuYW1lID0gY2FtZWxpemUodmFsKTtcclxuICAgICAgICAgICAgICAgIHJlc1tuYW1lXSA9IHsgdHlwZTogbnVsbCB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4kMigncHJvcHMgbXVzdCBiZSBzdHJpbmdzIHdoZW4gdXNpbmcgYXJyYXkgc3ludGF4LicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNQbGFpbk9iamVjdChwcm9wcykpIHtcclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcclxuICAgICAgICAgICAgdmFsID0gcHJvcHNba2V5XTtcclxuICAgICAgICAgICAgbmFtZSA9IGNhbWVsaXplKGtleSk7XHJcbiAgICAgICAgICAgIHJlc1tuYW1lXSA9IGlzUGxhaW5PYmplY3QodmFsKSA/IHZhbCA6IHsgdHlwZTogdmFsIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgIHdhcm4kMihcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwicHJvcHNcXFwiOiBleHBlY3RlZCBhbiBBcnJheSBvciBhbiBPYmplY3QsIFwiICtcclxuICAgICAgICAgICAgXCJidXQgZ290IFwiLmNvbmNhdCh0b1Jhd1R5cGUocHJvcHMpLCBcIi5cIiksIHZtKTtcclxuICAgIH1cclxuICAgIG9wdGlvbnMucHJvcHMgPSByZXM7XHJcbn1cclxuLyoqXHJcbiAqIE5vcm1hbGl6ZSBhbGwgaW5qZWN0aW9ucyBpbnRvIE9iamVjdC1iYXNlZCBmb3JtYXRcclxuICovXHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZUluamVjdChvcHRpb25zLCB2bSkge1xyXG4gICAgdmFyIGluamVjdCA9IG9wdGlvbnMuaW5qZWN0O1xyXG4gICAgaWYgKCFpbmplY3QpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgdmFyIG5vcm1hbGl6ZWQgPSAob3B0aW9ucy5pbmplY3QgPSB7fSk7XHJcbiAgICBpZiAoaXNBcnJheShpbmplY3QpKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmplY3QubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbm9ybWFsaXplZFtpbmplY3RbaV1dID0geyBmcm9tOiBpbmplY3RbaV0gfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc1BsYWluT2JqZWN0KGluamVjdCkpIHtcclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gaW5qZWN0KSB7XHJcbiAgICAgICAgICAgIHZhciB2YWwgPSBpbmplY3Rba2V5XTtcclxuICAgICAgICAgICAgbm9ybWFsaXplZFtrZXldID0gaXNQbGFpbk9iamVjdCh2YWwpXHJcbiAgICAgICAgICAgICAgICA/IGV4dGVuZCh7IGZyb206IGtleSB9LCB2YWwpXHJcbiAgICAgICAgICAgICAgICA6IHsgZnJvbTogdmFsIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgIHdhcm4kMihcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwiaW5qZWN0XFxcIjogZXhwZWN0ZWQgYW4gQXJyYXkgb3IgYW4gT2JqZWN0LCBcIiArXHJcbiAgICAgICAgICAgIFwiYnV0IGdvdCBcIi5jb25jYXQodG9SYXdUeXBlKGluamVjdCksIFwiLlwiKSwgdm0pO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBOb3JtYWxpemUgcmF3IGZ1bmN0aW9uIGRpcmVjdGl2ZXMgaW50byBvYmplY3QgZm9ybWF0LlxyXG4gKi9cclxuZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyQxKG9wdGlvbnMpIHtcclxuICAgIHZhciBkaXJzID0gb3B0aW9ucy5kaXJlY3RpdmVzO1xyXG4gICAgaWYgKGRpcnMpIHtcclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZGlycykge1xyXG4gICAgICAgICAgICB2YXIgZGVmID0gZGlyc1trZXldO1xyXG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihkZWYpKSB7XHJcbiAgICAgICAgICAgICAgICBkaXJzW2tleV0gPSB7IGJpbmQ6IGRlZiwgdXBkYXRlOiBkZWYgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBhc3NlcnRPYmplY3RUeXBlKG5hbWUsIHZhbHVlLCB2bSkge1xyXG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xyXG4gICAgICAgIHdhcm4kMihcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwiXCIuY29uY2F0KG5hbWUsIFwiXFxcIjogZXhwZWN0ZWQgYW4gT2JqZWN0LCBcIikgK1xyXG4gICAgICAgICAgICBcImJ1dCBnb3QgXCIuY29uY2F0KHRvUmF3VHlwZSh2YWx1ZSksIFwiLlwiKSwgdm0pO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBNZXJnZSB0d28gb3B0aW9uIG9iamVjdHMgaW50byBhIG5ldyBvbmUuXHJcbiAqIENvcmUgdXRpbGl0eSB1c2VkIGluIGJvdGggaW5zdGFudGlhdGlvbiBhbmQgaW5oZXJpdGFuY2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZCwgdm0pIHtcclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgY2hlY2tDb21wb25lbnRzKGNoaWxkKTtcclxuICAgIH1cclxuICAgIGlmIChpc0Z1bmN0aW9uKGNoaWxkKSkge1xyXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgICAgICBjaGlsZCA9IGNoaWxkLm9wdGlvbnM7XHJcbiAgICB9XHJcbiAgICBub3JtYWxpemVQcm9wcyhjaGlsZCwgdm0pO1xyXG4gICAgbm9ybWFsaXplSW5qZWN0KGNoaWxkLCB2bSk7XHJcbiAgICBub3JtYWxpemVEaXJlY3RpdmVzJDEoY2hpbGQpO1xyXG4gICAgLy8gQXBwbHkgZXh0ZW5kcyBhbmQgbWl4aW5zIG9uIHRoZSBjaGlsZCBvcHRpb25zLFxyXG4gICAgLy8gYnV0IG9ubHkgaWYgaXQgaXMgYSByYXcgb3B0aW9ucyBvYmplY3QgdGhhdCBpc24ndFxyXG4gICAgLy8gdGhlIHJlc3VsdCBvZiBhbm90aGVyIG1lcmdlT3B0aW9ucyBjYWxsLlxyXG4gICAgLy8gT25seSBtZXJnZWQgb3B0aW9ucyBoYXMgdGhlIF9iYXNlIHByb3BlcnR5LlxyXG4gICAgaWYgKCFjaGlsZC5fYmFzZSkge1xyXG4gICAgICAgIGlmIChjaGlsZC5leHRlbmRzKSB7XHJcbiAgICAgICAgICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGNoaWxkLmV4dGVuZHMsIHZtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNoaWxkLm1peGlucykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkLm1peGlucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGNoaWxkLm1peGluc1tpXSwgdm0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdmFyIG9wdGlvbnMgPSB7fTtcclxuICAgIHZhciBrZXk7XHJcbiAgICBmb3IgKGtleSBpbiBwYXJlbnQpIHtcclxuICAgICAgICBtZXJnZUZpZWxkKGtleSk7XHJcbiAgICB9XHJcbiAgICBmb3IgKGtleSBpbiBjaGlsZCkge1xyXG4gICAgICAgIGlmICghaGFzT3duKHBhcmVudCwga2V5KSkge1xyXG4gICAgICAgICAgICBtZXJnZUZpZWxkKGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gbWVyZ2VGaWVsZChrZXkpIHtcclxuICAgICAgICB2YXIgc3RyYXQgPSBzdHJhdHNba2V5XSB8fCBkZWZhdWx0U3RyYXQ7XHJcbiAgICAgICAgb3B0aW9uc1trZXldID0gc3RyYXQocGFyZW50W2tleV0sIGNoaWxkW2tleV0sIHZtLCBrZXkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG9wdGlvbnM7XHJcbn1cclxuLyoqXHJcbiAqIFJlc29sdmUgYW4gYXNzZXQuXHJcbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBiZWNhdXNlIGNoaWxkIGluc3RhbmNlcyBuZWVkIGFjY2Vzc1xyXG4gKiB0byBhc3NldHMgZGVmaW5lZCBpbiBpdHMgYW5jZXN0b3IgY2hhaW4uXHJcbiAqL1xyXG5mdW5jdGlvbiByZXNvbHZlQXNzZXQob3B0aW9ucywgdHlwZSwgaWQsIHdhcm5NaXNzaW5nKSB7XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIGlmICh0eXBlb2YgaWQgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdmFyIGFzc2V0cyA9IG9wdGlvbnNbdHlwZV07XHJcbiAgICAvLyBjaGVjayBsb2NhbCByZWdpc3RyYXRpb24gdmFyaWF0aW9ucyBmaXJzdFxyXG4gICAgaWYgKGhhc093bihhc3NldHMsIGlkKSlcclxuICAgICAgICByZXR1cm4gYXNzZXRzW2lkXTtcclxuICAgIHZhciBjYW1lbGl6ZWRJZCA9IGNhbWVsaXplKGlkKTtcclxuICAgIGlmIChoYXNPd24oYXNzZXRzLCBjYW1lbGl6ZWRJZCkpXHJcbiAgICAgICAgcmV0dXJuIGFzc2V0c1tjYW1lbGl6ZWRJZF07XHJcbiAgICB2YXIgUGFzY2FsQ2FzZUlkID0gY2FwaXRhbGl6ZShjYW1lbGl6ZWRJZCk7XHJcbiAgICBpZiAoaGFzT3duKGFzc2V0cywgUGFzY2FsQ2FzZUlkKSlcclxuICAgICAgICByZXR1cm4gYXNzZXRzW1Bhc2NhbENhc2VJZF07XHJcbiAgICAvLyBmYWxsYmFjayB0byBwcm90b3R5cGUgY2hhaW5cclxuICAgIHZhciByZXMgPSBhc3NldHNbaWRdIHx8IGFzc2V0c1tjYW1lbGl6ZWRJZF0gfHwgYXNzZXRzW1Bhc2NhbENhc2VJZF07XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuTWlzc2luZyAmJiAhcmVzKSB7XHJcbiAgICAgICAgd2FybiQyKCdGYWlsZWQgdG8gcmVzb2x2ZSAnICsgdHlwZS5zbGljZSgwLCAtMSkgKyAnOiAnICsgaWQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wT3B0aW9ucywgcHJvcHNEYXRhLCB2bSkge1xyXG4gICAgdmFyIHByb3AgPSBwcm9wT3B0aW9uc1trZXldO1xyXG4gICAgdmFyIGFic2VudCA9ICFoYXNPd24ocHJvcHNEYXRhLCBrZXkpO1xyXG4gICAgdmFyIHZhbHVlID0gcHJvcHNEYXRhW2tleV07XHJcbiAgICAvLyBib29sZWFuIGNhc3RpbmdcclxuICAgIHZhciBib29sZWFuSW5kZXggPSBnZXRUeXBlSW5kZXgoQm9vbGVhbiwgcHJvcC50eXBlKTtcclxuICAgIGlmIChib29sZWFuSW5kZXggPiAtMSkge1xyXG4gICAgICAgIGlmIChhYnNlbnQgJiYgIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gaHlwaGVuYXRlKGtleSkpIHtcclxuICAgICAgICAgICAgLy8gb25seSBjYXN0IGVtcHR5IHN0cmluZyAvIHNhbWUgbmFtZSB0byBib29sZWFuIGlmXHJcbiAgICAgICAgICAgIC8vIGJvb2xlYW4gaGFzIGhpZ2hlciBwcmlvcml0eVxyXG4gICAgICAgICAgICB2YXIgc3RyaW5nSW5kZXggPSBnZXRUeXBlSW5kZXgoU3RyaW5nLCBwcm9wLnR5cGUpO1xyXG4gICAgICAgICAgICBpZiAoc3RyaW5nSW5kZXggPCAwIHx8IGJvb2xlYW5JbmRleCA8IHN0cmluZ0luZGV4KSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBjaGVjayBkZWZhdWx0IHZhbHVlXHJcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHZhbHVlID0gZ2V0UHJvcERlZmF1bHRWYWx1ZSh2bSwgcHJvcCwga2V5KTtcclxuICAgICAgICAvLyBzaW5jZSB0aGUgZGVmYXVsdCB2YWx1ZSBpcyBhIGZyZXNoIGNvcHksXHJcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRvIG9ic2VydmUgaXQuXHJcbiAgICAgICAgdmFyIHByZXZTaG91bGRPYnNlcnZlID0gc2hvdWxkT2JzZXJ2ZTtcclxuICAgICAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XHJcbiAgICAgICAgb2JzZXJ2ZSh2YWx1ZSk7XHJcbiAgICAgICAgdG9nZ2xlT2JzZXJ2aW5nKHByZXZTaG91bGRPYnNlcnZlKTtcclxuICAgIH1cclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgYXNzZXJ0UHJvcChwcm9wLCBrZXksIHZhbHVlLCB2bSwgYWJzZW50KTtcclxuICAgIH1cclxuICAgIHJldHVybiB2YWx1ZTtcclxufVxyXG4vKipcclxuICogR2V0IHRoZSBkZWZhdWx0IHZhbHVlIG9mIGEgcHJvcC5cclxuICovXHJcbmZ1bmN0aW9uIGdldFByb3BEZWZhdWx0VmFsdWUodm0sIHByb3AsIGtleSkge1xyXG4gICAgLy8gbm8gZGVmYXVsdCwgcmV0dXJuIHVuZGVmaW5lZFxyXG4gICAgaWYgKCFoYXNPd24ocHJvcCwgJ2RlZmF1bHQnKSkge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICB2YXIgZGVmID0gcHJvcC5kZWZhdWx0O1xyXG4gICAgLy8gd2FybiBhZ2FpbnN0IG5vbi1mYWN0b3J5IGRlZmF1bHRzIGZvciBPYmplY3QgJiBBcnJheVxyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaXNPYmplY3QoZGVmKSkge1xyXG4gICAgICAgIHdhcm4kMignSW52YWxpZCBkZWZhdWx0IHZhbHVlIGZvciBwcm9wIFwiJyArXHJcbiAgICAgICAgICAgIGtleSArXHJcbiAgICAgICAgICAgICdcIjogJyArXHJcbiAgICAgICAgICAgICdQcm9wcyB3aXRoIHR5cGUgT2JqZWN0L0FycmF5IG11c3QgdXNlIGEgZmFjdG9yeSBmdW5jdGlvbiAnICtcclxuICAgICAgICAgICAgJ3RvIHJldHVybiB0aGUgZGVmYXVsdCB2YWx1ZS4nLCB2bSk7XHJcbiAgICB9XHJcbiAgICAvLyB0aGUgcmF3IHByb3AgdmFsdWUgd2FzIGFsc28gdW5kZWZpbmVkIGZyb20gcHJldmlvdXMgcmVuZGVyLFxyXG4gICAgLy8gcmV0dXJuIHByZXZpb3VzIGRlZmF1bHQgdmFsdWUgdG8gYXZvaWQgdW5uZWNlc3Nhcnkgd2F0Y2hlciB0cmlnZ2VyXHJcbiAgICBpZiAodm0gJiZcclxuICAgICAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgJiZcclxuICAgICAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGFba2V5XSA9PT0gdW5kZWZpbmVkICYmXHJcbiAgICAgICAgdm0uX3Byb3BzW2tleV0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiB2bS5fcHJvcHNba2V5XTtcclxuICAgIH1cclxuICAgIC8vIGNhbGwgZmFjdG9yeSBmdW5jdGlvbiBmb3Igbm9uLUZ1bmN0aW9uIHR5cGVzXHJcbiAgICAvLyBhIHZhbHVlIGlzIEZ1bmN0aW9uIGlmIGl0cyBwcm90b3R5cGUgaXMgZnVuY3Rpb24gZXZlbiBhY3Jvc3MgZGlmZmVyZW50IGV4ZWN1dGlvbiBjb250ZXh0XHJcbiAgICByZXR1cm4gaXNGdW5jdGlvbihkZWYpICYmIGdldFR5cGUocHJvcC50eXBlKSAhPT0gJ0Z1bmN0aW9uJ1xyXG4gICAgICAgID8gZGVmLmNhbGwodm0pXHJcbiAgICAgICAgOiBkZWY7XHJcbn1cclxuLyoqXHJcbiAqIEFzc2VydCB3aGV0aGVyIGEgcHJvcCBpcyB2YWxpZC5cclxuICovXHJcbmZ1bmN0aW9uIGFzc2VydFByb3AocHJvcCwgbmFtZSwgdmFsdWUsIHZtLCBhYnNlbnQpIHtcclxuICAgIGlmIChwcm9wLnJlcXVpcmVkICYmIGFic2VudCkge1xyXG4gICAgICAgIHdhcm4kMignTWlzc2luZyByZXF1aXJlZCBwcm9wOiBcIicgKyBuYW1lICsgJ1wiJywgdm0pO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICh2YWx1ZSA9PSBudWxsICYmICFwcm9wLnJlcXVpcmVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdmFyIHR5cGUgPSBwcm9wLnR5cGU7XHJcbiAgICB2YXIgdmFsaWQgPSAhdHlwZSB8fCB0eXBlID09PSB0cnVlO1xyXG4gICAgdmFyIGV4cGVjdGVkVHlwZXMgPSBbXTtcclxuICAgIGlmICh0eXBlKSB7XHJcbiAgICAgICAgaWYgKCFpc0FycmF5KHR5cGUpKSB7XHJcbiAgICAgICAgICAgIHR5cGUgPSBbdHlwZV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZS5sZW5ndGggJiYgIXZhbGlkOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGFzc2VydGVkVHlwZSA9IGFzc2VydFR5cGUodmFsdWUsIHR5cGVbaV0sIHZtKTtcclxuICAgICAgICAgICAgZXhwZWN0ZWRUeXBlcy5wdXNoKGFzc2VydGVkVHlwZS5leHBlY3RlZFR5cGUgfHwgJycpO1xyXG4gICAgICAgICAgICB2YWxpZCA9IGFzc2VydGVkVHlwZS52YWxpZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB2YXIgaGF2ZUV4cGVjdGVkVHlwZXMgPSBleHBlY3RlZFR5cGVzLnNvbWUoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQ7IH0pO1xyXG4gICAgaWYgKCF2YWxpZCAmJiBoYXZlRXhwZWN0ZWRUeXBlcykge1xyXG4gICAgICAgIHdhcm4kMihnZXRJbnZhbGlkVHlwZU1lc3NhZ2UobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpLCB2bSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdmFyIHZhbGlkYXRvciA9IHByb3AudmFsaWRhdG9yO1xyXG4gICAgaWYgKHZhbGlkYXRvcikge1xyXG4gICAgICAgIGlmICghdmFsaWRhdG9yKHZhbHVlKSkge1xyXG4gICAgICAgICAgICB3YXJuJDIoJ0ludmFsaWQgcHJvcDogY3VzdG9tIHZhbGlkYXRvciBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCInICsgbmFtZSArICdcIi4nLCB2bSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbnZhciBzaW1wbGVDaGVja1JFID0gL14oU3RyaW5nfE51bWJlcnxCb29sZWFufEZ1bmN0aW9ufFN5bWJvbHxCaWdJbnQpJC87XHJcbmZ1bmN0aW9uIGFzc2VydFR5cGUodmFsdWUsIHR5cGUsIHZtKSB7XHJcbiAgICB2YXIgdmFsaWQ7XHJcbiAgICB2YXIgZXhwZWN0ZWRUeXBlID0gZ2V0VHlwZSh0eXBlKTtcclxuICAgIGlmIChzaW1wbGVDaGVja1JFLnRlc3QoZXhwZWN0ZWRUeXBlKSkge1xyXG4gICAgICAgIHZhciB0ID0gdHlwZW9mIHZhbHVlO1xyXG4gICAgICAgIHZhbGlkID0gdCA9PT0gZXhwZWN0ZWRUeXBlLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgLy8gZm9yIHByaW1pdGl2ZSB3cmFwcGVyIG9iamVjdHNcclxuICAgICAgICBpZiAoIXZhbGlkICYmIHQgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ09iamVjdCcpIHtcclxuICAgICAgICB2YWxpZCA9IGlzUGxhaW5PYmplY3QodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnQXJyYXknKSB7XHJcbiAgICAgICAgdmFsaWQgPSBpc0FycmF5KHZhbHVlKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICB3YXJuJDIoJ0ludmFsaWQgcHJvcCB0eXBlOiBcIicgKyBTdHJpbmcodHlwZSkgKyAnXCIgaXMgbm90IGEgY29uc3RydWN0b3InLCB2bSk7XHJcbiAgICAgICAgICAgIHZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB2YWxpZDogdmFsaWQsXHJcbiAgICAgICAgZXhwZWN0ZWRUeXBlOiBleHBlY3RlZFR5cGVcclxuICAgIH07XHJcbn1cclxudmFyIGZ1bmN0aW9uVHlwZUNoZWNrUkUgPSAvXlxccypmdW5jdGlvbiAoXFx3KykvO1xyXG4vKipcclxuICogVXNlIGZ1bmN0aW9uIHN0cmluZyBuYW1lIHRvIGNoZWNrIGJ1aWx0LWluIHR5cGVzLFxyXG4gKiBiZWNhdXNlIGEgc2ltcGxlIGVxdWFsaXR5IGNoZWNrIHdpbGwgZmFpbCB3aGVuIHJ1bm5pbmdcclxuICogYWNyb3NzIGRpZmZlcmVudCB2bXMgLyBpZnJhbWVzLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0VHlwZShmbikge1xyXG4gICAgdmFyIG1hdGNoID0gZm4gJiYgZm4udG9TdHJpbmcoKS5tYXRjaChmdW5jdGlvblR5cGVDaGVja1JFKTtcclxuICAgIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdIDogJyc7XHJcbn1cclxuZnVuY3Rpb24gaXNTYW1lVHlwZShhLCBiKSB7XHJcbiAgICByZXR1cm4gZ2V0VHlwZShhKSA9PT0gZ2V0VHlwZShiKTtcclxufVxyXG5mdW5jdGlvbiBnZXRUeXBlSW5kZXgodHlwZSwgZXhwZWN0ZWRUeXBlcykge1xyXG4gICAgaWYgKCFpc0FycmF5KGV4cGVjdGVkVHlwZXMpKSB7XHJcbiAgICAgICAgcmV0dXJuIGlzU2FtZVR5cGUoZXhwZWN0ZWRUeXBlcywgdHlwZSkgPyAwIDogLTE7XHJcbiAgICB9XHJcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZXhwZWN0ZWRUeXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgIGlmIChpc1NhbWVUeXBlKGV4cGVjdGVkVHlwZXNbaV0sIHR5cGUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiAtMTtcclxufVxyXG5mdW5jdGlvbiBnZXRJbnZhbGlkVHlwZU1lc3NhZ2UobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpIHtcclxuICAgIHZhciBtZXNzYWdlID0gXCJJbnZhbGlkIHByb3A6IHR5cGUgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFxcXCJcIi5jb25jYXQobmFtZSwgXCJcXFwiLlwiKSArXHJcbiAgICAgICAgXCIgRXhwZWN0ZWQgXCIuY29uY2F0KGV4cGVjdGVkVHlwZXMubWFwKGNhcGl0YWxpemUpLmpvaW4oJywgJykpO1xyXG4gICAgdmFyIGV4cGVjdGVkVHlwZSA9IGV4cGVjdGVkVHlwZXNbMF07XHJcbiAgICB2YXIgcmVjZWl2ZWRUeXBlID0gdG9SYXdUeXBlKHZhbHVlKTtcclxuICAgIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gc3BlY2lmeSBleHBlY3RlZCB2YWx1ZVxyXG4gICAgaWYgKGV4cGVjdGVkVHlwZXMubGVuZ3RoID09PSAxICYmXHJcbiAgICAgICAgaXNFeHBsaWNhYmxlKGV4cGVjdGVkVHlwZSkgJiZcclxuICAgICAgICBpc0V4cGxpY2FibGUodHlwZW9mIHZhbHVlKSAmJlxyXG4gICAgICAgICFpc0Jvb2xlYW4oZXhwZWN0ZWRUeXBlLCByZWNlaXZlZFR5cGUpKSB7XHJcbiAgICAgICAgbWVzc2FnZSArPSBcIiB3aXRoIHZhbHVlIFwiLmNvbmNhdChzdHlsZVZhbHVlKHZhbHVlLCBleHBlY3RlZFR5cGUpKTtcclxuICAgIH1cclxuICAgIG1lc3NhZ2UgKz0gXCIsIGdvdCBcIi5jb25jYXQocmVjZWl2ZWRUeXBlLCBcIiBcIik7XHJcbiAgICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIHNwZWNpZnkgcmVjZWl2ZWQgdmFsdWVcclxuICAgIGlmIChpc0V4cGxpY2FibGUocmVjZWl2ZWRUeXBlKSkge1xyXG4gICAgICAgIG1lc3NhZ2UgKz0gXCJ3aXRoIHZhbHVlIFwiLmNvbmNhdChzdHlsZVZhbHVlKHZhbHVlLCByZWNlaXZlZFR5cGUpLCBcIi5cIik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWVzc2FnZTtcclxufVxyXG5mdW5jdGlvbiBzdHlsZVZhbHVlKHZhbHVlLCB0eXBlKSB7XHJcbiAgICBpZiAodHlwZSA9PT0gJ1N0cmluZycpIHtcclxuICAgICAgICByZXR1cm4gXCJcXFwiXCIuY29uY2F0KHZhbHVlLCBcIlxcXCJcIik7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlID09PSAnTnVtYmVyJykge1xyXG4gICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChOdW1iZXIodmFsdWUpKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBcIlwiLmNvbmNhdCh2YWx1ZSk7XHJcbiAgICB9XHJcbn1cclxudmFyIEVYUExJQ0FCTEVfVFlQRVMgPSBbJ3N0cmluZycsICdudW1iZXInLCAnYm9vbGVhbiddO1xyXG5mdW5jdGlvbiBpc0V4cGxpY2FibGUodmFsdWUpIHtcclxuICAgIHJldHVybiBFWFBMSUNBQkxFX1RZUEVTLnNvbWUoZnVuY3Rpb24gKGVsZW0pIHsgcmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09IGVsZW07IH0pO1xyXG59XHJcbmZ1bmN0aW9uIGlzQm9vbGVhbigpIHtcclxuICAgIHZhciBhcmdzID0gW107XHJcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIHJldHVybiBhcmdzLnNvbWUoZnVuY3Rpb24gKGVsZW0pIHsgcmV0dXJuIGVsZW0udG9Mb3dlckNhc2UoKSA9PT0gJ2Jvb2xlYW4nOyB9KTtcclxufVxuXG5mdW5jdGlvbiBWdWUob3B0aW9ucykge1xyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgISh0aGlzIGluc3RhbmNlb2YgVnVlKSkge1xyXG4gICAgICAgIHdhcm4kMignVnVlIGlzIGEgY29uc3RydWN0b3IgYW5kIHNob3VsZCBiZSBjYWxsZWQgd2l0aCB0aGUgYG5ld2Aga2V5d29yZCcpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5faW5pdChvcHRpb25zKTtcclxufVxyXG4vL0B0cy1leHBlY3QtZXJyb3IgVnVlIGhhcyBmdW5jdGlvbiB0eXBlXHJcbmluaXRNaXhpbiQxKFZ1ZSk7XHJcbi8vQHRzLWV4cGVjdC1lcnJvciBWdWUgaGFzIGZ1bmN0aW9uIHR5cGVcclxuc3RhdGVNaXhpbihWdWUpO1xyXG4vL0B0cy1leHBlY3QtZXJyb3IgVnVlIGhhcyBmdW5jdGlvbiB0eXBlXHJcbmV2ZW50c01peGluKFZ1ZSk7XHJcbi8vQHRzLWV4cGVjdC1lcnJvciBWdWUgaGFzIGZ1bmN0aW9uIHR5cGVcclxubGlmZWN5Y2xlTWl4aW4oVnVlKTtcclxuLy9AdHMtZXhwZWN0LWVycm9yIFZ1ZSBoYXMgZnVuY3Rpb24gdHlwZVxyXG5yZW5kZXJNaXhpbihWdWUpO1xuXG5mdW5jdGlvbiBpbml0VXNlKFZ1ZSkge1xyXG4gICAgVnVlLnVzZSA9IGZ1bmN0aW9uIChwbHVnaW4pIHtcclxuICAgICAgICB2YXIgaW5zdGFsbGVkUGx1Z2lucyA9IHRoaXMuX2luc3RhbGxlZFBsdWdpbnMgfHwgKHRoaXMuX2luc3RhbGxlZFBsdWdpbnMgPSBbXSk7XHJcbiAgICAgICAgaWYgKGluc3RhbGxlZFBsdWdpbnMuaW5kZXhPZihwbHVnaW4pID4gLTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGFkZGl0aW9uYWwgcGFyYW1ldGVyc1xyXG4gICAgICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xyXG4gICAgICAgIGFyZ3MudW5zaGlmdCh0aGlzKTtcclxuICAgICAgICBpZiAoaXNGdW5jdGlvbihwbHVnaW4uaW5zdGFsbCkpIHtcclxuICAgICAgICAgICAgcGx1Z2luLmluc3RhbGwuYXBwbHkocGx1Z2luLCBhcmdzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNGdW5jdGlvbihwbHVnaW4pKSB7XHJcbiAgICAgICAgICAgIHBsdWdpbi5hcHBseShudWxsLCBhcmdzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaW5zdGFsbGVkUGx1Z2lucy5wdXNoKHBsdWdpbik7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG59XG5cbmZ1bmN0aW9uIGluaXRNaXhpbihWdWUpIHtcclxuICAgIFZ1ZS5taXhpbiA9IGZ1bmN0aW9uIChtaXhpbikge1xyXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG1peGluKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbn1cblxuZnVuY3Rpb24gaW5pdEV4dGVuZChWdWUpIHtcclxuICAgIC8qKlxyXG4gICAgICogRWFjaCBpbnN0YW5jZSBjb25zdHJ1Y3RvciwgaW5jbHVkaW5nIFZ1ZSwgaGFzIGEgdW5pcXVlXHJcbiAgICAgKiBjaWQuIFRoaXMgZW5hYmxlcyB1cyB0byBjcmVhdGUgd3JhcHBlZCBcImNoaWxkXHJcbiAgICAgKiBjb25zdHJ1Y3RvcnNcIiBmb3IgcHJvdG90eXBhbCBpbmhlcml0YW5jZSBhbmQgY2FjaGUgdGhlbS5cclxuICAgICAqL1xyXG4gICAgVnVlLmNpZCA9IDA7XHJcbiAgICB2YXIgY2lkID0gMTtcclxuICAgIC8qKlxyXG4gICAgICogQ2xhc3MgaW5oZXJpdGFuY2VcclxuICAgICAqL1xyXG4gICAgVnVlLmV4dGVuZCA9IGZ1bmN0aW9uIChleHRlbmRPcHRpb25zKSB7XHJcbiAgICAgICAgZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnMgfHwge307XHJcbiAgICAgICAgdmFyIFN1cGVyID0gdGhpcztcclxuICAgICAgICB2YXIgU3VwZXJJZCA9IFN1cGVyLmNpZDtcclxuICAgICAgICB2YXIgY2FjaGVkQ3RvcnMgPSBleHRlbmRPcHRpb25zLl9DdG9yIHx8IChleHRlbmRPcHRpb25zLl9DdG9yID0ge30pO1xyXG4gICAgICAgIGlmIChjYWNoZWRDdG9yc1tTdXBlcklkXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ3RvcnNbU3VwZXJJZF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShleHRlbmRPcHRpb25zKSB8fCBnZXRDb21wb25lbnROYW1lKFN1cGVyLm9wdGlvbnMpO1xyXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG5hbWUpIHtcclxuICAgICAgICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKG5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgU3ViID0gZnVuY3Rpb24gVnVlQ29tcG9uZW50KG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgdGhpcy5faW5pdChvcHRpb25zKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFN1Yi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFN1cGVyLnByb3RvdHlwZSk7XHJcbiAgICAgICAgU3ViLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN1YjtcclxuICAgICAgICBTdWIuY2lkID0gY2lkKys7XHJcbiAgICAgICAgU3ViLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoU3VwZXIub3B0aW9ucywgZXh0ZW5kT3B0aW9ucyk7XHJcbiAgICAgICAgU3ViWydzdXBlciddID0gU3VwZXI7XHJcbiAgICAgICAgLy8gRm9yIHByb3BzIGFuZCBjb21wdXRlZCBwcm9wZXJ0aWVzLCB3ZSBkZWZpbmUgdGhlIHByb3h5IGdldHRlcnMgb25cclxuICAgICAgICAvLyB0aGUgVnVlIGluc3RhbmNlcyBhdCBleHRlbnNpb24gdGltZSwgb24gdGhlIGV4dGVuZGVkIHByb3RvdHlwZS4gVGhpc1xyXG4gICAgICAgIC8vIGF2b2lkcyBPYmplY3QuZGVmaW5lUHJvcGVydHkgY2FsbHMgZm9yIGVhY2ggaW5zdGFuY2UgY3JlYXRlZC5cclxuICAgICAgICBpZiAoU3ViLm9wdGlvbnMucHJvcHMpIHtcclxuICAgICAgICAgICAgaW5pdFByb3BzKFN1Yik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChTdWIub3B0aW9ucy5jb21wdXRlZCkge1xyXG4gICAgICAgICAgICBpbml0Q29tcHV0ZWQoU3ViKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYWxsb3cgZnVydGhlciBleHRlbnNpb24vbWl4aW4vcGx1Z2luIHVzYWdlXHJcbiAgICAgICAgU3ViLmV4dGVuZCA9IFN1cGVyLmV4dGVuZDtcclxuICAgICAgICBTdWIubWl4aW4gPSBTdXBlci5taXhpbjtcclxuICAgICAgICBTdWIudXNlID0gU3VwZXIudXNlO1xyXG4gICAgICAgIC8vIGNyZWF0ZSBhc3NldCByZWdpc3RlcnMsIHNvIGV4dGVuZGVkIGNsYXNzZXNcclxuICAgICAgICAvLyBjYW4gaGF2ZSB0aGVpciBwcml2YXRlIGFzc2V0cyB0b28uXHJcbiAgICAgICAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xyXG4gICAgICAgICAgICBTdWJbdHlwZV0gPSBTdXBlclt0eXBlXTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBlbmFibGUgcmVjdXJzaXZlIHNlbGYtbG9va3VwXHJcbiAgICAgICAgaWYgKG5hbWUpIHtcclxuICAgICAgICAgICAgU3ViLm9wdGlvbnMuY29tcG9uZW50c1tuYW1lXSA9IFN1YjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgc3VwZXIgb3B0aW9ucyBhdCBleHRlbnNpb24gdGltZS5cclxuICAgICAgICAvLyBsYXRlciBhdCBpbnN0YW50aWF0aW9uIHdlIGNhbiBjaGVjayBpZiBTdXBlcidzIG9wdGlvbnMgaGF2ZVxyXG4gICAgICAgIC8vIGJlZW4gdXBkYXRlZC5cclxuICAgICAgICBTdWIuc3VwZXJPcHRpb25zID0gU3VwZXIub3B0aW9ucztcclxuICAgICAgICBTdWIuZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnM7XHJcbiAgICAgICAgU3ViLnNlYWxlZE9wdGlvbnMgPSBleHRlbmQoe30sIFN1Yi5vcHRpb25zKTtcclxuICAgICAgICAvLyBjYWNoZSBjb25zdHJ1Y3RvclxyXG4gICAgICAgIGNhY2hlZEN0b3JzW1N1cGVySWRdID0gU3ViO1xyXG4gICAgICAgIHJldHVybiBTdWI7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGluaXRQcm9wcyhDb21wKSB7XHJcbiAgICB2YXIgcHJvcHMgPSBDb21wLm9wdGlvbnMucHJvcHM7XHJcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcclxuICAgICAgICBwcm94eShDb21wLnByb3RvdHlwZSwgXCJfcHJvcHNcIiwga2V5KTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpbml0Q29tcHV0ZWQoQ29tcCkge1xyXG4gICAgdmFyIGNvbXB1dGVkID0gQ29tcC5vcHRpb25zLmNvbXB1dGVkO1xyXG4gICAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XHJcbiAgICAgICAgZGVmaW5lQ29tcHV0ZWQoQ29tcC5wcm90b3R5cGUsIGtleSwgY29tcHV0ZWRba2V5XSk7XHJcbiAgICB9XHJcbn1cblxuZnVuY3Rpb24gaW5pdEFzc2V0UmVnaXN0ZXJzKFZ1ZSkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYXNzZXQgcmVnaXN0cmF0aW9uIG1ldGhvZHMuXHJcbiAgICAgKi9cclxuICAgIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcclxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGZ1bmN0aW9uIGlzIG5vdCBleGFjdCBzYW1lIHR5cGVcclxuICAgICAgICBWdWVbdHlwZV0gPSBmdW5jdGlvbiAoaWQsIGRlZmluaXRpb24pIHtcclxuICAgICAgICAgICAgaWYgKCFkZWZpbml0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZSA9PT0gJ2NvbXBvbmVudCcpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUoaWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdjb21wb25lbnQnICYmIGlzUGxhaW5PYmplY3QoZGVmaW5pdGlvbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXHJcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5pdGlvbi5uYW1lID0gZGVmaW5pdGlvbi5uYW1lIHx8IGlkO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmluaXRpb24gPSB0aGlzLm9wdGlvbnMuX2Jhc2UuZXh0ZW5kKGRlZmluaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdkaXJlY3RpdmUnICYmIGlzRnVuY3Rpb24oZGVmaW5pdGlvbikpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWZpbml0aW9uID0geyBiaW5kOiBkZWZpbml0aW9uLCB1cGRhdGU6IGRlZmluaXRpb24gfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF0gPSBkZWZpbml0aW9uO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmluaXRpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfSk7XHJcbn1cblxuZnVuY3Rpb24gX2dldENvbXBvbmVudE5hbWUob3B0cykge1xyXG4gICAgcmV0dXJuIG9wdHMgJiYgKGdldENvbXBvbmVudE5hbWUob3B0cy5DdG9yLm9wdGlvbnMpIHx8IG9wdHMudGFnKTtcclxufVxyXG5mdW5jdGlvbiBtYXRjaGVzKHBhdHRlcm4sIG5hbWUpIHtcclxuICAgIGlmIChpc0FycmF5KHBhdHRlcm4pKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhdHRlcm4uaW5kZXhPZihuYW1lKSA+IC0xO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhdHRlcm4uc3BsaXQoJywnKS5pbmRleE9mKG5hbWUpID4gLTE7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc1JlZ0V4cChwYXR0ZXJuKSkge1xyXG4gICAgICAgIHJldHVybiBwYXR0ZXJuLnRlc3QobmFtZSk7XHJcbiAgICB9XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIHBydW5lQ2FjaGUoa2VlcEFsaXZlSW5zdGFuY2UsIGZpbHRlcikge1xyXG4gICAgdmFyIGNhY2hlID0ga2VlcEFsaXZlSW5zdGFuY2UuY2FjaGUsIGtleXMgPSBrZWVwQWxpdmVJbnN0YW5jZS5rZXlzLCBfdm5vZGUgPSBrZWVwQWxpdmVJbnN0YW5jZS5fdm5vZGU7XHJcbiAgICBmb3IgKHZhciBrZXkgaW4gY2FjaGUpIHtcclxuICAgICAgICB2YXIgZW50cnkgPSBjYWNoZVtrZXldO1xyXG4gICAgICAgIGlmIChlbnRyeSkge1xyXG4gICAgICAgICAgICB2YXIgbmFtZV8xID0gZW50cnkubmFtZTtcclxuICAgICAgICAgICAgaWYgKG5hbWVfMSAmJiAhZmlsdGVyKG5hbWVfMSkpIHtcclxuICAgICAgICAgICAgICAgIHBydW5lQ2FjaGVFbnRyeShjYWNoZSwga2V5LCBrZXlzLCBfdm5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHBydW5lQ2FjaGVFbnRyeShjYWNoZSwga2V5LCBrZXlzLCBjdXJyZW50KSB7XHJcbiAgICB2YXIgZW50cnkgPSBjYWNoZVtrZXldO1xyXG4gICAgaWYgKGVudHJ5ICYmICghY3VycmVudCB8fCBlbnRyeS50YWcgIT09IGN1cnJlbnQudGFnKSkge1xyXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgY2FuIGJlIHVuZGVmaW5lZFxyXG4gICAgICAgIGVudHJ5LmNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XHJcbiAgICB9XHJcbiAgICBjYWNoZVtrZXldID0gbnVsbDtcclxuICAgIHJlbW92ZSQyKGtleXMsIGtleSk7XHJcbn1cclxudmFyIHBhdHRlcm5UeXBlcyA9IFtTdHJpbmcsIFJlZ0V4cCwgQXJyYXldO1xyXG4vLyBUT0RPIGRlZmluZUNvbXBvbmVudFxyXG52YXIgS2VlcEFsaXZlID0ge1xyXG4gICAgbmFtZTogJ2tlZXAtYWxpdmUnLFxyXG4gICAgYWJzdHJhY3Q6IHRydWUsXHJcbiAgICBwcm9wczoge1xyXG4gICAgICAgIGluY2x1ZGU6IHBhdHRlcm5UeXBlcyxcclxuICAgICAgICBleGNsdWRlOiBwYXR0ZXJuVHlwZXMsXHJcbiAgICAgICAgbWF4OiBbU3RyaW5nLCBOdW1iZXJdXHJcbiAgICB9LFxyXG4gICAgbWV0aG9kczoge1xyXG4gICAgICAgIGNhY2hlVk5vZGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF9hID0gdGhpcywgY2FjaGUgPSBfYS5jYWNoZSwga2V5cyA9IF9hLmtleXMsIHZub2RlVG9DYWNoZSA9IF9hLnZub2RlVG9DYWNoZSwga2V5VG9DYWNoZSA9IF9hLmtleVRvQ2FjaGU7XHJcbiAgICAgICAgICAgIGlmICh2bm9kZVRvQ2FjaGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0YWcgPSB2bm9kZVRvQ2FjaGUudGFnLCBjb21wb25lbnRJbnN0YW5jZSA9IHZub2RlVG9DYWNoZS5jb21wb25lbnRJbnN0YW5jZSwgY29tcG9uZW50T3B0aW9ucyA9IHZub2RlVG9DYWNoZS5jb21wb25lbnRPcHRpb25zO1xyXG4gICAgICAgICAgICAgICAgY2FjaGVba2V5VG9DYWNoZV0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogX2dldENvbXBvbmVudE5hbWUoY29tcG9uZW50T3B0aW9ucyksXHJcbiAgICAgICAgICAgICAgICAgICAgdGFnOiB0YWcsXHJcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50SW5zdGFuY2U6IGNvbXBvbmVudEluc3RhbmNlXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAga2V5cy5wdXNoKGtleVRvQ2FjaGUpO1xyXG4gICAgICAgICAgICAgICAgLy8gcHJ1bmUgb2xkZXN0IGVudHJ5XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXggJiYga2V5cy5sZW5ndGggPiBwYXJzZUludCh0aGlzLm1heCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBwcnVuZUNhY2hlRW50cnkoY2FjaGUsIGtleXNbMF0sIGtleXMsIHRoaXMuX3Zub2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMudm5vZGVUb0NhY2hlID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBjcmVhdGVkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICAgICAgdGhpcy5rZXlzID0gW107XHJcbiAgICB9LFxyXG4gICAgZGVzdHJveWVkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuY2FjaGUpIHtcclxuICAgICAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KHRoaXMuY2FjaGUsIGtleSwgdGhpcy5rZXlzKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgbW91bnRlZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5jYWNoZVZOb2RlKCk7XHJcbiAgICAgICAgdGhpcy4kd2F0Y2goJ2luY2x1ZGUnLCBmdW5jdGlvbiAodmFsKSB7XHJcbiAgICAgICAgICAgIHBydW5lQ2FjaGUoX3RoaXMsIGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBtYXRjaGVzKHZhbCwgbmFtZSk7IH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuJHdhdGNoKCdleGNsdWRlJywgZnVuY3Rpb24gKHZhbCkge1xyXG4gICAgICAgICAgICBwcnVuZUNhY2hlKF90aGlzLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gIW1hdGNoZXModmFsLCBuYW1lKTsgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgdXBkYXRlZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY2FjaGVWTm9kZSgpO1xyXG4gICAgfSxcclxuICAgIHJlbmRlcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBzbG90ID0gdGhpcy4kc2xvdHMuZGVmYXVsdDtcclxuICAgICAgICB2YXIgdm5vZGUgPSBnZXRGaXJzdENvbXBvbmVudENoaWxkKHNsb3QpO1xyXG4gICAgICAgIHZhciBjb21wb25lbnRPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcclxuICAgICAgICBpZiAoY29tcG9uZW50T3B0aW9ucykge1xyXG4gICAgICAgICAgICAvLyBjaGVjayBwYXR0ZXJuXHJcbiAgICAgICAgICAgIHZhciBuYW1lXzIgPSBfZ2V0Q29tcG9uZW50TmFtZShjb21wb25lbnRPcHRpb25zKTtcclxuICAgICAgICAgICAgdmFyIF9hID0gdGhpcywgaW5jbHVkZSA9IF9hLmluY2x1ZGUsIGV4Y2x1ZGUgPSBfYS5leGNsdWRlO1xyXG4gICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIC8vIG5vdCBpbmNsdWRlZFxyXG4gICAgICAgICAgICAoaW5jbHVkZSAmJiAoIW5hbWVfMiB8fCAhbWF0Y2hlcyhpbmNsdWRlLCBuYW1lXzIpKSkgfHxcclxuICAgICAgICAgICAgICAgIC8vIGV4Y2x1ZGVkXHJcbiAgICAgICAgICAgICAgICAoZXhjbHVkZSAmJiBuYW1lXzIgJiYgbWF0Y2hlcyhleGNsdWRlLCBuYW1lXzIpKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZub2RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBfYiA9IHRoaXMsIGNhY2hlID0gX2IuY2FjaGUsIGtleXMgPSBfYi5rZXlzO1xyXG4gICAgICAgICAgICB2YXIga2V5ID0gdm5vZGUua2V5ID09IG51bGxcclxuICAgICAgICAgICAgICAgID8gLy8gc2FtZSBjb25zdHJ1Y3RvciBtYXkgZ2V0IHJlZ2lzdGVyZWQgYXMgZGlmZmVyZW50IGxvY2FsIGNvbXBvbmVudHNcclxuICAgICAgICAgICAgICAgICAgICAvLyBzbyBjaWQgYWxvbmUgaXMgbm90IGVub3VnaCAoIzMyNjkpXHJcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50T3B0aW9ucy5DdG9yLmNpZCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChjb21wb25lbnRPcHRpb25zLnRhZyA/IFwiOjpcIi5jb25jYXQoY29tcG9uZW50T3B0aW9ucy50YWcpIDogJycpXHJcbiAgICAgICAgICAgICAgICA6IHZub2RlLmtleTtcclxuICAgICAgICAgICAgaWYgKGNhY2hlW2tleV0pIHtcclxuICAgICAgICAgICAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gY2FjaGVba2V5XS5jb21wb25lbnRJbnN0YW5jZTtcclxuICAgICAgICAgICAgICAgIC8vIG1ha2UgY3VycmVudCBrZXkgZnJlc2hlc3RcclxuICAgICAgICAgICAgICAgIHJlbW92ZSQyKGtleXMsIGtleSk7XHJcbiAgICAgICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGRlbGF5IHNldHRpbmcgdGhlIGNhY2hlIHVudGlsIHVwZGF0ZVxyXG4gICAgICAgICAgICAgICAgdGhpcy52bm9kZVRvQ2FjaGUgPSB2bm9kZTtcclxuICAgICAgICAgICAgICAgIHRoaXMua2V5VG9DYWNoZSA9IGtleTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGNhbiB2bm9kZS5kYXRhIGNhbiBiZSB1bmRlZmluZWRcclxuICAgICAgICAgICAgdm5vZGUuZGF0YS5rZWVwQWxpdmUgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdm5vZGUgfHwgKHNsb3QgJiYgc2xvdFswXSk7XHJcbiAgICB9XHJcbn07XG5cbnZhciBidWlsdEluQ29tcG9uZW50cyA9IHtcclxuICAgIEtlZXBBbGl2ZTogS2VlcEFsaXZlXHJcbn07XG5cbmZ1bmN0aW9uIGluaXRHbG9iYWxBUEkoVnVlKSB7XHJcbiAgICAvLyBjb25maWdcclxuICAgIHZhciBjb25maWdEZWYgPSB7fTtcclxuICAgIGNvbmZpZ0RlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25maWc7IH07XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgIGNvbmZpZ0RlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHdhcm4kMignRG8gbm90IHJlcGxhY2UgdGhlIFZ1ZS5jb25maWcgb2JqZWN0LCBzZXQgaW5kaXZpZHVhbCBmaWVsZHMgaW5zdGVhZC4nKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSwgJ2NvbmZpZycsIGNvbmZpZ0RlZik7XHJcbiAgICAvLyBleHBvc2VkIHV0aWwgbWV0aG9kcy5cclxuICAgIC8vIE5PVEU6IHRoZXNlIGFyZSBub3QgY29uc2lkZXJlZCBwYXJ0IG9mIHRoZSBwdWJsaWMgQVBJIC0gYXZvaWQgcmVseWluZyBvblxyXG4gICAgLy8gdGhlbSB1bmxlc3MgeW91IGFyZSBhd2FyZSBvZiB0aGUgcmlzay5cclxuICAgIFZ1ZS51dGlsID0ge1xyXG4gICAgICAgIHdhcm46IHdhcm4kMixcclxuICAgICAgICBleHRlbmQ6IGV4dGVuZCxcclxuICAgICAgICBtZXJnZU9wdGlvbnM6IG1lcmdlT3B0aW9ucyxcclxuICAgICAgICBkZWZpbmVSZWFjdGl2ZTogZGVmaW5lUmVhY3RpdmVcclxuICAgIH07XHJcbiAgICBWdWUuc2V0ID0gc2V0O1xyXG4gICAgVnVlLmRlbGV0ZSA9IGRlbDtcclxuICAgIFZ1ZS5uZXh0VGljayA9IG5leHRUaWNrO1xyXG4gICAgLy8gMi42IGV4cGxpY2l0IG9ic2VydmFibGUgQVBJXHJcbiAgICBWdWUub2JzZXJ2YWJsZSA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICBvYnNlcnZlKG9iaik7XHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgIH07XHJcbiAgICBWdWUub3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XHJcbiAgICAgICAgVnVlLm9wdGlvbnNbdHlwZSArICdzJ10gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgfSk7XHJcbiAgICAvLyB0aGlzIGlzIHVzZWQgdG8gaWRlbnRpZnkgdGhlIFwiYmFzZVwiIGNvbnN0cnVjdG9yIHRvIGV4dGVuZCBhbGwgcGxhaW4tb2JqZWN0XHJcbiAgICAvLyBjb21wb25lbnRzIHdpdGggaW4gV2VleCdzIG11bHRpLWluc3RhbmNlIHNjZW5hcmlvcy5cclxuICAgIFZ1ZS5vcHRpb25zLl9iYXNlID0gVnVlO1xyXG4gICAgZXh0ZW5kKFZ1ZS5vcHRpb25zLmNvbXBvbmVudHMsIGJ1aWx0SW5Db21wb25lbnRzKTtcclxuICAgIGluaXRVc2UoVnVlKTtcclxuICAgIGluaXRNaXhpbihWdWUpO1xyXG4gICAgaW5pdEV4dGVuZChWdWUpO1xyXG4gICAgaW5pdEFzc2V0UmVnaXN0ZXJzKFZ1ZSk7XHJcbn1cblxuaW5pdEdsb2JhbEFQSShWdWUpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRpc1NlcnZlcicsIHtcclxuICAgIGdldDogaXNTZXJ2ZXJSZW5kZXJpbmdcclxufSk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJHNzckNvbnRleHQnLCB7XHJcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIHJldHVybiB0aGlzLiR2bm9kZSAmJiB0aGlzLiR2bm9kZS5zc3JDb250ZXh0O1xyXG4gICAgfVxyXG59KTtcclxuLy8gZXhwb3NlIEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0IGZvciBzc3IgcnVudGltZSBoZWxwZXIgaW5zdGFsbGF0aW9uXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUsICdGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCcsIHtcclxuICAgIHZhbHVlOiBGdW5jdGlvbmFsUmVuZGVyQ29udGV4dFxyXG59KTtcclxuVnVlLnZlcnNpb24gPSB2ZXJzaW9uO1xuXG4vLyB0aGVzZSBhcmUgcmVzZXJ2ZWQgZm9yIHdlYiBiZWNhdXNlIHRoZXkgYXJlIGRpcmVjdGx5IGNvbXBpbGVkIGF3YXlcclxuLy8gZHVyaW5nIHRlbXBsYXRlIGNvbXBpbGF0aW9uXHJcbnZhciBpc1Jlc2VydmVkQXR0ciA9IG1ha2VNYXAoJ3N0eWxlLGNsYXNzJyk7XHJcbi8vIGF0dHJpYnV0ZXMgdGhhdCBzaG91bGQgYmUgdXNpbmcgcHJvcHMgZm9yIGJpbmRpbmdcclxudmFyIGFjY2VwdFZhbHVlID0gbWFrZU1hcCgnaW5wdXQsdGV4dGFyZWEsb3B0aW9uLHNlbGVjdCxwcm9ncmVzcycpO1xyXG52YXIgbXVzdFVzZVByb3AgPSBmdW5jdGlvbiAodGFnLCB0eXBlLCBhdHRyKSB7XHJcbiAgICByZXR1cm4gKChhdHRyID09PSAndmFsdWUnICYmIGFjY2VwdFZhbHVlKHRhZykgJiYgdHlwZSAhPT0gJ2J1dHRvbicpIHx8XHJcbiAgICAgICAgKGF0dHIgPT09ICdzZWxlY3RlZCcgJiYgdGFnID09PSAnb3B0aW9uJykgfHxcclxuICAgICAgICAoYXR0ciA9PT0gJ2NoZWNrZWQnICYmIHRhZyA9PT0gJ2lucHV0JykgfHxcclxuICAgICAgICAoYXR0ciA9PT0gJ211dGVkJyAmJiB0YWcgPT09ICd2aWRlbycpKTtcclxufTtcclxudmFyIGlzRW51bWVyYXRlZEF0dHIgPSBtYWtlTWFwKCdjb250ZW50ZWRpdGFibGUsZHJhZ2dhYmxlLHNwZWxsY2hlY2snKTtcclxudmFyIGlzVmFsaWRDb250ZW50RWRpdGFibGVWYWx1ZSA9IG1ha2VNYXAoJ2V2ZW50cyxjYXJldCx0eXBpbmcscGxhaW50ZXh0LW9ubHknKTtcclxudmFyIGNvbnZlcnRFbnVtZXJhdGVkVmFsdWUgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xyXG4gICAgcmV0dXJuIGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpIHx8IHZhbHVlID09PSAnZmFsc2UnXHJcbiAgICAgICAgPyAnZmFsc2UnXHJcbiAgICAgICAgOiAvLyBhbGxvdyBhcmJpdHJhcnkgc3RyaW5nIHZhbHVlIGZvciBjb250ZW50ZWRpdGFibGVcclxuICAgICAgICAgICAga2V5ID09PSAnY29udGVudGVkaXRhYmxlJyAmJiBpc1ZhbGlkQ29udGVudEVkaXRhYmxlVmFsdWUodmFsdWUpXHJcbiAgICAgICAgICAgICAgICA/IHZhbHVlXHJcbiAgICAgICAgICAgICAgICA6ICd0cnVlJztcclxufTtcclxudmFyIGlzQm9vbGVhbkF0dHIgPSBtYWtlTWFwKCdhbGxvd2Z1bGxzY3JlZW4sYXN5bmMsYXV0b2ZvY3VzLGF1dG9wbGF5LGNoZWNrZWQsY29tcGFjdCxjb250cm9scyxkZWNsYXJlLCcgK1xyXG4gICAgJ2RlZmF1bHQsZGVmYXVsdGNoZWNrZWQsZGVmYXVsdG11dGVkLGRlZmF1bHRzZWxlY3RlZCxkZWZlcixkaXNhYmxlZCwnICtcclxuICAgICdlbmFibGVkLGZvcm1ub3ZhbGlkYXRlLGhpZGRlbixpbmRldGVybWluYXRlLGluZXJ0LGlzbWFwLGl0ZW1zY29wZSxsb29wLG11bHRpcGxlLCcgK1xyXG4gICAgJ211dGVkLG5vaHJlZixub3Jlc2l6ZSxub3NoYWRlLG5vdmFsaWRhdGUsbm93cmFwLG9wZW4scGF1c2VvbmV4aXQscmVhZG9ubHksJyArXHJcbiAgICAncmVxdWlyZWQscmV2ZXJzZWQsc2NvcGVkLHNlYW1sZXNzLHNlbGVjdGVkLHNvcnRhYmxlLCcgK1xyXG4gICAgJ3RydWVzcGVlZCx0eXBlbXVzdG1hdGNoLHZpc2libGUnKTtcclxudmFyIHhsaW5rTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XHJcbnZhciBpc1hsaW5rID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgIHJldHVybiBuYW1lLmNoYXJBdCg1KSA9PT0gJzonICYmIG5hbWUuc2xpY2UoMCwgNSkgPT09ICd4bGluayc7XHJcbn07XHJcbnZhciBnZXRYbGlua1Byb3AgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgcmV0dXJuIGlzWGxpbmsobmFtZSkgPyBuYW1lLnNsaWNlKDYsIG5hbWUubGVuZ3RoKSA6ICcnO1xyXG59O1xyXG52YXIgaXNGYWxzeUF0dHJWYWx1ZSA9IGZ1bmN0aW9uICh2YWwpIHtcclxuICAgIHJldHVybiB2YWwgPT0gbnVsbCB8fCB2YWwgPT09IGZhbHNlO1xyXG59O1xuXG5mdW5jdGlvbiBnZW5DbGFzc0ZvclZub2RlKHZub2RlKSB7XHJcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XHJcbiAgICB2YXIgcGFyZW50Tm9kZSA9IHZub2RlO1xyXG4gICAgdmFyIGNoaWxkTm9kZSA9IHZub2RlO1xyXG4gICAgd2hpbGUgKGlzRGVmKGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcclxuICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xyXG4gICAgICAgIGlmIChjaGlsZE5vZGUgJiYgY2hpbGROb2RlLmRhdGEpIHtcclxuICAgICAgICAgICAgZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGNoaWxkTm9kZS5kYXRhLCBkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHBhcmVudE5vZGUucGFyZW50IG5vdCBWTm9kZVdpdGhEYXRhXHJcbiAgICB3aGlsZSAoaXNEZWYoKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpKSB7XHJcbiAgICAgICAgaWYgKHBhcmVudE5vZGUgJiYgcGFyZW50Tm9kZS5kYXRhKSB7XHJcbiAgICAgICAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShkYXRhLCBwYXJlbnROb2RlLmRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZW5kZXJDbGFzcyhkYXRhLnN0YXRpY0NsYXNzLCBkYXRhLmNsYXNzKTtcclxufVxyXG5mdW5jdGlvbiBtZXJnZUNsYXNzRGF0YShjaGlsZCwgcGFyZW50KSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHN0YXRpY0NsYXNzOiBjb25jYXQoY2hpbGQuc3RhdGljQ2xhc3MsIHBhcmVudC5zdGF0aWNDbGFzcyksXHJcbiAgICAgICAgY2xhc3M6IGlzRGVmKGNoaWxkLmNsYXNzKSA/IFtjaGlsZC5jbGFzcywgcGFyZW50LmNsYXNzXSA6IHBhcmVudC5jbGFzc1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiByZW5kZXJDbGFzcyhzdGF0aWNDbGFzcywgZHluYW1pY0NsYXNzKSB7XHJcbiAgICBpZiAoaXNEZWYoc3RhdGljQ2xhc3MpIHx8IGlzRGVmKGR5bmFtaWNDbGFzcykpIHtcclxuICAgICAgICByZXR1cm4gY29uY2F0KHN0YXRpY0NsYXNzLCBzdHJpbmdpZnlDbGFzcyhkeW5hbWljQ2xhc3MpKTtcclxuICAgIH1cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICByZXR1cm4gJyc7XHJcbn1cclxuZnVuY3Rpb24gY29uY2F0KGEsIGIpIHtcclxuICAgIHJldHVybiBhID8gKGIgPyBhICsgJyAnICsgYiA6IGEpIDogYiB8fCAnJztcclxufVxyXG5mdW5jdGlvbiBzdHJpbmdpZnlDbGFzcyh2YWx1ZSkge1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeUFycmF5KHZhbHVlKTtcclxuICAgIH1cclxuICAgIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gc3RyaW5naWZ5T2JqZWN0KHZhbHVlKTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgIHJldHVybiAnJztcclxufVxyXG5mdW5jdGlvbiBzdHJpbmdpZnlBcnJheSh2YWx1ZSkge1xyXG4gICAgdmFyIHJlcyA9ICcnO1xyXG4gICAgdmFyIHN0cmluZ2lmaWVkO1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICBpZiAoaXNEZWYoKHN0cmluZ2lmaWVkID0gc3RyaW5naWZ5Q2xhc3ModmFsdWVbaV0pKSkgJiYgc3RyaW5naWZpZWQgIT09ICcnKSB7XHJcbiAgICAgICAgICAgIGlmIChyZXMpXHJcbiAgICAgICAgICAgICAgICByZXMgKz0gJyAnO1xyXG4gICAgICAgICAgICByZXMgKz0gc3RyaW5naWZpZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG5mdW5jdGlvbiBzdHJpbmdpZnlPYmplY3QodmFsdWUpIHtcclxuICAgIHZhciByZXMgPSAnJztcclxuICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xyXG4gICAgICAgIGlmICh2YWx1ZVtrZXldKSB7XHJcbiAgICAgICAgICAgIGlmIChyZXMpXHJcbiAgICAgICAgICAgICAgICByZXMgKz0gJyAnO1xyXG4gICAgICAgICAgICByZXMgKz0ga2V5O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXM7XHJcbn1cblxudmFyIG5hbWVzcGFjZU1hcCA9IHtcclxuICAgIHN2ZzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcclxuICAgIG1hdGg6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJ1xyXG59O1xyXG52YXIgaXNIVE1MVGFnID0gbWFrZU1hcCgnaHRtbCxib2R5LGJhc2UsaGVhZCxsaW5rLG1ldGEsc3R5bGUsdGl0bGUsJyArXHJcbiAgICAnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGZvb3RlcixoZWFkZXIsaDEsaDIsaDMsaDQsaDUsaDYsaGdyb3VwLG5hdixzZWN0aW9uLCcgK1xyXG4gICAgJ2RpdixkZCxkbCxkdCxmaWdjYXB0aW9uLGZpZ3VyZSxwaWN0dXJlLGhyLGltZyxsaSxtYWluLG9sLHAscHJlLHVsLCcgK1xyXG4gICAgJ2EsYixhYmJyLGJkaSxiZG8sYnIsY2l0ZSxjb2RlLGRhdGEsZGZuLGVtLGksa2JkLG1hcmsscSxycCxydCxydGMscnVieSwnICtcclxuICAgICdzLHNhbXAsc21hbGwsc3BhbixzdHJvbmcsc3ViLHN1cCx0aW1lLHUsdmFyLHdicixhcmVhLGF1ZGlvLG1hcCx0cmFjayx2aWRlbywnICtcclxuICAgICdlbWJlZCxvYmplY3QscGFyYW0sc291cmNlLGNhbnZhcyxzY3JpcHQsbm9zY3JpcHQsZGVsLGlucywnICtcclxuICAgICdjYXB0aW9uLGNvbCxjb2xncm91cCx0YWJsZSx0aGVhZCx0Ym9keSx0ZCx0aCx0ciwnICtcclxuICAgICdidXR0b24sZGF0YWxpc3QsZmllbGRzZXQsZm9ybSxpbnB1dCxsYWJlbCxsZWdlbmQsbWV0ZXIsb3B0Z3JvdXAsb3B0aW9uLCcgK1xyXG4gICAgJ291dHB1dCxwcm9ncmVzcyxzZWxlY3QsdGV4dGFyZWEsJyArXHJcbiAgICAnZGV0YWlscyxkaWFsb2csbWVudSxtZW51aXRlbSxzdW1tYXJ5LCcgK1xyXG4gICAgJ2NvbnRlbnQsZWxlbWVudCxzaGFkb3csdGVtcGxhdGUsYmxvY2txdW90ZSxpZnJhbWUsdGZvb3QnKTtcclxuLy8gdGhpcyBtYXAgaXMgaW50ZW50aW9uYWxseSBzZWxlY3RpdmUsIG9ubHkgY292ZXJpbmcgU1ZHIGVsZW1lbnRzIHRoYXQgbWF5XHJcbi8vIGNvbnRhaW4gY2hpbGQgZWxlbWVudHMuXHJcbnZhciBpc1NWRyA9IG1ha2VNYXAoJ3N2ZyxhbmltYXRlLGNpcmNsZSxjbGlwcGF0aCxjdXJzb3IsZGVmcyxkZXNjLGVsbGlwc2UsZmlsdGVyLGZvbnQtZmFjZSwnICtcclxuICAgICdmb3JlaWdub2JqZWN0LGcsZ2x5cGgsaW1hZ2UsbGluZSxtYXJrZXIsbWFzayxtaXNzaW5nLWdseXBoLHBhdGgscGF0dGVybiwnICtcclxuICAgICdwb2x5Z29uLHBvbHlsaW5lLHJlY3Qsc3dpdGNoLHN5bWJvbCx0ZXh0LHRleHRwYXRoLHRzcGFuLHVzZSx2aWV3JywgdHJ1ZSk7XHJcbnZhciBpc1ByZVRhZyA9IGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIHRhZyA9PT0gJ3ByZSc7IH07XHJcbnZhciBpc1Jlc2VydmVkVGFnID0gZnVuY3Rpb24gKHRhZykge1xyXG4gICAgcmV0dXJuIGlzSFRNTFRhZyh0YWcpIHx8IGlzU1ZHKHRhZyk7XHJcbn07XHJcbmZ1bmN0aW9uIGdldFRhZ05hbWVzcGFjZSh0YWcpIHtcclxuICAgIGlmIChpc1NWRyh0YWcpKSB7XHJcbiAgICAgICAgcmV0dXJuICdzdmcnO1xyXG4gICAgfVxyXG4gICAgLy8gYmFzaWMgc3VwcG9ydCBmb3IgTWF0aE1MXHJcbiAgICAvLyBub3RlIGl0IGRvZXNuJ3Qgc3VwcG9ydCBvdGhlciBNYXRoTUwgZWxlbWVudHMgYmVpbmcgY29tcG9uZW50IHJvb3RzXHJcbiAgICBpZiAodGFnID09PSAnbWF0aCcpIHtcclxuICAgICAgICByZXR1cm4gJ21hdGgnO1xyXG4gICAgfVxyXG59XHJcbnZhciB1bmtub3duRWxlbWVudENhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuZnVuY3Rpb24gaXNVbmtub3duRWxlbWVudCh0YWcpIHtcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKCFpbkJyb3dzZXIpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmIChpc1Jlc2VydmVkVGFnKHRhZykpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICB0YWcgPSB0YWcudG9Mb3dlckNhc2UoKTtcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSAhPSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHVua25vd25FbGVtZW50Q2FjaGVbdGFnXTtcclxuICAgIH1cclxuICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcclxuICAgIGlmICh0YWcuaW5kZXhPZignLScpID4gLTEpIHtcclxuICAgICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yODIxMDM2NC8xMDcwMjQ0XHJcbiAgICAgICAgcmV0dXJuICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gPVxyXG4gICAgICAgICAgICBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxVbmtub3duRWxlbWVudCB8fFxyXG4gICAgICAgICAgICAgICAgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MRWxlbWVudCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9IC9IVE1MVW5rbm93bkVsZW1lbnQvLnRlc3QoZWwudG9TdHJpbmcoKSkpO1xyXG4gICAgfVxyXG59XHJcbnZhciBpc1RleHRJbnB1dFR5cGUgPSBtYWtlTWFwKCd0ZXh0LG51bWJlcixwYXNzd29yZCxzZWFyY2gsZW1haWwsdGVsLHVybCcpO1xuXG4vKipcclxuICogUXVlcnkgYW4gZWxlbWVudCBzZWxlY3RvciBpZiBpdCdzIG5vdCBhbiBlbGVtZW50IGFscmVhZHkuXHJcbiAqL1xyXG5mdW5jdGlvbiBxdWVyeShlbCkge1xyXG4gICAgaWYgKHR5cGVvZiBlbCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICB2YXIgc2VsZWN0ZWQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsKTtcclxuICAgICAgICBpZiAoIXNlbGVjdGVkKSB7XHJcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybiQyKCdDYW5ub3QgZmluZCBlbGVtZW50OiAnICsgZWwpO1xyXG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzZWxlY3RlZDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBlbDtcclxuICAgIH1cclxufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50KHRhZ05hbWUsIHZub2RlKSB7XHJcbiAgICB2YXIgZWxtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcclxuICAgIGlmICh0YWdOYW1lICE9PSAnc2VsZWN0Jykge1xyXG4gICAgICAgIHJldHVybiBlbG07XHJcbiAgICB9XHJcbiAgICAvLyBmYWxzZSBvciBudWxsIHdpbGwgcmVtb3ZlIHRoZSBhdHRyaWJ1dGUgYnV0IHVuZGVmaW5lZCB3aWxsIG5vdFxyXG4gICAgaWYgKHZub2RlLmRhdGEgJiZcclxuICAgICAgICB2bm9kZS5kYXRhLmF0dHJzICYmXHJcbiAgICAgICAgdm5vZGUuZGF0YS5hdHRycy5tdWx0aXBsZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgZWxtLnNldEF0dHJpYnV0ZSgnbXVsdGlwbGUnLCAnbXVsdGlwbGUnKTtcclxuICAgIH1cclxuICAgIHJldHVybiBlbG07XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZSwgdGFnTmFtZSkge1xyXG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VNYXBbbmFtZXNwYWNlXSwgdGFnTmFtZSk7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlVGV4dE5vZGUodGV4dCkge1xyXG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnQodGV4dCkge1xyXG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQodGV4dCk7XHJcbn1cclxuZnVuY3Rpb24gaW5zZXJ0QmVmb3JlKHBhcmVudE5vZGUsIG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpIHtcclxuICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpO1xyXG59XHJcbmZ1bmN0aW9uIHJlbW92ZUNoaWxkKG5vZGUsIGNoaWxkKSB7XHJcbiAgICBub2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcclxufVxyXG5mdW5jdGlvbiBhcHBlbmRDaGlsZChub2RlLCBjaGlsZCkge1xyXG4gICAgbm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7XHJcbn1cclxuZnVuY3Rpb24gcGFyZW50Tm9kZShub2RlKSB7XHJcbiAgICByZXR1cm4gbm9kZS5wYXJlbnROb2RlO1xyXG59XHJcbmZ1bmN0aW9uIG5leHRTaWJsaW5nKG5vZGUpIHtcclxuICAgIHJldHVybiBub2RlLm5leHRTaWJsaW5nO1xyXG59XHJcbmZ1bmN0aW9uIHRhZ05hbWUobm9kZSkge1xyXG4gICAgcmV0dXJuIG5vZGUudGFnTmFtZTtcclxufVxyXG5mdW5jdGlvbiBzZXRUZXh0Q29udGVudChub2RlLCB0ZXh0KSB7XHJcbiAgICBub2RlLnRleHRDb250ZW50ID0gdGV4dDtcclxufVxyXG5mdW5jdGlvbiBzZXRTdHlsZVNjb3BlKG5vZGUsIHNjb3BlSWQpIHtcclxuICAgIG5vZGUuc2V0QXR0cmlidXRlKHNjb3BlSWQsICcnKTtcclxufVxuXG52YXIgbm9kZU9wcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBjcmVhdGVFbGVtZW50OiBjcmVhdGVFbGVtZW50LFxuICBjcmVhdGVFbGVtZW50TlM6IGNyZWF0ZUVsZW1lbnROUyxcbiAgY3JlYXRlVGV4dE5vZGU6IGNyZWF0ZVRleHROb2RlLFxuICBjcmVhdGVDb21tZW50OiBjcmVhdGVDb21tZW50LFxuICBpbnNlcnRCZWZvcmU6IGluc2VydEJlZm9yZSxcbiAgcmVtb3ZlQ2hpbGQ6IHJlbW92ZUNoaWxkLFxuICBhcHBlbmRDaGlsZDogYXBwZW5kQ2hpbGQsXG4gIHBhcmVudE5vZGU6IHBhcmVudE5vZGUsXG4gIG5leHRTaWJsaW5nOiBuZXh0U2libGluZyxcbiAgdGFnTmFtZTogdGFnTmFtZSxcbiAgc2V0VGV4dENvbnRlbnQ6IHNldFRleHRDb250ZW50LFxuICBzZXRTdHlsZVNjb3BlOiBzZXRTdHlsZVNjb3BlXG59KTtcblxudmFyIHJlZiA9IHtcclxuICAgIGNyZWF0ZTogZnVuY3Rpb24gKF8sIHZub2RlKSB7XHJcbiAgICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xyXG4gICAgfSxcclxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKG9sZFZub2RlLCB2bm9kZSkge1xyXG4gICAgICAgIGlmIChvbGRWbm9kZS5kYXRhLnJlZiAhPT0gdm5vZGUuZGF0YS5yZWYpIHtcclxuICAgICAgICAgICAgcmVnaXN0ZXJSZWYob2xkVm5vZGUsIHRydWUpO1xyXG4gICAgICAgICAgICByZWdpc3RlclJlZih2bm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICh2bm9kZSkge1xyXG4gICAgICAgIHJlZ2lzdGVyUmVmKHZub2RlLCB0cnVlKTtcclxuICAgIH1cclxufTtcclxuZnVuY3Rpb24gcmVnaXN0ZXJSZWYodm5vZGUsIGlzUmVtb3ZhbCkge1xyXG4gICAgdmFyIHJlZiA9IHZub2RlLmRhdGEucmVmO1xyXG4gICAgaWYgKCFpc0RlZihyZWYpKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIHZhciB2bSA9IHZub2RlLmNvbnRleHQ7XHJcbiAgICB2YXIgcmVmVmFsdWUgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSB8fCB2bm9kZS5lbG07XHJcbiAgICB2YXIgdmFsdWUgPSBpc1JlbW92YWwgPyBudWxsIDogcmVmVmFsdWU7XHJcbiAgICB2YXIgJHJlZnNWYWx1ZSA9IGlzUmVtb3ZhbCA/IHVuZGVmaW5lZCA6IHJlZlZhbHVlO1xyXG4gICAgaWYgKGlzRnVuY3Rpb24ocmVmKSkge1xyXG4gICAgICAgIGludm9rZVdpdGhFcnJvckhhbmRsaW5nKHJlZiwgdm0sIFt2YWx1ZV0sIHZtLCBcInRlbXBsYXRlIHJlZiBmdW5jdGlvblwiKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB2YXIgaXNGb3IgPSB2bm9kZS5kYXRhLnJlZkluRm9yO1xyXG4gICAgdmFyIF9pc1N0cmluZyA9IHR5cGVvZiByZWYgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiByZWYgPT09ICdudW1iZXInO1xyXG4gICAgdmFyIF9pc1JlZiA9IGlzUmVmKHJlZik7XHJcbiAgICB2YXIgcmVmcyA9IHZtLiRyZWZzO1xyXG4gICAgaWYgKF9pc1N0cmluZyB8fCBfaXNSZWYpIHtcclxuICAgICAgICBpZiAoaXNGb3IpIHtcclxuICAgICAgICAgICAgdmFyIGV4aXN0aW5nID0gX2lzU3RyaW5nID8gcmVmc1tyZWZdIDogcmVmLnZhbHVlO1xyXG4gICAgICAgICAgICBpZiAoaXNSZW1vdmFsKSB7XHJcbiAgICAgICAgICAgICAgICBpc0FycmF5KGV4aXN0aW5nKSAmJiByZW1vdmUkMihleGlzdGluZywgcmVmVmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0FycmF5KGV4aXN0aW5nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfaXNTdHJpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmc1tyZWZdID0gW3JlZlZhbHVlXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0U2V0dXBSZWYodm0sIHJlZiwgcmVmc1tyZWZdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZi52YWx1ZSA9IFtyZWZWYWx1ZV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWV4aXN0aW5nLmluY2x1ZGVzKHJlZlZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLnB1c2gocmVmVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKF9pc1N0cmluZykge1xyXG4gICAgICAgICAgICBpZiAoaXNSZW1vdmFsICYmIHJlZnNbcmVmXSAhPT0gcmVmVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZWZzW3JlZl0gPSAkcmVmc1ZhbHVlO1xyXG4gICAgICAgICAgICBzZXRTZXR1cFJlZih2bSwgcmVmLCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKF9pc1JlZikge1xyXG4gICAgICAgICAgICBpZiAoaXNSZW1vdmFsICYmIHJlZi52YWx1ZSAhPT0gcmVmVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZWYudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgICB3YXJuJDIoXCJJbnZhbGlkIHRlbXBsYXRlIHJlZiB0eXBlOiBcIi5jb25jYXQodHlwZW9mIHJlZikpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBzZXRTZXR1cFJlZihfYSwga2V5LCB2YWwpIHtcclxuICAgIHZhciBfc2V0dXBTdGF0ZSA9IF9hLl9zZXR1cFN0YXRlO1xyXG4gICAgaWYgKF9zZXR1cFN0YXRlICYmIGhhc093bihfc2V0dXBTdGF0ZSwga2V5KSkge1xyXG4gICAgICAgIGlmIChpc1JlZihfc2V0dXBTdGF0ZVtrZXldKSkge1xyXG4gICAgICAgICAgICBfc2V0dXBTdGF0ZVtrZXldLnZhbHVlID0gdmFsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgX3NldHVwU3RhdGVba2V5XSA9IHZhbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIFZpcnR1YWwgRE9NIHBhdGNoaW5nIGFsZ29yaXRobSBiYXNlZCBvbiBTbmFiYmRvbSBieVxyXG4gKiBTaW1vbiBGcmlpcyBWaW5kdW0gKEBwYWxkZXBpbmQpXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcGFsZGVwaW5kL3NuYWJiZG9tL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcclxuICpcclxuICogbW9kaWZpZWQgYnkgRXZhbiBZb3UgKEB5eXg5OTA4MDMpXHJcbiAqXHJcbiAqIE5vdCB0eXBlLWNoZWNraW5nIHRoaXMgYmVjYXVzZSB0aGlzIGZpbGUgaXMgcGVyZi1jcml0aWNhbCBhbmQgdGhlIGNvc3RcclxuICogb2YgbWFraW5nIGZsb3cgdW5kZXJzdGFuZCBpdCBpcyBub3Qgd29ydGggaXQuXHJcbiAqL1xyXG52YXIgZW1wdHlOb2RlID0gbmV3IFZOb2RlKCcnLCB7fSwgW10pO1xyXG52YXIgaG9va3MgPSBbJ2NyZWF0ZScsICdhY3RpdmF0ZScsICd1cGRhdGUnLCAncmVtb3ZlJywgJ2Rlc3Ryb3knXTtcclxuZnVuY3Rpb24gc2FtZVZub2RlKGEsIGIpIHtcclxuICAgIHJldHVybiAoYS5rZXkgPT09IGIua2V5ICYmXHJcbiAgICAgICAgYS5hc3luY0ZhY3RvcnkgPT09IGIuYXN5bmNGYWN0b3J5ICYmXHJcbiAgICAgICAgKChhLnRhZyA9PT0gYi50YWcgJiZcclxuICAgICAgICAgICAgYS5pc0NvbW1lbnQgPT09IGIuaXNDb21tZW50ICYmXHJcbiAgICAgICAgICAgIGlzRGVmKGEuZGF0YSkgPT09IGlzRGVmKGIuZGF0YSkgJiZcclxuICAgICAgICAgICAgc2FtZUlucHV0VHlwZShhLCBiKSkgfHxcclxuICAgICAgICAgICAgKGlzVHJ1ZShhLmlzQXN5bmNQbGFjZWhvbGRlcikgJiYgaXNVbmRlZihiLmFzeW5jRmFjdG9yeS5lcnJvcikpKSk7XHJcbn1cclxuZnVuY3Rpb24gc2FtZUlucHV0VHlwZShhLCBiKSB7XHJcbiAgICBpZiAoYS50YWcgIT09ICdpbnB1dCcpXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB2YXIgaTtcclxuICAgIHZhciB0eXBlQSA9IGlzRGVmKChpID0gYS5kYXRhKSkgJiYgaXNEZWYoKGkgPSBpLmF0dHJzKSkgJiYgaS50eXBlO1xyXG4gICAgdmFyIHR5cGVCID0gaXNEZWYoKGkgPSBiLmRhdGEpKSAmJiBpc0RlZigoaSA9IGkuYXR0cnMpKSAmJiBpLnR5cGU7XHJcbiAgICByZXR1cm4gdHlwZUEgPT09IHR5cGVCIHx8IChpc1RleHRJbnB1dFR5cGUodHlwZUEpICYmIGlzVGV4dElucHV0VHlwZSh0eXBlQikpO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUtleVRvT2xkSWR4KGNoaWxkcmVuLCBiZWdpbklkeCwgZW5kSWR4KSB7XHJcbiAgICB2YXIgaSwga2V5O1xyXG4gICAgdmFyIG1hcCA9IHt9O1xyXG4gICAgZm9yIChpID0gYmVnaW5JZHg7IGkgPD0gZW5kSWR4OyArK2kpIHtcclxuICAgICAgICBrZXkgPSBjaGlsZHJlbltpXS5rZXk7XHJcbiAgICAgICAgaWYgKGlzRGVmKGtleSkpXHJcbiAgICAgICAgICAgIG1hcFtrZXldID0gaTtcclxuICAgIH1cclxuICAgIHJldHVybiBtYXA7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlUGF0Y2hGdW5jdGlvbihiYWNrZW5kKSB7XHJcbiAgICB2YXIgaSwgajtcclxuICAgIHZhciBjYnMgPSB7fTtcclxuICAgIHZhciBtb2R1bGVzID0gYmFja2VuZC5tb2R1bGVzLCBub2RlT3BzID0gYmFja2VuZC5ub2RlT3BzO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgY2JzW2hvb2tzW2ldXSA9IFtdO1xyXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBtb2R1bGVzLmxlbmd0aDsgKytqKSB7XHJcbiAgICAgICAgICAgIGlmIChpc0RlZihtb2R1bGVzW2pdW2hvb2tzW2ldXSkpIHtcclxuICAgICAgICAgICAgICAgIGNic1tob29rc1tpXV0ucHVzaChtb2R1bGVzW2pdW2hvb2tzW2ldXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBlbXB0eU5vZGVBdChlbG0pIHtcclxuICAgICAgICByZXR1cm4gbmV3IFZOb2RlKG5vZGVPcHMudGFnTmFtZShlbG0pLnRvTG93ZXJDYXNlKCksIHt9LCBbXSwgdW5kZWZpbmVkLCBlbG0pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY3JlYXRlUm1DYihjaGlsZEVsbSwgbGlzdGVuZXJzKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gcmVtb3ZlKCkge1xyXG4gICAgICAgICAgICBpZiAoLS1yZW1vdmUubGlzdGVuZXJzID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVOb2RlKGNoaWxkRWxtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZW1vdmUubGlzdGVuZXJzID0gbGlzdGVuZXJzO1xyXG4gICAgICAgIHJldHVybiByZW1vdmU7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZW1vdmVOb2RlKGVsKSB7XHJcbiAgICAgICAgdmFyIHBhcmVudCA9IG5vZGVPcHMucGFyZW50Tm9kZShlbCk7XHJcbiAgICAgICAgLy8gZWxlbWVudCBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gcmVtb3ZlZCBkdWUgdG8gdi1odG1sIC8gdi10ZXh0XHJcbiAgICAgICAgaWYgKGlzRGVmKHBhcmVudCkpIHtcclxuICAgICAgICAgICAgbm9kZU9wcy5yZW1vdmVDaGlsZChwYXJlbnQsIGVsKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBpc1Vua25vd25FbGVtZW50KHZub2RlLCBpblZQcmUpIHtcclxuICAgICAgICByZXR1cm4gKCFpblZQcmUgJiZcclxuICAgICAgICAgICAgIXZub2RlLm5zICYmXHJcbiAgICAgICAgICAgICEoY29uZmlnLmlnbm9yZWRFbGVtZW50cy5sZW5ndGggJiZcclxuICAgICAgICAgICAgICAgIGNvbmZpZy5pZ25vcmVkRWxlbWVudHMuc29tZShmdW5jdGlvbiAoaWdub3JlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzUmVnRXhwKGlnbm9yZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBpZ25vcmUudGVzdCh2bm9kZS50YWcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogaWdub3JlID09PSB2bm9kZS50YWc7XHJcbiAgICAgICAgICAgICAgICB9KSkgJiZcclxuICAgICAgICAgICAgY29uZmlnLmlzVW5rbm93bkVsZW1lbnQodm5vZGUudGFnKSk7XHJcbiAgICB9XHJcbiAgICB2YXIgY3JlYXRpbmdFbG1JblZQcmUgPSAwO1xyXG4gICAgZnVuY3Rpb24gY3JlYXRlRWxtKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtLCBuZXN0ZWQsIG93bmVyQXJyYXksIGluZGV4KSB7XHJcbiAgICAgICAgaWYgKGlzRGVmKHZub2RlLmVsbSkgJiYgaXNEZWYob3duZXJBcnJheSkpIHtcclxuICAgICAgICAgICAgLy8gVGhpcyB2bm9kZSB3YXMgdXNlZCBpbiBhIHByZXZpb3VzIHJlbmRlciFcclxuICAgICAgICAgICAgLy8gbm93IGl0J3MgdXNlZCBhcyBhIG5ldyBub2RlLCBvdmVyd3JpdGluZyBpdHMgZWxtIHdvdWxkIGNhdXNlXHJcbiAgICAgICAgICAgIC8vIHBvdGVudGlhbCBwYXRjaCBlcnJvcnMgZG93biB0aGUgcm9hZCB3aGVuIGl0J3MgdXNlZCBhcyBhbiBpbnNlcnRpb25cclxuICAgICAgICAgICAgLy8gcmVmZXJlbmNlIG5vZGUuIEluc3RlYWQsIHdlIGNsb25lIHRoZSBub2RlIG9uLWRlbWFuZCBiZWZvcmUgY3JlYXRpbmdcclxuICAgICAgICAgICAgLy8gYXNzb2NpYXRlZCBET00gZWxlbWVudCBmb3IgaXQuXHJcbiAgICAgICAgICAgIHZub2RlID0gb3duZXJBcnJheVtpbmRleF0gPSBjbG9uZVZOb2RlKHZub2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdm5vZGUuaXNSb290SW5zZXJ0ID0gIW5lc3RlZDsgLy8gZm9yIHRyYW5zaXRpb24gZW50ZXIgY2hlY2tcclxuICAgICAgICBpZiAoY3JlYXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcclxuICAgICAgICB2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcclxuICAgICAgICB2YXIgdGFnID0gdm5vZGUudGFnO1xyXG4gICAgICAgIGlmIChpc0RlZih0YWcpKSB7XHJcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLnByZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0aW5nRWxtSW5WUHJlKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNVbmtub3duRWxlbWVudCh2bm9kZSwgY3JlYXRpbmdFbG1JblZQcmUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybiQyKCdVbmtub3duIGN1c3RvbSBlbGVtZW50OiA8JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICc+IC0gZGlkIHlvdSAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ3JlZ2lzdGVyIHRoZSBjb21wb25lbnQgY29ycmVjdGx5PyBGb3IgcmVjdXJzaXZlIGNvbXBvbmVudHMsICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWFrZSBzdXJlIHRvIHByb3ZpZGUgdGhlIFwibmFtZVwiIG9wdGlvbi4nLCB2bm9kZS5jb250ZXh0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2bm9kZS5lbG0gPSB2bm9kZS5uc1xyXG4gICAgICAgICAgICAgICAgPyBub2RlT3BzLmNyZWF0ZUVsZW1lbnROUyh2bm9kZS5ucywgdGFnKVxyXG4gICAgICAgICAgICAgICAgOiBub2RlT3BzLmNyZWF0ZUVsZW1lbnQodGFnLCB2bm9kZSk7XHJcbiAgICAgICAgICAgIHNldFNjb3BlKHZub2RlKTtcclxuICAgICAgICAgICAgY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpO1xyXG4gICAgICAgICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcclxuICAgICAgICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcclxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZGF0YSAmJiBkYXRhLnByZSkge1xyXG4gICAgICAgICAgICAgICAgY3JlYXRpbmdFbG1JblZQcmUtLTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc1RydWUodm5vZGUuaXNDb21tZW50KSkge1xyXG4gICAgICAgICAgICB2bm9kZS5lbG0gPSBub2RlT3BzLmNyZWF0ZUNvbW1lbnQodm5vZGUudGV4dCk7XHJcbiAgICAgICAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUodm5vZGUudGV4dCk7XHJcbiAgICAgICAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjcmVhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pIHtcclxuICAgICAgICB2YXIgaSA9IHZub2RlLmRhdGE7XHJcbiAgICAgICAgaWYgKGlzRGVmKGkpKSB7XHJcbiAgICAgICAgICAgIHZhciBpc1JlYWN0aXZhdGVkID0gaXNEZWYodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGkua2VlcEFsaXZlO1xyXG4gICAgICAgICAgICBpZiAoaXNEZWYoKGkgPSBpLmhvb2spKSAmJiBpc0RlZigoaSA9IGkuaW5pdCkpKSB7XHJcbiAgICAgICAgICAgICAgICBpKHZub2RlLCBmYWxzZSAvKiBoeWRyYXRpbmcgKi8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGFmdGVyIGNhbGxpbmcgdGhlIGluaXQgaG9vaywgaWYgdGhlIHZub2RlIGlzIGEgY2hpbGQgY29tcG9uZW50XHJcbiAgICAgICAgICAgIC8vIGl0IHNob3VsZCd2ZSBjcmVhdGVkIGEgY2hpbGQgaW5zdGFuY2UgYW5kIG1vdW50ZWQgaXQuIHRoZSBjaGlsZFxyXG4gICAgICAgICAgICAvLyBjb21wb25lbnQgYWxzbyBoYXMgc2V0IHRoZSBwbGFjZWhvbGRlciB2bm9kZSdzIGVsbS5cclxuICAgICAgICAgICAgLy8gaW4gdGhhdCBjYXNlIHdlIGNhbiBqdXN0IHJldHVybiB0aGUgZWxlbWVudCBhbmQgYmUgZG9uZS5cclxuICAgICAgICAgICAgaWYgKGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xyXG4gICAgICAgICAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcclxuICAgICAgICAgICAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcclxuICAgICAgICAgICAgICAgIGlmIChpc1RydWUoaXNSZWFjdGl2YXRlZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWFjdGl2YXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XHJcbiAgICAgICAgaWYgKGlzRGVmKHZub2RlLmRhdGEucGVuZGluZ0luc2VydCkpIHtcclxuICAgICAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2guYXBwbHkoaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQpO1xyXG4gICAgICAgICAgICB2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2bm9kZS5lbG0gPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS4kZWw7XHJcbiAgICAgICAgaWYgKGlzUGF0Y2hhYmxlKHZub2RlKSkge1xyXG4gICAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcclxuICAgICAgICAgICAgc2V0U2NvcGUodm5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gZW1wdHkgY29tcG9uZW50IHJvb3QuXHJcbiAgICAgICAgICAgIC8vIHNraXAgYWxsIGVsZW1lbnQtcmVsYXRlZCBtb2R1bGVzIGV4Y2VwdCBmb3IgcmVmICgjMzQ1NSlcclxuICAgICAgICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xyXG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgdG8gaW52b2tlIHRoZSBpbnNlcnQgaG9va1xyXG4gICAgICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaCh2bm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVhY3RpdmF0ZUNvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIC8vIGhhY2sgZm9yICM0MzM5OiBhIHJlYWN0aXZhdGVkIGNvbXBvbmVudCB3aXRoIGlubmVyIHRyYW5zaXRpb25cclxuICAgICAgICAvLyBkb2VzIG5vdCB0cmlnZ2VyIGJlY2F1c2UgdGhlIGlubmVyIG5vZGUncyBjcmVhdGVkIGhvb2tzIGFyZSBub3QgY2FsbGVkXHJcbiAgICAgICAgLy8gYWdhaW4uIEl0J3Mgbm90IGlkZWFsIHRvIGludm9sdmUgbW9kdWxlLXNwZWNpZmljIGxvZ2ljIGluIGhlcmUgYnV0XHJcbiAgICAgICAgLy8gdGhlcmUgZG9lc24ndCBzZWVtIHRvIGJlIGEgYmV0dGVyIHdheSB0byBkbyBpdC5cclxuICAgICAgICB2YXIgaW5uZXJOb2RlID0gdm5vZGU7XHJcbiAgICAgICAgd2hpbGUgKGlubmVyTm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICBpbm5lck5vZGUgPSBpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xyXG4gICAgICAgICAgICBpZiAoaXNEZWYoKGkgPSBpbm5lck5vZGUuZGF0YSkpICYmIGlzRGVmKChpID0gaS50cmFuc2l0aW9uKSkpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuYWN0aXZhdGUubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYnMuYWN0aXZhdGVbaV0oZW1wdHlOb2RlLCBpbm5lck5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2goaW5uZXJOb2RlKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHVubGlrZSBhIG5ld2x5IGNyZWF0ZWQgY29tcG9uZW50LFxyXG4gICAgICAgIC8vIGEgcmVhY3RpdmF0ZWQga2VlcC1hbGl2ZSBjb21wb25lbnQgZG9lc24ndCBpbnNlcnQgaXRzZWxmXHJcbiAgICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaW5zZXJ0KHBhcmVudCwgZWxtLCByZWYpIHtcclxuICAgICAgICBpZiAoaXNEZWYocGFyZW50KSkge1xyXG4gICAgICAgICAgICBpZiAoaXNEZWYocmVmKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGVPcHMucGFyZW50Tm9kZShyZWYpID09PSBwYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnQsIGVsbSwgcmVmKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQocGFyZW50LCBlbG0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcclxuICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcclxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIGNoZWNrRHVwbGljYXRlS2V5cyhjaGlsZHJlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yICh2YXIgaV8xID0gMDsgaV8xIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2lfMSkge1xyXG4gICAgICAgICAgICAgICAgY3JlYXRlRWxtKGNoaWxkcmVuW2lfMV0sIGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZWxtLCBudWxsLCB0cnVlLCBjaGlsZHJlbiwgaV8xKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc1ByaW1pdGl2ZSh2bm9kZS50ZXh0KSkge1xyXG4gICAgICAgICAgICBub2RlT3BzLmFwcGVuZENoaWxkKHZub2RlLmVsbSwgbm9kZU9wcy5jcmVhdGVUZXh0Tm9kZShTdHJpbmcodm5vZGUudGV4dCkpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBpc1BhdGNoYWJsZSh2bm9kZSkge1xyXG4gICAgICAgIHdoaWxlICh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICB2bm9kZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGlzRGVmKHZub2RlLnRhZyk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaV8yID0gMDsgaV8yIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraV8yKSB7XHJcbiAgICAgICAgICAgIGNicy5jcmVhdGVbaV8yXShlbXB0eU5vZGUsIHZub2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaSA9IHZub2RlLmRhdGEuaG9vazsgLy8gUmV1c2UgdmFyaWFibGVcclxuICAgICAgICBpZiAoaXNEZWYoaSkpIHtcclxuICAgICAgICAgICAgaWYgKGlzRGVmKGkuY3JlYXRlKSlcclxuICAgICAgICAgICAgICAgIGkuY3JlYXRlKGVtcHR5Tm9kZSwgdm5vZGUpO1xyXG4gICAgICAgICAgICBpZiAoaXNEZWYoaS5pbnNlcnQpKVxyXG4gICAgICAgICAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIHNldCBzY29wZSBpZCBhdHRyaWJ1dGUgZm9yIHNjb3BlZCBDU1MuXHJcbiAgICAvLyB0aGlzIGlzIGltcGxlbWVudGVkIGFzIGEgc3BlY2lhbCBjYXNlIHRvIGF2b2lkIHRoZSBvdmVyaGVhZFxyXG4gICAgLy8gb2YgZ29pbmcgdGhyb3VnaCB0aGUgbm9ybWFsIGF0dHJpYnV0ZSBwYXRjaGluZyBwcm9jZXNzLlxyXG4gICAgZnVuY3Rpb24gc2V0U2NvcGUodm5vZGUpIHtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBpZiAoaXNEZWYoKGkgPSB2bm9kZS5mblNjb3BlSWQpKSkge1xyXG4gICAgICAgICAgICBub2RlT3BzLnNldFN0eWxlU2NvcGUodm5vZGUuZWxtLCBpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBhbmNlc3RvciA9IHZub2RlO1xyXG4gICAgICAgICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc0RlZigoaSA9IGFuY2VzdG9yLmNvbnRleHQpKSAmJiBpc0RlZigoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGVPcHMuc2V0U3R5bGVTY29wZSh2bm9kZS5lbG0sIGkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZm9yIHNsb3QgY29udGVudCB0aGV5IHNob3VsZCBhbHNvIGdldCB0aGUgc2NvcGVJZCBmcm9tIHRoZSBob3N0IGluc3RhbmNlLlxyXG4gICAgICAgIGlmIChpc0RlZigoaSA9IGFjdGl2ZUluc3RhbmNlKSkgJiZcclxuICAgICAgICAgICAgaSAhPT0gdm5vZGUuY29udGV4dCAmJlxyXG4gICAgICAgICAgICBpICE9PSB2bm9kZS5mbkNvbnRleHQgJiZcclxuICAgICAgICAgICAgaXNEZWYoKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKSkpIHtcclxuICAgICAgICAgICAgbm9kZU9wcy5zZXRTdHlsZVNjb3BlKHZub2RlLmVsbSwgaSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYWRkVm5vZGVzKHBhcmVudEVsbSwgcmVmRWxtLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xyXG4gICAgICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcclxuICAgICAgICAgICAgY3JlYXRlRWxtKHZub2Rlc1tzdGFydElkeF0sIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0sIGZhbHNlLCB2bm9kZXMsIHN0YXJ0SWR4KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBpbnZva2VEZXN0cm95SG9vayh2bm9kZSkge1xyXG4gICAgICAgIHZhciBpLCBqO1xyXG4gICAgICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcclxuICAgICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcclxuICAgICAgICAgICAgaWYgKGlzRGVmKChpID0gZGF0YS5ob29rKSkgJiYgaXNEZWYoKGkgPSBpLmRlc3Ryb3kpKSlcclxuICAgICAgICAgICAgICAgIGkodm5vZGUpO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmRlc3Ryb3kubGVuZ3RoOyArK2kpXHJcbiAgICAgICAgICAgICAgICBjYnMuZGVzdHJveVtpXSh2bm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0RlZigoaSA9IHZub2RlLmNoaWxkcmVuKSkpIHtcclxuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgKytqKSB7XHJcbiAgICAgICAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayh2bm9kZS5jaGlsZHJlbltqXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZW1vdmVWbm9kZXModm5vZGVzLCBzdGFydElkeCwgZW5kSWR4KSB7XHJcbiAgICAgICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xyXG4gICAgICAgICAgICB2YXIgY2ggPSB2bm9kZXNbc3RhcnRJZHhdO1xyXG4gICAgICAgICAgICBpZiAoaXNEZWYoY2gpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWYoY2gudGFnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soY2gpO1xyXG4gICAgICAgICAgICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKGNoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRleHQgbm9kZVxyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZU5vZGUoY2guZWxtKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2sodm5vZGUsIHJtKSB7XHJcbiAgICAgICAgaWYgKGlzRGVmKHJtKSB8fCBpc0RlZih2bm9kZS5kYXRhKSkge1xyXG4gICAgICAgICAgICB2YXIgaV8zO1xyXG4gICAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gY2JzLnJlbW92ZS5sZW5ndGggKyAxO1xyXG4gICAgICAgICAgICBpZiAoaXNEZWYocm0pKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB3ZSBoYXZlIGEgcmVjdXJzaXZlbHkgcGFzc2VkIGRvd24gcm0gY2FsbGJhY2tcclxuICAgICAgICAgICAgICAgIC8vIGluY3JlYXNlIHRoZSBsaXN0ZW5lcnMgY291bnRcclxuICAgICAgICAgICAgICAgIHJtLmxpc3RlbmVycyArPSBsaXN0ZW5lcnM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBkaXJlY3RseSByZW1vdmluZ1xyXG4gICAgICAgICAgICAgICAgcm0gPSBjcmVhdGVSbUNiKHZub2RlLmVsbSwgbGlzdGVuZXJzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyByZWN1cnNpdmVseSBpbnZva2UgaG9va3Mgb24gY2hpbGQgY29tcG9uZW50IHJvb3Qgbm9kZVxyXG4gICAgICAgICAgICBpZiAoaXNEZWYoKGlfMyA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkgJiZcclxuICAgICAgICAgICAgICAgIGlzRGVmKChpXzMgPSBpXzMuX3Zub2RlKSkgJiZcclxuICAgICAgICAgICAgICAgIGlzRGVmKGlfMy5kYXRhKSkge1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayhpXzMsIHJtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGlfMyA9IDA7IGlfMyA8IGNicy5yZW1vdmUubGVuZ3RoOyArK2lfMykge1xyXG4gICAgICAgICAgICAgICAgY2JzLnJlbW92ZVtpXzNdKHZub2RlLCBybSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlzRGVmKChpXzMgPSB2bm9kZS5kYXRhLmhvb2spKSAmJiBpc0RlZigoaV8zID0gaV8zLnJlbW92ZSkpKSB7XHJcbiAgICAgICAgICAgICAgICBpXzModm5vZGUsIHJtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJtKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJlbW92ZU5vZGUodm5vZGUuZWxtKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiB1cGRhdGVDaGlsZHJlbihwYXJlbnRFbG0sIG9sZENoLCBuZXdDaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KSB7XHJcbiAgICAgICAgdmFyIG9sZFN0YXJ0SWR4ID0gMDtcclxuICAgICAgICB2YXIgbmV3U3RhcnRJZHggPSAwO1xyXG4gICAgICAgIHZhciBvbGRFbmRJZHggPSBvbGRDaC5sZW5ndGggLSAxO1xyXG4gICAgICAgIHZhciBvbGRTdGFydFZub2RlID0gb2xkQ2hbMF07XHJcbiAgICAgICAgdmFyIG9sZEVuZFZub2RlID0gb2xkQ2hbb2xkRW5kSWR4XTtcclxuICAgICAgICB2YXIgbmV3RW5kSWR4ID0gbmV3Q2gubGVuZ3RoIC0gMTtcclxuICAgICAgICB2YXIgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWzBdO1xyXG4gICAgICAgIHZhciBuZXdFbmRWbm9kZSA9IG5ld0NoW25ld0VuZElkeF07XHJcbiAgICAgICAgdmFyIG9sZEtleVRvSWR4LCBpZHhJbk9sZCwgdm5vZGVUb01vdmUsIHJlZkVsbTtcclxuICAgICAgICAvLyByZW1vdmVPbmx5IGlzIGEgc3BlY2lhbCBmbGFnIHVzZWQgb25seSBieSA8dHJhbnNpdGlvbi1ncm91cD5cclxuICAgICAgICAvLyB0byBlbnN1cmUgcmVtb3ZlZCBlbGVtZW50cyBzdGF5IGluIGNvcnJlY3QgcmVsYXRpdmUgcG9zaXRpb25zXHJcbiAgICAgICAgLy8gZHVyaW5nIGxlYXZpbmcgdHJhbnNpdGlvbnNcclxuICAgICAgICB2YXIgY2FuTW92ZSA9ICFyZW1vdmVPbmx5O1xyXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICAgIGNoZWNrRHVwbGljYXRlS2V5cyhuZXdDaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdoaWxlIChvbGRTdGFydElkeCA8PSBvbGRFbmRJZHggJiYgbmV3U3RhcnRJZHggPD0gbmV3RW5kSWR4KSB7XHJcbiAgICAgICAgICAgIGlmIChpc1VuZGVmKG9sZFN0YXJ0Vm5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07IC8vIFZub2RlIGhhcyBiZWVuIG1vdmVkIGxlZnRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc1VuZGVmKG9sZEVuZFZub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcclxuICAgICAgICAgICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcclxuICAgICAgICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld0VuZElkeCk7XHJcbiAgICAgICAgICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcclxuICAgICAgICAgICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFZub2RlIG1vdmVkIHJpZ2h0XHJcbiAgICAgICAgICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdFbmRJZHgpO1xyXG4gICAgICAgICAgICAgICAgY2FuTW92ZSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIG5vZGVPcHMubmV4dFNpYmxpbmcob2xkRW5kVm5vZGUuZWxtKSk7XHJcbiAgICAgICAgICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XHJcbiAgICAgICAgICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBWbm9kZSBtb3ZlZCBsZWZ0XHJcbiAgICAgICAgICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdTdGFydElkeCk7XHJcbiAgICAgICAgICAgICAgICBjYW5Nb3ZlICYmXHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRFbmRWbm9kZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcclxuICAgICAgICAgICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xyXG4gICAgICAgICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzVW5kZWYob2xkS2V5VG9JZHgpKVxyXG4gICAgICAgICAgICAgICAgICAgIG9sZEtleVRvSWR4ID0gY3JlYXRlS2V5VG9PbGRJZHgob2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xyXG4gICAgICAgICAgICAgICAgaWR4SW5PbGQgPSBpc0RlZihuZXdTdGFydFZub2RlLmtleSlcclxuICAgICAgICAgICAgICAgICAgICA/IG9sZEtleVRvSWR4W25ld1N0YXJ0Vm5vZGUua2V5XVxyXG4gICAgICAgICAgICAgICAgICAgIDogZmluZElkeEluT2xkKG5ld1N0YXJ0Vm5vZGUsIG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcclxuICAgICAgICAgICAgICAgIGlmIChpc1VuZGVmKGlkeEluT2xkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE5ldyBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgZmFsc2UsIG5ld0NoLCBuZXdTdGFydElkeCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2bm9kZVRvTW92ZSA9IG9sZENoW2lkeEluT2xkXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2FtZVZub2RlKHZub2RlVG9Nb3ZlLCBuZXdTdGFydFZub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRjaFZub2RlKHZub2RlVG9Nb3ZlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdTdGFydElkeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZENoW2lkeEluT2xkXSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FuTW92ZSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCB2bm9kZVRvTW92ZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNhbWUga2V5IGJ1dCBkaWZmZXJlbnQgZWxlbWVudC4gdHJlYXQgYXMgbmV3IGVsZW1lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgZmFsc2UsIG5ld0NoLCBuZXdTdGFydElkeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvbGRTdGFydElkeCA+IG9sZEVuZElkeCkge1xyXG4gICAgICAgICAgICByZWZFbG0gPSBpc1VuZGVmKG5ld0NoW25ld0VuZElkeCArIDFdKSA/IG51bGwgOiBuZXdDaFtuZXdFbmRJZHggKyAxXS5lbG07XHJcbiAgICAgICAgICAgIGFkZFZub2RlcyhwYXJlbnRFbG0sIHJlZkVsbSwgbmV3Q2gsIG5ld1N0YXJ0SWR4LCBuZXdFbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG5ld1N0YXJ0SWR4ID4gbmV3RW5kSWR4KSB7XHJcbiAgICAgICAgICAgIHJlbW92ZVZub2RlcyhvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY2hlY2tEdXBsaWNhdGVLZXlzKGNoaWxkcmVuKSB7XHJcbiAgICAgICAgdmFyIHNlZW5LZXlzID0ge307XHJcbiAgICAgICAgZm9yICh2YXIgaV80ID0gMDsgaV80IDwgY2hpbGRyZW4ubGVuZ3RoOyBpXzQrKykge1xyXG4gICAgICAgICAgICB2YXIgdm5vZGUgPSBjaGlsZHJlbltpXzRdO1xyXG4gICAgICAgICAgICB2YXIga2V5ID0gdm5vZGUua2V5O1xyXG4gICAgICAgICAgICBpZiAoaXNEZWYoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlZW5LZXlzW2tleV0pIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuJDIoXCJEdXBsaWNhdGUga2V5cyBkZXRlY3RlZDogJ1wiLmNvbmNhdChrZXksIFwiJy4gVGhpcyBtYXkgY2F1c2UgYW4gdXBkYXRlIGVycm9yLlwiKSwgdm5vZGUuY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWVuS2V5c1trZXldID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGZpbmRJZHhJbk9sZChub2RlLCBvbGRDaCwgc3RhcnQsIGVuZCkge1xyXG4gICAgICAgIGZvciAodmFyIGlfNSA9IHN0YXJ0OyBpXzUgPCBlbmQ7IGlfNSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBjID0gb2xkQ2hbaV81XTtcclxuICAgICAgICAgICAgaWYgKGlzRGVmKGMpICYmIHNhbWVWbm9kZShub2RlLCBjKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBpXzU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcGF0Y2hWbm9kZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgb3duZXJBcnJheSwgaW5kZXgsIHJlbW92ZU9ubHkpIHtcclxuICAgICAgICBpZiAob2xkVm5vZGUgPT09IHZub2RlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzRGVmKHZub2RlLmVsbSkgJiYgaXNEZWYob3duZXJBcnJheSkpIHtcclxuICAgICAgICAgICAgLy8gY2xvbmUgcmV1c2VkIHZub2RlXHJcbiAgICAgICAgICAgIHZub2RlID0gb3duZXJBcnJheVtpbmRleF0gPSBjbG9uZVZOb2RlKHZub2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGVsbSA9ICh2bm9kZS5lbG0gPSBvbGRWbm9kZS5lbG0pO1xyXG4gICAgICAgIGlmIChpc1RydWUob2xkVm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyKSkge1xyXG4gICAgICAgICAgICBpZiAoaXNEZWYodm5vZGUuYXN5bmNGYWN0b3J5LnJlc29sdmVkKSkge1xyXG4gICAgICAgICAgICAgICAgaHlkcmF0ZShvbGRWbm9kZS5lbG0sIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHJldXNlIGVsZW1lbnQgZm9yIHN0YXRpYyB0cmVlcy5cclxuICAgICAgICAvLyBub3RlIHdlIG9ubHkgZG8gdGhpcyBpZiB0aGUgdm5vZGUgaXMgY2xvbmVkIC1cclxuICAgICAgICAvLyBpZiB0aGUgbmV3IG5vZGUgaXMgbm90IGNsb25lZCBpdCBtZWFucyB0aGUgcmVuZGVyIGZ1bmN0aW9ucyBoYXZlIGJlZW5cclxuICAgICAgICAvLyByZXNldCBieSB0aGUgaG90LXJlbG9hZC1hcGkgYW5kIHdlIG5lZWQgdG8gZG8gYSBwcm9wZXIgcmUtcmVuZGVyLlxyXG4gICAgICAgIGlmIChpc1RydWUodm5vZGUuaXNTdGF0aWMpICYmXHJcbiAgICAgICAgICAgIGlzVHJ1ZShvbGRWbm9kZS5pc1N0YXRpYykgJiZcclxuICAgICAgICAgICAgdm5vZGUua2V5ID09PSBvbGRWbm9kZS5rZXkgJiZcclxuICAgICAgICAgICAgKGlzVHJ1ZSh2bm9kZS5pc0Nsb25lZCkgfHwgaXNUcnVlKHZub2RlLmlzT25jZSkpKSB7XHJcbiAgICAgICAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xyXG4gICAgICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZigoaSA9IGRhdGEuaG9vaykpICYmIGlzRGVmKChpID0gaS5wcmVwYXRjaCkpKSB7XHJcbiAgICAgICAgICAgIGkob2xkVm5vZGUsIHZub2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG9sZENoID0gb2xkVm5vZGUuY2hpbGRyZW47XHJcbiAgICAgICAgdmFyIGNoID0gdm5vZGUuY2hpbGRyZW47XHJcbiAgICAgICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzUGF0Y2hhYmxlKHZub2RlKSkge1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnVwZGF0ZS5sZW5ndGg7ICsraSlcclxuICAgICAgICAgICAgICAgIGNicy51cGRhdGVbaV0ob2xkVm5vZGUsIHZub2RlKTtcclxuICAgICAgICAgICAgaWYgKGlzRGVmKChpID0gZGF0YS5ob29rKSkgJiYgaXNEZWYoKGkgPSBpLnVwZGF0ZSkpKVxyXG4gICAgICAgICAgICAgICAgaShvbGRWbm9kZSwgdm5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNVbmRlZih2bm9kZS50ZXh0KSkge1xyXG4gICAgICAgICAgICBpZiAoaXNEZWYob2xkQ2gpICYmIGlzRGVmKGNoKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9sZENoICE9PSBjaClcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVDaGlsZHJlbihlbG0sIG9sZENoLCBjaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc0RlZihjaCkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tEdXBsaWNhdGVLZXlzKGNoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSlcclxuICAgICAgICAgICAgICAgICAgICBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpO1xyXG4gICAgICAgICAgICAgICAgYWRkVm5vZGVzKGVsbSwgbnVsbCwgY2gsIDAsIGNoLmxlbmd0aCAtIDEsIGluc2VydGVkVm5vZGVRdWV1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNEZWYob2xkQ2gpKSB7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVWbm9kZXMob2xkQ2gsIDAsIG9sZENoLmxlbmd0aCAtIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzRGVmKG9sZFZub2RlLnRleHQpKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG9sZFZub2RlLnRleHQgIT09IHZub2RlLnRleHQpIHtcclxuICAgICAgICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sIHZub2RlLnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcclxuICAgICAgICAgICAgaWYgKGlzRGVmKChpID0gZGF0YS5ob29rKSkgJiYgaXNEZWYoKGkgPSBpLnBvc3RwYXRjaCkpKVxyXG4gICAgICAgICAgICAgICAgaShvbGRWbm9kZSwgdm5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGludm9rZUluc2VydEhvb2sodm5vZGUsIHF1ZXVlLCBpbml0aWFsKSB7XHJcbiAgICAgICAgLy8gZGVsYXkgaW5zZXJ0IGhvb2tzIGZvciBjb21wb25lbnQgcm9vdCBub2RlcywgaW52b2tlIHRoZW0gYWZ0ZXIgdGhlXHJcbiAgICAgICAgLy8gZWxlbWVudCBpcyByZWFsbHkgaW5zZXJ0ZWRcclxuICAgICAgICBpZiAoaXNUcnVlKGluaXRpYWwpICYmIGlzRGVmKHZub2RlLnBhcmVudCkpIHtcclxuICAgICAgICAgICAgdm5vZGUucGFyZW50LmRhdGEucGVuZGluZ0luc2VydCA9IHF1ZXVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaV82ID0gMDsgaV82IDwgcXVldWUubGVuZ3RoOyArK2lfNikge1xyXG4gICAgICAgICAgICAgICAgcXVldWVbaV82XS5kYXRhLmhvb2suaW5zZXJ0KHF1ZXVlW2lfNl0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdmFyIGh5ZHJhdGlvbkJhaWxlZCA9IGZhbHNlO1xyXG4gICAgLy8gbGlzdCBvZiBtb2R1bGVzIHRoYXQgY2FuIHNraXAgY3JlYXRlIGhvb2sgZHVyaW5nIGh5ZHJhdGlvbiBiZWNhdXNlIHRoZXlcclxuICAgIC8vIGFyZSBhbHJlYWR5IHJlbmRlcmVkIG9uIHRoZSBjbGllbnQgb3IgaGFzIG5vIG5lZWQgZm9yIGluaXRpYWxpemF0aW9uXHJcbiAgICAvLyBOb3RlOiBzdHlsZSBpcyBleGNsdWRlZCBiZWNhdXNlIGl0IHJlbGllcyBvbiBpbml0aWFsIGNsb25lIGZvciBmdXR1cmVcclxuICAgIC8vIGRlZXAgdXBkYXRlcyAoIzcwNjMpLlxyXG4gICAgdmFyIGlzUmVuZGVyZWRNb2R1bGUgPSBtYWtlTWFwKCdhdHRycyxjbGFzcyxzdGF0aWNDbGFzcyxzdGF0aWNTdHlsZSxrZXknKTtcclxuICAgIC8vIE5vdGU6IHRoaXMgaXMgYSBicm93c2VyLW9ubHkgZnVuY3Rpb24gc28gd2UgY2FuIGFzc3VtZSBlbG1zIGFyZSBET00gbm9kZXMuXHJcbiAgICBmdW5jdGlvbiBoeWRyYXRlKGVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgaW5WUHJlKSB7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIHRhZyA9IHZub2RlLnRhZywgZGF0YSA9IHZub2RlLmRhdGEsIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XHJcbiAgICAgICAgaW5WUHJlID0gaW5WUHJlIHx8IChkYXRhICYmIGRhdGEucHJlKTtcclxuICAgICAgICB2bm9kZS5lbG0gPSBlbG07XHJcbiAgICAgICAgaWYgKGlzVHJ1ZSh2bm9kZS5pc0NvbW1lbnQpICYmIGlzRGVmKHZub2RlLmFzeW5jRmFjdG9yeSkpIHtcclxuICAgICAgICAgICAgdm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyID0gdHJ1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGFzc2VydCBub2RlIG1hdGNoXHJcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgICAgaWYgKCFhc3NlcnROb2RlTWF0Y2goZWxtLCB2bm9kZSwgaW5WUHJlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0RlZihkYXRhKSkge1xyXG4gICAgICAgICAgICBpZiAoaXNEZWYoKGkgPSBkYXRhLmhvb2spKSAmJiBpc0RlZigoaSA9IGkuaW5pdCkpKVxyXG4gICAgICAgICAgICAgICAgaSh2bm9kZSwgdHJ1ZSAvKiBoeWRyYXRpbmcgKi8pO1xyXG4gICAgICAgICAgICBpZiAoaXNEZWYoKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjaGlsZCBjb21wb25lbnQuIGl0IHNob3VsZCBoYXZlIGh5ZHJhdGVkIGl0cyBvd24gdHJlZS5cclxuICAgICAgICAgICAgICAgIGluaXRDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNEZWYodGFnKSkge1xyXG4gICAgICAgICAgICBpZiAoaXNEZWYoY2hpbGRyZW4pKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBlbXB0eSBlbGVtZW50LCBhbGxvdyBjbGllbnQgdG8gcGljayB1cCBhbmQgcG9wdWxhdGUgY2hpbGRyZW5cclxuICAgICAgICAgICAgICAgIGlmICghZWxtLmhhc0NoaWxkTm9kZXMoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHYtaHRtbCBhbmQgZG9tUHJvcHM6IGlubmVySFRNTFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0RlZigoaSA9IGRhdGEpKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0RlZigoaSA9IGkuZG9tUHJvcHMpKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0RlZigoaSA9IGkuaW5uZXJIVE1MKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgIT09IGVsbS5pbm5lckhUTUwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhaHlkcmF0aW9uQmFpbGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHlkcmF0aW9uQmFpbGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BhcmVudDogJywgZWxtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ3NlcnZlciBpbm5lckhUTUw6ICcsIGkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignY2xpZW50IGlubmVySFRNTDogJywgZWxtLmlubmVySFRNTCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0ZXJhdGUgYW5kIGNvbXBhcmUgY2hpbGRyZW4gbGlzdHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuTWF0Y2ggPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGROb2RlID0gZWxtLmZpcnN0Q2hpbGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGlfNyA9IDA7IGlfNyA8IGNoaWxkcmVuLmxlbmd0aDsgaV83KyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2hpbGROb2RlIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIWh5ZHJhdGUoY2hpbGROb2RlLCBjaGlsZHJlbltpXzddLCBpbnNlcnRlZFZub2RlUXVldWUsIGluVlByZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbk1hdGNoID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUubmV4dFNpYmxpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgY2hpbGROb2RlIGlzIG5vdCBudWxsLCBpdCBtZWFucyB0aGUgYWN0dWFsIGNoaWxkTm9kZXMgbGlzdCBpc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsb25nZXIgdGhhbiB0aGUgdmlydHVhbCBjaGlsZHJlbiBsaXN0LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNoaWxkcmVuTWF0Y2ggfHwgY2hpbGROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIWh5ZHJhdGlvbkJhaWxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh5ZHJhdGlvbkJhaWxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdQYXJlbnQ6ICcsIGVsbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdNaXNtYXRjaGluZyBjaGlsZE5vZGVzIHZzLiBWTm9kZXM6ICcsIGVsbS5jaGlsZE5vZGVzLCBjaGlsZHJlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZnVsbEludm9rZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUmVuZGVyZWRNb2R1bGUoa2V5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdWxsSW52b2tlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghZnVsbEludm9rZSAmJiBkYXRhWydjbGFzcyddKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZW5zdXJlIGNvbGxlY3RpbmcgZGVwcyBmb3IgZGVlcCBjbGFzcyBiaW5kaW5ncyBmb3IgZnV0dXJlIHVwZGF0ZXNcclxuICAgICAgICAgICAgICAgICAgICB0cmF2ZXJzZShkYXRhWydjbGFzcyddKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChlbG0uZGF0YSAhPT0gdm5vZGUudGV4dCkge1xyXG4gICAgICAgICAgICBlbG0uZGF0YSA9IHZub2RlLnRleHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYXNzZXJ0Tm9kZU1hdGNoKG5vZGUsIHZub2RlLCBpblZQcmUpIHtcclxuICAgICAgICBpZiAoaXNEZWYodm5vZGUudGFnKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gKHZub2RlLnRhZy5pbmRleE9mKCd2dWUtY29tcG9uZW50JykgPT09IDAgfHxcclxuICAgICAgICAgICAgICAgICghaXNVbmtub3duRWxlbWVudCh2bm9kZSwgaW5WUHJlKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHZub2RlLnRhZy50b0xvd2VyQ2FzZSgpID09PVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAobm9kZS50YWdOYW1lICYmIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09ICh2bm9kZS5pc0NvbW1lbnQgPyA4IDogMyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHBhdGNoKG9sZFZub2RlLCB2bm9kZSwgaHlkcmF0aW5nLCByZW1vdmVPbmx5KSB7XHJcbiAgICAgICAgaWYgKGlzVW5kZWYodm5vZGUpKSB7XHJcbiAgICAgICAgICAgIGlmIChpc0RlZihvbGRWbm9kZSkpXHJcbiAgICAgICAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayhvbGRWbm9kZSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGlzSW5pdGlhbFBhdGNoID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIGluc2VydGVkVm5vZGVRdWV1ZSA9IFtdO1xyXG4gICAgICAgIGlmIChpc1VuZGVmKG9sZFZub2RlKSkge1xyXG4gICAgICAgICAgICAvLyBlbXB0eSBtb3VudCAobGlrZWx5IGFzIGNvbXBvbmVudCksIGNyZWF0ZSBuZXcgcm9vdCBlbGVtZW50XHJcbiAgICAgICAgICAgIGlzSW5pdGlhbFBhdGNoID0gdHJ1ZTtcclxuICAgICAgICAgICAgY3JlYXRlRWxtKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIGlzUmVhbEVsZW1lbnQgPSBpc0RlZihvbGRWbm9kZS5ub2RlVHlwZSk7XHJcbiAgICAgICAgICAgIGlmICghaXNSZWFsRWxlbWVudCAmJiBzYW1lVm5vZGUob2xkVm5vZGUsIHZub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gcGF0Y2ggZXhpc3Rpbmcgcm9vdCBub2RlXHJcbiAgICAgICAgICAgICAgICBwYXRjaFZub2RlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBudWxsLCBudWxsLCByZW1vdmVPbmx5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc1JlYWxFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbW91bnRpbmcgdG8gYSByZWFsIGVsZW1lbnRcclxuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiB0aGlzIGlzIHNlcnZlci1yZW5kZXJlZCBjb250ZW50IGFuZCBpZiB3ZSBjYW4gcGVyZm9ybVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGEgc3VjY2Vzc2Z1bCBoeWRyYXRpb24uXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9sZFZub2RlLm5vZGVUeXBlID09PSAxICYmIG9sZFZub2RlLmhhc0F0dHJpYnV0ZShTU1JfQVRUUikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2xkVm5vZGUucmVtb3ZlQXR0cmlidXRlKFNTUl9BVFRSKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaHlkcmF0aW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVHJ1ZShoeWRyYXRpbmcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoeWRyYXRlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvbGRWbm9kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXJuJDIoJ1RoZSBjbGllbnQtc2lkZSByZW5kZXJlZCB2aXJ0dWFsIERPTSB0cmVlIGlzIG5vdCBtYXRjaGluZyAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQuIFRoaXMgaXMgbGlrZWx5IGNhdXNlZCBieSBpbmNvcnJlY3QgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0hUTUwgbWFya3VwLCBmb3IgZXhhbXBsZSBuZXN0aW5nIGJsb2NrLWxldmVsIGVsZW1lbnRzIGluc2lkZSAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPHA+LCBvciBtaXNzaW5nIDx0Ym9keT4uIEJhaWxpbmcgaHlkcmF0aW9uIGFuZCBwZXJmb3JtaW5nICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdmdWxsIGNsaWVudC1zaWRlIHJlbmRlci4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBlaXRoZXIgbm90IHNlcnZlci1yZW5kZXJlZCwgb3IgaHlkcmF0aW9uIGZhaWxlZC5cclxuICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGUgYW4gZW1wdHkgbm9kZSBhbmQgcmVwbGFjZSBpdFxyXG4gICAgICAgICAgICAgICAgICAgIG9sZFZub2RlID0gZW1wdHlOb2RlQXQob2xkVm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gcmVwbGFjaW5nIGV4aXN0aW5nIGVsZW1lbnRcclxuICAgICAgICAgICAgICAgIHZhciBvbGRFbG0gPSBvbGRWbm9kZS5lbG07XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50RWxtID0gbm9kZU9wcy5wYXJlbnROb2RlKG9sZEVsbSk7XHJcbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgbmV3IG5vZGVcclxuICAgICAgICAgICAgICAgIGNyZWF0ZUVsbSh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBcclxuICAgICAgICAgICAgICAgIC8vIGV4dHJlbWVseSByYXJlIGVkZ2UgY2FzZTogZG8gbm90IGluc2VydCBpZiBvbGQgZWxlbWVudCBpcyBpbiBhXHJcbiAgICAgICAgICAgICAgICAvLyBsZWF2aW5nIHRyYW5zaXRpb24uIE9ubHkgaGFwcGVucyB3aGVuIGNvbWJpbmluZyB0cmFuc2l0aW9uICtcclxuICAgICAgICAgICAgICAgIC8vIGtlZXAtYWxpdmUgKyBIT0NzLiAoIzQ1OTApXHJcbiAgICAgICAgICAgICAgICBvbGRFbG0uX2xlYXZlQ2IgPyBudWxsIDogcGFyZW50RWxtLCBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVsbSkpO1xyXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIHBhcmVudCBwbGFjZWhvbGRlciBub2RlIGVsZW1lbnQsIHJlY3Vyc2l2ZWx5XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWYodm5vZGUucGFyZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmNlc3RvciA9IHZub2RlLnBhcmVudDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGF0Y2hhYmxlID0gaXNQYXRjaGFibGUodm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChhbmNlc3Rvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpXzggPSAwOyBpXzggPCBjYnMuZGVzdHJveS5sZW5ndGg7ICsraV84KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYnMuZGVzdHJveVtpXzhdKGFuY2VzdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmNlc3Rvci5lbG0gPSB2bm9kZS5lbG07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXRjaGFibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGlfOSA9IDA7IGlfOSA8IGNicy5jcmVhdGUubGVuZ3RoOyArK2lfOSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNicy5jcmVhdGVbaV85XShlbXB0eU5vZGUsIGFuY2VzdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICM2NTEzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnZva2UgaW5zZXJ0IGhvb2tzIHRoYXQgbWF5IGhhdmUgYmVlbiBtZXJnZWQgYnkgY3JlYXRlIGhvb2tzLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZS5nLiBmb3IgZGlyZWN0aXZlcyB0aGF0IHVzZXMgdGhlIFwiaW5zZXJ0ZWRcIiBob29rLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluc2VydF8xID0gYW5jZXN0b3IuZGF0YS5ob29rLmluc2VydDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnNlcnRfMS5tZXJnZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdGFydCBhdCBpbmRleCAxIHRvIGF2b2lkIHJlLWludm9raW5nIGNvbXBvbmVudCBtb3VudGVkIGhvb2tcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpXzEwID0gMTsgaV8xMCA8IGluc2VydF8xLmZucy5sZW5ndGg7IGlfMTArKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRfMS5mbnNbaV8xMF0oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWdpc3RlclJlZihhbmNlc3Rvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gZGVzdHJveSBvbGQgbm9kZVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmKHBhcmVudEVsbSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmVWbm9kZXMoW29sZFZub2RlXSwgMCwgMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50YWcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgaXNJbml0aWFsUGF0Y2gpO1xyXG4gICAgICAgIHJldHVybiB2bm9kZS5lbG07XHJcbiAgICB9O1xyXG59XG5cbnZhciBkaXJlY3RpdmVzJDEgPSB7XHJcbiAgICBjcmVhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXHJcbiAgICB1cGRhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXHJcbiAgICBkZXN0cm95OiBmdW5jdGlvbiB1bmJpbmREaXJlY3RpdmVzKHZub2RlKSB7XHJcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBlbXB0eU5vZGUgaXMgbm90IFZOb2RlV2l0aERhdGFcclxuICAgICAgICB1cGRhdGVEaXJlY3RpdmVzKHZub2RlLCBlbXB0eU5vZGUpO1xyXG4gICAgfVxyXG59O1xyXG5mdW5jdGlvbiB1cGRhdGVEaXJlY3RpdmVzKG9sZFZub2RlLCB2bm9kZSkge1xyXG4gICAgaWYgKG9sZFZub2RlLmRhdGEuZGlyZWN0aXZlcyB8fCB2bm9kZS5kYXRhLmRpcmVjdGl2ZXMpIHtcclxuICAgICAgICBfdXBkYXRlKG9sZFZub2RlLCB2bm9kZSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gX3VwZGF0ZShvbGRWbm9kZSwgdm5vZGUpIHtcclxuICAgIHZhciBpc0NyZWF0ZSA9IG9sZFZub2RlID09PSBlbXB0eU5vZGU7XHJcbiAgICB2YXIgaXNEZXN0cm95ID0gdm5vZGUgPT09IGVtcHR5Tm9kZTtcclxuICAgIHZhciBvbGREaXJzID0gbm9ybWFsaXplRGlyZWN0aXZlcyhvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMsIG9sZFZub2RlLmNvbnRleHQpO1xyXG4gICAgdmFyIG5ld0RpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzKHZub2RlLmRhdGEuZGlyZWN0aXZlcywgdm5vZGUuY29udGV4dCk7XHJcbiAgICB2YXIgZGlyc1dpdGhJbnNlcnQgPSBbXTtcclxuICAgIHZhciBkaXJzV2l0aFBvc3RwYXRjaCA9IFtdO1xyXG4gICAgdmFyIGtleSwgb2xkRGlyLCBkaXI7XHJcbiAgICBmb3IgKGtleSBpbiBuZXdEaXJzKSB7XHJcbiAgICAgICAgb2xkRGlyID0gb2xkRGlyc1trZXldO1xyXG4gICAgICAgIGRpciA9IG5ld0RpcnNba2V5XTtcclxuICAgICAgICBpZiAoIW9sZERpcikge1xyXG4gICAgICAgICAgICAvLyBuZXcgZGlyZWN0aXZlLCBiaW5kXHJcbiAgICAgICAgICAgIGNhbGxIb29rKGRpciwgJ2JpbmQnLCB2bm9kZSwgb2xkVm5vZGUpO1xyXG4gICAgICAgICAgICBpZiAoZGlyLmRlZiAmJiBkaXIuZGVmLmluc2VydGVkKSB7XHJcbiAgICAgICAgICAgICAgICBkaXJzV2l0aEluc2VydC5wdXNoKGRpcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGV4aXN0aW5nIGRpcmVjdGl2ZSwgdXBkYXRlXHJcbiAgICAgICAgICAgIGRpci5vbGRWYWx1ZSA9IG9sZERpci52YWx1ZTtcclxuICAgICAgICAgICAgZGlyLm9sZEFyZyA9IG9sZERpci5hcmc7XHJcbiAgICAgICAgICAgIGNhbGxIb29rKGRpciwgJ3VwZGF0ZScsIHZub2RlLCBvbGRWbm9kZSk7XHJcbiAgICAgICAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuY29tcG9uZW50VXBkYXRlZCkge1xyXG4gICAgICAgICAgICAgICAgZGlyc1dpdGhQb3N0cGF0Y2gucHVzaChkaXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aCkge1xyXG4gICAgICAgIHZhciBjYWxsSW5zZXJ0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsSG9vayhkaXJzV2l0aEluc2VydFtpXSwgJ2luc2VydGVkJywgdm5vZGUsIG9sZFZub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKGlzQ3JlYXRlKSB7XHJcbiAgICAgICAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAnaW5zZXJ0JywgY2FsbEluc2VydCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjYWxsSW5zZXJ0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aCkge1xyXG4gICAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAncG9zdHBhdGNoJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsSG9vayhkaXJzV2l0aFBvc3RwYXRjaFtpXSwgJ2NvbXBvbmVudFVwZGF0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpZiAoIWlzQ3JlYXRlKSB7XHJcbiAgICAgICAgZm9yIChrZXkgaW4gb2xkRGlycykge1xyXG4gICAgICAgICAgICBpZiAoIW5ld0RpcnNba2V5XSkge1xyXG4gICAgICAgICAgICAgICAgLy8gbm8gbG9uZ2VyIHByZXNlbnQsIHVuYmluZFxyXG4gICAgICAgICAgICAgICAgY2FsbEhvb2sob2xkRGlyc1trZXldLCAndW5iaW5kJywgb2xkVm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbnZhciBlbXB0eU1vZGlmaWVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMoZGlycywgdm0pIHtcclxuICAgIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgaWYgKCFkaXJzKSB7XHJcbiAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIHZhciBpLCBkaXI7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgZGlycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGRpciA9IGRpcnNbaV07XHJcbiAgICAgICAgaWYgKCFkaXIubW9kaWZpZXJzKSB7XHJcbiAgICAgICAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxyXG4gICAgICAgICAgICBkaXIubW9kaWZpZXJzID0gZW1wdHlNb2RpZmllcnM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc1tnZXRSYXdEaXJOYW1lKGRpcildID0gZGlyO1xyXG4gICAgICAgIGlmICh2bS5fc2V0dXBTdGF0ZSAmJiB2bS5fc2V0dXBTdGF0ZS5fX3NmYykge1xyXG4gICAgICAgICAgICBkaXIuZGVmID0gZGlyLmRlZiB8fCByZXNvbHZlQXNzZXQodm0sICdfc2V0dXBTdGF0ZScsICd2LScgKyBkaXIubmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRpci5kZWYgPSBkaXIuZGVmIHx8IHJlc29sdmVBc3NldCh2bS4kb3B0aW9ucywgJ2RpcmVjdGl2ZXMnLCBkaXIubmFtZSwgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuZnVuY3Rpb24gZ2V0UmF3RGlyTmFtZShkaXIpIHtcclxuICAgIHJldHVybiAoZGlyLnJhd05hbWUgfHwgXCJcIi5jb25jYXQoZGlyLm5hbWUsIFwiLlwiKS5jb25jYXQoT2JqZWN0LmtleXMoZGlyLm1vZGlmaWVycyB8fCB7fSkuam9pbignLicpKSk7XHJcbn1cclxuZnVuY3Rpb24gY2FsbEhvb2soZGlyLCBob29rLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSkge1xyXG4gICAgdmFyIGZuID0gZGlyLmRlZiAmJiBkaXIuZGVmW2hvb2tdO1xyXG4gICAgaWYgKGZuKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgZm4odm5vZGUuZWxtLCBkaXIsIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm5vZGUuY29udGV4dCwgXCJkaXJlY3RpdmUgXCIuY29uY2F0KGRpci5uYW1lLCBcIiBcIikuY29uY2F0KGhvb2ssIFwiIGhvb2tcIikpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG52YXIgYmFzZU1vZHVsZXMgPSBbcmVmLCBkaXJlY3RpdmVzJDFdO1xuXG5mdW5jdGlvbiB1cGRhdGVBdHRycyhvbGRWbm9kZSwgdm5vZGUpIHtcclxuICAgIHZhciBvcHRzID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcclxuICAgIGlmIChpc0RlZihvcHRzKSAmJiBvcHRzLkN0b3Iub3B0aW9ucy5pbmhlcml0QXR0cnMgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5hdHRycykgJiYgaXNVbmRlZih2bm9kZS5kYXRhLmF0dHJzKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHZhciBrZXksIGN1ciwgb2xkO1xyXG4gICAgdmFyIGVsbSA9IHZub2RlLmVsbTtcclxuICAgIHZhciBvbGRBdHRycyA9IG9sZFZub2RlLmRhdGEuYXR0cnMgfHwge307XHJcbiAgICB2YXIgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xyXG4gICAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XHJcbiAgICBpZiAoaXNEZWYoYXR0cnMuX19vYl9fKSB8fCBpc1RydWUoYXR0cnMuX3ZfYXR0cl9wcm94eSkpIHtcclxuICAgICAgICBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgPSBleHRlbmQoe30sIGF0dHJzKTtcclxuICAgIH1cclxuICAgIGZvciAoa2V5IGluIGF0dHJzKSB7XHJcbiAgICAgICAgY3VyID0gYXR0cnNba2V5XTtcclxuICAgICAgICBvbGQgPSBvbGRBdHRyc1trZXldO1xyXG4gICAgICAgIGlmIChvbGQgIT09IGN1cikge1xyXG4gICAgICAgICAgICBzZXRBdHRyKGVsbSwga2V5LCBjdXIsIHZub2RlLmRhdGEucHJlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyAjNDM5MTogaW4gSUU5LCBzZXR0aW5nIHR5cGUgY2FuIHJlc2V0IHZhbHVlIGZvciBpbnB1dFt0eXBlPXJhZGlvXVxyXG4gICAgLy8gIzY2NjY6IElFL0VkZ2UgZm9yY2VzIHByb2dyZXNzIHZhbHVlIGRvd24gdG8gMSBiZWZvcmUgc2V0dGluZyBhIG1heFxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICBpZiAoKGlzSUUgfHwgaXNFZGdlKSAmJiBhdHRycy52YWx1ZSAhPT0gb2xkQXR0cnMudmFsdWUpIHtcclxuICAgICAgICBzZXRBdHRyKGVsbSwgJ3ZhbHVlJywgYXR0cnMudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZm9yIChrZXkgaW4gb2xkQXR0cnMpIHtcclxuICAgICAgICBpZiAoaXNVbmRlZihhdHRyc1trZXldKSkge1xyXG4gICAgICAgICAgICBpZiAoaXNYbGluayhrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywgZ2V0WGxpbmtQcm9wKGtleSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc0VudW1lcmF0ZWRBdHRyKGtleSkpIHtcclxuICAgICAgICAgICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBzZXRBdHRyKGVsLCBrZXksIHZhbHVlLCBpc0luUHJlKSB7XHJcbiAgICBpZiAoaXNJblByZSB8fCBlbC50YWdOYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XHJcbiAgICAgICAgYmFzZVNldEF0dHIoZWwsIGtleSwgdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNCb29sZWFuQXR0cihrZXkpKSB7XHJcbiAgICAgICAgLy8gc2V0IGF0dHJpYnV0ZSBmb3IgYmxhbmsgdmFsdWVcclxuICAgICAgICAvLyBlLmcuIDxvcHRpb24gZGlzYWJsZWQ+U2VsZWN0IG9uZTwvb3B0aW9uPlxyXG4gICAgICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xyXG4gICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHRlY2huaWNhbGx5IGFsbG93ZnVsbHNjcmVlbiBpcyBhIGJvb2xlYW4gYXR0cmlidXRlIGZvciA8aWZyYW1lPixcclxuICAgICAgICAgICAgLy8gYnV0IEZsYXNoIGV4cGVjdHMgYSB2YWx1ZSBvZiBcInRydWVcIiB3aGVuIHVzZWQgb24gPGVtYmVkPiB0YWdcclxuICAgICAgICAgICAgdmFsdWUgPSBrZXkgPT09ICdhbGxvd2Z1bGxzY3JlZW4nICYmIGVsLnRhZ05hbWUgPT09ICdFTUJFRCcgPyAndHJ1ZScgOiBrZXk7XHJcbiAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0VudW1lcmF0ZWRBdHRyKGtleSkpIHtcclxuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCBjb252ZXJ0RW51bWVyYXRlZFZhbHVlKGtleSwgdmFsdWUpKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzWGxpbmsoa2V5KSkge1xyXG4gICAgICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xyXG4gICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGVOUyh4bGlua05TLCBrZXksIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBiYXNlU2V0QXR0cihlbCwga2V5LCB2YWx1ZSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gYmFzZVNldEF0dHIoZWwsIGtleSwgdmFsdWUpIHtcclxuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xyXG4gICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gIzcxMzg6IElFMTAgJiAxMSBmaXJlcyBpbnB1dCBldmVudCB3aGVuIHNldHRpbmcgcGxhY2Vob2xkZXIgb25cclxuICAgICAgICAvLyA8dGV4dGFyZWE+Li4uIGJsb2NrIHRoZSBmaXJzdCBpbnB1dCBldmVudCBhbmQgcmVtb3ZlIHRoZSBibG9ja2VyXHJcbiAgICAgICAgLy8gaW1tZWRpYXRlbHkuXHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgaWYgKGlzSUUgJiZcclxuICAgICAgICAgICAgIWlzSUU5ICYmXHJcbiAgICAgICAgICAgIGVsLnRhZ05hbWUgPT09ICdURVhUQVJFQScgJiZcclxuICAgICAgICAgICAga2V5ID09PSAncGxhY2Vob2xkZXInICYmXHJcbiAgICAgICAgICAgIHZhbHVlICE9PSAnJyAmJlxyXG4gICAgICAgICAgICAhZWwuX19pZXBoKSB7XHJcbiAgICAgICAgICAgIHZhciBibG9ja2VyXzEgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lucHV0JywgYmxvY2tlcl8xKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBibG9ja2VyXzEpO1xyXG4gICAgICAgICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcclxuICAgICAgICAgICAgZWwuX19pZXBoID0gdHJ1ZTsgLyogSUUgcGxhY2Vob2xkZXIgcGF0Y2hlZCAqL1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XHJcbiAgICB9XHJcbn1cclxudmFyIGF0dHJzID0ge1xyXG4gICAgY3JlYXRlOiB1cGRhdGVBdHRycyxcclxuICAgIHVwZGF0ZTogdXBkYXRlQXR0cnNcclxufTtcblxuZnVuY3Rpb24gdXBkYXRlQ2xhc3Mob2xkVm5vZGUsIHZub2RlKSB7XHJcbiAgICB2YXIgZWwgPSB2bm9kZS5lbG07XHJcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XHJcbiAgICB2YXIgb2xkRGF0YSA9IG9sZFZub2RlLmRhdGE7XHJcbiAgICBpZiAoaXNVbmRlZihkYXRhLnN0YXRpY0NsYXNzKSAmJlxyXG4gICAgICAgIGlzVW5kZWYoZGF0YS5jbGFzcykgJiZcclxuICAgICAgICAoaXNVbmRlZihvbGREYXRhKSB8fFxyXG4gICAgICAgICAgICAoaXNVbmRlZihvbGREYXRhLnN0YXRpY0NsYXNzKSAmJiBpc1VuZGVmKG9sZERhdGEuY2xhc3MpKSkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB2YXIgY2xzID0gZ2VuQ2xhc3NGb3JWbm9kZSh2bm9kZSk7XHJcbiAgICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBjbGFzc2VzXHJcbiAgICB2YXIgdHJhbnNpdGlvbkNsYXNzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzO1xyXG4gICAgaWYgKGlzRGVmKHRyYW5zaXRpb25DbGFzcykpIHtcclxuICAgICAgICBjbHMgPSBjb25jYXQoY2xzLCBzdHJpbmdpZnlDbGFzcyh0cmFuc2l0aW9uQ2xhc3MpKTtcclxuICAgIH1cclxuICAgIC8vIHNldCB0aGUgY2xhc3NcclxuICAgIGlmIChjbHMgIT09IGVsLl9wcmV2Q2xhc3MpIHtcclxuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY2xzKTtcclxuICAgICAgICBlbC5fcHJldkNsYXNzID0gY2xzO1xyXG4gICAgfVxyXG59XHJcbnZhciBrbGFzcyQxID0ge1xyXG4gICAgY3JlYXRlOiB1cGRhdGVDbGFzcyxcclxuICAgIHVwZGF0ZTogdXBkYXRlQ2xhc3NcclxufTtcblxudmFyIHZhbGlkRGl2aXNpb25DaGFyUkUgPSAvW1xcdykuK1xcLV8kXFxdXS87XHJcbmZ1bmN0aW9uIHBhcnNlRmlsdGVycyhleHApIHtcclxuICAgIHZhciBpblNpbmdsZSA9IGZhbHNlO1xyXG4gICAgdmFyIGluRG91YmxlID0gZmFsc2U7XHJcbiAgICB2YXIgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlO1xyXG4gICAgdmFyIGluUmVnZXggPSBmYWxzZTtcclxuICAgIHZhciBjdXJseSA9IDA7XHJcbiAgICB2YXIgc3F1YXJlID0gMDtcclxuICAgIHZhciBwYXJlbiA9IDA7XHJcbiAgICB2YXIgbGFzdEZpbHRlckluZGV4ID0gMDtcclxuICAgIHZhciBjLCBwcmV2LCBpLCBleHByZXNzaW9uLCBmaWx0ZXJzO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGV4cC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHByZXYgPSBjO1xyXG4gICAgICAgIGMgPSBleHAuY2hhckNvZGVBdChpKTtcclxuICAgICAgICBpZiAoaW5TaW5nbGUpIHtcclxuICAgICAgICAgICAgaWYgKGMgPT09IDB4MjcgJiYgcHJldiAhPT0gMHg1YylcclxuICAgICAgICAgICAgICAgIGluU2luZ2xlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGluRG91YmxlKSB7XHJcbiAgICAgICAgICAgIGlmIChjID09PSAweDIyICYmIHByZXYgIT09IDB4NWMpXHJcbiAgICAgICAgICAgICAgICBpbkRvdWJsZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpblRlbXBsYXRlU3RyaW5nKSB7XHJcbiAgICAgICAgICAgIGlmIChjID09PSAweDYwICYmIHByZXYgIT09IDB4NWMpXHJcbiAgICAgICAgICAgICAgICBpblRlbXBsYXRlU3RyaW5nID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGluUmVnZXgpIHtcclxuICAgICAgICAgICAgaWYgKGMgPT09IDB4MmYgJiYgcHJldiAhPT0gMHg1YylcclxuICAgICAgICAgICAgICAgIGluUmVnZXggPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYyA9PT0gMHg3YyAmJiAvLyBwaXBlXHJcbiAgICAgICAgICAgIGV4cC5jaGFyQ29kZUF0KGkgKyAxKSAhPT0gMHg3YyAmJlxyXG4gICAgICAgICAgICBleHAuY2hhckNvZGVBdChpIC0gMSkgIT09IDB4N2MgJiZcclxuICAgICAgICAgICAgIWN1cmx5ICYmXHJcbiAgICAgICAgICAgICFzcXVhcmUgJiZcclxuICAgICAgICAgICAgIXBhcmVuKSB7XHJcbiAgICAgICAgICAgIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIGZpcnN0IGZpbHRlciwgZW5kIG9mIGV4cHJlc3Npb25cclxuICAgICAgICAgICAgICAgIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxO1xyXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA9IGV4cC5zbGljZSgwLCBpKS50cmltKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBwdXNoRmlsdGVyKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoYykge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAweDIyOlxyXG4gICAgICAgICAgICAgICAgICAgIGluRG91YmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gXCJcclxuICAgICAgICAgICAgICAgIGNhc2UgMHgyNzpcclxuICAgICAgICAgICAgICAgICAgICBpblNpbmdsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vICdcclxuICAgICAgICAgICAgICAgIGNhc2UgMHg2MDpcclxuICAgICAgICAgICAgICAgICAgICBpblRlbXBsYXRlU3RyaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gYFxyXG4gICAgICAgICAgICAgICAgY2FzZSAweDI4OlxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVuKys7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIChcclxuICAgICAgICAgICAgICAgIGNhc2UgMHgyOTpcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbi0tO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyApXHJcbiAgICAgICAgICAgICAgICBjYXNlIDB4NWI6XHJcbiAgICAgICAgICAgICAgICAgICAgc3F1YXJlKys7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIFtcclxuICAgICAgICAgICAgICAgIGNhc2UgMHg1ZDpcclxuICAgICAgICAgICAgICAgICAgICBzcXVhcmUtLTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gXVxyXG4gICAgICAgICAgICAgICAgY2FzZSAweDdiOlxyXG4gICAgICAgICAgICAgICAgICAgIGN1cmx5Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMHg3ZDpcclxuICAgICAgICAgICAgICAgICAgICBjdXJseS0tO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGMgPT09IDB4MmYpIHtcclxuICAgICAgICAgICAgICAgIC8vIC9cclxuICAgICAgICAgICAgICAgIHZhciBqID0gaSAtIDE7XHJcbiAgICAgICAgICAgICAgICB2YXIgcCBcclxuICAgICAgICAgICAgICAgIC8vIGZpbmQgZmlyc3Qgbm9uLXdoaXRlc3BhY2UgcHJldiBjaGFyXHJcbiAgICAgICAgICAgICAgICA9IHZvaWQgMDtcclxuICAgICAgICAgICAgICAgIC8vIGZpbmQgZmlyc3Qgbm9uLXdoaXRlc3BhY2UgcHJldiBjaGFyXHJcbiAgICAgICAgICAgICAgICBmb3IgKDsgaiA+PSAwOyBqLS0pIHtcclxuICAgICAgICAgICAgICAgICAgICBwID0gZXhwLmNoYXJBdChqKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocCAhPT0gJyAnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghcCB8fCAhdmFsaWREaXZpc2lvbkNoYXJSRS50ZXN0KHApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5SZWdleCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoZXhwcmVzc2lvbiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgZXhwcmVzc2lvbiA9IGV4cC5zbGljZSgwLCBpKS50cmltKCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChsYXN0RmlsdGVySW5kZXggIT09IDApIHtcclxuICAgICAgICBwdXNoRmlsdGVyKCk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBwdXNoRmlsdGVyKCkge1xyXG4gICAgICAgIChmaWx0ZXJzIHx8IChmaWx0ZXJzID0gW10pKS5wdXNoKGV4cC5zbGljZShsYXN0RmlsdGVySW5kZXgsIGkpLnRyaW0oKSk7XHJcbiAgICAgICAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XHJcbiAgICB9XHJcbiAgICBpZiAoZmlsdGVycykge1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBmaWx0ZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGV4cHJlc3Npb24gPSB3cmFwRmlsdGVyKGV4cHJlc3Npb24sIGZpbHRlcnNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBleHByZXNzaW9uO1xyXG59XHJcbmZ1bmN0aW9uIHdyYXBGaWx0ZXIoZXhwLCBmaWx0ZXIpIHtcclxuICAgIHZhciBpID0gZmlsdGVyLmluZGV4T2YoJygnKTtcclxuICAgIGlmIChpIDwgMCkge1xyXG4gICAgICAgIC8vIF9mOiByZXNvbHZlRmlsdGVyXHJcbiAgICAgICAgcmV0dXJuIFwiX2YoXFxcIlwiLmNvbmNhdChmaWx0ZXIsIFwiXFxcIikoXCIpLmNvbmNhdChleHAsIFwiKVwiKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhciBuYW1lXzEgPSBmaWx0ZXIuc2xpY2UoMCwgaSk7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBmaWx0ZXIuc2xpY2UoaSArIDEpO1xyXG4gICAgICAgIHJldHVybiBcIl9mKFxcXCJcIi5jb25jYXQobmFtZV8xLCBcIlxcXCIpKFwiKS5jb25jYXQoZXhwKS5jb25jYXQoYXJncyAhPT0gJyknID8gJywnICsgYXJncyA6IGFyZ3MpO1xyXG4gICAgfVxyXG59XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXHJcbmZ1bmN0aW9uIGJhc2VXYXJuKG1zZywgcmFuZ2UpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoXCJbVnVlIGNvbXBpbGVyXTogXCIuY29uY2F0KG1zZykpO1xyXG59XHJcbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cclxuZnVuY3Rpb24gcGx1Y2tNb2R1bGVGdW5jdGlvbihtb2R1bGVzLCBrZXkpIHtcclxuICAgIHJldHVybiBtb2R1bGVzID8gbW9kdWxlcy5tYXAoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG1ba2V5XTsgfSkuZmlsdGVyKGZ1bmN0aW9uIChfKSB7IHJldHVybiBfOyB9KSA6IFtdO1xyXG59XHJcbmZ1bmN0aW9uIGFkZFByb3AoZWwsIG5hbWUsIHZhbHVlLCByYW5nZSwgZHluYW1pYykge1xyXG4gICAgKGVsLnByb3BzIHx8IChlbC5wcm9wcyA9IFtdKSkucHVzaChyYW5nZVNldEl0ZW0oeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUsIGR5bmFtaWM6IGR5bmFtaWMgfSwgcmFuZ2UpKTtcclxuICAgIGVsLnBsYWluID0gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gYWRkQXR0cihlbCwgbmFtZSwgdmFsdWUsIHJhbmdlLCBkeW5hbWljKSB7XHJcbiAgICB2YXIgYXR0cnMgPSBkeW5hbWljXHJcbiAgICAgICAgPyBlbC5keW5hbWljQXR0cnMgfHwgKGVsLmR5bmFtaWNBdHRycyA9IFtdKVxyXG4gICAgICAgIDogZWwuYXR0cnMgfHwgKGVsLmF0dHJzID0gW10pO1xyXG4gICAgYXR0cnMucHVzaChyYW5nZVNldEl0ZW0oeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUsIGR5bmFtaWM6IGR5bmFtaWMgfSwgcmFuZ2UpKTtcclxuICAgIGVsLnBsYWluID0gZmFsc2U7XHJcbn1cclxuLy8gYWRkIGEgcmF3IGF0dHIgKHVzZSB0aGlzIGluIHByZVRyYW5zZm9ybXMpXHJcbmZ1bmN0aW9uIGFkZFJhd0F0dHIoZWwsIG5hbWUsIHZhbHVlLCByYW5nZSkge1xyXG4gICAgZWwuYXR0cnNNYXBbbmFtZV0gPSB2YWx1ZTtcclxuICAgIGVsLmF0dHJzTGlzdC5wdXNoKHJhbmdlU2V0SXRlbSh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9LCByYW5nZSkpO1xyXG59XHJcbmZ1bmN0aW9uIGFkZERpcmVjdGl2ZShlbCwgbmFtZSwgcmF3TmFtZSwgdmFsdWUsIGFyZywgaXNEeW5hbWljQXJnLCBtb2RpZmllcnMsIHJhbmdlKSB7XHJcbiAgICAoZWwuZGlyZWN0aXZlcyB8fCAoZWwuZGlyZWN0aXZlcyA9IFtdKSkucHVzaChyYW5nZVNldEl0ZW0oe1xyXG4gICAgICAgIG5hbWU6IG5hbWUsXHJcbiAgICAgICAgcmF3TmFtZTogcmF3TmFtZSxcclxuICAgICAgICB2YWx1ZTogdmFsdWUsXHJcbiAgICAgICAgYXJnOiBhcmcsXHJcbiAgICAgICAgaXNEeW5hbWljQXJnOiBpc0R5bmFtaWNBcmcsXHJcbiAgICAgICAgbW9kaWZpZXJzOiBtb2RpZmllcnNcclxuICAgIH0sIHJhbmdlKSk7XHJcbiAgICBlbC5wbGFpbiA9IGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIHByZXBlbmRNb2RpZmllck1hcmtlcihzeW1ib2wsIG5hbWUsIGR5bmFtaWMpIHtcclxuICAgIHJldHVybiBkeW5hbWljID8gXCJfcChcIi5jb25jYXQobmFtZSwgXCIsXFxcIlwiKS5jb25jYXQoc3ltYm9sLCBcIlxcXCIpXCIpIDogc3ltYm9sICsgbmFtZTsgLy8gbWFyayB0aGUgZXZlbnQgYXMgY2FwdHVyZWRcclxufVxyXG5mdW5jdGlvbiBhZGRIYW5kbGVyKGVsLCBuYW1lLCB2YWx1ZSwgbW9kaWZpZXJzLCBpbXBvcnRhbnQsIHdhcm4sIHJhbmdlLCBkeW5hbWljKSB7XHJcbiAgICBtb2RpZmllcnMgPSBtb2RpZmllcnMgfHwgZW1wdHlPYmplY3Q7XHJcbiAgICAvLyB3YXJuIHByZXZlbnQgYW5kIHBhc3NpdmUgbW9kaWZpZXJcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybiAmJiBtb2RpZmllcnMucHJldmVudCAmJiBtb2RpZmllcnMucGFzc2l2ZSkge1xyXG4gICAgICAgIHdhcm4oXCJwYXNzaXZlIGFuZCBwcmV2ZW50IGNhbid0IGJlIHVzZWQgdG9nZXRoZXIuIFwiICtcclxuICAgICAgICAgICAgXCJQYXNzaXZlIGhhbmRsZXIgY2FuJ3QgcHJldmVudCBkZWZhdWx0IGV2ZW50LlwiLCByYW5nZSk7XHJcbiAgICB9XHJcbiAgICAvLyBub3JtYWxpemUgY2xpY2sucmlnaHQgYW5kIGNsaWNrLm1pZGRsZSBzaW5jZSB0aGV5IGRvbid0IGFjdHVhbGx5IGZpcmVcclxuICAgIC8vIHRoaXMgaXMgdGVjaG5pY2FsbHkgYnJvd3Nlci1zcGVjaWZpYywgYnV0IGF0IGxlYXN0IGZvciBub3cgYnJvd3NlcnMgYXJlXHJcbiAgICAvLyB0aGUgb25seSB0YXJnZXQgZW52cyB0aGF0IGhhdmUgcmlnaHQvbWlkZGxlIGNsaWNrcy5cclxuICAgIGlmIChtb2RpZmllcnMucmlnaHQpIHtcclxuICAgICAgICBpZiAoZHluYW1pYykge1xyXG4gICAgICAgICAgICBuYW1lID0gXCIoXCIuY29uY2F0KG5hbWUsIFwiKT09PSdjbGljayc/J2NvbnRleHRtZW51JzooXCIpLmNvbmNhdChuYW1lLCBcIilcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG5hbWUgPT09ICdjbGljaycpIHtcclxuICAgICAgICAgICAgbmFtZSA9ICdjb250ZXh0bWVudSc7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBtb2RpZmllcnMucmlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobW9kaWZpZXJzLm1pZGRsZSkge1xyXG4gICAgICAgIGlmIChkeW5hbWljKSB7XHJcbiAgICAgICAgICAgIG5hbWUgPSBcIihcIi5jb25jYXQobmFtZSwgXCIpPT09J2NsaWNrJz8nbW91c2V1cCc6KFwiKS5jb25jYXQobmFtZSwgXCIpXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChuYW1lID09PSAnY2xpY2snKSB7XHJcbiAgICAgICAgICAgIG5hbWUgPSAnbW91c2V1cCc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gY2hlY2sgY2FwdHVyZSBtb2RpZmllclxyXG4gICAgaWYgKG1vZGlmaWVycy5jYXB0dXJlKSB7XHJcbiAgICAgICAgZGVsZXRlIG1vZGlmaWVycy5jYXB0dXJlO1xyXG4gICAgICAgIG5hbWUgPSBwcmVwZW5kTW9kaWZpZXJNYXJrZXIoJyEnLCBuYW1lLCBkeW5hbWljKTtcclxuICAgIH1cclxuICAgIGlmIChtb2RpZmllcnMub25jZSkge1xyXG4gICAgICAgIGRlbGV0ZSBtb2RpZmllcnMub25jZTtcclxuICAgICAgICBuYW1lID0gcHJlcGVuZE1vZGlmaWVyTWFya2VyKCd+JywgbmFtZSwgZHluYW1pYyk7XHJcbiAgICB9XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIGlmIChtb2RpZmllcnMucGFzc2l2ZSkge1xyXG4gICAgICAgIGRlbGV0ZSBtb2RpZmllcnMucGFzc2l2ZTtcclxuICAgICAgICBuYW1lID0gcHJlcGVuZE1vZGlmaWVyTWFya2VyKCcmJywgbmFtZSwgZHluYW1pYyk7XHJcbiAgICB9XHJcbiAgICB2YXIgZXZlbnRzO1xyXG4gICAgaWYgKG1vZGlmaWVycy5uYXRpdmUpIHtcclxuICAgICAgICBkZWxldGUgbW9kaWZpZXJzLm5hdGl2ZTtcclxuICAgICAgICBldmVudHMgPSBlbC5uYXRpdmVFdmVudHMgfHwgKGVsLm5hdGl2ZUV2ZW50cyA9IHt9KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGV2ZW50cyA9IGVsLmV2ZW50cyB8fCAoZWwuZXZlbnRzID0ge30pO1xyXG4gICAgfVxyXG4gICAgdmFyIG5ld0hhbmRsZXIgPSByYW5nZVNldEl0ZW0oeyB2YWx1ZTogdmFsdWUudHJpbSgpLCBkeW5hbWljOiBkeW5hbWljIH0sIHJhbmdlKTtcclxuICAgIGlmIChtb2RpZmllcnMgIT09IGVtcHR5T2JqZWN0KSB7XHJcbiAgICAgICAgbmV3SGFuZGxlci5tb2RpZmllcnMgPSBtb2RpZmllcnM7XHJcbiAgICB9XHJcbiAgICB2YXIgaGFuZGxlcnMgPSBldmVudHNbbmFtZV07XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXJzKSkge1xyXG4gICAgICAgIGltcG9ydGFudCA/IGhhbmRsZXJzLnVuc2hpZnQobmV3SGFuZGxlcikgOiBoYW5kbGVycy5wdXNoKG5ld0hhbmRsZXIpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaGFuZGxlcnMpIHtcclxuICAgICAgICBldmVudHNbbmFtZV0gPSBpbXBvcnRhbnQgPyBbbmV3SGFuZGxlciwgaGFuZGxlcnNdIDogW2hhbmRsZXJzLCBuZXdIYW5kbGVyXTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGV2ZW50c1tuYW1lXSA9IG5ld0hhbmRsZXI7XHJcbiAgICB9XHJcbiAgICBlbC5wbGFpbiA9IGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIGdldFJhd0JpbmRpbmdBdHRyKGVsLCBuYW1lKSB7XHJcbiAgICByZXR1cm4gKGVsLnJhd0F0dHJzTWFwWyc6JyArIG5hbWVdIHx8XHJcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtYmluZDonICsgbmFtZV0gfHxcclxuICAgICAgICBlbC5yYXdBdHRyc01hcFtuYW1lXSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0QmluZGluZ0F0dHIoZWwsIG5hbWUsIGdldFN0YXRpYykge1xyXG4gICAgdmFyIGR5bmFtaWNWYWx1ZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICc6JyArIG5hbWUpIHx8IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWJpbmQ6JyArIG5hbWUpO1xyXG4gICAgaWYgKGR5bmFtaWNWYWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlRmlsdGVycyhkeW5hbWljVmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZ2V0U3RhdGljICE9PSBmYWxzZSkge1xyXG4gICAgICAgIHZhciBzdGF0aWNWYWx1ZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsIG5hbWUpO1xyXG4gICAgICAgIGlmIChzdGF0aWNWYWx1ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShzdGF0aWNWYWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8vIG5vdGU6IHRoaXMgb25seSByZW1vdmVzIHRoZSBhdHRyIGZyb20gdGhlIEFycmF5IChhdHRyc0xpc3QpIHNvIHRoYXQgaXRcclxuLy8gZG9lc24ndCBnZXQgcHJvY2Vzc2VkIGJ5IHByb2Nlc3NBdHRycy5cclxuLy8gQnkgZGVmYXVsdCBpdCBkb2VzIE5PVCByZW1vdmUgaXQgZnJvbSB0aGUgbWFwIChhdHRyc01hcCkgYmVjYXVzZSB0aGUgbWFwIGlzXHJcbi8vIG5lZWRlZCBkdXJpbmcgY29kZWdlbi5cclxuZnVuY3Rpb24gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgbmFtZSwgcmVtb3ZlRnJvbU1hcCkge1xyXG4gICAgdmFyIHZhbDtcclxuICAgIGlmICgodmFsID0gZWwuYXR0cnNNYXBbbmFtZV0pICE9IG51bGwpIHtcclxuICAgICAgICB2YXIgbGlzdCA9IGVsLmF0dHJzTGlzdDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChsaXN0W2ldLm5hbWUgPT09IG5hbWUpIHtcclxuICAgICAgICAgICAgICAgIGxpc3Quc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAocmVtb3ZlRnJvbU1hcCkge1xyXG4gICAgICAgIGRlbGV0ZSBlbC5hdHRyc01hcFtuYW1lXTtcclxuICAgIH1cclxuICAgIHJldHVybiB2YWw7XHJcbn1cclxuZnVuY3Rpb24gZ2V0QW5kUmVtb3ZlQXR0ckJ5UmVnZXgoZWwsIG5hbWUpIHtcclxuICAgIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIHZhciBhdHRyID0gbGlzdFtpXTtcclxuICAgICAgICBpZiAobmFtZS50ZXN0KGF0dHIubmFtZSkpIHtcclxuICAgICAgICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgIHJldHVybiBhdHRyO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiByYW5nZVNldEl0ZW0oaXRlbSwgcmFuZ2UpIHtcclxuICAgIGlmIChyYW5nZSkge1xyXG4gICAgICAgIGlmIChyYW5nZS5zdGFydCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGl0ZW0uc3RhcnQgPSByYW5nZS5zdGFydDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJhbmdlLmVuZCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGl0ZW0uZW5kID0gcmFuZ2UuZW5kO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBpdGVtO1xyXG59XG5cbi8qKlxyXG4gKiBDcm9zcy1wbGF0Zm9ybSBjb2RlIGdlbmVyYXRpb24gZm9yIGNvbXBvbmVudCB2LW1vZGVsXHJcbiAqL1xyXG5mdW5jdGlvbiBnZW5Db21wb25lbnRNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycykge1xyXG4gICAgdmFyIF9hID0gbW9kaWZpZXJzIHx8IHt9LCBudW1iZXIgPSBfYS5udW1iZXIsIHRyaW0gPSBfYS50cmltO1xyXG4gICAgdmFyIGJhc2VWYWx1ZUV4cHJlc3Npb24gPSAnJCR2JztcclxuICAgIHZhciB2YWx1ZUV4cHJlc3Npb24gPSBiYXNlVmFsdWVFeHByZXNzaW9uO1xyXG4gICAgaWYgKHRyaW0pIHtcclxuICAgICAgICB2YWx1ZUV4cHJlc3Npb24gPVxyXG4gICAgICAgICAgICBcIih0eXBlb2YgXCIuY29uY2F0KGJhc2VWYWx1ZUV4cHJlc3Npb24sIFwiID09PSAnc3RyaW5nJ1wiKSArXHJcbiAgICAgICAgICAgICAgICBcIj8gXCIuY29uY2F0KGJhc2VWYWx1ZUV4cHJlc3Npb24sIFwiLnRyaW0oKVwiKSArXHJcbiAgICAgICAgICAgICAgICBcIjogXCIuY29uY2F0KGJhc2VWYWx1ZUV4cHJlc3Npb24sIFwiKVwiKTtcclxuICAgIH1cclxuICAgIGlmIChudW1iZXIpIHtcclxuICAgICAgICB2YWx1ZUV4cHJlc3Npb24gPSBcIl9uKFwiLmNvbmNhdCh2YWx1ZUV4cHJlc3Npb24sIFwiKVwiKTtcclxuICAgIH1cclxuICAgIHZhciBhc3NpZ25tZW50ID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlRXhwcmVzc2lvbik7XHJcbiAgICBlbC5tb2RlbCA9IHtcclxuICAgICAgICB2YWx1ZTogXCIoXCIuY29uY2F0KHZhbHVlLCBcIilcIiksXHJcbiAgICAgICAgZXhwcmVzc2lvbjogSlNPTi5zdHJpbmdpZnkodmFsdWUpLFxyXG4gICAgICAgIGNhbGxiYWNrOiBcImZ1bmN0aW9uIChcIi5jb25jYXQoYmFzZVZhbHVlRXhwcmVzc2lvbiwgXCIpIHtcIikuY29uY2F0KGFzc2lnbm1lbnQsIFwifVwiKVxyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogQ3Jvc3MtcGxhdGZvcm0gY29kZWdlbiBoZWxwZXIgZm9yIGdlbmVyYXRpbmcgdi1tb2RlbCB2YWx1ZSBhc3NpZ25tZW50IGNvZGUuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgYXNzaWdubWVudCkge1xyXG4gICAgdmFyIHJlcyA9IHBhcnNlTW9kZWwodmFsdWUpO1xyXG4gICAgaWYgKHJlcy5rZXkgPT09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQodmFsdWUsIFwiPVwiKS5jb25jYXQoYXNzaWdubWVudCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gXCIkc2V0KFwiLmNvbmNhdChyZXMuZXhwLCBcIiwgXCIpLmNvbmNhdChyZXMua2V5LCBcIiwgXCIpLmNvbmNhdChhc3NpZ25tZW50LCBcIilcIik7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFBhcnNlIGEgdi1tb2RlbCBleHByZXNzaW9uIGludG8gYSBiYXNlIHBhdGggYW5kIGEgZmluYWwga2V5IHNlZ21lbnQuXHJcbiAqIEhhbmRsZXMgYm90aCBkb3QtcGF0aCBhbmQgcG9zc2libGUgc3F1YXJlIGJyYWNrZXRzLlxyXG4gKlxyXG4gKiBQb3NzaWJsZSBjYXNlczpcclxuICpcclxuICogLSB0ZXN0XHJcbiAqIC0gdGVzdFtrZXldXHJcbiAqIC0gdGVzdFt0ZXN0MVtrZXldXVxyXG4gKiAtIHRlc3RbXCJhXCJdW2tleV1cclxuICogLSB4eHgudGVzdFthW2FdLnRlc3QxW2tleV1dXHJcbiAqIC0gdGVzdC54eHguYVtcImFzYVwiXVt0ZXN0MVtrZXldXVxyXG4gKlxyXG4gKi9cclxudmFyIGxlbiwgc3RyLCBjaHIsIGluZGV4LCBleHByZXNzaW9uUG9zLCBleHByZXNzaW9uRW5kUG9zO1xyXG5mdW5jdGlvbiBwYXJzZU1vZGVsKHZhbCkge1xyXG4gICAgLy8gRml4IGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUvcHVsbC83NzMwXHJcbiAgICAvLyBhbGxvdyB2LW1vZGVsPVwib2JqLnZhbCBcIiAodHJhaWxpbmcgd2hpdGVzcGFjZSlcclxuICAgIHZhbCA9IHZhbC50cmltKCk7XHJcbiAgICBsZW4gPSB2YWwubGVuZ3RoO1xyXG4gICAgaWYgKHZhbC5pbmRleE9mKCdbJykgPCAwIHx8IHZhbC5sYXN0SW5kZXhPZignXScpIDwgbGVuIC0gMSkge1xyXG4gICAgICAgIGluZGV4ID0gdmFsLmxhc3RJbmRleE9mKCcuJyk7XHJcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGV4cDogdmFsLnNsaWNlKDAsIGluZGV4KSxcclxuICAgICAgICAgICAgICAgIGtleTogJ1wiJyArIHZhbC5zbGljZShpbmRleCArIDEpICsgJ1wiJ1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGV4cDogdmFsLFxyXG4gICAgICAgICAgICAgICAga2V5OiBudWxsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RyID0gdmFsO1xyXG4gICAgaW5kZXggPSBleHByZXNzaW9uUG9zID0gZXhwcmVzc2lvbkVuZFBvcyA9IDA7XHJcbiAgICB3aGlsZSAoIWVvZigpKSB7XHJcbiAgICAgICAgY2hyID0gbmV4dCgpO1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICAgIGlmIChpc1N0cmluZ1N0YXJ0KGNocikpIHtcclxuICAgICAgICAgICAgcGFyc2VTdHJpbmcoY2hyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY2hyID09PSAweDViKSB7XHJcbiAgICAgICAgICAgIHBhcnNlQnJhY2tldChjaHIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZXhwOiB2YWwuc2xpY2UoMCwgZXhwcmVzc2lvblBvcyksXHJcbiAgICAgICAga2V5OiB2YWwuc2xpY2UoZXhwcmVzc2lvblBvcyArIDEsIGV4cHJlc3Npb25FbmRQb3MpXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIG5leHQoKSB7XHJcbiAgICByZXR1cm4gc3RyLmNoYXJDb2RlQXQoKytpbmRleCk7XHJcbn1cclxuZnVuY3Rpb24gZW9mKCkge1xyXG4gICAgcmV0dXJuIGluZGV4ID49IGxlbjtcclxufVxyXG5mdW5jdGlvbiBpc1N0cmluZ1N0YXJ0KGNocikge1xyXG4gICAgcmV0dXJuIGNociA9PT0gMHgyMiB8fCBjaHIgPT09IDB4Mjc7XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VCcmFja2V0KGNocikge1xyXG4gICAgdmFyIGluQnJhY2tldCA9IDE7XHJcbiAgICBleHByZXNzaW9uUG9zID0gaW5kZXg7XHJcbiAgICB3aGlsZSAoIWVvZigpKSB7XHJcbiAgICAgICAgY2hyID0gbmV4dCgpO1xyXG4gICAgICAgIGlmIChpc1N0cmluZ1N0YXJ0KGNocikpIHtcclxuICAgICAgICAgICAgcGFyc2VTdHJpbmcoY2hyKTtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjaHIgPT09IDB4NWIpXHJcbiAgICAgICAgICAgIGluQnJhY2tldCsrO1xyXG4gICAgICAgIGlmIChjaHIgPT09IDB4NWQpXHJcbiAgICAgICAgICAgIGluQnJhY2tldC0tO1xyXG4gICAgICAgIGlmIChpbkJyYWNrZXQgPT09IDApIHtcclxuICAgICAgICAgICAgZXhwcmVzc2lvbkVuZFBvcyA9IGluZGV4O1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VTdHJpbmcoY2hyKSB7XHJcbiAgICB2YXIgc3RyaW5nUXVvdGUgPSBjaHI7XHJcbiAgICB3aGlsZSAoIWVvZigpKSB7XHJcbiAgICAgICAgY2hyID0gbmV4dCgpO1xyXG4gICAgICAgIGlmIChjaHIgPT09IHN0cmluZ1F1b3RlKSB7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG52YXIgd2FybiQxO1xyXG4vLyBpbiBzb21lIGNhc2VzLCB0aGUgZXZlbnQgdXNlZCBoYXMgdG8gYmUgZGV0ZXJtaW5lZCBhdCBydW50aW1lXHJcbi8vIHNvIHdlIHVzZWQgc29tZSByZXNlcnZlZCB0b2tlbnMgZHVyaW5nIGNvbXBpbGUuXHJcbnZhciBSQU5HRV9UT0tFTiA9ICdfX3InO1xyXG52YXIgQ0hFQ0tCT1hfUkFESU9fVE9LRU4gPSAnX19jJztcclxuZnVuY3Rpb24gbW9kZWwkMShlbCwgZGlyLCBfd2Fybikge1xyXG4gICAgd2FybiQxID0gX3dhcm47XHJcbiAgICB2YXIgdmFsdWUgPSBkaXIudmFsdWU7XHJcbiAgICB2YXIgbW9kaWZpZXJzID0gZGlyLm1vZGlmaWVycztcclxuICAgIHZhciB0YWcgPSBlbC50YWc7XHJcbiAgICB2YXIgdHlwZSA9IGVsLmF0dHJzTWFwLnR5cGU7XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgIC8vIGlucHV0cyB3aXRoIHR5cGU9XCJmaWxlXCIgYXJlIHJlYWQgb25seSBhbmQgc2V0dGluZyB0aGUgaW5wdXQnc1xyXG4gICAgICAgIC8vIHZhbHVlIHdpbGwgdGhyb3cgYW4gZXJyb3IuXHJcbiAgICAgICAgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAnZmlsZScpIHtcclxuICAgICAgICAgICAgd2FybiQxKFwiPFwiLmNvbmNhdChlbC50YWcsIFwiIHYtbW9kZWw9XFxcIlwiKS5jb25jYXQodmFsdWUsIFwiXFxcIiB0eXBlPVxcXCJmaWxlXFxcIj46XFxuXCIpICtcclxuICAgICAgICAgICAgICAgIFwiRmlsZSBpbnB1dHMgYXJlIHJlYWQgb25seS4gVXNlIGEgdi1vbjpjaGFuZ2UgbGlzdGVuZXIgaW5zdGVhZC5cIiwgZWwucmF3QXR0cnNNYXBbJ3YtbW9kZWwnXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGVsLmNvbXBvbmVudCkge1xyXG4gICAgICAgIGdlbkNvbXBvbmVudE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcclxuICAgICAgICAvLyBjb21wb25lbnQgdi1tb2RlbCBkb2Vzbid0IG5lZWQgZXh0cmEgcnVudGltZVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHRhZyA9PT0gJ3NlbGVjdCcpIHtcclxuICAgICAgICBnZW5TZWxlY3QoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdjaGVja2JveCcpIHtcclxuICAgICAgICBnZW5DaGVja2JveE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAncmFkaW8nKSB7XHJcbiAgICAgICAgZ2VuUmFkaW9Nb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgfHwgdGFnID09PSAndGV4dGFyZWEnKSB7XHJcbiAgICAgICAgZ2VuRGVmYXVsdE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCFjb25maWcuaXNSZXNlcnZlZFRhZyh0YWcpKSB7XHJcbiAgICAgICAgZ2VuQ29tcG9uZW50TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xyXG4gICAgICAgIC8vIGNvbXBvbmVudCB2LW1vZGVsIGRvZXNuJ3QgbmVlZCBleHRyYSBydW50aW1lXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgIHdhcm4kMShcIjxcIi5jb25jYXQoZWwudGFnLCBcIiB2LW1vZGVsPVxcXCJcIikuY29uY2F0KHZhbHVlLCBcIlxcXCI+OiBcIikgK1xyXG4gICAgICAgICAgICBcInYtbW9kZWwgaXMgbm90IHN1cHBvcnRlZCBvbiB0aGlzIGVsZW1lbnQgdHlwZS4gXCIgK1xyXG4gICAgICAgICAgICBcIklmIHlvdSBhcmUgd29ya2luZyB3aXRoIGNvbnRlbnRlZGl0YWJsZSwgaXQncyByZWNvbW1lbmRlZCB0byBcIiArXHJcbiAgICAgICAgICAgICd3cmFwIGEgbGlicmFyeSBkZWRpY2F0ZWQgZm9yIHRoYXQgcHVycG9zZSBpbnNpZGUgYSBjdXN0b20gY29tcG9uZW50LicsIGVsLnJhd0F0dHJzTWFwWyd2LW1vZGVsJ10pO1xyXG4gICAgfVxyXG4gICAgLy8gZW5zdXJlIHJ1bnRpbWUgZGlyZWN0aXZlIG1ldGFkYXRhXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5mdW5jdGlvbiBnZW5DaGVja2JveE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKSB7XHJcbiAgICB2YXIgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XHJcbiAgICB2YXIgdmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd2YWx1ZScpIHx8ICdudWxsJztcclxuICAgIHZhciB0cnVlVmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd0cnVlLXZhbHVlJykgfHwgJ3RydWUnO1xyXG4gICAgdmFyIGZhbHNlVmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdmYWxzZS12YWx1ZScpIHx8ICdmYWxzZSc7XHJcbiAgICBhZGRQcm9wKGVsLCAnY2hlY2tlZCcsIFwiQXJyYXkuaXNBcnJheShcIi5jb25jYXQodmFsdWUsIFwiKVwiKSArXHJcbiAgICAgICAgXCI/X2koXCIuY29uY2F0KHZhbHVlLCBcIixcIikuY29uY2F0KHZhbHVlQmluZGluZywgXCIpPi0xXCIpICtcclxuICAgICAgICAodHJ1ZVZhbHVlQmluZGluZyA9PT0gJ3RydWUnXHJcbiAgICAgICAgICAgID8gXCI6KFwiLmNvbmNhdCh2YWx1ZSwgXCIpXCIpXHJcbiAgICAgICAgICAgIDogXCI6X3EoXCIuY29uY2F0KHZhbHVlLCBcIixcIikuY29uY2F0KHRydWVWYWx1ZUJpbmRpbmcsIFwiKVwiKSkpO1xyXG4gICAgYWRkSGFuZGxlcihlbCwgJ2NoYW5nZScsIFwidmFyICQkYT1cIi5jb25jYXQodmFsdWUsIFwiLFwiKSArXHJcbiAgICAgICAgJyQkZWw9JGV2ZW50LnRhcmdldCwnICtcclxuICAgICAgICBcIiQkYz0kJGVsLmNoZWNrZWQ/KFwiLmNvbmNhdCh0cnVlVmFsdWVCaW5kaW5nLCBcIik6KFwiKS5jb25jYXQoZmFsc2VWYWx1ZUJpbmRpbmcsIFwiKTtcIikgK1xyXG4gICAgICAgICdpZihBcnJheS5pc0FycmF5KCQkYSkpeycgK1xyXG4gICAgICAgIFwidmFyICQkdj1cIi5jb25jYXQobnVtYmVyID8gJ19uKCcgKyB2YWx1ZUJpbmRpbmcgKyAnKScgOiB2YWx1ZUJpbmRpbmcsIFwiLFwiKSArXHJcbiAgICAgICAgJyQkaT1faSgkJGEsJCR2KTsnICtcclxuICAgICAgICBcImlmKCQkZWwuY2hlY2tlZCl7JCRpPDAmJihcIi5jb25jYXQoZ2VuQXNzaWdubWVudENvZGUodmFsdWUsICckJGEuY29uY2F0KFskJHZdKScpLCBcIil9XCIpICtcclxuICAgICAgICBcImVsc2V7JCRpPi0xJiYoXCIuY29uY2F0KGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCAnJCRhLnNsaWNlKDAsJCRpKS5jb25jYXQoJCRhLnNsaWNlKCQkaSsxKSknKSwgXCIpfVwiKSArXHJcbiAgICAgICAgXCJ9ZWxzZXtcIi5jb25jYXQoZ2VuQXNzaWdubWVudENvZGUodmFsdWUsICckJGMnKSwgXCJ9XCIpLCBudWxsLCB0cnVlKTtcclxufVxyXG5mdW5jdGlvbiBnZW5SYWRpb01vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKSB7XHJcbiAgICB2YXIgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XHJcbiAgICB2YXIgdmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd2YWx1ZScpIHx8ICdudWxsJztcclxuICAgIHZhbHVlQmluZGluZyA9IG51bWJlciA/IFwiX24oXCIuY29uY2F0KHZhbHVlQmluZGluZywgXCIpXCIpIDogdmFsdWVCaW5kaW5nO1xyXG4gICAgYWRkUHJvcChlbCwgJ2NoZWNrZWQnLCBcIl9xKFwiLmNvbmNhdCh2YWx1ZSwgXCIsXCIpLmNvbmNhdCh2YWx1ZUJpbmRpbmcsIFwiKVwiKSk7XHJcbiAgICBhZGRIYW5kbGVyKGVsLCAnY2hhbmdlJywgZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlQmluZGluZyksIG51bGwsIHRydWUpO1xyXG59XHJcbmZ1bmN0aW9uIGdlblNlbGVjdChlbCwgdmFsdWUsIG1vZGlmaWVycykge1xyXG4gICAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xyXG4gICAgdmFyIHNlbGVjdGVkVmFsID0gXCJBcnJheS5wcm90b3R5cGUuZmlsdGVyXCIgK1xyXG4gICAgICAgIFwiLmNhbGwoJGV2ZW50LnRhcmdldC5vcHRpb25zLGZ1bmN0aW9uKG8pe3JldHVybiBvLnNlbGVjdGVkfSlcIiArXHJcbiAgICAgICAgXCIubWFwKGZ1bmN0aW9uKG8pe3ZhciB2YWwgPSBcXFwiX3ZhbHVlXFxcIiBpbiBvID8gby5fdmFsdWUgOiBvLnZhbHVlO1wiICtcclxuICAgICAgICBcInJldHVybiBcIi5jb25jYXQobnVtYmVyID8gJ19uKHZhbCknIDogJ3ZhbCcsIFwifSlcIik7XHJcbiAgICB2YXIgYXNzaWdubWVudCA9ICckZXZlbnQudGFyZ2V0Lm11bHRpcGxlID8gJCRzZWxlY3RlZFZhbCA6ICQkc2VsZWN0ZWRWYWxbMF0nO1xyXG4gICAgdmFyIGNvZGUgPSBcInZhciAkJHNlbGVjdGVkVmFsID0gXCIuY29uY2F0KHNlbGVjdGVkVmFsLCBcIjtcIik7XHJcbiAgICBjb2RlID0gXCJcIi5jb25jYXQoY29kZSwgXCIgXCIpLmNvbmNhdChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgYXNzaWdubWVudCkpO1xyXG4gICAgYWRkSGFuZGxlcihlbCwgJ2NoYW5nZScsIGNvZGUsIG51bGwsIHRydWUpO1xyXG59XHJcbmZ1bmN0aW9uIGdlbkRlZmF1bHRNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycykge1xyXG4gICAgdmFyIHR5cGUgPSBlbC5hdHRyc01hcC50eXBlO1xyXG4gICAgLy8gd2FybiBpZiB2LWJpbmQ6dmFsdWUgY29uZmxpY3RzIHdpdGggdi1tb2RlbFxyXG4gICAgLy8gZXhjZXB0IGZvciBpbnB1dHMgd2l0aCB2LWJpbmQ6dHlwZVxyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICB2YXIgdmFsdWVfMSA9IGVsLmF0dHJzTWFwWyd2LWJpbmQ6dmFsdWUnXSB8fCBlbC5hdHRyc01hcFsnOnZhbHVlJ107XHJcbiAgICAgICAgdmFyIHR5cGVCaW5kaW5nID0gZWwuYXR0cnNNYXBbJ3YtYmluZDp0eXBlJ10gfHwgZWwuYXR0cnNNYXBbJzp0eXBlJ107XHJcbiAgICAgICAgaWYgKHZhbHVlXzEgJiYgIXR5cGVCaW5kaW5nKSB7XHJcbiAgICAgICAgICAgIHZhciBiaW5kaW5nID0gZWwuYXR0cnNNYXBbJ3YtYmluZDp2YWx1ZSddID8gJ3YtYmluZDp2YWx1ZScgOiAnOnZhbHVlJztcclxuICAgICAgICAgICAgd2FybiQxKFwiXCIuY29uY2F0KGJpbmRpbmcsIFwiPVxcXCJcIikuY29uY2F0KHZhbHVlXzEsIFwiXFxcIiBjb25mbGljdHMgd2l0aCB2LW1vZGVsIG9uIHRoZSBzYW1lIGVsZW1lbnQgXCIpICtcclxuICAgICAgICAgICAgICAgICdiZWNhdXNlIHRoZSBsYXR0ZXIgYWxyZWFkeSBleHBhbmRzIHRvIGEgdmFsdWUgYmluZGluZyBpbnRlcm5hbGx5JywgZWwucmF3QXR0cnNNYXBbYmluZGluZ10pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHZhciBfYSA9IG1vZGlmaWVycyB8fCB7fSwgbGF6eSA9IF9hLmxhenksIG51bWJlciA9IF9hLm51bWJlciwgdHJpbSA9IF9hLnRyaW07XHJcbiAgICB2YXIgbmVlZENvbXBvc2l0aW9uR3VhcmQgPSAhbGF6eSAmJiB0eXBlICE9PSAncmFuZ2UnO1xyXG4gICAgdmFyIGV2ZW50ID0gbGF6eSA/ICdjaGFuZ2UnIDogdHlwZSA9PT0gJ3JhbmdlJyA/IFJBTkdFX1RPS0VOIDogJ2lucHV0JztcclxuICAgIHZhciB2YWx1ZUV4cHJlc3Npb24gPSAnJGV2ZW50LnRhcmdldC52YWx1ZSc7XHJcbiAgICBpZiAodHJpbSkge1xyXG4gICAgICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiJGV2ZW50LnRhcmdldC52YWx1ZS50cmltKClcIjtcclxuICAgIH1cclxuICAgIGlmIChudW1iZXIpIHtcclxuICAgICAgICB2YWx1ZUV4cHJlc3Npb24gPSBcIl9uKFwiLmNvbmNhdCh2YWx1ZUV4cHJlc3Npb24sIFwiKVwiKTtcclxuICAgIH1cclxuICAgIHZhciBjb2RlID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlRXhwcmVzc2lvbik7XHJcbiAgICBpZiAobmVlZENvbXBvc2l0aW9uR3VhcmQpIHtcclxuICAgICAgICBjb2RlID0gXCJpZigkZXZlbnQudGFyZ2V0LmNvbXBvc2luZylyZXR1cm47XCIuY29uY2F0KGNvZGUpO1xyXG4gICAgfVxyXG4gICAgYWRkUHJvcChlbCwgJ3ZhbHVlJywgXCIoXCIuY29uY2F0KHZhbHVlLCBcIilcIikpO1xyXG4gICAgYWRkSGFuZGxlcihlbCwgZXZlbnQsIGNvZGUsIG51bGwsIHRydWUpO1xyXG4gICAgaWYgKHRyaW0gfHwgbnVtYmVyKSB7XHJcbiAgICAgICAgYWRkSGFuZGxlcihlbCwgJ2JsdXInLCAnJGZvcmNlVXBkYXRlKCknKTtcclxuICAgIH1cclxufVxuXG4vLyBub3JtYWxpemUgdi1tb2RlbCBldmVudCB0b2tlbnMgdGhhdCBjYW4gb25seSBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWUuXHJcbi8vIGl0J3MgaW1wb3J0YW50IHRvIHBsYWNlIHRoZSBldmVudCBhcyB0aGUgZmlyc3QgaW4gdGhlIGFycmF5IGJlY2F1c2VcclxuLy8gdGhlIHdob2xlIHBvaW50IGlzIGVuc3VyaW5nIHRoZSB2LW1vZGVsIGNhbGxiYWNrIGdldHMgY2FsbGVkIGJlZm9yZVxyXG4vLyB1c2VyLWF0dGFjaGVkIGhhbmRsZXJzLlxyXG5mdW5jdGlvbiBub3JtYWxpemVFdmVudHMob24pIHtcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKGlzRGVmKG9uW1JBTkdFX1RPS0VOXSkpIHtcclxuICAgICAgICAvLyBJRSBpbnB1dFt0eXBlPXJhbmdlXSBvbmx5IHN1cHBvcnRzIGBjaGFuZ2VgIGV2ZW50XHJcbiAgICAgICAgdmFyIGV2ZW50XzEgPSBpc0lFID8gJ2NoYW5nZScgOiAnaW5wdXQnO1xyXG4gICAgICAgIG9uW2V2ZW50XzFdID0gW10uY29uY2F0KG9uW1JBTkdFX1RPS0VOXSwgb25bZXZlbnRfMV0gfHwgW10pO1xyXG4gICAgICAgIGRlbGV0ZSBvbltSQU5HRV9UT0tFTl07XHJcbiAgICB9XHJcbiAgICAvLyBUaGlzIHdhcyBvcmlnaW5hbGx5IGludGVuZGVkIHRvIGZpeCAjNDUyMSBidXQgbm8gbG9uZ2VyIG5lY2Vzc2FyeVxyXG4gICAgLy8gYWZ0ZXIgMi41LiBLZWVwaW5nIGl0IGZvciBiYWNrd2FyZHMgY29tcGF0IHdpdGggZ2VuZXJhdGVkIGNvZGUgZnJvbSA8IDIuNFxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICBpZiAoaXNEZWYob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dKSkge1xyXG4gICAgICAgIG9uLmNoYW5nZSA9IFtdLmNvbmNhdChvbltDSEVDS0JPWF9SQURJT19UT0tFTl0sIG9uLmNoYW5nZSB8fCBbXSk7XHJcbiAgICAgICAgZGVsZXRlIG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXTtcclxuICAgIH1cclxufVxyXG52YXIgdGFyZ2V0O1xyXG5mdW5jdGlvbiBjcmVhdGVPbmNlSGFuZGxlcihldmVudCwgaGFuZGxlciwgY2FwdHVyZSkge1xyXG4gICAgdmFyIF90YXJnZXQgPSB0YXJnZXQ7IC8vIHNhdmUgY3VycmVudCB0YXJnZXQgZWxlbWVudCBpbiBjbG9zdXJlXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gb25jZUhhbmRsZXIoKSB7XHJcbiAgICAgICAgdmFyIHJlcyA9IGhhbmRsZXIuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcclxuICAgICAgICBpZiAocmVzICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJlbW92ZShldmVudCwgb25jZUhhbmRsZXIsIGNhcHR1cmUsIF90YXJnZXQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuLy8gIzk0NDY6IEZpcmVmb3ggPD0gNTMgKGluIHBhcnRpY3VsYXIsIEVTUiA1MikgaGFzIGluY29ycmVjdCBFdmVudC50aW1lU3RhbXBcclxuLy8gaW1wbGVtZW50YXRpb24gYW5kIGRvZXMgbm90IGZpcmUgbWljcm90YXNrcyBpbiBiZXR3ZWVuIGV2ZW50IHByb3BhZ2F0aW9uLCBzb1xyXG4vLyBzYWZlIHRvIGV4Y2x1ZGUuXHJcbnZhciB1c2VNaWNyb3Rhc2tGaXggPSBpc1VzaW5nTWljcm9UYXNrICYmICEoaXNGRiAmJiBOdW1iZXIoaXNGRlsxXSkgPD0gNTMpO1xyXG5mdW5jdGlvbiBhZGQobmFtZSwgaGFuZGxlciwgY2FwdHVyZSwgcGFzc2l2ZSkge1xyXG4gICAgLy8gYXN5bmMgZWRnZSBjYXNlICM2NTY2OiBpbm5lciBjbGljayBldmVudCB0cmlnZ2VycyBwYXRjaCwgZXZlbnQgaGFuZGxlclxyXG4gICAgLy8gYXR0YWNoZWQgdG8gb3V0ZXIgZWxlbWVudCBkdXJpbmcgcGF0Y2gsIGFuZCB0cmlnZ2VyZWQgYWdhaW4uIFRoaXNcclxuICAgIC8vIGhhcHBlbnMgYmVjYXVzZSBicm93c2VycyBmaXJlIG1pY3JvdGFzayB0aWNrcyBiZXR3ZWVuIGV2ZW50IHByb3BhZ2F0aW9uLlxyXG4gICAgLy8gdGhlIHNvbHV0aW9uIGlzIHNpbXBsZTogd2Ugc2F2ZSB0aGUgdGltZXN0YW1wIHdoZW4gYSBoYW5kbGVyIGlzIGF0dGFjaGVkLFxyXG4gICAgLy8gYW5kIHRoZSBoYW5kbGVyIHdvdWxkIG9ubHkgZmlyZSBpZiB0aGUgZXZlbnQgcGFzc2VkIHRvIGl0IHdhcyBmaXJlZFxyXG4gICAgLy8gQUZURVIgaXQgd2FzIGF0dGFjaGVkLlxyXG4gICAgaWYgKHVzZU1pY3JvdGFza0ZpeCkge1xyXG4gICAgICAgIHZhciBhdHRhY2hlZFRpbWVzdGFtcF8xID0gY3VycmVudEZsdXNoVGltZXN0YW1wO1xyXG4gICAgICAgIHZhciBvcmlnaW5hbF8xID0gaGFuZGxlcjtcclxuICAgICAgICAvL0B0cy1leHBlY3QtZXJyb3JcclxuICAgICAgICBoYW5kbGVyID0gb3JpZ2luYWxfMS5fd3JhcHBlciA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgLy8gbm8gYnViYmxpbmcsIHNob3VsZCBhbHdheXMgZmlyZS5cclxuICAgICAgICAgICAgLy8gdGhpcyBpcyBqdXN0IGEgc2FmZXR5IG5ldCBpbiBjYXNlIGV2ZW50LnRpbWVTdGFtcCBpcyB1bnJlbGlhYmxlIGluXHJcbiAgICAgICAgICAgIC8vIGNlcnRhaW4gd2VpcmQgZW52aXJvbm1lbnRzLi4uXHJcbiAgICAgICAgICAgIGUudGFyZ2V0ID09PSBlLmN1cnJlbnRUYXJnZXQgfHxcclxuICAgICAgICAgICAgICAgIC8vIGV2ZW50IGlzIGZpcmVkIGFmdGVyIGhhbmRsZXIgYXR0YWNobWVudFxyXG4gICAgICAgICAgICAgICAgZS50aW1lU3RhbXAgPj0gYXR0YWNoZWRUaW1lc3RhbXBfMSB8fFxyXG4gICAgICAgICAgICAgICAgLy8gYmFpbCBmb3IgZW52aXJvbm1lbnRzIHRoYXQgaGF2ZSBidWdneSBldmVudC50aW1lU3RhbXAgaW1wbGVtZW50YXRpb25zXHJcbiAgICAgICAgICAgICAgICAvLyAjOTQ2MiBpT1MgOSBidWc6IGV2ZW50LnRpbWVTdGFtcCBpcyAwIGFmdGVyIGhpc3RvcnkucHVzaFN0YXRlXHJcbiAgICAgICAgICAgICAgICAvLyAjOTY4MSBRdFdlYkVuZ2luZSBldmVudC50aW1lU3RhbXAgaXMgbmVnYXRpdmUgdmFsdWVcclxuICAgICAgICAgICAgICAgIGUudGltZVN0YW1wIDw9IDAgfHxcclxuICAgICAgICAgICAgICAgIC8vICM5NDQ4IGJhaWwgaWYgZXZlbnQgaXMgZmlyZWQgaW4gYW5vdGhlciBkb2N1bWVudCBpbiBhIG11bHRpLXBhZ2VcclxuICAgICAgICAgICAgICAgIC8vIGVsZWN0cm9uL253LmpzIGFwcCwgc2luY2UgZXZlbnQudGltZVN0YW1wIHdpbGwgYmUgdXNpbmcgYSBkaWZmZXJlbnRcclxuICAgICAgICAgICAgICAgIC8vIHN0YXJ0aW5nIHJlZmVyZW5jZVxyXG4gICAgICAgICAgICAgICAgZS50YXJnZXQub3duZXJEb2N1bWVudCAhPT0gZG9jdW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbF8xLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlciwgc3VwcG9ydHNQYXNzaXZlID8geyBjYXB0dXJlOiBjYXB0dXJlLCBwYXNzaXZlOiBwYXNzaXZlIH0gOiBjYXB0dXJlKTtcclxufVxyXG5mdW5jdGlvbiByZW1vdmUobmFtZSwgaGFuZGxlciwgY2FwdHVyZSwgX3RhcmdldCkge1xyXG4gICAgKF90YXJnZXQgfHwgdGFyZ2V0KS5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIFxyXG4gICAgLy9AdHMtZXhwZWN0LWVycm9yXHJcbiAgICBoYW5kbGVyLl93cmFwcGVyIHx8IGhhbmRsZXIsIGNhcHR1cmUpO1xyXG59XHJcbmZ1bmN0aW9uIHVwZGF0ZURPTUxpc3RlbmVycyhvbGRWbm9kZSwgdm5vZGUpIHtcclxuICAgIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEub24pICYmIGlzVW5kZWYodm5vZGUuZGF0YS5vbikpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB2YXIgb24gPSB2bm9kZS5kYXRhLm9uIHx8IHt9O1xyXG4gICAgdmFyIG9sZE9uID0gb2xkVm5vZGUuZGF0YS5vbiB8fCB7fTtcclxuICAgIC8vIHZub2RlIGlzIGVtcHR5IHdoZW4gcmVtb3ZpbmcgYWxsIGxpc3RlbmVycyxcclxuICAgIC8vIGFuZCB1c2Ugb2xkIHZub2RlIGRvbSBlbGVtZW50XHJcbiAgICB0YXJnZXQgPSB2bm9kZS5lbG0gfHwgb2xkVm5vZGUuZWxtO1xyXG4gICAgbm9ybWFsaXplRXZlbnRzKG9uKTtcclxuICAgIHVwZGF0ZUxpc3RlbmVycyhvbiwgb2xkT24sIGFkZCwgcmVtb3ZlLCBjcmVhdGVPbmNlSGFuZGxlciwgdm5vZGUuY29udGV4dCk7XHJcbiAgICB0YXJnZXQgPSB1bmRlZmluZWQ7XHJcbn1cclxudmFyIGV2ZW50cyA9IHtcclxuICAgIGNyZWF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzLFxyXG4gICAgdXBkYXRlOiB1cGRhdGVET01MaXN0ZW5lcnMsXHJcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGVtcHR5Tm9kZSBoYXMgYWN0dWFsbHkgZGF0YVxyXG4gICAgZGVzdHJveTogZnVuY3Rpb24gKHZub2RlKSB7IHJldHVybiB1cGRhdGVET01MaXN0ZW5lcnModm5vZGUsIGVtcHR5Tm9kZSk7IH1cclxufTtcblxudmFyIHN2Z0NvbnRhaW5lcjtcclxuZnVuY3Rpb24gdXBkYXRlRE9NUHJvcHMob2xkVm5vZGUsIHZub2RlKSB7XHJcbiAgICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLmRvbVByb3BzKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEuZG9tUHJvcHMpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdmFyIGtleSwgY3VyO1xyXG4gICAgdmFyIGVsbSA9IHZub2RlLmVsbTtcclxuICAgIHZhciBvbGRQcm9wcyA9IG9sZFZub2RlLmRhdGEuZG9tUHJvcHMgfHwge307XHJcbiAgICB2YXIgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xyXG4gICAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XHJcbiAgICBpZiAoaXNEZWYocHJvcHMuX19vYl9fKSB8fCBpc1RydWUocHJvcHMuX3ZfYXR0cl9wcm94eSkpIHtcclxuICAgICAgICBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgPSBleHRlbmQoe30sIHByb3BzKTtcclxuICAgIH1cclxuICAgIGZvciAoa2V5IGluIG9sZFByb3BzKSB7XHJcbiAgICAgICAgaWYgKCEoa2V5IGluIHByb3BzKSkge1xyXG4gICAgICAgICAgICBlbG1ba2V5XSA9ICcnO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZvciAoa2V5IGluIHByb3BzKSB7XHJcbiAgICAgICAgY3VyID0gcHJvcHNba2V5XTtcclxuICAgICAgICAvLyBpZ25vcmUgY2hpbGRyZW4gaWYgdGhlIG5vZGUgaGFzIHRleHRDb250ZW50IG9yIGlubmVySFRNTCxcclxuICAgICAgICAvLyBhcyB0aGVzZSB3aWxsIHRocm93IGF3YXkgZXhpc3RpbmcgRE9NIG5vZGVzIGFuZCBjYXVzZSByZW1vdmFsIGVycm9yc1xyXG4gICAgICAgIC8vIG9uIHN1YnNlcXVlbnQgcGF0Y2hlcyAoIzMzNjApXHJcbiAgICAgICAgaWYgKGtleSA9PT0gJ3RleHRDb250ZW50JyB8fCBrZXkgPT09ICdpbm5lckhUTUwnKSB7XHJcbiAgICAgICAgICAgIGlmICh2bm9kZS5jaGlsZHJlbilcclxuICAgICAgICAgICAgICAgIHZub2RlLmNoaWxkcmVuLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIGlmIChjdXIgPT09IG9sZFByb3BzW2tleV0pXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgLy8gIzY2MDEgd29yayBhcm91bmQgQ2hyb21lIHZlcnNpb24gPD0gNTUgYnVnIHdoZXJlIHNpbmdsZSB0ZXh0Tm9kZVxyXG4gICAgICAgICAgICAvLyByZXBsYWNlZCBieSBpbm5lckhUTUwvdGV4dENvbnRlbnQgcmV0YWlucyBpdHMgcGFyZW50Tm9kZSBwcm9wZXJ0eVxyXG4gICAgICAgICAgICBpZiAoZWxtLmNoaWxkTm9kZXMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICBlbG0ucmVtb3ZlQ2hpbGQoZWxtLmNoaWxkTm9kZXNbMF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChrZXkgPT09ICd2YWx1ZScgJiYgZWxtLnRhZ05hbWUgIT09ICdQUk9HUkVTUycpIHtcclxuICAgICAgICAgICAgLy8gc3RvcmUgdmFsdWUgYXMgX3ZhbHVlIGFzIHdlbGwgc2luY2VcclxuICAgICAgICAgICAgLy8gbm9uLXN0cmluZyB2YWx1ZXMgd2lsbCBiZSBzdHJpbmdpZmllZFxyXG4gICAgICAgICAgICBlbG0uX3ZhbHVlID0gY3VyO1xyXG4gICAgICAgICAgICAvLyBhdm9pZCByZXNldHRpbmcgY3Vyc29yIHBvc2l0aW9uIHdoZW4gdmFsdWUgaXMgdGhlIHNhbWVcclxuICAgICAgICAgICAgdmFyIHN0ckN1ciA9IGlzVW5kZWYoY3VyKSA/ICcnIDogU3RyaW5nKGN1cik7XHJcbiAgICAgICAgICAgIGlmIChzaG91bGRVcGRhdGVWYWx1ZShlbG0sIHN0ckN1cikpIHtcclxuICAgICAgICAgICAgICAgIGVsbS52YWx1ZSA9IHN0ckN1cjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChrZXkgPT09ICdpbm5lckhUTUwnICYmXHJcbiAgICAgICAgICAgIGlzU1ZHKGVsbS50YWdOYW1lKSAmJlxyXG4gICAgICAgICAgICBpc1VuZGVmKGVsbS5pbm5lckhUTUwpKSB7XHJcbiAgICAgICAgICAgIC8vIElFIGRvZXNuJ3Qgc3VwcG9ydCBpbm5lckhUTUwgZm9yIFNWRyBlbGVtZW50c1xyXG4gICAgICAgICAgICBzdmdDb250YWluZXIgPSBzdmdDb250YWluZXIgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgICAgIHN2Z0NvbnRhaW5lci5pbm5lckhUTUwgPSBcIjxzdmc+XCIuY29uY2F0KGN1ciwgXCI8L3N2Zz5cIik7XHJcbiAgICAgICAgICAgIHZhciBzdmcgPSBzdmdDb250YWluZXIuZmlyc3RDaGlsZDtcclxuICAgICAgICAgICAgd2hpbGUgKGVsbS5maXJzdENoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICBlbG0ucmVtb3ZlQ2hpbGQoZWxtLmZpcnN0Q2hpbGQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHdoaWxlIChzdmcuZmlyc3RDaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgZWxtLmFwcGVuZENoaWxkKHN2Zy5maXJzdENoaWxkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChcclxuICAgICAgICAvLyBza2lwIHRoZSB1cGRhdGUgaWYgb2xkIGFuZCBuZXcgVkRPTSBzdGF0ZSBpcyB0aGUgc2FtZS5cclxuICAgICAgICAvLyBgdmFsdWVgIGlzIGhhbmRsZWQgc2VwYXJhdGVseSBiZWNhdXNlIHRoZSBET00gdmFsdWUgbWF5IGJlIHRlbXBvcmFyaWx5XHJcbiAgICAgICAgLy8gb3V0IG9mIHN5bmMgd2l0aCBWRE9NIHN0YXRlIGR1ZSB0byBmb2N1cywgY29tcG9zaXRpb24gYW5kIG1vZGlmaWVycy5cclxuICAgICAgICAvLyBUaGlzICAjNDUyMSBieSBza2lwcGluZyB0aGUgdW5uZWNlc3NhcnkgYGNoZWNrZWRgIHVwZGF0ZS5cclxuICAgICAgICBjdXIgIT09IG9sZFByb3BzW2tleV0pIHtcclxuICAgICAgICAgICAgLy8gc29tZSBwcm9wZXJ0eSB1cGRhdGVzIGNhbiB0aHJvd1xyXG4gICAgICAgICAgICAvLyBlLmcuIGB2YWx1ZWAgb24gPHByb2dyZXNzPiB3LyBub24tZmluaXRlIHZhbHVlXHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBlbG1ba2V5XSA9IGN1cjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkgeyB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHNob3VsZFVwZGF0ZVZhbHVlKGVsbSwgY2hlY2tWYWwpIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAvL0B0cy1leHBlY3QtZXJyb3JcclxuICAgICFlbG0uY29tcG9zaW5nICYmXHJcbiAgICAgICAgKGVsbS50YWdOYW1lID09PSAnT1BUSU9OJyB8fFxyXG4gICAgICAgICAgICBpc05vdEluRm9jdXNBbmREaXJ0eShlbG0sIGNoZWNrVmFsKSB8fFxyXG4gICAgICAgICAgICBpc0RpcnR5V2l0aE1vZGlmaWVycyhlbG0sIGNoZWNrVmFsKSkpO1xyXG59XHJcbmZ1bmN0aW9uIGlzTm90SW5Gb2N1c0FuZERpcnR5KGVsbSwgY2hlY2tWYWwpIHtcclxuICAgIC8vIHJldHVybiB0cnVlIHdoZW4gdGV4dGJveCAoLm51bWJlciBhbmQgLnRyaW0pIGxvc2VzIGZvY3VzIGFuZCBpdHMgdmFsdWUgaXNcclxuICAgIC8vIG5vdCBlcXVhbCB0byB0aGUgdXBkYXRlZCB2YWx1ZVxyXG4gICAgdmFyIG5vdEluRm9jdXMgPSB0cnVlO1xyXG4gICAgLy8gIzYxNTdcclxuICAgIC8vIHdvcmsgYXJvdW5kIElFIGJ1ZyB3aGVuIGFjY2Vzc2luZyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGluIGFuIGlmcmFtZVxyXG4gICAgdHJ5IHtcclxuICAgICAgICBub3RJbkZvY3VzID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gZWxtO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHsgfVxyXG4gICAgcmV0dXJuIG5vdEluRm9jdXMgJiYgZWxtLnZhbHVlICE9PSBjaGVja1ZhbDtcclxufVxyXG5mdW5jdGlvbiBpc0RpcnR5V2l0aE1vZGlmaWVycyhlbG0sIG5ld1ZhbCkge1xyXG4gICAgdmFyIHZhbHVlID0gZWxtLnZhbHVlO1xyXG4gICAgdmFyIG1vZGlmaWVycyA9IGVsbS5fdk1vZGlmaWVyczsgLy8gaW5qZWN0ZWQgYnkgdi1tb2RlbCBydW50aW1lXHJcbiAgICBpZiAoaXNEZWYobW9kaWZpZXJzKSkge1xyXG4gICAgICAgIGlmIChtb2RpZmllcnMubnVtYmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0b051bWJlcih2YWx1ZSkgIT09IHRvTnVtYmVyKG5ld1ZhbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtb2RpZmllcnMudHJpbSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudHJpbSgpICE9PSBuZXdWYWwudHJpbSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB2YWx1ZSAhPT0gbmV3VmFsO1xyXG59XHJcbnZhciBkb21Qcm9wcyA9IHtcclxuICAgIGNyZWF0ZTogdXBkYXRlRE9NUHJvcHMsXHJcbiAgICB1cGRhdGU6IHVwZGF0ZURPTVByb3BzXHJcbn07XG5cbnZhciBwYXJzZVN0eWxlVGV4dCA9IGNhY2hlZChmdW5jdGlvbiAoY3NzVGV4dCkge1xyXG4gICAgdmFyIHJlcyA9IHt9O1xyXG4gICAgdmFyIGxpc3REZWxpbWl0ZXIgPSAvOyg/IVteKF0qXFwpKS9nO1xyXG4gICAgdmFyIHByb3BlcnR5RGVsaW1pdGVyID0gLzooLispLztcclxuICAgIGNzc1RleHQuc3BsaXQobGlzdERlbGltaXRlcikuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgIGlmIChpdGVtKSB7XHJcbiAgICAgICAgICAgIHZhciB0bXAgPSBpdGVtLnNwbGl0KHByb3BlcnR5RGVsaW1pdGVyKTtcclxuICAgICAgICAgICAgdG1wLmxlbmd0aCA+IDEgJiYgKHJlc1t0bXBbMF0udHJpbSgpXSA9IHRtcFsxXS50cmltKCkpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlcztcclxufSk7XHJcbi8vIG1lcmdlIHN0YXRpYyBhbmQgZHluYW1pYyBzdHlsZSBkYXRhIG9uIHRoZSBzYW1lIHZub2RlXHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlRGF0YShkYXRhKSB7XHJcbiAgICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcoZGF0YS5zdHlsZSk7XHJcbiAgICAvLyBzdGF0aWMgc3R5bGUgaXMgcHJlLXByb2Nlc3NlZCBpbnRvIGFuIG9iamVjdCBkdXJpbmcgY29tcGlsYXRpb25cclxuICAgIC8vIGFuZCBpcyBhbHdheXMgYSBmcmVzaCBvYmplY3QsIHNvIGl0J3Mgc2FmZSB0byBtZXJnZSBpbnRvIGl0XHJcbiAgICByZXR1cm4gZGF0YS5zdGF0aWNTdHlsZSA/IGV4dGVuZChkYXRhLnN0YXRpY1N0eWxlLCBzdHlsZSkgOiBzdHlsZTtcclxufVxyXG4vLyBub3JtYWxpemUgcG9zc2libGUgYXJyYXkgLyBzdHJpbmcgdmFsdWVzIGludG8gT2JqZWN0XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlQmluZGluZyhiaW5kaW5nU3R5bGUpIHtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KGJpbmRpbmdTdHlsZSkpIHtcclxuICAgICAgICByZXR1cm4gdG9PYmplY3QoYmluZGluZ1N0eWxlKTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgYmluZGluZ1N0eWxlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHJldHVybiBwYXJzZVN0eWxlVGV4dChiaW5kaW5nU3R5bGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGJpbmRpbmdTdHlsZTtcclxufVxyXG4vKipcclxuICogcGFyZW50IGNvbXBvbmVudCBzdHlsZSBzaG91bGQgYmUgYWZ0ZXIgY2hpbGQnc1xyXG4gKiBzbyB0aGF0IHBhcmVudCBjb21wb25lbnQncyBzdHlsZSBjb3VsZCBvdmVycmlkZSBpdFxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0U3R5bGUodm5vZGUsIGNoZWNrQ2hpbGQpIHtcclxuICAgIHZhciByZXMgPSB7fTtcclxuICAgIHZhciBzdHlsZURhdGE7XHJcbiAgICBpZiAoY2hlY2tDaGlsZCkge1xyXG4gICAgICAgIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcclxuICAgICAgICB3aGlsZSAoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGUgJiZcclxuICAgICAgICAgICAgICAgIGNoaWxkTm9kZS5kYXRhICYmXHJcbiAgICAgICAgICAgICAgICAoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKGNoaWxkTm9kZS5kYXRhKSkpIHtcclxuICAgICAgICAgICAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YSh2bm9kZS5kYXRhKSkpIHtcclxuICAgICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xyXG4gICAgfVxyXG4gICAgdmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcclxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgcGFyZW50Tm9kZS5wYXJlbnQgbm90IFZOb2RlV2l0aERhdGFcclxuICAgIHdoaWxlICgocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50KSkge1xyXG4gICAgICAgIGlmIChwYXJlbnROb2RlLmRhdGEgJiYgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShwYXJlbnROb2RlLmRhdGEpKSkge1xyXG4gICAgICAgICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXM7XHJcbn1cblxudmFyIGNzc1ZhclJFID0gL14tLS87XHJcbnZhciBpbXBvcnRhbnRSRSA9IC9cXHMqIWltcG9ydGFudCQvO1xyXG52YXIgc2V0UHJvcCA9IGZ1bmN0aW9uIChlbCwgbmFtZSwgdmFsKSB7XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIGlmIChjc3NWYXJSRS50ZXN0KG5hbWUpKSB7XHJcbiAgICAgICAgZWwuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGltcG9ydGFudFJFLnRlc3QodmFsKSkge1xyXG4gICAgICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KGh5cGhlbmF0ZShuYW1lKSwgdmFsLnJlcGxhY2UoaW1wb3J0YW50UkUsICcnKSwgJ2ltcG9ydGFudCcpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWROYW1lID0gbm9ybWFsaXplKG5hbWUpO1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcclxuICAgICAgICAgICAgLy8gU3VwcG9ydCB2YWx1ZXMgYXJyYXkgY3JlYXRlZCBieSBhdXRvcHJlZml4ZXIsIGUuZy5cclxuICAgICAgICAgICAgLy8ge2Rpc3BsYXk6IFtcIi13ZWJraXQtYm94XCIsIFwiLW1zLWZsZXhib3hcIiwgXCJmbGV4XCJdfVxyXG4gICAgICAgICAgICAvLyBTZXQgdGhlbSBvbmUgYnkgb25lLCBhbmQgdGhlIGJyb3dzZXIgd2lsbCBvbmx5IHNldCB0aG9zZSBpdCBjYW4gcmVjb2duaXplXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB2YWwubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGVsLnN0eWxlW25vcm1hbGl6ZWROYW1lXSA9IHZhbFtpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZWwuc3R5bGVbbm9ybWFsaXplZE5hbWVdID0gdmFsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxudmFyIHZlbmRvck5hbWVzID0gWydXZWJraXQnLCAnTW96JywgJ21zJ107XHJcbnZhciBlbXB0eVN0eWxlO1xyXG52YXIgbm9ybWFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChwcm9wKSB7XHJcbiAgICBlbXB0eVN0eWxlID0gZW1wdHlTdHlsZSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5zdHlsZTtcclxuICAgIHByb3AgPSBjYW1lbGl6ZShwcm9wKTtcclxuICAgIGlmIChwcm9wICE9PSAnZmlsdGVyJyAmJiBwcm9wIGluIGVtcHR5U3R5bGUpIHtcclxuICAgICAgICByZXR1cm4gcHJvcDtcclxuICAgIH1cclxuICAgIHZhciBjYXBOYW1lID0gcHJvcC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3Auc2xpY2UoMSk7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlbmRvck5hbWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIG5hbWVfMSA9IHZlbmRvck5hbWVzW2ldICsgY2FwTmFtZTtcclxuICAgICAgICBpZiAobmFtZV8xIGluIGVtcHR5U3R5bGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5hbWVfMTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0pO1xyXG5mdW5jdGlvbiB1cGRhdGVTdHlsZShvbGRWbm9kZSwgdm5vZGUpIHtcclxuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcclxuICAgIHZhciBvbGREYXRhID0gb2xkVm5vZGUuZGF0YTtcclxuICAgIGlmIChpc1VuZGVmKGRhdGEuc3RhdGljU3R5bGUpICYmXHJcbiAgICAgICAgaXNVbmRlZihkYXRhLnN0eWxlKSAmJlxyXG4gICAgICAgIGlzVW5kZWYob2xkRGF0YS5zdGF0aWNTdHlsZSkgJiZcclxuICAgICAgICBpc1VuZGVmKG9sZERhdGEuc3R5bGUpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdmFyIGN1ciwgbmFtZTtcclxuICAgIHZhciBlbCA9IHZub2RlLmVsbTtcclxuICAgIHZhciBvbGRTdGF0aWNTdHlsZSA9IG9sZERhdGEuc3RhdGljU3R5bGU7XHJcbiAgICB2YXIgb2xkU3R5bGVCaW5kaW5nID0gb2xkRGF0YS5ub3JtYWxpemVkU3R5bGUgfHwgb2xkRGF0YS5zdHlsZSB8fCB7fTtcclxuICAgIC8vIGlmIHN0YXRpYyBzdHlsZSBleGlzdHMsIHN0eWxlYmluZGluZyBhbHJlYWR5IG1lcmdlZCBpbnRvIGl0IHdoZW4gZG9pbmcgbm9ybWFsaXplU3R5bGVEYXRhXHJcbiAgICB2YXIgb2xkU3R5bGUgPSBvbGRTdGF0aWNTdHlsZSB8fCBvbGRTdHlsZUJpbmRpbmc7XHJcbiAgICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcodm5vZGUuZGF0YS5zdHlsZSkgfHwge307XHJcbiAgICAvLyBzdG9yZSBub3JtYWxpemVkIHN0eWxlIHVuZGVyIGEgZGlmZmVyZW50IGtleSBmb3IgbmV4dCBkaWZmXHJcbiAgICAvLyBtYWtlIHN1cmUgdG8gY2xvbmUgaXQgaWYgaXQncyByZWFjdGl2ZSwgc2luY2UgdGhlIHVzZXIgbGlrZWx5IHdhbnRzXHJcbiAgICAvLyB0byBtdXRhdGUgaXQuXHJcbiAgICB2bm9kZS5kYXRhLm5vcm1hbGl6ZWRTdHlsZSA9IGlzRGVmKHN0eWxlLl9fb2JfXykgPyBleHRlbmQoe30sIHN0eWxlKSA6IHN0eWxlO1xyXG4gICAgdmFyIG5ld1N0eWxlID0gZ2V0U3R5bGUodm5vZGUsIHRydWUpO1xyXG4gICAgZm9yIChuYW1lIGluIG9sZFN0eWxlKSB7XHJcbiAgICAgICAgaWYgKGlzVW5kZWYobmV3U3R5bGVbbmFtZV0pKSB7XHJcbiAgICAgICAgICAgIHNldFByb3AoZWwsIG5hbWUsICcnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmb3IgKG5hbWUgaW4gbmV3U3R5bGUpIHtcclxuICAgICAgICBjdXIgPSBuZXdTdHlsZVtuYW1lXTtcclxuICAgICAgICBpZiAoY3VyICE9PSBvbGRTdHlsZVtuYW1lXSkge1xyXG4gICAgICAgICAgICAvLyBpZTkgc2V0dGluZyB0byBudWxsIGhhcyBubyBlZmZlY3QsIG11c3QgdXNlIGVtcHR5IHN0cmluZ1xyXG4gICAgICAgICAgICBzZXRQcm9wKGVsLCBuYW1lLCBjdXIgPT0gbnVsbCA/ICcnIDogY3VyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxudmFyIHN0eWxlJDEgPSB7XHJcbiAgICBjcmVhdGU6IHVwZGF0ZVN0eWxlLFxyXG4gICAgdXBkYXRlOiB1cGRhdGVTdHlsZVxyXG59O1xuXG52YXIgd2hpdGVzcGFjZVJFJDEgPSAvXFxzKy87XHJcbi8qKlxyXG4gKiBBZGQgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBTVkcgc2luY2UgY2xhc3NMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgb25cclxuICogU1ZHIGVsZW1lbnRzIGluIElFXHJcbiAqL1xyXG5mdW5jdGlvbiBhZGRDbGFzcyhlbCwgY2xzKSB7XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIGlmICghY2xzIHx8ICEoY2xzID0gY2xzLnRyaW0oKSkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xyXG4gICAgaWYgKGVsLmNsYXNzTGlzdCkge1xyXG4gICAgICAgIGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcclxuICAgICAgICAgICAgY2xzLnNwbGl0KHdoaXRlc3BhY2VSRSQxKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IHJldHVybiBlbC5jbGFzc0xpc3QuYWRkKGMpOyB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB2YXIgY3VyID0gXCIgXCIuY29uY2F0KGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJywgXCIgXCIpO1xyXG4gICAgICAgIGlmIChjdXIuaW5kZXhPZignICcgKyBjbHMgKyAnICcpIDwgMCkge1xyXG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgKGN1ciArIGNscykudHJpbSgpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJlbW92ZSBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxyXG4gKiBTVkcgZWxlbWVudHMgaW4gSUVcclxuICovXHJcbmZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsLCBjbHMpIHtcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXHJcbiAgICBpZiAoZWwuY2xhc3NMaXN0KSB7XHJcbiAgICAgICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xyXG4gICAgICAgICAgICBjbHMuc3BsaXQod2hpdGVzcGFjZVJFJDEpLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGVsLmNsYXNzTGlzdC5yZW1vdmUoYyk7IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShjbHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWVsLmNsYXNzTGlzdC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhciBjdXIgPSBcIiBcIi5jb25jYXQoZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnLCBcIiBcIik7XHJcbiAgICAgICAgdmFyIHRhciA9ICcgJyArIGNscyArICcgJztcclxuICAgICAgICB3aGlsZSAoY3VyLmluZGV4T2YodGFyKSA+PSAwKSB7XHJcbiAgICAgICAgICAgIGN1ciA9IGN1ci5yZXBsYWNlKHRhciwgJyAnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3VyID0gY3VyLnRyaW0oKTtcclxuICAgICAgICBpZiAoY3VyKSB7XHJcbiAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjdXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxuXG5mdW5jdGlvbiByZXNvbHZlVHJhbnNpdGlvbihkZWYpIHtcclxuICAgIGlmICghZGVmKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cclxuICAgIGlmICh0eXBlb2YgZGVmID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIHZhciByZXMgPSB7fTtcclxuICAgICAgICBpZiAoZGVmLmNzcyAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgZXh0ZW5kKHJlcywgYXV0b0Nzc1RyYW5zaXRpb24oZGVmLm5hbWUgfHwgJ3YnKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGV4dGVuZChyZXMsIGRlZik7XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBkZWYgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgcmV0dXJuIGF1dG9Dc3NUcmFuc2l0aW9uKGRlZik7XHJcbiAgICB9XHJcbn1cclxudmFyIGF1dG9Dc3NUcmFuc2l0aW9uID0gY2FjaGVkKGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGVudGVyQ2xhc3M6IFwiXCIuY29uY2F0KG5hbWUsIFwiLWVudGVyXCIpLFxyXG4gICAgICAgIGVudGVyVG9DbGFzczogXCJcIi5jb25jYXQobmFtZSwgXCItZW50ZXItdG9cIiksXHJcbiAgICAgICAgZW50ZXJBY3RpdmVDbGFzczogXCJcIi5jb25jYXQobmFtZSwgXCItZW50ZXItYWN0aXZlXCIpLFxyXG4gICAgICAgIGxlYXZlQ2xhc3M6IFwiXCIuY29uY2F0KG5hbWUsIFwiLWxlYXZlXCIpLFxyXG4gICAgICAgIGxlYXZlVG9DbGFzczogXCJcIi5jb25jYXQobmFtZSwgXCItbGVhdmUtdG9cIiksXHJcbiAgICAgICAgbGVhdmVBY3RpdmVDbGFzczogXCJcIi5jb25jYXQobmFtZSwgXCItbGVhdmUtYWN0aXZlXCIpXHJcbiAgICB9O1xyXG59KTtcclxudmFyIGhhc1RyYW5zaXRpb24gPSBpbkJyb3dzZXIgJiYgIWlzSUU5O1xyXG52YXIgVFJBTlNJVElPTiA9ICd0cmFuc2l0aW9uJztcclxudmFyIEFOSU1BVElPTiA9ICdhbmltYXRpb24nO1xyXG4vLyBUcmFuc2l0aW9uIHByb3BlcnR5L2V2ZW50IHNuaWZmaW5nXHJcbnZhciB0cmFuc2l0aW9uUHJvcCA9ICd0cmFuc2l0aW9uJztcclxudmFyIHRyYW5zaXRpb25FbmRFdmVudCA9ICd0cmFuc2l0aW9uZW5kJztcclxudmFyIGFuaW1hdGlvblByb3AgPSAnYW5pbWF0aW9uJztcclxudmFyIGFuaW1hdGlvbkVuZEV2ZW50ID0gJ2FuaW1hdGlvbmVuZCc7XHJcbmlmIChoYXNUcmFuc2l0aW9uKSB7XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIGlmICh3aW5kb3cub250cmFuc2l0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcclxuICAgICAgICB3aW5kb3cub253ZWJraXR0cmFuc2l0aW9uZW5kICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICB0cmFuc2l0aW9uUHJvcCA9ICdXZWJraXRUcmFuc2l0aW9uJztcclxuICAgICAgICB0cmFuc2l0aW9uRW5kRXZlbnQgPSAnd2Via2l0VHJhbnNpdGlvbkVuZCc7XHJcbiAgICB9XHJcbiAgICBpZiAod2luZG93Lm9uYW5pbWF0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcclxuICAgICAgICB3aW5kb3cub253ZWJraXRhbmltYXRpb25lbmQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGFuaW1hdGlvblByb3AgPSAnV2Via2l0QW5pbWF0aW9uJztcclxuICAgICAgICBhbmltYXRpb25FbmRFdmVudCA9ICd3ZWJraXRBbmltYXRpb25FbmQnO1xyXG4gICAgfVxyXG59XHJcbi8vIGJpbmRpbmcgdG8gd2luZG93IGlzIG5lY2Vzc2FyeSB0byBtYWtlIGhvdCByZWxvYWQgd29yayBpbiBJRSBpbiBzdHJpY3QgbW9kZVxyXG52YXIgcmFmID0gaW5Ccm93c2VyXHJcbiAgICA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcclxuICAgICAgICA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpXHJcbiAgICAgICAgOiBzZXRUaW1lb3V0XHJcbiAgICA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZ1bmN0aW9uICgvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBmbikgeyByZXR1cm4gZm4oKTsgfTtcclxuZnVuY3Rpb24gbmV4dEZyYW1lKGZuKSB7XHJcbiAgICByYWYoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgICAgICByYWYoZm4pO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBjbHMpIHtcclxuICAgIHZhciB0cmFuc2l0aW9uQ2xhc3NlcyA9IGVsLl90cmFuc2l0aW9uQ2xhc3NlcyB8fCAoZWwuX3RyYW5zaXRpb25DbGFzc2VzID0gW10pO1xyXG4gICAgaWYgKHRyYW5zaXRpb25DbGFzc2VzLmluZGV4T2YoY2xzKSA8IDApIHtcclxuICAgICAgICB0cmFuc2l0aW9uQ2xhc3Nlcy5wdXNoKGNscyk7XHJcbiAgICAgICAgYWRkQ2xhc3MoZWwsIGNscyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBjbHMpIHtcclxuICAgIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcclxuICAgICAgICByZW1vdmUkMihlbC5fdHJhbnNpdGlvbkNsYXNzZXMsIGNscyk7XHJcbiAgICB9XHJcbiAgICByZW1vdmVDbGFzcyhlbCwgY2xzKTtcclxufVxyXG5mdW5jdGlvbiB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIGV4cGVjdGVkVHlwZSwgY2IpIHtcclxuICAgIHZhciBfYSA9IGdldFRyYW5zaXRpb25JbmZvKGVsLCBleHBlY3RlZFR5cGUpLCB0eXBlID0gX2EudHlwZSwgdGltZW91dCA9IF9hLnRpbWVvdXQsIHByb3BDb3VudCA9IF9hLnByb3BDb3VudDtcclxuICAgIGlmICghdHlwZSlcclxuICAgICAgICByZXR1cm4gY2IoKTtcclxuICAgIHZhciBldmVudCA9IHR5cGUgPT09IFRSQU5TSVRJT04gPyB0cmFuc2l0aW9uRW5kRXZlbnQgOiBhbmltYXRpb25FbmRFdmVudDtcclxuICAgIHZhciBlbmRlZCA9IDA7XHJcbiAgICB2YXIgZW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uRW5kKTtcclxuICAgICAgICBjYigpO1xyXG4gICAgfTtcclxuICAgIHZhciBvbkVuZCA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgaWYgKGUudGFyZ2V0ID09PSBlbCkge1xyXG4gICAgICAgICAgICBpZiAoKytlbmRlZCA+PSBwcm9wQ291bnQpIHtcclxuICAgICAgICAgICAgICAgIGVuZCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChlbmRlZCA8IHByb3BDb3VudCkge1xyXG4gICAgICAgICAgICBlbmQoKTtcclxuICAgICAgICB9XHJcbiAgICB9LCB0aW1lb3V0ICsgMSk7XHJcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBvbkVuZCk7XHJcbn1cclxudmFyIHRyYW5zZm9ybVJFID0gL1xcYih0cmFuc2Zvcm18YWxsKSgsfCQpLztcclxuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSkge1xyXG4gICAgdmFyIHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcclxuICAgIC8vIEpTRE9NIG1heSByZXR1cm4gdW5kZWZpbmVkIGZvciB0cmFuc2l0aW9uIHByb3BlcnRpZXNcclxuICAgIHZhciB0cmFuc2l0aW9uRGVsYXlzID0gKHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEZWxheSddIHx8ICcnKS5zcGxpdCgnLCAnKTtcclxuICAgIHZhciB0cmFuc2l0aW9uRHVyYXRpb25zID0gKHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEdXJhdGlvbiddIHx8ICcnKS5zcGxpdCgnLCAnKTtcclxuICAgIHZhciB0cmFuc2l0aW9uVGltZW91dCA9IGdldFRpbWVvdXQodHJhbnNpdGlvbkRlbGF5cywgdHJhbnNpdGlvbkR1cmF0aW9ucyk7XHJcbiAgICB2YXIgYW5pbWF0aW9uRGVsYXlzID0gKHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0RlbGF5J10gfHwgJycpLnNwbGl0KCcsICcpO1xyXG4gICAgdmFyIGFuaW1hdGlvbkR1cmF0aW9ucyA9IChzdHlsZXNbYW5pbWF0aW9uUHJvcCArICdEdXJhdGlvbiddIHx8ICcnKS5zcGxpdCgnLCAnKTtcclxuICAgIHZhciBhbmltYXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dChhbmltYXRpb25EZWxheXMsIGFuaW1hdGlvbkR1cmF0aW9ucyk7XHJcbiAgICB2YXIgdHlwZTtcclxuICAgIHZhciB0aW1lb3V0ID0gMDtcclxuICAgIHZhciBwcm9wQ291bnQgPSAwO1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICBpZiAoZXhwZWN0ZWRUeXBlID09PSBUUkFOU0lUSU9OKSB7XHJcbiAgICAgICAgaWYgKHRyYW5zaXRpb25UaW1lb3V0ID4gMCkge1xyXG4gICAgICAgICAgICB0eXBlID0gVFJBTlNJVElPTjtcclxuICAgICAgICAgICAgdGltZW91dCA9IHRyYW5zaXRpb25UaW1lb3V0O1xyXG4gICAgICAgICAgICBwcm9wQ291bnQgPSB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09IEFOSU1BVElPTikge1xyXG4gICAgICAgIGlmIChhbmltYXRpb25UaW1lb3V0ID4gMCkge1xyXG4gICAgICAgICAgICB0eXBlID0gQU5JTUFUSU9OO1xyXG4gICAgICAgICAgICB0aW1lb3V0ID0gYW5pbWF0aW9uVGltZW91dDtcclxuICAgICAgICAgICAgcHJvcENvdW50ID0gYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0aW1lb3V0ID0gTWF0aC5tYXgodHJhbnNpdGlvblRpbWVvdXQsIGFuaW1hdGlvblRpbWVvdXQpO1xyXG4gICAgICAgIHR5cGUgPVxyXG4gICAgICAgICAgICB0aW1lb3V0ID4gMFxyXG4gICAgICAgICAgICAgICAgPyB0cmFuc2l0aW9uVGltZW91dCA+IGFuaW1hdGlvblRpbWVvdXRcclxuICAgICAgICAgICAgICAgICAgICA/IFRSQU5TSVRJT05cclxuICAgICAgICAgICAgICAgICAgICA6IEFOSU1BVElPTlxyXG4gICAgICAgICAgICAgICAgOiBudWxsO1xyXG4gICAgICAgIHByb3BDb3VudCA9IHR5cGVcclxuICAgICAgICAgICAgPyB0eXBlID09PSBUUkFOU0lUSU9OXHJcbiAgICAgICAgICAgICAgICA/IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoXHJcbiAgICAgICAgICAgICAgICA6IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGhcclxuICAgICAgICAgICAgOiAwO1xyXG4gICAgfVxyXG4gICAgdmFyIGhhc1RyYW5zZm9ybSA9IHR5cGUgPT09IFRSQU5TSVRJT04gJiYgdHJhbnNmb3JtUkUudGVzdChzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnUHJvcGVydHknXSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IHR5cGUsXHJcbiAgICAgICAgdGltZW91dDogdGltZW91dCxcclxuICAgICAgICBwcm9wQ291bnQ6IHByb3BDb3VudCxcclxuICAgICAgICBoYXNUcmFuc2Zvcm06IGhhc1RyYW5zZm9ybVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBnZXRUaW1lb3V0KGRlbGF5cywgZHVyYXRpb25zKSB7XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgd2hpbGUgKGRlbGF5cy5sZW5ndGggPCBkdXJhdGlvbnMubGVuZ3RoKSB7XHJcbiAgICAgICAgZGVsYXlzID0gZGVsYXlzLmNvbmNhdChkZWxheXMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KG51bGwsIGR1cmF0aW9ucy5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcclxuICAgICAgICByZXR1cm4gdG9NcyhkKSArIHRvTXMoZGVsYXlzW2ldKTtcclxuICAgIH0pKTtcclxufVxyXG4vLyBPbGQgdmVyc2lvbnMgb2YgQ2hyb21pdW0gKGJlbG93IDYxLjAuMzE2My4xMDApIGZvcm1hdHMgZmxvYXRpbmcgcG9pbnRlciBudW1iZXJzXHJcbi8vIGluIGEgbG9jYWxlLWRlcGVuZGVudCB3YXksIHVzaW5nIGEgY29tbWEgaW5zdGVhZCBvZiBhIGRvdC5cclxuLy8gSWYgY29tbWEgaXMgbm90IHJlcGxhY2VkIHdpdGggYSBkb3QsIHRoZSBpbnB1dCB3aWxsIGJlIHJvdW5kZWQgZG93biAoaS5lLiBhY3RpbmdcclxuLy8gYXMgYSBmbG9vciBmdW5jdGlvbikgY2F1c2luZyB1bmV4cGVjdGVkIGJlaGF2aW9yc1xyXG5mdW5jdGlvbiB0b01zKHMpIHtcclxuICAgIHJldHVybiBOdW1iZXIocy5zbGljZSgwLCAtMSkucmVwbGFjZSgnLCcsICcuJykpICogMTAwMDtcclxufVxuXG5mdW5jdGlvbiBlbnRlcih2bm9kZSwgdG9nZ2xlRGlzcGxheSkge1xyXG4gICAgdmFyIGVsID0gdm5vZGUuZWxtO1xyXG4gICAgLy8gY2FsbCBsZWF2ZSBjYWxsYmFjayBub3dcclxuICAgIGlmIChpc0RlZihlbC5fbGVhdmVDYikpIHtcclxuICAgICAgICBlbC5fbGVhdmVDYi5jYW5jZWxsZWQgPSB0cnVlO1xyXG4gICAgICAgIGVsLl9sZWF2ZUNiKCk7XHJcbiAgICB9XHJcbiAgICB2YXIgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XHJcbiAgICBpZiAoaXNVbmRlZihkYXRhKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKGlzRGVmKGVsLl9lbnRlckNiKSB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHZhciBjc3MgPSBkYXRhLmNzcywgdHlwZSA9IGRhdGEudHlwZSwgZW50ZXJDbGFzcyA9IGRhdGEuZW50ZXJDbGFzcywgZW50ZXJUb0NsYXNzID0gZGF0YS5lbnRlclRvQ2xhc3MsIGVudGVyQWN0aXZlQ2xhc3MgPSBkYXRhLmVudGVyQWN0aXZlQ2xhc3MsIGFwcGVhckNsYXNzID0gZGF0YS5hcHBlYXJDbGFzcywgYXBwZWFyVG9DbGFzcyA9IGRhdGEuYXBwZWFyVG9DbGFzcywgYXBwZWFyQWN0aXZlQ2xhc3MgPSBkYXRhLmFwcGVhckFjdGl2ZUNsYXNzLCBiZWZvcmVFbnRlciA9IGRhdGEuYmVmb3JlRW50ZXIsIGVudGVyID0gZGF0YS5lbnRlciwgYWZ0ZXJFbnRlciA9IGRhdGEuYWZ0ZXJFbnRlciwgZW50ZXJDYW5jZWxsZWQgPSBkYXRhLmVudGVyQ2FuY2VsbGVkLCBiZWZvcmVBcHBlYXIgPSBkYXRhLmJlZm9yZUFwcGVhciwgYXBwZWFyID0gZGF0YS5hcHBlYXIsIGFmdGVyQXBwZWFyID0gZGF0YS5hZnRlckFwcGVhciwgYXBwZWFyQ2FuY2VsbGVkID0gZGF0YS5hcHBlYXJDYW5jZWxsZWQsIGR1cmF0aW9uID0gZGF0YS5kdXJhdGlvbjtcclxuICAgIC8vIGFjdGl2ZUluc3RhbmNlIHdpbGwgYWx3YXlzIGJlIHRoZSA8dHJhbnNpdGlvbj4gY29tcG9uZW50IG1hbmFnaW5nIHRoaXNcclxuICAgIC8vIHRyYW5zaXRpb24uIE9uZSBlZGdlIGNhc2UgdG8gY2hlY2sgaXMgd2hlbiB0aGUgPHRyYW5zaXRpb24+IGlzIHBsYWNlZFxyXG4gICAgLy8gYXMgdGhlIHJvb3Qgbm9kZSBvZiBhIGNoaWxkIGNvbXBvbmVudC4gSW4gdGhhdCBjYXNlIHdlIG5lZWQgdG8gY2hlY2tcclxuICAgIC8vIDx0cmFuc2l0aW9uPidzIHBhcmVudCBmb3IgYXBwZWFyIGNoZWNrLlxyXG4gICAgdmFyIGNvbnRleHQgPSBhY3RpdmVJbnN0YW5jZTtcclxuICAgIHZhciB0cmFuc2l0aW9uTm9kZSA9IGFjdGl2ZUluc3RhbmNlLiR2bm9kZTtcclxuICAgIHdoaWxlICh0cmFuc2l0aW9uTm9kZSAmJiB0cmFuc2l0aW9uTm9kZS5wYXJlbnQpIHtcclxuICAgICAgICBjb250ZXh0ID0gdHJhbnNpdGlvbk5vZGUuY29udGV4dDtcclxuICAgICAgICB0cmFuc2l0aW9uTm9kZSA9IHRyYW5zaXRpb25Ob2RlLnBhcmVudDtcclxuICAgIH1cclxuICAgIHZhciBpc0FwcGVhciA9ICFjb250ZXh0Ll9pc01vdW50ZWQgfHwgIXZub2RlLmlzUm9vdEluc2VydDtcclxuICAgIGlmIChpc0FwcGVhciAmJiAhYXBwZWFyICYmIGFwcGVhciAhPT0gJycpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB2YXIgc3RhcnRDbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhckNsYXNzID8gYXBwZWFyQ2xhc3MgOiBlbnRlckNsYXNzO1xyXG4gICAgdmFyIGFjdGl2ZUNsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQWN0aXZlQ2xhc3MgPyBhcHBlYXJBY3RpdmVDbGFzcyA6IGVudGVyQWN0aXZlQ2xhc3M7XHJcbiAgICB2YXIgdG9DbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhclRvQ2xhc3MgPyBhcHBlYXJUb0NsYXNzIDogZW50ZXJUb0NsYXNzO1xyXG4gICAgdmFyIGJlZm9yZUVudGVySG9vayA9IGlzQXBwZWFyID8gYmVmb3JlQXBwZWFyIHx8IGJlZm9yZUVudGVyIDogYmVmb3JlRW50ZXI7XHJcbiAgICB2YXIgZW50ZXJIb29rID0gaXNBcHBlYXIgPyAoaXNGdW5jdGlvbihhcHBlYXIpID8gYXBwZWFyIDogZW50ZXIpIDogZW50ZXI7XHJcbiAgICB2YXIgYWZ0ZXJFbnRlckhvb2sgPSBpc0FwcGVhciA/IGFmdGVyQXBwZWFyIHx8IGFmdGVyRW50ZXIgOiBhZnRlckVudGVyO1xyXG4gICAgdmFyIGVudGVyQ2FuY2VsbGVkSG9vayA9IGlzQXBwZWFyXHJcbiAgICAgICAgPyBhcHBlYXJDYW5jZWxsZWQgfHwgZW50ZXJDYW5jZWxsZWRcclxuICAgICAgICA6IGVudGVyQ2FuY2VsbGVkO1xyXG4gICAgdmFyIGV4cGxpY2l0RW50ZXJEdXJhdGlvbiA9IHRvTnVtYmVyKGlzT2JqZWN0KGR1cmF0aW9uKSA/IGR1cmF0aW9uLmVudGVyIDogZHVyYXRpb24pO1xyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZXhwbGljaXRFbnRlckR1cmF0aW9uICE9IG51bGwpIHtcclxuICAgICAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbiwgJ2VudGVyJywgdm5vZGUpO1xyXG4gICAgfVxyXG4gICAgdmFyIGV4cGVjdHNDU1MgPSBjc3MgIT09IGZhbHNlICYmICFpc0lFOTtcclxuICAgIHZhciB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChlbnRlckhvb2spO1xyXG4gICAgdmFyIGNiID0gKGVsLl9lbnRlckNiID0gb25jZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcclxuICAgICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcclxuICAgICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgICAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XHJcbiAgICAgICAgICAgIGlmIChleHBlY3RzQ1NTKSB7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVudGVyQ2FuY2VsbGVkSG9vayAmJiBlbnRlckNhbmNlbGxlZEhvb2soZWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYWZ0ZXJFbnRlckhvb2sgJiYgYWZ0ZXJFbnRlckhvb2soZWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbC5fZW50ZXJDYiA9IG51bGw7XHJcbiAgICB9KSk7XHJcbiAgICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xyXG4gICAgICAgIC8vIHJlbW92ZSBwZW5kaW5nIGxlYXZlIGVsZW1lbnQgb24gZW50ZXIgYnkgaW5qZWN0aW5nIGFuIGluc2VydCBob29rXHJcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdpbnNlcnQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xyXG4gICAgICAgICAgICB2YXIgcGVuZGluZ05vZGUgPSBwYXJlbnQgJiYgcGFyZW50Ll9wZW5kaW5nICYmIHBhcmVudC5fcGVuZGluZ1t2bm9kZS5rZXldO1xyXG4gICAgICAgICAgICBpZiAocGVuZGluZ05vZGUgJiZcclxuICAgICAgICAgICAgICAgIHBlbmRpbmdOb2RlLnRhZyA9PT0gdm5vZGUudGFnICYmXHJcbiAgICAgICAgICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2IpIHtcclxuICAgICAgICAgICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8vIHN0YXJ0IGVudGVyIHRyYW5zaXRpb25cclxuICAgIGJlZm9yZUVudGVySG9vayAmJiBiZWZvcmVFbnRlckhvb2soZWwpO1xyXG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcclxuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xyXG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xyXG4gICAgICAgIG5leHRGcmFtZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XHJcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgICAgICAgICAgaWYgKCFjYi5jYW5jZWxsZWQpIHtcclxuICAgICAgICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXVzZXJXYW50c0NvbnRyb2wpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZER1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChjYiwgZXhwbGljaXRFbnRlckR1cmF0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgY2IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgaWYgKHZub2RlLmRhdGEuc2hvdykge1xyXG4gICAgICAgIHRvZ2dsZURpc3BsYXkgJiYgdG9nZ2xlRGlzcGxheSgpO1xyXG4gICAgICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcclxuICAgIH1cclxuICAgIGlmICghZXhwZWN0c0NTUyAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xyXG4gICAgICAgIGNiKCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbGVhdmUodm5vZGUsIHJtKSB7XHJcbiAgICB2YXIgZWwgPSB2bm9kZS5lbG07XHJcbiAgICAvLyBjYWxsIGVudGVyIGNhbGxiYWNrIG5vd1xyXG4gICAgaWYgKGlzRGVmKGVsLl9lbnRlckNiKSkge1xyXG4gICAgICAgIGVsLl9lbnRlckNiLmNhbmNlbGxlZCA9IHRydWU7XHJcbiAgICAgICAgZWwuX2VudGVyQ2IoKTtcclxuICAgIH1cclxuICAgIHZhciBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcclxuICAgIGlmIChpc1VuZGVmKGRhdGEpIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XHJcbiAgICAgICAgcmV0dXJuIHJtKCk7XHJcbiAgICB9XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIGlmIChpc0RlZihlbC5fbGVhdmVDYikpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB2YXIgY3NzID0gZGF0YS5jc3MsIHR5cGUgPSBkYXRhLnR5cGUsIGxlYXZlQ2xhc3MgPSBkYXRhLmxlYXZlQ2xhc3MsIGxlYXZlVG9DbGFzcyA9IGRhdGEubGVhdmVUb0NsYXNzLCBsZWF2ZUFjdGl2ZUNsYXNzID0gZGF0YS5sZWF2ZUFjdGl2ZUNsYXNzLCBiZWZvcmVMZWF2ZSA9IGRhdGEuYmVmb3JlTGVhdmUsIGxlYXZlID0gZGF0YS5sZWF2ZSwgYWZ0ZXJMZWF2ZSA9IGRhdGEuYWZ0ZXJMZWF2ZSwgbGVhdmVDYW5jZWxsZWQgPSBkYXRhLmxlYXZlQ2FuY2VsbGVkLCBkZWxheUxlYXZlID0gZGF0YS5kZWxheUxlYXZlLCBkdXJhdGlvbiA9IGRhdGEuZHVyYXRpb247XHJcbiAgICB2YXIgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2UgJiYgIWlzSUU5O1xyXG4gICAgdmFyIHVzZXJXYW50c0NvbnRyb2wgPSBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGxlYXZlKTtcclxuICAgIHZhciBleHBsaWNpdExlYXZlRHVyYXRpb24gPSB0b051bWJlcihpc09iamVjdChkdXJhdGlvbikgPyBkdXJhdGlvbi5sZWF2ZSA6IGR1cmF0aW9uKTtcclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzRGVmKGV4cGxpY2l0TGVhdmVEdXJhdGlvbikpIHtcclxuICAgICAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbiwgJ2xlYXZlJywgdm5vZGUpO1xyXG4gICAgfVxyXG4gICAgdmFyIGNiID0gKGVsLl9sZWF2ZUNiID0gb25jZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKGVsLnBhcmVudE5vZGUgJiYgZWwucGFyZW50Tm9kZS5fcGVuZGluZykge1xyXG4gICAgICAgICAgICBlbC5wYXJlbnROb2RlLl9wZW5kaW5nW3Zub2RlLmtleV0gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZXhwZWN0c0NTUykge1xyXG4gICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XHJcbiAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgICAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XHJcbiAgICAgICAgICAgIGlmIChleHBlY3RzQ1NTKSB7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxlYXZlQ2FuY2VsbGVkICYmIGxlYXZlQ2FuY2VsbGVkKGVsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJtKCk7XHJcbiAgICAgICAgICAgIGFmdGVyTGVhdmUgJiYgYWZ0ZXJMZWF2ZShlbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsLl9sZWF2ZUNiID0gbnVsbDtcclxuICAgIH0pKTtcclxuICAgIGlmIChkZWxheUxlYXZlKSB7XHJcbiAgICAgICAgZGVsYXlMZWF2ZShwZXJmb3JtTGVhdmUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcGVyZm9ybUxlYXZlKCk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBwZXJmb3JtTGVhdmUoKSB7XHJcbiAgICAgICAgLy8gdGhlIGRlbGF5ZWQgbGVhdmUgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIGNhbmNlbGxlZFxyXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgICAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcmVjb3JkIGxlYXZpbmcgZWxlbWVudFxyXG4gICAgICAgIGlmICghdm5vZGUuZGF0YS5zaG93ICYmIGVsLnBhcmVudE5vZGUpIHtcclxuICAgICAgICAgICAgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgfHwgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgPSB7fSkpW3Zub2RlLmtleV0gPVxyXG4gICAgICAgICAgICAgICAgdm5vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJlZm9yZUxlYXZlICYmIGJlZm9yZUxlYXZlKGVsKTtcclxuICAgICAgICBpZiAoZXhwZWN0c0NTUykge1xyXG4gICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xyXG4gICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xyXG4gICAgICAgICAgICBuZXh0RnJhbWUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcclxuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgICAgICAgICAgICAgIGlmICghY2IuY2FuY2VsbGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdXNlcldhbnRzQ29udHJvbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZER1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoY2IsIGV4cGxpY2l0TGVhdmVEdXJhdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxlYXZlICYmIGxlYXZlKGVsLCBjYik7XHJcbiAgICAgICAgaWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XHJcbiAgICAgICAgICAgIGNiKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8vIG9ubHkgdXNlZCBpbiBkZXYgbW9kZVxyXG5mdW5jdGlvbiBjaGVja0R1cmF0aW9uKHZhbCwgbmFtZSwgdm5vZGUpIHtcclxuICAgIGlmICh0eXBlb2YgdmFsICE9PSAnbnVtYmVyJykge1xyXG4gICAgICAgIHdhcm4kMihcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIi5jb25jYXQobmFtZSwgXCIgZHVyYXRpb24gaXMgbm90IGEgdmFsaWQgbnVtYmVyIC0gXCIpICtcclxuICAgICAgICAgICAgXCJnb3QgXCIuY29uY2F0KEpTT04uc3RyaW5naWZ5KHZhbCksIFwiLlwiKSwgdm5vZGUuY29udGV4dCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc05hTih2YWwpKSB7XHJcbiAgICAgICAgd2FybiQyKFwiPHRyYW5zaXRpb24+IGV4cGxpY2l0IFwiLmNvbmNhdChuYW1lLCBcIiBkdXJhdGlvbiBpcyBOYU4gLSBcIikgK1xyXG4gICAgICAgICAgICAndGhlIGR1cmF0aW9uIGV4cHJlc3Npb24gbWlnaHQgYmUgaW5jb3JyZWN0LicsIHZub2RlLmNvbnRleHQpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGlzVmFsaWREdXJhdGlvbih2YWwpIHtcclxuICAgIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsKTtcclxufVxyXG4vKipcclxuICogTm9ybWFsaXplIGEgdHJhbnNpdGlvbiBob29rJ3MgYXJndW1lbnQgbGVuZ3RoLiBUaGUgaG9vayBtYXkgYmU6XHJcbiAqIC0gYSBtZXJnZWQgaG9vayAoaW52b2tlcikgd2l0aCB0aGUgb3JpZ2luYWwgaW4gLmZuc1xyXG4gKiAtIGEgd3JhcHBlZCBjb21wb25lbnQgbWV0aG9kIChjaGVjayAuX2xlbmd0aClcclxuICogLSBhIHBsYWluIGZ1bmN0aW9uICgubGVuZ3RoKVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChmbikge1xyXG4gICAgaWYgKGlzVW5kZWYoZm4pKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxyXG4gICAgdmFyIGludm9rZXJGbnMgPSBmbi5mbnM7XHJcbiAgICBpZiAoaXNEZWYoaW52b2tlckZucykpIHtcclxuICAgICAgICAvLyBpbnZva2VyXHJcbiAgICAgICAgcmV0dXJuIGdldEhvb2tBcmd1bWVudHNMZW5ndGgoQXJyYXkuaXNBcnJheShpbnZva2VyRm5zKSA/IGludm9rZXJGbnNbMF0gOiBpbnZva2VyRm5zKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgICAgICByZXR1cm4gKGZuLl9sZW5ndGggfHwgZm4ubGVuZ3RoKSA+IDE7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gX2VudGVyKF8sIHZub2RlKSB7XHJcbiAgICBpZiAodm5vZGUuZGF0YS5zaG93ICE9PSB0cnVlKSB7XHJcbiAgICAgICAgZW50ZXIodm5vZGUpO1xyXG4gICAgfVxyXG59XHJcbnZhciB0cmFuc2l0aW9uID0gaW5Ccm93c2VyXHJcbiAgICA/IHtcclxuICAgICAgICBjcmVhdGU6IF9lbnRlcixcclxuICAgICAgICBhY3RpdmF0ZTogX2VudGVyLFxyXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gKHZub2RlLCBybSkge1xyXG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xyXG4gICAgICAgICAgICBpZiAodm5vZGUuZGF0YS5zaG93ICE9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXHJcbiAgICAgICAgICAgICAgICBsZWF2ZSh2bm9kZSwgcm0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcm0oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDoge307XG5cbnZhciBwbGF0Zm9ybU1vZHVsZXMgPSBbYXR0cnMsIGtsYXNzJDEsIGV2ZW50cywgZG9tUHJvcHMsIHN0eWxlJDEsIHRyYW5zaXRpb25dO1xuXG4vLyB0aGUgZGlyZWN0aXZlIG1vZHVsZSBzaG91bGQgYmUgYXBwbGllZCBsYXN0LCBhZnRlciBhbGxcclxuLy8gYnVpbHQtaW4gbW9kdWxlcyBoYXZlIGJlZW4gYXBwbGllZC5cclxudmFyIG1vZHVsZXMkMSA9IHBsYXRmb3JtTW9kdWxlcy5jb25jYXQoYmFzZU1vZHVsZXMpO1xyXG52YXIgcGF0Y2ggPSBjcmVhdGVQYXRjaEZ1bmN0aW9uKHsgbm9kZU9wczogbm9kZU9wcywgbW9kdWxlczogbW9kdWxlcyQxIH0pO1xuXG4vKipcclxuICogTm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IGxpa2UgYXR0YWNoaW5nXHJcbiAqIHByb3BlcnRpZXMgdG8gRWxlbWVudHMuXHJcbiAqL1xyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuaWYgKGlzSUU5KSB7XHJcbiAgICAvLyBodHRwOi8vd3d3Lm1hdHRzNDExLmNvbS9wb3N0L2ludGVybmV0LWV4cGxvcmVyLTktb25pbnB1dC9cclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdGlvbmNoYW5nZScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZWwgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xyXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgICAgICBpZiAoZWwgJiYgZWwudm1vZGVsKSB7XHJcbiAgICAgICAgICAgIHRyaWdnZXIoZWwsICdpbnB1dCcpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbnZhciBkaXJlY3RpdmUgPSB7XHJcbiAgICBpbnNlcnRlZDogZnVuY3Rpb24gKGVsLCBiaW5kaW5nLCB2bm9kZSwgb2xkVm5vZGUpIHtcclxuICAgICAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xyXG4gICAgICAgICAgICAvLyAjNjkwM1xyXG4gICAgICAgICAgICBpZiAob2xkVm5vZGUuZWxtICYmICFvbGRWbm9kZS5lbG0uX3ZPcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ3Bvc3RwYXRjaCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBkaXJlY3RpdmUuY29tcG9uZW50VXBkYXRlZChlbCwgYmluZGluZywgdm5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWwuX3ZPcHRpb25zID0gW10ubWFwLmNhbGwoZWwub3B0aW9ucywgZ2V0VmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh2bm9kZS50YWcgPT09ICd0ZXh0YXJlYScgfHwgaXNUZXh0SW5wdXRUeXBlKGVsLnR5cGUpKSB7XHJcbiAgICAgICAgICAgIGVsLl92TW9kaWZpZXJzID0gYmluZGluZy5tb2RpZmllcnM7XHJcbiAgICAgICAgICAgIGlmICghYmluZGluZy5tb2RpZmllcnMubGF6eSkge1xyXG4gICAgICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25zdGFydCcsIG9uQ29tcG9zaXRpb25TdGFydCk7XHJcbiAgICAgICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbmVuZCcsIG9uQ29tcG9zaXRpb25FbmQpO1xyXG4gICAgICAgICAgICAgICAgLy8gU2FmYXJpIDwgMTAuMiAmIFVJV2ViVmlldyBkb2Vzbid0IGZpcmUgY29tcG9zaXRpb25lbmQgd2hlblxyXG4gICAgICAgICAgICAgICAgLy8gc3dpdGNoaW5nIGZvY3VzIGJlZm9yZSBjb25maXJtaW5nIGNvbXBvc2l0aW9uIGNob2ljZVxyXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBhbHNvIGZpeGVzIHRoZSBpc3N1ZSB3aGVyZSBzb21lIGJyb3dzZXJzIGUuZy4gaU9TIENocm9tZVxyXG4gICAgICAgICAgICAgICAgLy8gZmlyZXMgXCJjaGFuZ2VcIiBpbnN0ZWFkIG9mIFwiaW5wdXRcIiBvbiBhdXRvY29tcGxldGUuXHJcbiAgICAgICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBvbkNvbXBvc2l0aW9uRW5kKTtcclxuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzSUU5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWwudm1vZGVsID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBjb21wb25lbnRVcGRhdGVkOiBmdW5jdGlvbiAoZWwsIGJpbmRpbmcsIHZub2RlKSB7XHJcbiAgICAgICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcclxuICAgICAgICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xyXG4gICAgICAgICAgICAvLyBpbiBjYXNlIHRoZSBvcHRpb25zIHJlbmRlcmVkIGJ5IHYtZm9yIGhhdmUgY2hhbmdlZCxcclxuICAgICAgICAgICAgLy8gaXQncyBwb3NzaWJsZSB0aGF0IHRoZSB2YWx1ZSBpcyBvdXQtb2Ytc3luYyB3aXRoIHRoZSByZW5kZXJlZCBvcHRpb25zLlxyXG4gICAgICAgICAgICAvLyBkZXRlY3Qgc3VjaCBjYXNlcyBhbmQgZmlsdGVyIG91dCB2YWx1ZXMgdGhhdCBubyBsb25nZXIgaGFzIGEgbWF0Y2hpbmdcclxuICAgICAgICAgICAgLy8gb3B0aW9uIGluIHRoZSBET00uXHJcbiAgICAgICAgICAgIHZhciBwcmV2T3B0aW9uc18xID0gZWwuX3ZPcHRpb25zO1xyXG4gICAgICAgICAgICB2YXIgY3VyT3B0aW9uc18xID0gKGVsLl92T3B0aW9ucyA9IFtdLm1hcC5jYWxsKGVsLm9wdGlvbnMsIGdldFZhbHVlKSk7XHJcbiAgICAgICAgICAgIGlmIChjdXJPcHRpb25zXzEuc29tZShmdW5jdGlvbiAobywgaSkgeyByZXR1cm4gIWxvb3NlRXF1YWwobywgcHJldk9wdGlvbnNfMVtpXSk7IH0pKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB0cmlnZ2VyIGNoYW5nZSBldmVudCBpZlxyXG4gICAgICAgICAgICAgICAgLy8gbm8gbWF0Y2hpbmcgb3B0aW9uIGZvdW5kIGZvciBhdCBsZWFzdCBvbmUgdmFsdWVcclxuICAgICAgICAgICAgICAgIHZhciBuZWVkUmVzZXQgPSBlbC5tdWx0aXBsZVxyXG4gICAgICAgICAgICAgICAgICAgID8gYmluZGluZy52YWx1ZS5zb21lKGZ1bmN0aW9uICh2KSB7IHJldHVybiBoYXNOb01hdGNoaW5nT3B0aW9uKHYsIGN1ck9wdGlvbnNfMSk7IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgOiBiaW5kaW5nLnZhbHVlICE9PSBiaW5kaW5nLm9sZFZhbHVlICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc05vTWF0Y2hpbmdPcHRpb24oYmluZGluZy52YWx1ZSwgY3VyT3B0aW9uc18xKTtcclxuICAgICAgICAgICAgICAgIGlmIChuZWVkUmVzZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyKGVsLCAnY2hhbmdlJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbmZ1bmN0aW9uIHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bSkge1xyXG4gICAgYWN0dWFsbHlTZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm0pO1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICBpZiAoaXNJRSB8fCBpc0VkZ2UpIHtcclxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgYWN0dWFsbHlTZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm0pO1xyXG4gICAgICAgIH0sIDApO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGFjdHVhbGx5U2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZtKSB7XHJcbiAgICB2YXIgdmFsdWUgPSBiaW5kaW5nLnZhbHVlO1xyXG4gICAgdmFyIGlzTXVsdGlwbGUgPSBlbC5tdWx0aXBsZTtcclxuICAgIGlmIChpc011bHRpcGxlICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcclxuICAgICAgICAgICAgd2FybiQyKFwiPHNlbGVjdCBtdWx0aXBsZSB2LW1vZGVsPVxcXCJcIi5jb25jYXQoYmluZGluZy5leHByZXNzaW9uLCBcIlxcXCI+IFwiKSArXHJcbiAgICAgICAgICAgICAgICBcImV4cGVjdHMgYW4gQXJyYXkgdmFsdWUgZm9yIGl0cyBiaW5kaW5nLCBidXQgZ290IFwiLmNvbmNhdChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgLmNhbGwodmFsdWUpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNsaWNlKDgsIC0xKSksIHZtKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB2YXIgc2VsZWN0ZWQsIG9wdGlvbjtcclxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gZWwub3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICBvcHRpb24gPSBlbC5vcHRpb25zW2ldO1xyXG4gICAgICAgIGlmIChpc011bHRpcGxlKSB7XHJcbiAgICAgICAgICAgIHNlbGVjdGVkID0gbG9vc2VJbmRleE9mKHZhbHVlLCBnZXRWYWx1ZShvcHRpb24pKSA+IC0xO1xyXG4gICAgICAgICAgICBpZiAob3B0aW9uLnNlbGVjdGVkICE9PSBzZWxlY3RlZCkge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChsb29zZUVxdWFsKGdldFZhbHVlKG9wdGlvbiksIHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVsLnNlbGVjdGVkSW5kZXggIT09IGkpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbC5zZWxlY3RlZEluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghaXNNdWx0aXBsZSkge1xyXG4gICAgICAgIGVsLnNlbGVjdGVkSW5kZXggPSAtMTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBoYXNOb01hdGNoaW5nT3B0aW9uKHZhbHVlLCBvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gb3B0aW9ucy5ldmVyeShmdW5jdGlvbiAobykgeyByZXR1cm4gIWxvb3NlRXF1YWwobywgdmFsdWUpOyB9KTtcclxufVxyXG5mdW5jdGlvbiBnZXRWYWx1ZShvcHRpb24pIHtcclxuICAgIHJldHVybiAnX3ZhbHVlJyBpbiBvcHRpb24gPyBvcHRpb24uX3ZhbHVlIDogb3B0aW9uLnZhbHVlO1xyXG59XHJcbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25TdGFydChlKSB7XHJcbiAgICBlLnRhcmdldC5jb21wb3NpbmcgPSB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25FbmQoZSkge1xyXG4gICAgLy8gcHJldmVudCB0cmlnZ2VyaW5nIGFuIGlucHV0IGV2ZW50IGZvciBubyByZWFzb25cclxuICAgIGlmICghZS50YXJnZXQuY29tcG9zaW5nKVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIGUudGFyZ2V0LmNvbXBvc2luZyA9IGZhbHNlO1xyXG4gICAgdHJpZ2dlcihlLnRhcmdldCwgJ2lucHV0Jyk7XHJcbn1cclxuZnVuY3Rpb24gdHJpZ2dlcihlbCwgdHlwZSkge1xyXG4gICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnSFRNTEV2ZW50cycpO1xyXG4gICAgZS5pbml0RXZlbnQodHlwZSwgdHJ1ZSwgdHJ1ZSk7XHJcbiAgICBlbC5kaXNwYXRjaEV2ZW50KGUpO1xyXG59XG5cbi8vIHJlY3Vyc2l2ZWx5IHNlYXJjaCBmb3IgcG9zc2libGUgdHJhbnNpdGlvbiBkZWZpbmVkIGluc2lkZSB0aGUgY29tcG9uZW50IHJvb3RcclxuZnVuY3Rpb24gbG9jYXRlTm9kZSh2bm9kZSkge1xyXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxyXG4gICAgcmV0dXJuIHZub2RlLmNvbXBvbmVudEluc3RhbmNlICYmICghdm5vZGUuZGF0YSB8fCAhdm5vZGUuZGF0YS50cmFuc2l0aW9uKVxyXG4gICAgICAgID8gbG9jYXRlTm9kZSh2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGUpXHJcbiAgICAgICAgOiB2bm9kZTtcclxufVxyXG52YXIgc2hvdyA9IHtcclxuICAgIGJpbmQ6IGZ1bmN0aW9uIChlbCwgX2EsIHZub2RlKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gX2EudmFsdWU7XHJcbiAgICAgICAgdm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcclxuICAgICAgICB2YXIgdHJhbnNpdGlvbiA9IHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS50cmFuc2l0aW9uO1xyXG4gICAgICAgIHZhciBvcmlnaW5hbERpc3BsYXkgPSAoZWwuX192T3JpZ2luYWxEaXNwbGF5ID1cclxuICAgICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnID8gJycgOiBlbC5zdHlsZS5kaXNwbGF5KTtcclxuICAgICAgICBpZiAodmFsdWUgJiYgdHJhbnNpdGlvbikge1xyXG4gICAgICAgICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xyXG4gICAgICAgICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IG9yaWdpbmFsRGlzcGxheTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBvcmlnaW5hbERpc3BsYXkgOiAnbm9uZSc7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKGVsLCBfYSwgdm5vZGUpIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSBfYS52YWx1ZSwgb2xkVmFsdWUgPSBfYS5vbGRWYWx1ZTtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgICBpZiAoIXZhbHVlID09PSAhb2xkVmFsdWUpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xyXG4gICAgICAgIHZhciB0cmFuc2l0aW9uID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XHJcbiAgICAgICAgaWYgKHRyYW5zaXRpb24pIHtcclxuICAgICAgICAgICAgdm5vZGUuZGF0YS5zaG93ID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxlYXZlKHZub2RlLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBlbC5fX3ZPcmlnaW5hbERpc3BsYXkgOiAnbm9uZSc7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHVuYmluZDogZnVuY3Rpb24gKGVsLCBiaW5kaW5nLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSkge1xyXG4gICAgICAgIGlmICghaXNEZXN0cm95KSB7XHJcbiAgICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xuXG52YXIgcGxhdGZvcm1EaXJlY3RpdmVzID0ge1xyXG4gICAgbW9kZWw6IGRpcmVjdGl2ZSxcclxuICAgIHNob3c6IHNob3dcclxufTtcblxuLy8gUHJvdmlkZXMgdHJhbnNpdGlvbiBzdXBwb3J0IGZvciBhIHNpbmdsZSBlbGVtZW50L2NvbXBvbmVudC5cclxudmFyIHRyYW5zaXRpb25Qcm9wcyA9IHtcclxuICAgIG5hbWU6IFN0cmluZyxcclxuICAgIGFwcGVhcjogQm9vbGVhbixcclxuICAgIGNzczogQm9vbGVhbixcclxuICAgIG1vZGU6IFN0cmluZyxcclxuICAgIHR5cGU6IFN0cmluZyxcclxuICAgIGVudGVyQ2xhc3M6IFN0cmluZyxcclxuICAgIGxlYXZlQ2xhc3M6IFN0cmluZyxcclxuICAgIGVudGVyVG9DbGFzczogU3RyaW5nLFxyXG4gICAgbGVhdmVUb0NsYXNzOiBTdHJpbmcsXHJcbiAgICBlbnRlckFjdGl2ZUNsYXNzOiBTdHJpbmcsXHJcbiAgICBsZWF2ZUFjdGl2ZUNsYXNzOiBTdHJpbmcsXHJcbiAgICBhcHBlYXJDbGFzczogU3RyaW5nLFxyXG4gICAgYXBwZWFyQWN0aXZlQ2xhc3M6IFN0cmluZyxcclxuICAgIGFwcGVhclRvQ2xhc3M6IFN0cmluZyxcclxuICAgIGR1cmF0aW9uOiBbTnVtYmVyLCBTdHJpbmcsIE9iamVjdF1cclxufTtcclxuLy8gaW4gY2FzZSB0aGUgY2hpbGQgaXMgYWxzbyBhbiBhYnN0cmFjdCBjb21wb25lbnQsIGUuZy4gPGtlZXAtYWxpdmU+XHJcbi8vIHdlIHdhbnQgdG8gcmVjdXJzaXZlbHkgcmV0cmlldmUgdGhlIHJlYWwgY29tcG9uZW50IHRvIGJlIHJlbmRlcmVkXHJcbmZ1bmN0aW9uIGdldFJlYWxDaGlsZCh2bm9kZSkge1xyXG4gICAgdmFyIGNvbXBPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcclxuICAgIGlmIChjb21wT3B0aW9ucyAmJiBjb21wT3B0aW9ucy5DdG9yLm9wdGlvbnMuYWJzdHJhY3QpIHtcclxuICAgICAgICByZXR1cm4gZ2V0UmVhbENoaWxkKGdldEZpcnN0Q29tcG9uZW50Q2hpbGQoY29tcE9wdGlvbnMuY2hpbGRyZW4pKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB2bm9kZTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBleHRyYWN0VHJhbnNpdGlvbkRhdGEoY29tcCkge1xyXG4gICAgdmFyIGRhdGEgPSB7fTtcclxuICAgIHZhciBvcHRpb25zID0gY29tcC4kb3B0aW9ucztcclxuICAgIC8vIHByb3BzXHJcbiAgICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5wcm9wc0RhdGEpIHtcclxuICAgICAgICBkYXRhW2tleV0gPSBjb21wW2tleV07XHJcbiAgICB9XHJcbiAgICAvLyBldmVudHMuXHJcbiAgICAvLyBleHRyYWN0IGxpc3RlbmVycyBhbmQgcGFzcyB0aGVtIGRpcmVjdGx5IHRvIHRoZSB0cmFuc2l0aW9uIG1ldGhvZHNcclxuICAgIHZhciBsaXN0ZW5lcnMgPSBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XHJcbiAgICBmb3IgKHZhciBrZXkgaW4gbGlzdGVuZXJzKSB7XHJcbiAgICAgICAgZGF0YVtjYW1lbGl6ZShrZXkpXSA9IGxpc3RlbmVyc1trZXldO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRhdGE7XHJcbn1cclxuZnVuY3Rpb24gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpIHtcclxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgIGlmICgvXFxkLWtlZXAtYWxpdmUkLy50ZXN0KHJhd0NoaWxkLnRhZykpIHtcclxuICAgICAgICByZXR1cm4gaCgna2VlcC1hbGl2ZScsIHtcclxuICAgICAgICAgICAgcHJvcHM6IHJhd0NoaWxkLmNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaGFzUGFyZW50VHJhbnNpdGlvbih2bm9kZSkge1xyXG4gICAgd2hpbGUgKCh2bm9kZSA9IHZub2RlLnBhcmVudCkpIHtcclxuICAgICAgICBpZiAodm5vZGUuZGF0YS50cmFuc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpc1NhbWVDaGlsZChjaGlsZCwgb2xkQ2hpbGQpIHtcclxuICAgIHJldHVybiBvbGRDaGlsZC5rZXkgPT09IGNoaWxkLmtleSAmJiBvbGRDaGlsZC50YWcgPT09IGNoaWxkLnRhZztcclxufVxyXG52YXIgaXNOb3RUZXh0Tm9kZSA9IGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRhZyB8fCBpc0FzeW5jUGxhY2Vob2xkZXIoYyk7IH07XHJcbnZhciBpc1ZTaG93RGlyZWN0aXZlID0gZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQubmFtZSA9PT0gJ3Nob3cnOyB9O1xyXG52YXIgVHJhbnNpdGlvbiA9IHtcclxuICAgIG5hbWU6ICd0cmFuc2l0aW9uJyxcclxuICAgIHByb3BzOiB0cmFuc2l0aW9uUHJvcHMsXHJcbiAgICBhYnN0cmFjdDogdHJ1ZSxcclxuICAgIHJlbmRlcjogZnVuY3Rpb24gKGgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XHJcbiAgICAgICAgaWYgKCFjaGlsZHJlbikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGZpbHRlciBvdXQgdGV4dCBub2RlcyAocG9zc2libGUgd2hpdGVzcGFjZXMpXHJcbiAgICAgICAgY2hpbGRyZW4gPSBjaGlsZHJlbi5maWx0ZXIoaXNOb3RUZXh0Tm9kZSk7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgaWYgKCFjaGlsZHJlbi5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB3YXJuIG11bHRpcGxlIGVsZW1lbnRzXHJcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICB3YXJuJDIoJzx0cmFuc2l0aW9uPiBjYW4gb25seSBiZSB1c2VkIG9uIGEgc2luZ2xlIGVsZW1lbnQuIFVzZSAnICtcclxuICAgICAgICAgICAgICAgICc8dHJhbnNpdGlvbi1ncm91cD4gZm9yIGxpc3RzLicsIHRoaXMuJHBhcmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBtb2RlID0gdGhpcy5tb2RlO1xyXG4gICAgICAgIC8vIHdhcm4gaW52YWxpZCBtb2RlXHJcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgbW9kZSAmJiBtb2RlICE9PSAnaW4tb3V0JyAmJiBtb2RlICE9PSAnb3V0LWluJykge1xyXG4gICAgICAgICAgICB3YXJuJDIoJ2ludmFsaWQgPHRyYW5zaXRpb24+IG1vZGU6ICcgKyBtb2RlLCB0aGlzLiRwYXJlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmF3Q2hpbGQgPSBjaGlsZHJlblswXTtcclxuICAgICAgICAvLyBpZiB0aGlzIGlzIGEgY29tcG9uZW50IHJvb3Qgbm9kZSBhbmQgdGhlIGNvbXBvbmVudCdzXHJcbiAgICAgICAgLy8gcGFyZW50IGNvbnRhaW5lciBub2RlIGFsc28gaGFzIHRyYW5zaXRpb24sIHNraXAuXHJcbiAgICAgICAgaWYgKGhhc1BhcmVudFRyYW5zaXRpb24odGhpcy4kdm5vZGUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByYXdDaGlsZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYXBwbHkgdHJhbnNpdGlvbiBkYXRhIHRvIGNoaWxkXHJcbiAgICAgICAgLy8gdXNlIGdldFJlYWxDaGlsZCgpIHRvIGlnbm9yZSBhYnN0cmFjdCBjb21wb25lbnRzIGUuZy4ga2VlcC1hbGl2ZVxyXG4gICAgICAgIHZhciBjaGlsZCA9IGdldFJlYWxDaGlsZChyYXdDaGlsZCk7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgaWYgKCFjaGlsZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmF3Q2hpbGQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9sZWF2aW5nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwbGFjZWhvbGRlcihoLCByYXdDaGlsZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGVuc3VyZSBhIGtleSB0aGF0IGlzIHVuaXF1ZSB0byB0aGUgdm5vZGUgdHlwZSBhbmQgdG8gdGhpcyB0cmFuc2l0aW9uXHJcbiAgICAgICAgLy8gY29tcG9uZW50IGluc3RhbmNlLiBUaGlzIGtleSB3aWxsIGJlIHVzZWQgdG8gcmVtb3ZlIHBlbmRpbmcgbGVhdmluZyBub2Rlc1xyXG4gICAgICAgIC8vIGR1cmluZyBlbnRlcmluZy5cclxuICAgICAgICB2YXIgaWQgPSBcIl9fdHJhbnNpdGlvbi1cIi5jb25jYXQodGhpcy5fdWlkLCBcIi1cIik7XHJcbiAgICAgICAgY2hpbGQua2V5ID1cclxuICAgICAgICAgICAgY2hpbGQua2V5ID09IG51bGxcclxuICAgICAgICAgICAgICAgID8gY2hpbGQuaXNDb21tZW50XHJcbiAgICAgICAgICAgICAgICAgICAgPyBpZCArICdjb21tZW50J1xyXG4gICAgICAgICAgICAgICAgICAgIDogaWQgKyBjaGlsZC50YWdcclxuICAgICAgICAgICAgICAgIDogaXNQcmltaXRpdmUoY2hpbGQua2V5KVxyXG4gICAgICAgICAgICAgICAgICAgID8gU3RyaW5nKGNoaWxkLmtleSkuaW5kZXhPZihpZCkgPT09IDBcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjaGlsZC5rZXlcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBpZCArIGNoaWxkLmtleVxyXG4gICAgICAgICAgICAgICAgICAgIDogY2hpbGQua2V5O1xyXG4gICAgICAgIHZhciBkYXRhID0gKChjaGlsZC5kYXRhIHx8IChjaGlsZC5kYXRhID0ge30pKS50cmFuc2l0aW9uID1cclxuICAgICAgICAgICAgZXh0cmFjdFRyYW5zaXRpb25EYXRhKHRoaXMpKTtcclxuICAgICAgICB2YXIgb2xkUmF3Q2hpbGQgPSB0aGlzLl92bm9kZTtcclxuICAgICAgICB2YXIgb2xkQ2hpbGQgPSBnZXRSZWFsQ2hpbGQob2xkUmF3Q2hpbGQpO1xyXG4gICAgICAgIC8vIG1hcmsgdi1zaG93XHJcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgdHJhbnNpdGlvbiBtb2R1bGUgY2FuIGhhbmQgb3ZlciB0aGUgY29udHJvbCB0byB0aGUgZGlyZWN0aXZlXHJcbiAgICAgICAgaWYgKGNoaWxkLmRhdGEuZGlyZWN0aXZlcyAmJiBjaGlsZC5kYXRhLmRpcmVjdGl2ZXMuc29tZShpc1ZTaG93RGlyZWN0aXZlKSkge1xyXG4gICAgICAgICAgICBjaGlsZC5kYXRhLnNob3cgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob2xkQ2hpbGQgJiZcclxuICAgICAgICAgICAgb2xkQ2hpbGQuZGF0YSAmJlxyXG4gICAgICAgICAgICAhaXNTYW1lQ2hpbGQoY2hpbGQsIG9sZENoaWxkKSAmJlxyXG4gICAgICAgICAgICAhaXNBc3luY1BsYWNlaG9sZGVyKG9sZENoaWxkKSAmJlxyXG4gICAgICAgICAgICAvLyAjNjY4NyBjb21wb25lbnQgcm9vdCBpcyBhIGNvbW1lbnQgbm9kZVxyXG4gICAgICAgICAgICAhKG9sZENoaWxkLmNvbXBvbmVudEluc3RhbmNlICYmXHJcbiAgICAgICAgICAgICAgICBvbGRDaGlsZC5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGUuaXNDb21tZW50KSkge1xyXG4gICAgICAgICAgICAvLyByZXBsYWNlIG9sZCBjaGlsZCB0cmFuc2l0aW9uIGRhdGEgd2l0aCBmcmVzaCBvbmVcclxuICAgICAgICAgICAgLy8gaW1wb3J0YW50IGZvciBkeW5hbWljIHRyYW5zaXRpb25zIVxyXG4gICAgICAgICAgICB2YXIgb2xkRGF0YSA9IChvbGRDaGlsZC5kYXRhLnRyYW5zaXRpb24gPSBleHRlbmQoe30sIGRhdGEpKTtcclxuICAgICAgICAgICAgLy8gaGFuZGxlIHRyYW5zaXRpb24gbW9kZVxyXG4gICAgICAgICAgICBpZiAobW9kZSA9PT0gJ291dC1pbicpIHtcclxuICAgICAgICAgICAgICAgIC8vIHJldHVybiBwbGFjZWhvbGRlciBub2RlIGFuZCBxdWV1ZSB1cGRhdGUgd2hlbiBsZWF2ZSBmaW5pc2hlc1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGVhdmluZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnYWZ0ZXJMZWF2ZScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbGVhdmluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLiRmb3JjZVVwZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG1vZGUgPT09ICdpbi1vdXQnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNBc3luY1BsYWNlaG9sZGVyKGNoaWxkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvbGRSYXdDaGlsZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBkZWxheWVkTGVhdmVfMTtcclxuICAgICAgICAgICAgICAgIHZhciBwZXJmb3JtTGVhdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsYXllZExlYXZlXzEoKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnYWZ0ZXJFbnRlcicsIHBlcmZvcm1MZWF2ZSk7XHJcbiAgICAgICAgICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnZW50ZXJDYW5jZWxsZWQnLCBwZXJmb3JtTGVhdmUpO1xyXG4gICAgICAgICAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2RlbGF5TGVhdmUnLCBmdW5jdGlvbiAobGVhdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxheWVkTGVhdmVfMSA9IGxlYXZlO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJhd0NoaWxkO1xyXG4gICAgfVxyXG59O1xuXG4vLyBQcm92aWRlcyB0cmFuc2l0aW9uIHN1cHBvcnQgZm9yIGxpc3QgaXRlbXMuXHJcbnZhciBwcm9wcyA9IGV4dGVuZCh7XHJcbiAgICB0YWc6IFN0cmluZyxcclxuICAgIG1vdmVDbGFzczogU3RyaW5nXHJcbn0sIHRyYW5zaXRpb25Qcm9wcyk7XHJcbmRlbGV0ZSBwcm9wcy5tb2RlO1xyXG52YXIgVHJhbnNpdGlvbkdyb3VwID0ge1xyXG4gICAgcHJvcHM6IHByb3BzLFxyXG4gICAgYmVmb3JlTW91bnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciB1cGRhdGUgPSB0aGlzLl91cGRhdGU7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlID0gZnVuY3Rpb24gKHZub2RlLCBoeWRyYXRpbmcpIHtcclxuICAgICAgICAgICAgdmFyIHJlc3RvcmVBY3RpdmVJbnN0YW5jZSA9IHNldEFjdGl2ZUluc3RhbmNlKF90aGlzKTtcclxuICAgICAgICAgICAgLy8gZm9yY2UgcmVtb3ZpbmcgcGFzc1xyXG4gICAgICAgICAgICBfdGhpcy5fX3BhdGNoX18oX3RoaXMuX3Zub2RlLCBfdGhpcy5rZXB0LCBmYWxzZSwgLy8gaHlkcmF0aW5nXHJcbiAgICAgICAgICAgIHRydWUgLy8gcmVtb3ZlT25seSAoIWltcG9ydGFudCwgYXZvaWRzIHVubmVjZXNzYXJ5IG1vdmVzKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBfdGhpcy5fdm5vZGUgPSBfdGhpcy5rZXB0O1xyXG4gICAgICAgICAgICByZXN0b3JlQWN0aXZlSW5zdGFuY2UoKTtcclxuICAgICAgICAgICAgdXBkYXRlLmNhbGwoX3RoaXMsIHZub2RlLCBoeWRyYXRpbmcpO1xyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgcmVuZGVyOiBmdW5jdGlvbiAoaCkge1xyXG4gICAgICAgIHZhciB0YWcgPSB0aGlzLnRhZyB8fCB0aGlzLiR2bm9kZS5kYXRhLnRhZyB8fCAnc3Bhbic7XHJcbiAgICAgICAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbiAgICAgICAgdmFyIHByZXZDaGlsZHJlbiA9ICh0aGlzLnByZXZDaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4pO1xyXG4gICAgICAgIHZhciByYXdDaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQgfHwgW107XHJcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gKHRoaXMuY2hpbGRyZW4gPSBbXSk7XHJcbiAgICAgICAgdmFyIHRyYW5zaXRpb25EYXRhID0gZXh0cmFjdFRyYW5zaXRpb25EYXRhKHRoaXMpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmF3Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGMgPSByYXdDaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgaWYgKGMudGFnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYy5rZXkgIT0gbnVsbCAmJiBTdHJpbmcoYy5rZXkpLmluZGV4T2YoJ19fdmxpc3QnKSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFwW2Mua2V5XSA9IGM7XHJcbiAgICAgICAgICAgICAgICAgICAgKGMuZGF0YSB8fCAoYy5kYXRhID0ge30pKS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wdHMgPSBjLmNvbXBvbmVudE9wdGlvbnM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWVfMSA9IG9wdHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBnZXRDb21wb25lbnROYW1lKG9wdHMuQ3Rvci5vcHRpb25zKSB8fCBvcHRzLnRhZyB8fCAnJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGMudGFnO1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4kMihcIjx0cmFuc2l0aW9uLWdyb3VwPiBjaGlsZHJlbiBtdXN0IGJlIGtleWVkOiA8XCIuY29uY2F0KG5hbWVfMSwgXCI+XCIpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocHJldkNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgIHZhciBrZXB0ID0gW107XHJcbiAgICAgICAgICAgIHZhciByZW1vdmVkID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJldkNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYyA9IHByZXZDaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgICAgIGMuZGF0YS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XHJcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC5nZXRCb3VuZGluZ0NsaWVudFJlY3QgaXMgbm90IHR5cGVkIGluIE5vZGVcclxuICAgICAgICAgICAgICAgIGMuZGF0YS5wb3MgPSBjLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICAgICAgICAgIGlmIChtYXBbYy5rZXldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAga2VwdC5wdXNoKGMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZC5wdXNoKGMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMua2VwdCA9IGgodGFnLCBudWxsLCBrZXB0KTtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVkID0gcmVtb3ZlZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGgodGFnLCBudWxsLCBjaGlsZHJlbik7XHJcbiAgICB9LFxyXG4gICAgdXBkYXRlZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuO1xyXG4gICAgICAgIHZhciBtb3ZlQ2xhc3MgPSB0aGlzLm1vdmVDbGFzcyB8fCAodGhpcy5uYW1lIHx8ICd2JykgKyAnLW1vdmUnO1xyXG4gICAgICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoIHx8ICF0aGlzLmhhc01vdmUoY2hpbGRyZW5bMF0uZWxtLCBtb3ZlQ2xhc3MpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gd2UgZGl2aWRlIHRoZSB3b3JrIGludG8gdGhyZWUgbG9vcHMgdG8gYXZvaWQgbWl4aW5nIERPTSByZWFkcyBhbmQgd3JpdGVzXHJcbiAgICAgICAgLy8gaW4gZWFjaCBpdGVyYXRpb24gLSB3aGljaCBoZWxwcyBwcmV2ZW50IGxheW91dCB0aHJhc2hpbmcuXHJcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjYWxsUGVuZGluZ0Nicyk7XHJcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChyZWNvcmRQb3NpdGlvbik7XHJcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChhcHBseVRyYW5zbGF0aW9uKTtcclxuICAgICAgICAvLyBmb3JjZSByZWZsb3cgdG8gcHV0IGV2ZXJ5dGhpbmcgaW4gcG9zaXRpb25cclxuICAgICAgICAvLyBhc3NpZ24gdG8gdGhpcyB0byBhdm9pZCBiZWluZyByZW1vdmVkIGluIHRyZWUtc2hha2luZ1xyXG4gICAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxyXG4gICAgICAgIHRoaXMuX3JlZmxvdyA9IGRvY3VtZW50LmJvZHkub2Zmc2V0SGVpZ2h0O1xyXG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcclxuICAgICAgICAgICAgaWYgKGMuZGF0YS5tb3ZlZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGVsXzEgPSBjLmVsbTtcclxuICAgICAgICAgICAgICAgIHZhciBzID0gZWxfMS5zdHlsZTtcclxuICAgICAgICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbF8xLCBtb3ZlQ2xhc3MpO1xyXG4gICAgICAgICAgICAgICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJyc7XHJcbiAgICAgICAgICAgICAgICBlbF8xLmFkZEV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCAoZWxfMS5fbW92ZUNiID0gZnVuY3Rpb24gY2IoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlICYmIGUudGFyZ2V0ICE9PSBlbF8xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlIHx8IC90cmFuc2Zvcm0kLy50ZXN0KGUucHJvcGVydHlOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbF8xLnJlbW92ZUV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBjYik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsXzEuX21vdmVDYiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbF8xLCBtb3ZlQ2xhc3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuICAgIG1ldGhvZHM6IHtcclxuICAgICAgICBoYXNNb3ZlOiBmdW5jdGlvbiAoZWwsIG1vdmVDbGFzcykge1xyXG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgICAgICAgaWYgKCFoYXNUcmFuc2l0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9oYXNNb3ZlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faGFzTW92ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBEZXRlY3Qgd2hldGhlciBhbiBlbGVtZW50IHdpdGggdGhlIG1vdmUgY2xhc3MgYXBwbGllZCBoYXNcclxuICAgICAgICAgICAgLy8gQ1NTIHRyYW5zaXRpb25zLiBTaW5jZSB0aGUgZWxlbWVudCBtYXkgYmUgaW5zaWRlIGFuIGVudGVyaW5nXHJcbiAgICAgICAgICAgIC8vIHRyYW5zaXRpb24gYXQgdGhpcyB2ZXJ5IG1vbWVudCwgd2UgbWFrZSBhIGNsb25lIG9mIGl0IGFuZCByZW1vdmVcclxuICAgICAgICAgICAgLy8gYWxsIG90aGVyIHRyYW5zaXRpb24gY2xhc3NlcyBhcHBsaWVkIHRvIGVuc3VyZSBvbmx5IHRoZSBtb3ZlIGNsYXNzXHJcbiAgICAgICAgICAgIC8vIGlzIGFwcGxpZWQuXHJcbiAgICAgICAgICAgIHZhciBjbG9uZSA9IGVsLmNsb25lTm9kZSgpO1xyXG4gICAgICAgICAgICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XHJcbiAgICAgICAgICAgICAgICBlbC5fdHJhbnNpdGlvbkNsYXNzZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3MoY2xvbmUsIGNscyk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhZGRDbGFzcyhjbG9uZSwgbW92ZUNsYXNzKTtcclxuICAgICAgICAgICAgY2xvbmUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgICAgICAgICAgdGhpcy4kZWwuYXBwZW5kQ2hpbGQoY2xvbmUpO1xyXG4gICAgICAgICAgICB2YXIgaW5mbyA9IGdldFRyYW5zaXRpb25JbmZvKGNsb25lKTtcclxuICAgICAgICAgICAgdGhpcy4kZWwucmVtb3ZlQ2hpbGQoY2xvbmUpO1xyXG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuX2hhc01vdmUgPSBpbmZvLmhhc1RyYW5zZm9ybSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5mdW5jdGlvbiBjYWxsUGVuZGluZ0NicyhjKSB7XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIGlmIChjLmVsbS5fbW92ZUNiKSB7XHJcbiAgICAgICAgYy5lbG0uX21vdmVDYigpO1xyXG4gICAgfVxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICBpZiAoYy5lbG0uX2VudGVyQ2IpIHtcclxuICAgICAgICBjLmVsbS5fZW50ZXJDYigpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHJlY29yZFBvc2l0aW9uKGMpIHtcclxuICAgIGMuZGF0YS5uZXdQb3MgPSBjLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxufVxyXG5mdW5jdGlvbiBhcHBseVRyYW5zbGF0aW9uKGMpIHtcclxuICAgIHZhciBvbGRQb3MgPSBjLmRhdGEucG9zO1xyXG4gICAgdmFyIG5ld1BvcyA9IGMuZGF0YS5uZXdQb3M7XHJcbiAgICB2YXIgZHggPSBvbGRQb3MubGVmdCAtIG5ld1Bvcy5sZWZ0O1xyXG4gICAgdmFyIGR5ID0gb2xkUG9zLnRvcCAtIG5ld1Bvcy50b3A7XHJcbiAgICBpZiAoZHggfHwgZHkpIHtcclxuICAgICAgICBjLmRhdGEubW92ZWQgPSB0cnVlO1xyXG4gICAgICAgIHZhciBzID0gYy5lbG0uc3R5bGU7XHJcbiAgICAgICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiLmNvbmNhdChkeCwgXCJweCxcIikuY29uY2F0KGR5LCBcInB4KVwiKTtcclxuICAgICAgICBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwcyc7XHJcbiAgICB9XHJcbn1cblxudmFyIHBsYXRmb3JtQ29tcG9uZW50cyA9IHtcclxuICAgIFRyYW5zaXRpb246IFRyYW5zaXRpb24sXHJcbiAgICBUcmFuc2l0aW9uR3JvdXA6IFRyYW5zaXRpb25Hcm91cFxyXG59O1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHNwZWNpZmljIHV0aWxzXHJcblZ1ZS5jb25maWcubXVzdFVzZVByb3AgPSBtdXN0VXNlUHJvcDtcclxuVnVlLmNvbmZpZy5pc1Jlc2VydmVkVGFnID0gaXNSZXNlcnZlZFRhZztcclxuVnVlLmNvbmZpZy5pc1Jlc2VydmVkQXR0ciA9IGlzUmVzZXJ2ZWRBdHRyO1xyXG5WdWUuY29uZmlnLmdldFRhZ05hbWVzcGFjZSA9IGdldFRhZ05hbWVzcGFjZTtcclxuVnVlLmNvbmZpZy5pc1Vua25vd25FbGVtZW50ID0gaXNVbmtub3duRWxlbWVudDtcclxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBydW50aW1lIGRpcmVjdGl2ZXMgJiBjb21wb25lbnRzXHJcbmV4dGVuZChWdWUub3B0aW9ucy5kaXJlY3RpdmVzLCBwbGF0Zm9ybURpcmVjdGl2ZXMpO1xyXG5leHRlbmQoVnVlLm9wdGlvbnMuY29tcG9uZW50cywgcGxhdGZvcm1Db21wb25lbnRzKTtcclxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBwYXRjaCBmdW5jdGlvblxyXG5WdWUucHJvdG90eXBlLl9fcGF0Y2hfXyA9IGluQnJvd3NlciA/IHBhdGNoIDogbm9vcDtcclxuLy8gcHVibGljIG1vdW50IG1ldGhvZFxyXG5WdWUucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChlbCwgaHlkcmF0aW5nKSB7XHJcbiAgICBlbCA9IGVsICYmIGluQnJvd3NlciA/IHF1ZXJ5KGVsKSA6IHVuZGVmaW5lZDtcclxuICAgIHJldHVybiBtb3VudENvbXBvbmVudCh0aGlzLCBlbCwgaHlkcmF0aW5nKTtcclxufTtcclxuLy8gZGV2dG9vbHMgZ2xvYmFsIGhvb2tcclxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuaWYgKGluQnJvd3Nlcikge1xyXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKGNvbmZpZy5kZXZ0b29scykge1xyXG4gICAgICAgICAgICBpZiAoZGV2dG9vbHMpIHtcclxuICAgICAgICAgICAgICAgIGRldnRvb2xzLmVtaXQoJ2luaXQnLCBWdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICd0ZXN0Jykge1xyXG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxyXG4gICAgICAgICAgICAgICAgY29uc29sZVtjb25zb2xlLmluZm8gPyAnaW5mbycgOiAnbG9nJ10oJ0Rvd25sb2FkIHRoZSBWdWUgRGV2dG9vbHMgZXh0ZW5zaW9uIGZvciBhIGJldHRlciBkZXZlbG9wbWVudCBleHBlcmllbmNlOlxcbicgK1xyXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlLWRldnRvb2xzJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcclxuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICd0ZXN0JyAmJlxyXG4gICAgICAgICAgICBjb25maWcucHJvZHVjdGlvblRpcCAhPT0gZmFsc2UgJiZcclxuICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcclxuICAgICAgICAgICAgY29uc29sZVtjb25zb2xlLmluZm8gPyAnaW5mbycgOiAnbG9nJ10oXCJZb3UgYXJlIHJ1bm5pbmcgVnVlIGluIGRldmVsb3BtZW50IG1vZGUuXFxuXCIgK1xyXG4gICAgICAgICAgICAgICAgXCJNYWtlIHN1cmUgdG8gdHVybiBvbiBwcm9kdWN0aW9uIG1vZGUgd2hlbiBkZXBsb3lpbmcgZm9yIHByb2R1Y3Rpb24uXFxuXCIgK1xyXG4gICAgICAgICAgICAgICAgXCJTZWUgbW9yZSB0aXBzIGF0IGh0dHBzOi8vdnVlanMub3JnL2d1aWRlL2RlcGxveW1lbnQuaHRtbFwiKTtcclxuICAgICAgICB9XHJcbiAgICB9LCAwKTtcclxufVxuXG52YXIgZGVmYXVsdFRhZ1JFID0gL1xce1xceygoPzoufFxccj9cXG4pKz8pXFx9XFx9L2c7XHJcbnZhciByZWdleEVzY2FwZVJFID0gL1stLiorP14ke30oKXxbXFxdXFwvXFxcXF0vZztcclxudmFyIGJ1aWxkUmVnZXggPSBjYWNoZWQoZnVuY3Rpb24gKGRlbGltaXRlcnMpIHtcclxuICAgIHZhciBvcGVuID0gZGVsaW1pdGVyc1swXS5yZXBsYWNlKHJlZ2V4RXNjYXBlUkUsICdcXFxcJCYnKTtcclxuICAgIHZhciBjbG9zZSA9IGRlbGltaXRlcnNbMV0ucmVwbGFjZShyZWdleEVzY2FwZVJFLCAnXFxcXCQmJyk7XHJcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChvcGVuICsgJygoPzoufFxcXFxuKSs/KScgKyBjbG9zZSwgJ2cnKTtcclxufSk7XHJcbmZ1bmN0aW9uIHBhcnNlVGV4dCh0ZXh0LCBkZWxpbWl0ZXJzKSB7XHJcbiAgICAvL0B0cy1leHBlY3QtZXJyb3JcclxuICAgIHZhciB0YWdSRSA9IGRlbGltaXRlcnMgPyBidWlsZFJlZ2V4KGRlbGltaXRlcnMpIDogZGVmYXVsdFRhZ1JFO1xyXG4gICAgaWYgKCF0YWdSRS50ZXN0KHRleHQpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdmFyIHRva2VucyA9IFtdO1xyXG4gICAgdmFyIHJhd1Rva2VucyA9IFtdO1xyXG4gICAgdmFyIGxhc3RJbmRleCA9ICh0YWdSRS5sYXN0SW5kZXggPSAwKTtcclxuICAgIHZhciBtYXRjaCwgaW5kZXgsIHRva2VuVmFsdWU7XHJcbiAgICB3aGlsZSAoKG1hdGNoID0gdGFnUkUuZXhlYyh0ZXh0KSkpIHtcclxuICAgICAgICBpbmRleCA9IG1hdGNoLmluZGV4O1xyXG4gICAgICAgIC8vIHB1c2ggdGV4dCB0b2tlblxyXG4gICAgICAgIGlmIChpbmRleCA+IGxhc3RJbmRleCkge1xyXG4gICAgICAgICAgICByYXdUb2tlbnMucHVzaCgodG9rZW5WYWx1ZSA9IHRleHQuc2xpY2UobGFzdEluZGV4LCBpbmRleCkpKTtcclxuICAgICAgICAgICAgdG9rZW5zLnB1c2goSlNPTi5zdHJpbmdpZnkodG9rZW5WYWx1ZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB0YWcgdG9rZW5cclxuICAgICAgICB2YXIgZXhwID0gcGFyc2VGaWx0ZXJzKG1hdGNoWzFdLnRyaW0oKSk7XHJcbiAgICAgICAgdG9rZW5zLnB1c2goXCJfcyhcIi5jb25jYXQoZXhwLCBcIilcIikpO1xyXG4gICAgICAgIHJhd1Rva2Vucy5wdXNoKHsgJ0BiaW5kaW5nJzogZXhwIH0pO1xyXG4gICAgICAgIGxhc3RJbmRleCA9IGluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgaWYgKGxhc3RJbmRleCA8IHRleHQubGVuZ3RoKSB7XHJcbiAgICAgICAgcmF3VG9rZW5zLnB1c2goKHRva2VuVmFsdWUgPSB0ZXh0LnNsaWNlKGxhc3RJbmRleCkpKTtcclxuICAgICAgICB0b2tlbnMucHVzaChKU09OLnN0cmluZ2lmeSh0b2tlblZhbHVlKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGV4cHJlc3Npb246IHRva2Vucy5qb2luKCcrJyksXHJcbiAgICAgICAgdG9rZW5zOiByYXdUb2tlbnNcclxuICAgIH07XHJcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtTm9kZSQxKGVsLCBvcHRpb25zKSB7XHJcbiAgICB2YXIgd2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcclxuICAgIHZhciBzdGF0aWNDbGFzcyA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdjbGFzcycpO1xyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgc3RhdGljQ2xhc3MpIHtcclxuICAgICAgICB2YXIgcmVzID0gcGFyc2VUZXh0KHN0YXRpY0NsYXNzLCBvcHRpb25zLmRlbGltaXRlcnMpO1xyXG4gICAgICAgIGlmIChyZXMpIHtcclxuICAgICAgICAgICAgd2FybihcImNsYXNzPVxcXCJcIi5jb25jYXQoc3RhdGljQ2xhc3MsIFwiXFxcIjogXCIpICtcclxuICAgICAgICAgICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xyXG4gICAgICAgICAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXHJcbiAgICAgICAgICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IGNsYXNzPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6Y2xhc3M9XCJ2YWxcIj4uJywgZWwucmF3QXR0cnNNYXBbJ2NsYXNzJ10pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChzdGF0aWNDbGFzcykge1xyXG4gICAgICAgIGVsLnN0YXRpY0NsYXNzID0gSlNPTi5zdHJpbmdpZnkoc3RhdGljQ2xhc3MucmVwbGFjZSgvXFxzKy9nLCAnICcpLnRyaW0oKSk7XHJcbiAgICB9XHJcbiAgICB2YXIgY2xhc3NCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdjbGFzcycsIGZhbHNlIC8qIGdldFN0YXRpYyAqLyk7XHJcbiAgICBpZiAoY2xhc3NCaW5kaW5nKSB7XHJcbiAgICAgICAgZWwuY2xhc3NCaW5kaW5nID0gY2xhc3NCaW5kaW5nO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdlbkRhdGEkMihlbCkge1xyXG4gICAgdmFyIGRhdGEgPSAnJztcclxuICAgIGlmIChlbC5zdGF0aWNDbGFzcykge1xyXG4gICAgICAgIGRhdGEgKz0gXCJzdGF0aWNDbGFzczpcIi5jb25jYXQoZWwuc3RhdGljQ2xhc3MsIFwiLFwiKTtcclxuICAgIH1cclxuICAgIGlmIChlbC5jbGFzc0JpbmRpbmcpIHtcclxuICAgICAgICBkYXRhICs9IFwiY2xhc3M6XCIuY29uY2F0KGVsLmNsYXNzQmluZGluZywgXCIsXCIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRhdGE7XHJcbn1cclxudmFyIGtsYXNzID0ge1xyXG4gICAgc3RhdGljS2V5czogWydzdGF0aWNDbGFzcyddLFxyXG4gICAgdHJhbnNmb3JtTm9kZTogdHJhbnNmb3JtTm9kZSQxLFxyXG4gICAgZ2VuRGF0YTogZ2VuRGF0YSQyXHJcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybU5vZGUoZWwsIG9wdGlvbnMpIHtcclxuICAgIHZhciB3YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xyXG4gICAgdmFyIHN0YXRpY1N0eWxlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3N0eWxlJyk7XHJcbiAgICBpZiAoc3RhdGljU3R5bGUpIHtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgICB2YXIgcmVzID0gcGFyc2VUZXh0KHN0YXRpY1N0eWxlLCBvcHRpb25zLmRlbGltaXRlcnMpO1xyXG4gICAgICAgICAgICBpZiAocmVzKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKFwic3R5bGU9XFxcIlwiLmNvbmNhdChzdGF0aWNTdHlsZSwgXCJcXFwiOiBcIikgK1xyXG4gICAgICAgICAgICAgICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgc3R5bGU9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDpzdHlsZT1cInZhbFwiPi4nLCBlbC5yYXdBdHRyc01hcFsnc3R5bGUnXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWwuc3RhdGljU3R5bGUgPSBKU09OLnN0cmluZ2lmeShwYXJzZVN0eWxlVGV4dChzdGF0aWNTdHlsZSkpO1xyXG4gICAgfVxyXG4gICAgdmFyIHN0eWxlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnc3R5bGUnLCBmYWxzZSAvKiBnZXRTdGF0aWMgKi8pO1xyXG4gICAgaWYgKHN0eWxlQmluZGluZykge1xyXG4gICAgICAgIGVsLnN0eWxlQmluZGluZyA9IHN0eWxlQmluZGluZztcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZW5EYXRhJDEoZWwpIHtcclxuICAgIHZhciBkYXRhID0gJyc7XHJcbiAgICBpZiAoZWwuc3RhdGljU3R5bGUpIHtcclxuICAgICAgICBkYXRhICs9IFwic3RhdGljU3R5bGU6XCIuY29uY2F0KGVsLnN0YXRpY1N0eWxlLCBcIixcIik7XHJcbiAgICB9XHJcbiAgICBpZiAoZWwuc3R5bGVCaW5kaW5nKSB7XHJcbiAgICAgICAgZGF0YSArPSBcInN0eWxlOihcIi5jb25jYXQoZWwuc3R5bGVCaW5kaW5nLCBcIiksXCIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRhdGE7XHJcbn1cclxudmFyIHN0eWxlID0ge1xyXG4gICAgc3RhdGljS2V5czogWydzdGF0aWNTdHlsZSddLFxyXG4gICAgdHJhbnNmb3JtTm9kZTogdHJhbnNmb3JtTm9kZSxcclxuICAgIGdlbkRhdGE6IGdlbkRhdGEkMVxyXG59O1xuXG52YXIgZGVjb2RlcjtcclxudmFyIGhlID0ge1xyXG4gICAgZGVjb2RlOiBmdW5jdGlvbiAoaHRtbCkge1xyXG4gICAgICAgIGRlY29kZXIgPSBkZWNvZGVyIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIGRlY29kZXIuaW5uZXJIVE1MID0gaHRtbDtcclxuICAgICAgICByZXR1cm4gZGVjb2Rlci50ZXh0Q29udGVudDtcclxuICAgIH1cclxufTtcblxudmFyIGlzVW5hcnlUYWcgPSBtYWtlTWFwKCdhcmVhLGJhc2UsYnIsY29sLGVtYmVkLGZyYW1lLGhyLGltZyxpbnB1dCxpc2luZGV4LGtleWdlbiwnICtcclxuICAgICdsaW5rLG1ldGEscGFyYW0sc291cmNlLHRyYWNrLHdicicpO1xyXG4vLyBFbGVtZW50cyB0aGF0IHlvdSBjYW4sIGludGVudGlvbmFsbHksIGxlYXZlIG9wZW5cclxuLy8gKGFuZCB3aGljaCBjbG9zZSB0aGVtc2VsdmVzKVxyXG52YXIgY2FuQmVMZWZ0T3BlblRhZyA9IG1ha2VNYXAoJ2NvbGdyb3VwLGRkLGR0LGxpLG9wdGlvbnMscCx0ZCx0Zm9vdCx0aCx0aGVhZCx0cixzb3VyY2UnKTtcclxuLy8gSFRNTDUgdGFncyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbmRpY2VzLmh0bWwjZWxlbWVudHMtM1xyXG4vLyBQaHJhc2luZyBDb250ZW50IGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2RvbS5odG1sI3BocmFzaW5nLWNvbnRlbnRcclxudmFyIGlzTm9uUGhyYXNpbmdUYWcgPSBtYWtlTWFwKCdhZGRyZXNzLGFydGljbGUsYXNpZGUsYmFzZSxibG9ja3F1b3RlLGJvZHksY2FwdGlvbixjb2wsY29sZ3JvdXAsZGQsJyArXHJcbiAgICAnZGV0YWlscyxkaWFsb2csZGl2LGRsLGR0LGZpZWxkc2V0LGZpZ2NhcHRpb24sZmlndXJlLGZvb3Rlcixmb3JtLCcgK1xyXG4gICAgJ2gxLGgyLGgzLGg0LGg1LGg2LGhlYWQsaGVhZGVyLGhncm91cCxocixodG1sLGxlZ2VuZCxsaSxtZW51aXRlbSxtZXRhLCcgK1xyXG4gICAgJ29wdGdyb3VwLG9wdGlvbixwYXJhbSxycCxydCxzb3VyY2Usc3R5bGUsc3VtbWFyeSx0Ym9keSx0ZCx0Zm9vdCx0aCx0aGVhZCwnICtcclxuICAgICd0aXRsZSx0cix0cmFjaycpO1xuXG4vKipcclxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgaXQncyBtb3N0bHkgdmVuZG9yIGNvZGUuXHJcbiAqL1xyXG4vLyBSZWd1bGFyIEV4cHJlc3Npb25zIGZvciBwYXJzaW5nIHRhZ3MgYW5kIGF0dHJpYnV0ZXNcclxudmFyIGF0dHJpYnV0ZSA9IC9eXFxzKihbXlxcc1wiJzw+XFwvPV0rKSg/OlxccyooPSlcXHMqKD86XCIoW15cIl0qKVwiK3wnKFteJ10qKScrfChbXlxcc1wiJz08PmBdKykpKT8vO1xyXG52YXIgZHluYW1pY0FyZ0F0dHJpYnV0ZSA9IC9eXFxzKigoPzp2LVtcXHctXSs6fEB8OnwjKVxcW1tePV0rP1xcXVteXFxzXCInPD5cXC89XSopKD86XFxzKig9KVxccyooPzpcIihbXlwiXSopXCIrfCcoW14nXSopJyt8KFteXFxzXCInPTw+YF0rKSkpPy87XHJcbnZhciBuY25hbWUgPSBcIlthLXpBLVpfXVtcXFxcLVxcXFwuMC05X2EtekEtWlwiLmNvbmNhdCh1bmljb2RlUmVnRXhwLnNvdXJjZSwgXCJdKlwiKTtcclxudmFyIHFuYW1lQ2FwdHVyZSA9IFwiKCg/OlwiLmNvbmNhdChuY25hbWUsIFwiXFxcXDopP1wiKS5jb25jYXQobmNuYW1lLCBcIilcIik7XHJcbnZhciBzdGFydFRhZ09wZW4gPSBuZXcgUmVnRXhwKFwiXjxcIi5jb25jYXQocW5hbWVDYXB0dXJlKSk7XHJcbnZhciBzdGFydFRhZ0Nsb3NlID0gL15cXHMqKFxcLz8pPi87XHJcbnZhciBlbmRUYWcgPSBuZXcgUmVnRXhwKFwiXjxcXFxcL1wiLmNvbmNhdChxbmFtZUNhcHR1cmUsIFwiW14+XSo+XCIpKTtcclxudmFyIGRvY3R5cGUgPSAvXjwhRE9DVFlQRSBbXj5dKz4vaTtcclxuLy8gIzcyOTg6IGVzY2FwZSAtIHRvIGF2b2lkIGJlaW5nIHBhc3NlZCBhcyBIVE1MIGNvbW1lbnQgd2hlbiBpbmxpbmVkIGluIHBhZ2VcclxudmFyIGNvbW1lbnQgPSAvXjwhXFwtLS87XHJcbnZhciBjb25kaXRpb25hbENvbW1lbnQgPSAvXjwhXFxbLztcclxuLy8gU3BlY2lhbCBFbGVtZW50cyAoY2FuIGNvbnRhaW4gYW55dGhpbmcpXHJcbnZhciBpc1BsYWluVGV4dEVsZW1lbnQgPSBtYWtlTWFwKCdzY3JpcHQsc3R5bGUsdGV4dGFyZWEnLCB0cnVlKTtcclxudmFyIHJlQ2FjaGUgPSB7fTtcclxudmFyIGRlY29kaW5nTWFwID0ge1xyXG4gICAgJyZsdDsnOiAnPCcsXHJcbiAgICAnJmd0Oyc6ICc+JyxcclxuICAgICcmcXVvdDsnOiAnXCInLFxyXG4gICAgJyZhbXA7JzogJyYnLFxyXG4gICAgJyYjMTA7JzogJ1xcbicsXHJcbiAgICAnJiM5Oyc6ICdcXHQnLFxyXG4gICAgJyYjMzk7JzogXCInXCJcclxufTtcclxudmFyIGVuY29kZWRBdHRyID0gLyYoPzpsdHxndHxxdW90fGFtcHwjMzkpOy9nO1xyXG52YXIgZW5jb2RlZEF0dHJXaXRoTmV3TGluZXMgPSAvJig/Omx0fGd0fHF1b3R8YW1wfCMzOXwjMTB8IzkpOy9nO1xyXG4vLyAjNTk5MlxyXG52YXIgaXNJZ25vcmVOZXdsaW5lVGFnID0gbWFrZU1hcCgncHJlLHRleHRhcmVhJywgdHJ1ZSk7XHJcbnZhciBzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUgPSBmdW5jdGlvbiAodGFnLCBodG1sKSB7XHJcbiAgICByZXR1cm4gdGFnICYmIGlzSWdub3JlTmV3bGluZVRhZyh0YWcpICYmIGh0bWxbMF0gPT09ICdcXG4nO1xyXG59O1xyXG5mdW5jdGlvbiBkZWNvZGVBdHRyKHZhbHVlLCBzaG91bGREZWNvZGVOZXdsaW5lcykge1xyXG4gICAgdmFyIHJlID0gc2hvdWxkRGVjb2RlTmV3bGluZXMgPyBlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyA6IGVuY29kZWRBdHRyO1xyXG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UocmUsIGZ1bmN0aW9uIChtYXRjaCkgeyByZXR1cm4gZGVjb2RpbmdNYXBbbWF0Y2hdOyB9KTtcclxufVxyXG5mdW5jdGlvbiBwYXJzZUhUTUwoaHRtbCwgb3B0aW9ucykge1xyXG4gICAgdmFyIHN0YWNrID0gW107XHJcbiAgICB2YXIgZXhwZWN0SFRNTCA9IG9wdGlvbnMuZXhwZWN0SFRNTDtcclxuICAgIHZhciBpc1VuYXJ5VGFnID0gb3B0aW9ucy5pc1VuYXJ5VGFnIHx8IG5vO1xyXG4gICAgdmFyIGNhbkJlTGVmdE9wZW5UYWcgPSBvcHRpb25zLmNhbkJlTGVmdE9wZW5UYWcgfHwgbm87XHJcbiAgICB2YXIgaW5kZXggPSAwO1xyXG4gICAgdmFyIGxhc3QsIGxhc3RUYWc7XHJcbiAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBsYXN0ID0gaHRtbDtcclxuICAgICAgICAvLyBNYWtlIHN1cmUgd2UncmUgbm90IGluIGEgcGxhaW50ZXh0IGNvbnRlbnQgZWxlbWVudCBsaWtlIHNjcmlwdC9zdHlsZVxyXG4gICAgICAgIGlmICghbGFzdFRhZyB8fCAhaXNQbGFpblRleHRFbGVtZW50KGxhc3RUYWcpKSB7XHJcbiAgICAgICAgICAgIHZhciB0ZXh0RW5kID0gaHRtbC5pbmRleE9mKCc8Jyk7XHJcbiAgICAgICAgICAgIGlmICh0ZXh0RW5kID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDb21tZW50OlxyXG4gICAgICAgICAgICAgICAgaWYgKGNvbW1lbnQudGVzdChodG1sKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb21tZW50RW5kID0gaHRtbC5pbmRleE9mKCctLT4nKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29tbWVudEVuZCA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnNob3VsZEtlZXBDb21tZW50ICYmIG9wdGlvbnMuY29tbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5jb21tZW50KGh0bWwuc3Vic3RyaW5nKDQsIGNvbW1lbnRFbmQpLCBpbmRleCwgaW5kZXggKyBjb21tZW50RW5kICsgMyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZShjb21tZW50RW5kICsgMyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db25kaXRpb25hbF9jb21tZW50I0Rvd25sZXZlbC1yZXZlYWxlZF9jb25kaXRpb25hbF9jb21tZW50XHJcbiAgICAgICAgICAgICAgICBpZiAoY29uZGl0aW9uYWxDb21tZW50LnRlc3QoaHRtbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29uZGl0aW9uYWxFbmQgPSBodG1sLmluZGV4T2YoJ10+Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmRpdGlvbmFsRW5kID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZShjb25kaXRpb25hbEVuZCArIDIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIERvY3R5cGU6XHJcbiAgICAgICAgICAgICAgICB2YXIgZG9jdHlwZU1hdGNoID0gaHRtbC5tYXRjaChkb2N0eXBlKTtcclxuICAgICAgICAgICAgICAgIGlmIChkb2N0eXBlTWF0Y2gpIHtcclxuICAgICAgICAgICAgICAgICAgICBhZHZhbmNlKGRvY3R5cGVNYXRjaFswXS5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBFbmQgdGFnOlxyXG4gICAgICAgICAgICAgICAgdmFyIGVuZFRhZ01hdGNoID0gaHRtbC5tYXRjaChlbmRUYWcpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGVuZFRhZ01hdGNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1ckluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgYWR2YW5jZShlbmRUYWdNYXRjaFswXS5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRW5kVGFnKGVuZFRhZ01hdGNoWzFdLCBjdXJJbmRleCwgaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBTdGFydCB0YWc6XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRUYWdNYXRjaCA9IHBhcnNlU3RhcnRUYWcoKTtcclxuICAgICAgICAgICAgICAgIGlmIChzdGFydFRhZ01hdGNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlU3RhcnRUYWcoc3RhcnRUYWdNYXRjaCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZElnbm9yZUZpcnN0TmV3bGluZShzdGFydFRhZ01hdGNoLnRhZ05hbWUsIGh0bWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkdmFuY2UoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHRleHQgPSB2b2lkIDAsIHJlc3QgPSB2b2lkIDAsIG5leHQgPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIGlmICh0ZXh0RW5kID49IDApIHtcclxuICAgICAgICAgICAgICAgIHJlc3QgPSBodG1sLnNsaWNlKHRleHRFbmQpO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKCFlbmRUYWcudGVzdChyZXN0KSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICFzdGFydFRhZ09wZW4udGVzdChyZXN0KSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICFjb21tZW50LnRlc3QocmVzdCkgJiZcclxuICAgICAgICAgICAgICAgICAgICAhY29uZGl0aW9uYWxDb21tZW50LnRlc3QocmVzdCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyA8IGluIHBsYWluIHRleHQsIGJlIGZvcmdpdmluZyBhbmQgdHJlYXQgaXQgYXMgdGV4dFxyXG4gICAgICAgICAgICAgICAgICAgIG5leHQgPSByZXN0LmluZGV4T2YoJzwnLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCA8IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHRFbmQgKz0gbmV4dDtcclxuICAgICAgICAgICAgICAgICAgICByZXN0ID0gaHRtbC5zbGljZSh0ZXh0RW5kKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRleHQgPSBodG1sLnN1YnN0cmluZygwLCB0ZXh0RW5kKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGV4dEVuZCA8IDApIHtcclxuICAgICAgICAgICAgICAgIHRleHQgPSBodG1sO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICBhZHZhbmNlKHRleHQubGVuZ3RoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jaGFycyAmJiB0ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLmNoYXJzKHRleHQsIGluZGV4IC0gdGV4dC5sZW5ndGgsIGluZGV4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIGVuZFRhZ0xlbmd0aF8xID0gMDtcclxuICAgICAgICAgICAgdmFyIHN0YWNrZWRUYWdfMSA9IGxhc3RUYWcudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgdmFyIHJlU3RhY2tlZFRhZyA9IHJlQ2FjaGVbc3RhY2tlZFRhZ18xXSB8fFxyXG4gICAgICAgICAgICAgICAgKHJlQ2FjaGVbc3RhY2tlZFRhZ18xXSA9IG5ldyBSZWdFeHAoJyhbXFxcXHNcXFxcU10qPykoPC8nICsgc3RhY2tlZFRhZ18xICsgJ1tePl0qPiknLCAnaScpKTtcclxuICAgICAgICAgICAgdmFyIHJlc3QgPSBodG1sLnJlcGxhY2UocmVTdGFja2VkVGFnLCBmdW5jdGlvbiAoYWxsLCB0ZXh0LCBlbmRUYWcpIHtcclxuICAgICAgICAgICAgICAgIGVuZFRhZ0xlbmd0aF8xID0gZW5kVGFnLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGlmICghaXNQbGFpblRleHRFbGVtZW50KHN0YWNrZWRUYWdfMSkgJiYgc3RhY2tlZFRhZ18xICE9PSAnbm9zY3JpcHQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHRleHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLzwhXFwtLShbXFxzXFxTXSo/KS0tPi9nLCAnJDEnKSAvLyAjNzI5OFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvPCFcXFtDREFUQVxcWyhbXFxzXFxTXSo/KV1dPi9nLCAnJDEnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUoc3RhY2tlZFRhZ18xLCB0ZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2hhcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmNoYXJzKHRleHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaW5kZXggKz0gaHRtbC5sZW5ndGggLSByZXN0Lmxlbmd0aDtcclxuICAgICAgICAgICAgaHRtbCA9IHJlc3Q7XHJcbiAgICAgICAgICAgIHBhcnNlRW5kVGFnKHN0YWNrZWRUYWdfMSwgaW5kZXggLSBlbmRUYWdMZW5ndGhfMSwgaW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaHRtbCA9PT0gbGFzdCkge1xyXG4gICAgICAgICAgICBvcHRpb25zLmNoYXJzICYmIG9wdGlvbnMuY2hhcnMoaHRtbCk7XHJcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFzdGFjay5sZW5ndGggJiYgb3B0aW9ucy53YXJuKSB7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLndhcm4oXCJNYWwtZm9ybWF0dGVkIHRhZyBhdCBlbmQgb2YgdGVtcGxhdGU6IFxcXCJcIi5jb25jYXQoaHRtbCwgXCJcXFwiXCIpLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGluZGV4ICsgaHRtbC5sZW5ndGhcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBcImJyZWFrXCI7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHdoaWxlIChodG1sKSB7XHJcbiAgICAgICAgdmFyIHN0YXRlXzEgPSBfbG9vcF8xKCk7XHJcbiAgICAgICAgaWYgKHN0YXRlXzEgPT09IFwiYnJlYWtcIilcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICAvLyBDbGVhbiB1cCBhbnkgcmVtYWluaW5nIHRhZ3NcclxuICAgIHBhcnNlRW5kVGFnKCk7XHJcbiAgICBmdW5jdGlvbiBhZHZhbmNlKG4pIHtcclxuICAgICAgICBpbmRleCArPSBuO1xyXG4gICAgICAgIGh0bWwgPSBodG1sLnN1YnN0cmluZyhuKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHBhcnNlU3RhcnRUYWcoKSB7XHJcbiAgICAgICAgdmFyIHN0YXJ0ID0gaHRtbC5tYXRjaChzdGFydFRhZ09wZW4pO1xyXG4gICAgICAgIGlmIChzdGFydCkge1xyXG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSB7XHJcbiAgICAgICAgICAgICAgICB0YWdOYW1lOiBzdGFydFsxXSxcclxuICAgICAgICAgICAgICAgIGF0dHJzOiBbXSxcclxuICAgICAgICAgICAgICAgIHN0YXJ0OiBpbmRleFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBhZHZhbmNlKHN0YXJ0WzBdLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIHZhciBlbmQgPSB2b2lkIDAsIGF0dHIgPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHdoaWxlICghKGVuZCA9IGh0bWwubWF0Y2goc3RhcnRUYWdDbG9zZSkpICYmXHJcbiAgICAgICAgICAgICAgICAoYXR0ciA9IGh0bWwubWF0Y2goZHluYW1pY0FyZ0F0dHJpYnV0ZSkgfHwgaHRtbC5tYXRjaChhdHRyaWJ1dGUpKSkge1xyXG4gICAgICAgICAgICAgICAgYXR0ci5zdGFydCA9IGluZGV4O1xyXG4gICAgICAgICAgICAgICAgYWR2YW5jZShhdHRyWzBdLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICBhdHRyLmVuZCA9IGluZGV4O1xyXG4gICAgICAgICAgICAgICAgbWF0Y2guYXR0cnMucHVzaChhdHRyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZW5kKSB7XHJcbiAgICAgICAgICAgICAgICBtYXRjaC51bmFyeVNsYXNoID0gZW5kWzFdO1xyXG4gICAgICAgICAgICAgICAgYWR2YW5jZShlbmRbMF0ubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIG1hdGNoLmVuZCA9IGluZGV4O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaGFuZGxlU3RhcnRUYWcobWF0Y2gpIHtcclxuICAgICAgICB2YXIgdGFnTmFtZSA9IG1hdGNoLnRhZ05hbWU7XHJcbiAgICAgICAgdmFyIHVuYXJ5U2xhc2ggPSBtYXRjaC51bmFyeVNsYXNoO1xyXG4gICAgICAgIGlmIChleHBlY3RIVE1MKSB7XHJcbiAgICAgICAgICAgIGlmIChsYXN0VGFnID09PSAncCcgJiYgaXNOb25QaHJhc2luZ1RhZyh0YWdOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgcGFyc2VFbmRUYWcobGFzdFRhZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNhbkJlTGVmdE9wZW5UYWcodGFnTmFtZSkgJiYgbGFzdFRhZyA9PT0gdGFnTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgcGFyc2VFbmRUYWcodGFnTmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHVuYXJ5ID0gaXNVbmFyeVRhZyh0YWdOYW1lKSB8fCAhIXVuYXJ5U2xhc2g7XHJcbiAgICAgICAgdmFyIGwgPSBtYXRjaC5hdHRycy5sZW5ndGg7XHJcbiAgICAgICAgdmFyIGF0dHJzID0gbmV3IEFycmF5KGwpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBhcmdzID0gbWF0Y2guYXR0cnNbaV07XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGFyZ3NbM10gfHwgYXJnc1s0XSB8fCBhcmdzWzVdIHx8ICcnO1xyXG4gICAgICAgICAgICB2YXIgc2hvdWxkRGVjb2RlTmV3bGluZXMgPSB0YWdOYW1lID09PSAnYScgJiYgYXJnc1sxXSA9PT0gJ2hyZWYnXHJcbiAgICAgICAgICAgICAgICA/IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmXHJcbiAgICAgICAgICAgICAgICA6IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXM7XHJcbiAgICAgICAgICAgIGF0dHJzW2ldID0ge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogYXJnc1sxXSxcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBkZWNvZGVBdHRyKHZhbHVlLCBzaG91bGREZWNvZGVOZXdsaW5lcylcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgb3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgYXR0cnNbaV0uc3RhcnQgPSBhcmdzLnN0YXJ0ICsgYXJnc1swXS5tYXRjaCgvXlxccyovKS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBhdHRyc1tpXS5lbmQgPSBhcmdzLmVuZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXVuYXJ5KSB7XHJcbiAgICAgICAgICAgIHN0YWNrLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgdGFnOiB0YWdOYW1lLFxyXG4gICAgICAgICAgICAgICAgbG93ZXJDYXNlZFRhZzogdGFnTmFtZS50b0xvd2VyQ2FzZSgpLFxyXG4gICAgICAgICAgICAgICAgYXR0cnM6IGF0dHJzLFxyXG4gICAgICAgICAgICAgICAgc3RhcnQ6IG1hdGNoLnN0YXJ0LFxyXG4gICAgICAgICAgICAgICAgZW5kOiBtYXRjaC5lbmRcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGxhc3RUYWcgPSB0YWdOYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3B0aW9ucy5zdGFydCkge1xyXG4gICAgICAgICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIGF0dHJzLCB1bmFyeSwgbWF0Y2guc3RhcnQsIG1hdGNoLmVuZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcGFyc2VFbmRUYWcodGFnTmFtZSwgc3RhcnQsIGVuZCkge1xyXG4gICAgICAgIHZhciBwb3MsIGxvd2VyQ2FzZWRUYWdOYW1lO1xyXG4gICAgICAgIGlmIChzdGFydCA9PSBudWxsKVxyXG4gICAgICAgICAgICBzdGFydCA9IGluZGV4O1xyXG4gICAgICAgIGlmIChlbmQgPT0gbnVsbClcclxuICAgICAgICAgICAgZW5kID0gaW5kZXg7XHJcbiAgICAgICAgLy8gRmluZCB0aGUgY2xvc2VzdCBvcGVuZWQgdGFnIG9mIHRoZSBzYW1lIHR5cGVcclxuICAgICAgICBpZiAodGFnTmFtZSkge1xyXG4gICAgICAgICAgICBsb3dlckNhc2VkVGFnTmFtZSA9IHRhZ05hbWUudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgZm9yIChwb3MgPSBzdGFjay5sZW5ndGggLSAxOyBwb3MgPj0gMDsgcG9zLS0pIHtcclxuICAgICAgICAgICAgICAgIGlmIChzdGFja1twb3NdLmxvd2VyQ2FzZWRUYWcgPT09IGxvd2VyQ2FzZWRUYWdOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIElmIG5vIHRhZyBuYW1lIGlzIHByb3ZpZGVkLCBjbGVhbiBzaG9wXHJcbiAgICAgICAgICAgIHBvcyA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwb3MgPj0gMCkge1xyXG4gICAgICAgICAgICAvLyBDbG9zZSBhbGwgdGhlIG9wZW4gZWxlbWVudHMsIHVwIHRoZSBzdGFja1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gc3RhY2subGVuZ3RoIC0gMTsgaSA+PSBwb3M7IGktLSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgKGkgPiBwb3MgfHwgIXRhZ05hbWUpICYmIG9wdGlvbnMud2Fybikge1xyXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMud2FybihcInRhZyA8XCIuY29uY2F0KHN0YWNrW2ldLnRhZywgXCI+IGhhcyBubyBtYXRjaGluZyBlbmQgdGFnLlwiKSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhY2tbaV0uc3RhcnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogc3RhY2tbaV0uZW5kXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5lbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmVuZChzdGFja1tpXS50YWcsIHN0YXJ0LCBlbmQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgb3BlbiBlbGVtZW50cyBmcm9tIHRoZSBzdGFja1xyXG4gICAgICAgICAgICBzdGFjay5sZW5ndGggPSBwb3M7XHJcbiAgICAgICAgICAgIGxhc3RUYWcgPSBwb3MgJiYgc3RhY2tbcG9zIC0gMV0udGFnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChsb3dlckNhc2VkVGFnTmFtZSA9PT0gJ2JyJykge1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zdGFydCkge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBbXSwgdHJ1ZSwgc3RhcnQsIGVuZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobG93ZXJDYXNlZFRhZ05hbWUgPT09ICdwJykge1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zdGFydCkge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBbXSwgZmFsc2UsIHN0YXJ0LCBlbmQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmVuZCkge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5lbmQodGFnTmFtZSwgc3RhcnQsIGVuZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxudmFyIG9uUkUgPSAvXkB8XnYtb246LztcclxudmFyIGRpclJFID0gL152LXxeQHxeOnxeIy87XHJcbnZhciBmb3JBbGlhc1JFID0gLyhbXFxzXFxTXSo/KVxccysoPzppbnxvZilcXHMrKFtcXHNcXFNdKikvO1xyXG52YXIgZm9ySXRlcmF0b3JSRSA9IC8sKFteLFxcfVxcXV0qKSg/OiwoW14sXFx9XFxdXSopKT8kLztcclxudmFyIHN0cmlwUGFyZW5zUkUgPSAvXlxcKHxcXCkkL2c7XHJcbnZhciBkeW5hbWljQXJnUkUgPSAvXlxcWy4qXFxdJC87XHJcbnZhciBhcmdSRSA9IC86KC4qKSQvO1xyXG52YXIgYmluZFJFID0gL146fF5cXC58XnYtYmluZDovO1xyXG52YXIgbW9kaWZpZXJSRSA9IC9cXC5bXi5cXF1dKyg/PVteXFxdXSokKS9nO1xyXG52YXIgc2xvdFJFID0gL152LXNsb3QoOnwkKXxeIy87XHJcbnZhciBsaW5lQnJlYWtSRSA9IC9bXFxyXFxuXS87XHJcbnZhciB3aGl0ZXNwYWNlUkUgPSAvWyBcXGZcXHRcXHJcXG5dKy9nO1xyXG52YXIgaW52YWxpZEF0dHJpYnV0ZVJFID0gL1tcXHNcIic8PlxcLz1dLztcclxudmFyIGRlY29kZUhUTUxDYWNoZWQgPSBjYWNoZWQoaGUuZGVjb2RlKTtcclxudmFyIGVtcHR5U2xvdFNjb3BlVG9rZW4gPSBcIl9lbXB0eV9cIjtcclxuLy8gY29uZmlndXJhYmxlIHN0YXRlXHJcbnZhciB3YXJuO1xyXG52YXIgZGVsaW1pdGVycztcclxudmFyIHRyYW5zZm9ybXM7XHJcbnZhciBwcmVUcmFuc2Zvcm1zO1xyXG52YXIgcG9zdFRyYW5zZm9ybXM7XHJcbnZhciBwbGF0Zm9ybUlzUHJlVGFnO1xyXG52YXIgcGxhdGZvcm1NdXN0VXNlUHJvcDtcclxudmFyIHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlO1xyXG52YXIgbWF5YmVDb21wb25lbnQ7XHJcbmZ1bmN0aW9uIGNyZWF0ZUFTVEVsZW1lbnQodGFnLCBhdHRycywgcGFyZW50KSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IDEsXHJcbiAgICAgICAgdGFnOiB0YWcsXHJcbiAgICAgICAgYXR0cnNMaXN0OiBhdHRycyxcclxuICAgICAgICBhdHRyc01hcDogbWFrZUF0dHJzTWFwKGF0dHJzKSxcclxuICAgICAgICByYXdBdHRyc01hcDoge30sXHJcbiAgICAgICAgcGFyZW50OiBwYXJlbnQsXHJcbiAgICAgICAgY2hpbGRyZW46IFtdXHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBDb252ZXJ0IEhUTUwgc3RyaW5nIHRvIEFTVC5cclxuICovXHJcbmZ1bmN0aW9uIHBhcnNlKHRlbXBsYXRlLCBvcHRpb25zKSB7XHJcbiAgICB3YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xyXG4gICAgcGxhdGZvcm1Jc1ByZVRhZyA9IG9wdGlvbnMuaXNQcmVUYWcgfHwgbm87XHJcbiAgICBwbGF0Zm9ybU11c3RVc2VQcm9wID0gb3B0aW9ucy5tdXN0VXNlUHJvcCB8fCBubztcclxuICAgIHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlID0gb3B0aW9ucy5nZXRUYWdOYW1lc3BhY2UgfHwgbm87XHJcbiAgICB2YXIgaXNSZXNlcnZlZFRhZyA9IG9wdGlvbnMuaXNSZXNlcnZlZFRhZyB8fCBubztcclxuICAgIG1heWJlQ29tcG9uZW50ID0gZnVuY3Rpb24gKGVsKSB7XHJcbiAgICAgICAgcmV0dXJuICEhKGVsLmNvbXBvbmVudCB8fFxyXG4gICAgICAgICAgICBlbC5hdHRyc01hcFsnOmlzJ10gfHxcclxuICAgICAgICAgICAgZWwuYXR0cnNNYXBbJ3YtYmluZDppcyddIHx8XHJcbiAgICAgICAgICAgICEoZWwuYXR0cnNNYXAuaXMgPyBpc1Jlc2VydmVkVGFnKGVsLmF0dHJzTWFwLmlzKSA6IGlzUmVzZXJ2ZWRUYWcoZWwudGFnKSkpO1xyXG4gICAgfTtcclxuICAgIHRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3RyYW5zZm9ybU5vZGUnKTtcclxuICAgIHByZVRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3ByZVRyYW5zZm9ybU5vZGUnKTtcclxuICAgIHBvc3RUcmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICdwb3N0VHJhbnNmb3JtTm9kZScpO1xyXG4gICAgZGVsaW1pdGVycyA9IG9wdGlvbnMuZGVsaW1pdGVycztcclxuICAgIHZhciBzdGFjayA9IFtdO1xyXG4gICAgdmFyIHByZXNlcnZlV2hpdGVzcGFjZSA9IG9wdGlvbnMucHJlc2VydmVXaGl0ZXNwYWNlICE9PSBmYWxzZTtcclxuICAgIHZhciB3aGl0ZXNwYWNlT3B0aW9uID0gb3B0aW9ucy53aGl0ZXNwYWNlO1xyXG4gICAgdmFyIHJvb3Q7XHJcbiAgICB2YXIgY3VycmVudFBhcmVudDtcclxuICAgIHZhciBpblZQcmUgPSBmYWxzZTtcclxuICAgIHZhciBpblByZSA9IGZhbHNlO1xyXG4gICAgdmFyIHdhcm5lZCA9IGZhbHNlO1xyXG4gICAgZnVuY3Rpb24gd2Fybk9uY2UobXNnLCByYW5nZSkge1xyXG4gICAgICAgIGlmICghd2FybmVkKSB7XHJcbiAgICAgICAgICAgIHdhcm5lZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHdhcm4obXNnLCByYW5nZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY2xvc2VFbGVtZW50KGVsZW1lbnQpIHtcclxuICAgICAgICB0cmltRW5kaW5nV2hpdGVzcGFjZShlbGVtZW50KTtcclxuICAgICAgICBpZiAoIWluVlByZSAmJiAhZWxlbWVudC5wcm9jZXNzZWQpIHtcclxuICAgICAgICAgICAgZWxlbWVudCA9IHByb2Nlc3NFbGVtZW50KGVsZW1lbnQsIG9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB0cmVlIG1hbmFnZW1lbnRcclxuICAgICAgICBpZiAoIXN0YWNrLmxlbmd0aCAmJiBlbGVtZW50ICE9PSByb290KSB7XHJcbiAgICAgICAgICAgIC8vIGFsbG93IHJvb3QgZWxlbWVudHMgd2l0aCB2LWlmLCB2LWVsc2UtaWYgYW5kIHYtZWxzZVxyXG4gICAgICAgICAgICBpZiAocm9vdC5pZiAmJiAoZWxlbWVudC5lbHNlaWYgfHwgZWxlbWVudC5lbHNlKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGVja1Jvb3RDb25zdHJhaW50cyhlbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGFkZElmQ29uZGl0aW9uKHJvb3QsIHtcclxuICAgICAgICAgICAgICAgICAgICBleHA6IGVsZW1lbnQuZWxzZWlmLFxyXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrOiBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuT25jZShcIkNvbXBvbmVudCB0ZW1wbGF0ZSBzaG91bGQgY29udGFpbiBleGFjdGx5IG9uZSByb290IGVsZW1lbnQuIFwiICtcclxuICAgICAgICAgICAgICAgICAgICBcIklmIHlvdSBhcmUgdXNpbmcgdi1pZiBvbiBtdWx0aXBsZSBlbGVtZW50cywgXCIgK1xyXG4gICAgICAgICAgICAgICAgICAgIFwidXNlIHYtZWxzZS1pZiB0byBjaGFpbiB0aGVtIGluc3RlYWQuXCIsIHsgc3RhcnQ6IGVsZW1lbnQuc3RhcnQgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGN1cnJlbnRQYXJlbnQgJiYgIWVsZW1lbnQuZm9yYmlkZGVuKSB7XHJcbiAgICAgICAgICAgIGlmIChlbGVtZW50LmVsc2VpZiB8fCBlbGVtZW50LmVsc2UpIHtcclxuICAgICAgICAgICAgICAgIHByb2Nlc3NJZkNvbmRpdGlvbnMoZWxlbWVudCwgY3VycmVudFBhcmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5zbG90U2NvcGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBzY29wZWQgc2xvdFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGtlZXAgaXQgaW4gdGhlIGNoaWxkcmVuIGxpc3Qgc28gdGhhdCB2LWVsc2UoLWlmKSBjb25kaXRpb25zIGNhblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGZpbmQgaXQgYXMgdGhlIHByZXYgbm9kZS5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZV8xID0gZWxlbWVudC5zbG90VGFyZ2V0IHx8ICdcImRlZmF1bHRcIic7XHJcbiAgICAgICAgICAgICAgICAgICAgKGN1cnJlbnRQYXJlbnQuc2NvcGVkU2xvdHMgfHwgKGN1cnJlbnRQYXJlbnQuc2NvcGVkU2xvdHMgPSB7fSkpW25hbWVfMV0gPSBlbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY3VycmVudFBhcmVudC5jaGlsZHJlbi5wdXNoKGVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5wYXJlbnQgPSBjdXJyZW50UGFyZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGZpbmFsIGNoaWxkcmVuIGNsZWFudXBcclxuICAgICAgICAvLyBmaWx0ZXIgb3V0IHNjb3BlZCBzbG90c1xyXG4gICAgICAgIGVsZW1lbnQuY2hpbGRyZW4gPSBlbGVtZW50LmNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gIWMuc2xvdFNjb3BlOyB9KTtcclxuICAgICAgICAvLyByZW1vdmUgdHJhaWxpbmcgd2hpdGVzcGFjZSBub2RlIGFnYWluXHJcbiAgICAgICAgdHJpbUVuZGluZ1doaXRlc3BhY2UoZWxlbWVudCk7XHJcbiAgICAgICAgLy8gY2hlY2sgcHJlIHN0YXRlXHJcbiAgICAgICAgaWYgKGVsZW1lbnQucHJlKSB7XHJcbiAgICAgICAgICAgIGluVlByZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocGxhdGZvcm1Jc1ByZVRhZyhlbGVtZW50LnRhZykpIHtcclxuICAgICAgICAgICAgaW5QcmUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYXBwbHkgcG9zdC10cmFuc2Zvcm1zXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb3N0VHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBwb3N0VHJhbnNmb3Jtc1tpXShlbGVtZW50LCBvcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiB0cmltRW5kaW5nV2hpdGVzcGFjZShlbCkge1xyXG4gICAgICAgIC8vIHJlbW92ZSB0cmFpbGluZyB3aGl0ZXNwYWNlIG5vZGVcclxuICAgICAgICBpZiAoIWluUHJlKSB7XHJcbiAgICAgICAgICAgIHZhciBsYXN0Tm9kZSA9IHZvaWQgMDtcclxuICAgICAgICAgICAgd2hpbGUgKChsYXN0Tm9kZSA9IGVsLmNoaWxkcmVuW2VsLmNoaWxkcmVuLmxlbmd0aCAtIDFdKSAmJlxyXG4gICAgICAgICAgICAgICAgbGFzdE5vZGUudHlwZSA9PT0gMyAmJlxyXG4gICAgICAgICAgICAgICAgbGFzdE5vZGUudGV4dCA9PT0gJyAnKSB7XHJcbiAgICAgICAgICAgICAgICBlbC5jaGlsZHJlbi5wb3AoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNoZWNrUm9vdENvbnN0cmFpbnRzKGVsKSB7XHJcbiAgICAgICAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnIHx8IGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xyXG4gICAgICAgICAgICB3YXJuT25jZShcIkNhbm5vdCB1c2UgPFwiLmNvbmNhdChlbC50YWcsIFwiPiBhcyBjb21wb25lbnQgcm9vdCBlbGVtZW50IGJlY2F1c2UgaXQgbWF5IFwiKSArXHJcbiAgICAgICAgICAgICAgICAnY29udGFpbiBtdWx0aXBsZSBub2Rlcy4nLCB7IHN0YXJ0OiBlbC5zdGFydCB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGVsLmF0dHJzTWFwLmhhc093blByb3BlcnR5KCd2LWZvcicpKSB7XHJcbiAgICAgICAgICAgIHdhcm5PbmNlKCdDYW5ub3QgdXNlIHYtZm9yIG9uIHN0YXRlZnVsIGNvbXBvbmVudCByb290IGVsZW1lbnQgYmVjYXVzZSAnICtcclxuICAgICAgICAgICAgICAgICdpdCByZW5kZXJzIG11bHRpcGxlIGVsZW1lbnRzLicsIGVsLnJhd0F0dHJzTWFwWyd2LWZvciddKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBwYXJzZUhUTUwodGVtcGxhdGUsIHtcclxuICAgICAgICB3YXJuOiB3YXJuLFxyXG4gICAgICAgIGV4cGVjdEhUTUw6IG9wdGlvbnMuZXhwZWN0SFRNTCxcclxuICAgICAgICBpc1VuYXJ5VGFnOiBvcHRpb25zLmlzVW5hcnlUYWcsXHJcbiAgICAgICAgY2FuQmVMZWZ0T3BlblRhZzogb3B0aW9ucy5jYW5CZUxlZnRPcGVuVGFnLFxyXG4gICAgICAgIHNob3VsZERlY29kZU5ld2xpbmVzOiBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzLFxyXG4gICAgICAgIHNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZjogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWYsXHJcbiAgICAgICAgc2hvdWxkS2VlcENvbW1lbnQ6IG9wdGlvbnMuY29tbWVudHMsXHJcbiAgICAgICAgb3V0cHV0U291cmNlUmFuZ2U6IG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UsXHJcbiAgICAgICAgc3RhcnQ6IGZ1bmN0aW9uICh0YWcsIGF0dHJzLCB1bmFyeSwgc3RhcnQsIGVuZCkge1xyXG4gICAgICAgICAgICAvLyBjaGVjayBuYW1lc3BhY2UuXHJcbiAgICAgICAgICAgIC8vIGluaGVyaXQgcGFyZW50IG5zIGlmIHRoZXJlIGlzIG9uZVxyXG4gICAgICAgICAgICB2YXIgbnMgPSAoY3VycmVudFBhcmVudCAmJiBjdXJyZW50UGFyZW50Lm5zKSB8fCBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZSh0YWcpO1xyXG4gICAgICAgICAgICAvLyBoYW5kbGUgSUUgc3ZnIGJ1Z1xyXG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgICAgICAgaWYgKGlzSUUgJiYgbnMgPT09ICdzdmcnKSB7XHJcbiAgICAgICAgICAgICAgICBhdHRycyA9IGd1YXJkSUVTVkdCdWcoYXR0cnMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gY3JlYXRlQVNURWxlbWVudCh0YWcsIGF0dHJzLCBjdXJyZW50UGFyZW50KTtcclxuICAgICAgICAgICAgaWYgKG5zKSB7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50Lm5zID0gbnM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zdGFydCA9IHN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuZW5kID0gZW5kO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQucmF3QXR0cnNNYXAgPSBlbGVtZW50LmF0dHJzTGlzdC5yZWR1Y2UoZnVuY3Rpb24gKGN1bXVsYXRlZCwgYXR0cikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdW11bGF0ZWRbYXR0ci5uYW1lXSA9IGF0dHI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdW11bGF0ZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfSwge30pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYXR0cnMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnZhbGlkQXR0cmlidXRlUkUudGVzdChhdHRyLm5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oXCJJbnZhbGlkIGR5bmFtaWMgYXJndW1lbnQgZXhwcmVzc2lvbjogYXR0cmlidXRlIG5hbWVzIGNhbm5vdCBjb250YWluIFwiICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic3BhY2VzLCBxdW90ZXMsIDwsID4sIC8gb3IgPS5cIiwgb3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGF0dHIuc3RhcnQgKyBhdHRyLm5hbWUuaW5kZXhPZihcIltcIiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBhdHRyLnN0YXJ0ICsgYXR0ci5uYW1lLmxlbmd0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpc0ZvcmJpZGRlblRhZyhlbGVtZW50KSAmJiAhaXNTZXJ2ZXJSZW5kZXJpbmcoKSkge1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5mb3JiaWRkZW4gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oJ1RlbXBsYXRlcyBzaG91bGQgb25seSBiZSByZXNwb25zaWJsZSBmb3IgbWFwcGluZyB0aGUgc3RhdGUgdG8gdGhlICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnVUkuIEF2b2lkIHBsYWNpbmcgdGFncyB3aXRoIHNpZGUtZWZmZWN0cyBpbiB5b3VyIHRlbXBsYXRlcywgc3VjaCBhcyAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCI8XCIuY29uY2F0KHRhZywgXCI+XCIpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJywgYXMgdGhleSB3aWxsIG5vdCBiZSBwYXJzZWQuJywgeyBzdGFydDogZWxlbWVudC5zdGFydCB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBhcHBseSBwcmUtdHJhbnNmb3Jtc1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByZVRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBwcmVUcmFuc2Zvcm1zW2ldKGVsZW1lbnQsIG9wdGlvbnMpIHx8IGVsZW1lbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFpblZQcmUpIHtcclxuICAgICAgICAgICAgICAgIHByb2Nlc3NQcmUoZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5wcmUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpblZQcmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwbGF0Zm9ybUlzUHJlVGFnKGVsZW1lbnQudGFnKSkge1xyXG4gICAgICAgICAgICAgICAgaW5QcmUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpblZQcmUpIHtcclxuICAgICAgICAgICAgICAgIHByb2Nlc3NSYXdBdHRycyhlbGVtZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghZWxlbWVudC5wcm9jZXNzZWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIHN0cnVjdHVyYWwgZGlyZWN0aXZlc1xyXG4gICAgICAgICAgICAgICAgcHJvY2Vzc0ZvcihlbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIHByb2Nlc3NJZihlbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIHByb2Nlc3NPbmNlKGVsZW1lbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghcm9vdCkge1xyXG4gICAgICAgICAgICAgICAgcm9vdCA9IGVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrUm9vdENvbnN0cmFpbnRzKHJvb3QpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghdW5hcnkpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBlbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaChlbGVtZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNsb3NlRWxlbWVudChlbGVtZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW5kOiBmdW5jdGlvbiAodGFnLCBzdGFydCwgZW5kKSB7XHJcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgIC8vIHBvcCBzdGFja1xyXG4gICAgICAgICAgICBzdGFjay5sZW5ndGggLT0gMTtcclxuICAgICAgICAgICAgY3VycmVudFBhcmVudCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50LmVuZCA9IGVuZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjbG9zZUVsZW1lbnQoZWxlbWVudCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjaGFyczogZnVuY3Rpb24gKHRleHQsIHN0YXJ0LCBlbmQpIHtcclxuICAgICAgICAgICAgaWYgKCFjdXJyZW50UGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0ID09PSB0ZW1wbGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuT25jZSgnQ29tcG9uZW50IHRlbXBsYXRlIHJlcXVpcmVzIGEgcm9vdCBlbGVtZW50LCByYXRoZXIgdGhhbiBqdXN0IHRleHQuJywgeyBzdGFydDogc3RhcnQgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCh0ZXh0ID0gdGV4dC50cmltKCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm5PbmNlKFwidGV4dCBcXFwiXCIuY29uY2F0KHRleHQsIFwiXFxcIiBvdXRzaWRlIHJvb3QgZWxlbWVudCB3aWxsIGJlIGlnbm9yZWQuXCIpLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIElFIHRleHRhcmVhIHBsYWNlaG9sZGVyIGJ1Z1xyXG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgICAgICAgaWYgKGlzSUUgJiZcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQudGFnID09PSAndGV4dGFyZWEnICYmXHJcbiAgICAgICAgICAgICAgICBjdXJyZW50UGFyZW50LmF0dHJzTWFwLnBsYWNlaG9sZGVyID09PSB0ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gY3VycmVudFBhcmVudC5jaGlsZHJlbjtcclxuICAgICAgICAgICAgaWYgKGluUHJlIHx8IHRleHQudHJpbSgpKSB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0ID0gaXNUZXh0VGFnKGN1cnJlbnRQYXJlbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgPyB0ZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgOiBkZWNvZGVIVE1MQ2FjaGVkKHRleHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFjaGlsZHJlbi5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgd2hpdGVzcGFjZS1vbmx5IG5vZGUgcmlnaHQgYWZ0ZXIgYW4gb3BlbmluZyB0YWdcclxuICAgICAgICAgICAgICAgIHRleHQgPSAnJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh3aGl0ZXNwYWNlT3B0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAod2hpdGVzcGFjZU9wdGlvbiA9PT0gJ2NvbmRlbnNlJykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGluIGNvbmRlbnNlIG1vZGUsIHJlbW92ZSB0aGUgd2hpdGVzcGFjZSBub2RlIGlmIGl0IGNvbnRhaW5zXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbGluZSBicmVhaywgb3RoZXJ3aXNlIGNvbmRlbnNlIHRvIGEgc2luZ2xlIHNwYWNlXHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IGxpbmVCcmVha1JFLnRlc3QodGV4dCkgPyAnJyA6ICcgJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHQgPSAnICc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0ID0gcHJlc2VydmVXaGl0ZXNwYWNlID8gJyAnIDogJyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRleHQpIHtcclxuICAgICAgICAgICAgICAgIGlmICghaW5QcmUgJiYgd2hpdGVzcGFjZU9wdGlvbiA9PT0gJ2NvbmRlbnNlJykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbmRlbnNlIGNvbnNlY3V0aXZlIHdoaXRlc3BhY2VzIGludG8gc2luZ2xlIHNwYWNlXHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSh3aGl0ZXNwYWNlUkUsICcgJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gdm9pZCAwO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gdm9pZCAwO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpblZQcmUgJiYgdGV4dCAhPT0gJyAnICYmIChyZXMgPSBwYXJzZVRleHQodGV4dCwgZGVsaW1pdGVycykpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IDIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IHJlcy5leHByZXNzaW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnM6IHJlcy50b2tlbnMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHRleHRcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGV4dCAhPT0gJyAnIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgIWNoaWxkcmVuLmxlbmd0aCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdLnRleHQgIT09ICcgJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0ZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChjaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQuc3RhcnQgPSBzdGFydDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQuZW5kID0gZW5kO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGNoaWxkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29tbWVudDogZnVuY3Rpb24gKHRleHQsIHN0YXJ0LCBlbmQpIHtcclxuICAgICAgICAgICAgLy8gYWRkaW5nIGFueXRoaW5nIGFzIGEgc2libGluZyB0byB0aGUgcm9vdCBub2RlIGlzIGZvcmJpZGRlblxyXG4gICAgICAgICAgICAvLyBjb21tZW50cyBzaG91bGQgc3RpbGwgYmUgYWxsb3dlZCwgYnV0IGlnbm9yZWRcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnRQYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAzLFxyXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IHRleHQsXHJcbiAgICAgICAgICAgICAgICAgICAgaXNDb21tZW50OiB0cnVlXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgb3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLnN0YXJ0ID0gc3RhcnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuZW5kID0gZW5kO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY3VycmVudFBhcmVudC5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJvb3Q7XHJcbn1cclxuZnVuY3Rpb24gcHJvY2Vzc1ByZShlbCkge1xyXG4gICAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LXByZScpICE9IG51bGwpIHtcclxuICAgICAgICBlbC5wcmUgPSB0cnVlO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHByb2Nlc3NSYXdBdHRycyhlbCkge1xyXG4gICAgdmFyIGxpc3QgPSBlbC5hdHRyc0xpc3Q7XHJcbiAgICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XHJcbiAgICBpZiAobGVuKSB7XHJcbiAgICAgICAgdmFyIGF0dHJzID0gKGVsLmF0dHJzID0gbmV3IEFycmF5KGxlbikpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgYXR0cnNbaV0gPSB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiBsaXN0W2ldLm5hbWUsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogSlNPTi5zdHJpbmdpZnkobGlzdFtpXS52YWx1ZSlcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKGxpc3RbaV0uc3RhcnQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgYXR0cnNbaV0uc3RhcnQgPSBsaXN0W2ldLnN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgYXR0cnNbaV0uZW5kID0gbGlzdFtpXS5lbmQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICghZWwucHJlKSB7XHJcbiAgICAgICAgLy8gbm9uIHJvb3Qgbm9kZSBpbiBwcmUgYmxvY2tzIHdpdGggbm8gYXR0cmlidXRlc1xyXG4gICAgICAgIGVsLnBsYWluID0gdHJ1ZTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBwcm9jZXNzRWxlbWVudChlbGVtZW50LCBvcHRpb25zKSB7XHJcbiAgICBwcm9jZXNzS2V5KGVsZW1lbnQpO1xyXG4gICAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBpcyBhIHBsYWluIGVsZW1lbnQgYWZ0ZXJcclxuICAgIC8vIHJlbW92aW5nIHN0cnVjdHVyYWwgYXR0cmlidXRlc1xyXG4gICAgZWxlbWVudC5wbGFpbiA9XHJcbiAgICAgICAgIWVsZW1lbnQua2V5ICYmICFlbGVtZW50LnNjb3BlZFNsb3RzICYmICFlbGVtZW50LmF0dHJzTGlzdC5sZW5ndGg7XHJcbiAgICBwcm9jZXNzUmVmKGVsZW1lbnQpO1xyXG4gICAgcHJvY2Vzc1Nsb3RDb250ZW50KGVsZW1lbnQpO1xyXG4gICAgcHJvY2Vzc1Nsb3RPdXRsZXQoZWxlbWVudCk7XHJcbiAgICBwcm9jZXNzQ29tcG9uZW50KGVsZW1lbnQpO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgZWxlbWVudCA9IHRyYW5zZm9ybXNbaV0oZWxlbWVudCwgb3B0aW9ucykgfHwgZWxlbWVudDtcclxuICAgIH1cclxuICAgIHByb2Nlc3NBdHRycyhlbGVtZW50KTtcclxuICAgIHJldHVybiBlbGVtZW50O1xyXG59XHJcbmZ1bmN0aW9uIHByb2Nlc3NLZXkoZWwpIHtcclxuICAgIHZhciBleHAgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2tleScpO1xyXG4gICAgaWYgKGV4cCkge1xyXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICAgIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcclxuICAgICAgICAgICAgICAgIHdhcm4oXCI8dGVtcGxhdGU+IGNhbm5vdCBiZSBrZXllZC4gUGxhY2UgdGhlIGtleSBvbiByZWFsIGVsZW1lbnRzIGluc3RlYWQuXCIsIGdldFJhd0JpbmRpbmdBdHRyKGVsLCAna2V5JykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlbC5mb3IpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpdGVyYXRvciA9IGVsLml0ZXJhdG9yMiB8fCBlbC5pdGVyYXRvcjE7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50XzEgPSBlbC5wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXRlcmF0b3IgJiZcclxuICAgICAgICAgICAgICAgICAgICBpdGVyYXRvciA9PT0gZXhwICYmXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50XzEgJiZcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRfMS50YWcgPT09ICd0cmFuc2l0aW9uLWdyb3VwJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oXCJEbyBub3QgdXNlIHYtZm9yIGluZGV4IGFzIGtleSBvbiA8dHJhbnNpdGlvbi1ncm91cD4gY2hpbGRyZW4sIFwiICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0aGlzIGlzIHRoZSBzYW1lIGFzIG5vdCB1c2luZyBrZXlzLlwiLCBnZXRSYXdCaW5kaW5nQXR0cihlbCwgJ2tleScpLCB0cnVlIC8qIHRpcCAqLyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWwua2V5ID0gZXhwO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHByb2Nlc3NSZWYoZWwpIHtcclxuICAgIHZhciByZWYgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3JlZicpO1xyXG4gICAgaWYgKHJlZikge1xyXG4gICAgICAgIGVsLnJlZiA9IHJlZjtcclxuICAgICAgICBlbC5yZWZJbkZvciA9IGNoZWNrSW5Gb3IoZWwpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHByb2Nlc3NGb3IoZWwpIHtcclxuICAgIHZhciBleHA7XHJcbiAgICBpZiAoKGV4cCA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWZvcicpKSkge1xyXG4gICAgICAgIHZhciByZXMgPSBwYXJzZUZvcihleHApO1xyXG4gICAgICAgIGlmIChyZXMpIHtcclxuICAgICAgICAgICAgZXh0ZW5kKGVsLCByZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHdhcm4oXCJJbnZhbGlkIHYtZm9yIGV4cHJlc3Npb246IFwiLmNvbmNhdChleHApLCBlbC5yYXdBdHRyc01hcFsndi1mb3InXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHBhcnNlRm9yKGV4cCkge1xyXG4gICAgdmFyIGluTWF0Y2ggPSBleHAubWF0Y2goZm9yQWxpYXNSRSk7XHJcbiAgICBpZiAoIWluTWF0Y2gpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgdmFyIHJlcyA9IHt9O1xyXG4gICAgcmVzLmZvciA9IGluTWF0Y2hbMl0udHJpbSgpO1xyXG4gICAgdmFyIGFsaWFzID0gaW5NYXRjaFsxXS50cmltKCkucmVwbGFjZShzdHJpcFBhcmVuc1JFLCAnJyk7XHJcbiAgICB2YXIgaXRlcmF0b3JNYXRjaCA9IGFsaWFzLm1hdGNoKGZvckl0ZXJhdG9yUkUpO1xyXG4gICAgaWYgKGl0ZXJhdG9yTWF0Y2gpIHtcclxuICAgICAgICByZXMuYWxpYXMgPSBhbGlhcy5yZXBsYWNlKGZvckl0ZXJhdG9yUkUsICcnKS50cmltKCk7XHJcbiAgICAgICAgcmVzLml0ZXJhdG9yMSA9IGl0ZXJhdG9yTWF0Y2hbMV0udHJpbSgpO1xyXG4gICAgICAgIGlmIChpdGVyYXRvck1hdGNoWzJdKSB7XHJcbiAgICAgICAgICAgIHJlcy5pdGVyYXRvcjIgPSBpdGVyYXRvck1hdGNoWzJdLnRyaW0oKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXMuYWxpYXMgPSBhbGlhcztcclxuICAgIH1cclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuZnVuY3Rpb24gcHJvY2Vzc0lmKGVsKSB7XHJcbiAgICB2YXIgZXhwID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtaWYnKTtcclxuICAgIGlmIChleHApIHtcclxuICAgICAgICBlbC5pZiA9IGV4cDtcclxuICAgICAgICBhZGRJZkNvbmRpdGlvbihlbCwge1xyXG4gICAgICAgICAgICBleHA6IGV4cCxcclxuICAgICAgICAgICAgYmxvY2s6IGVsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZScpICE9IG51bGwpIHtcclxuICAgICAgICAgICAgZWwuZWxzZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBlbHNlaWYgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlLWlmJyk7XHJcbiAgICAgICAgaWYgKGVsc2VpZikge1xyXG4gICAgICAgICAgICBlbC5lbHNlaWYgPSBlbHNlaWY7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHByb2Nlc3NJZkNvbmRpdGlvbnMoZWwsIHBhcmVudCkge1xyXG4gICAgdmFyIHByZXYgPSBmaW5kUHJldkVsZW1lbnQocGFyZW50LmNoaWxkcmVuKTtcclxuICAgIGlmIChwcmV2ICYmIHByZXYuaWYpIHtcclxuICAgICAgICBhZGRJZkNvbmRpdGlvbihwcmV2LCB7XHJcbiAgICAgICAgICAgIGV4cDogZWwuZWxzZWlmLFxyXG4gICAgICAgICAgICBibG9jazogZWxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICB3YXJuKFwidi1cIi5jb25jYXQoZWwuZWxzZWlmID8gJ2Vsc2UtaWY9XCInICsgZWwuZWxzZWlmICsgJ1wiJyA6ICdlbHNlJywgXCIgXCIpICtcclxuICAgICAgICAgICAgXCJ1c2VkIG9uIGVsZW1lbnQgPFwiLmNvbmNhdChlbC50YWcsIFwiPiB3aXRob3V0IGNvcnJlc3BvbmRpbmcgdi1pZi5cIiksIGVsLnJhd0F0dHJzTWFwW2VsLmVsc2VpZiA/ICd2LWVsc2UtaWYnIDogJ3YtZWxzZSddKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBmaW5kUHJldkVsZW1lbnQoY2hpbGRyZW4pIHtcclxuICAgIHZhciBpID0gY2hpbGRyZW4ubGVuZ3RoO1xyXG4gICAgd2hpbGUgKGktLSkge1xyXG4gICAgICAgIGlmIChjaGlsZHJlbltpXS50eXBlID09PSAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjaGlsZHJlbltpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNoaWxkcmVuW2ldLnRleHQgIT09ICcgJykge1xyXG4gICAgICAgICAgICAgICAgd2FybihcInRleHQgXFxcIlwiLmNvbmNhdChjaGlsZHJlbltpXS50ZXh0LnRyaW0oKSwgXCJcXFwiIGJldHdlZW4gdi1pZiBhbmQgdi1lbHNlKC1pZikgXCIpICtcclxuICAgICAgICAgICAgICAgICAgICBcIndpbGwgYmUgaWdub3JlZC5cIiwgY2hpbGRyZW5baV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNoaWxkcmVuLnBvcCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBhZGRJZkNvbmRpdGlvbihlbCwgY29uZGl0aW9uKSB7XHJcbiAgICBpZiAoIWVsLmlmQ29uZGl0aW9ucykge1xyXG4gICAgICAgIGVsLmlmQ29uZGl0aW9ucyA9IFtdO1xyXG4gICAgfVxyXG4gICAgZWwuaWZDb25kaXRpb25zLnB1c2goY29uZGl0aW9uKTtcclxufVxyXG5mdW5jdGlvbiBwcm9jZXNzT25jZShlbCkge1xyXG4gICAgdmFyIG9uY2UgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1vbmNlJyk7XHJcbiAgICBpZiAob25jZSAhPSBudWxsKSB7XHJcbiAgICAgICAgZWwub25jZSA9IHRydWU7XHJcbiAgICB9XHJcbn1cclxuLy8gaGFuZGxlIGNvbnRlbnQgYmVpbmcgcGFzc2VkIHRvIGEgY29tcG9uZW50IGFzIHNsb3QsXHJcbi8vIGUuZy4gPHRlbXBsYXRlIHNsb3Q9XCJ4eHhcIj4sIDxkaXYgc2xvdC1zY29wZT1cInh4eFwiPlxyXG5mdW5jdGlvbiBwcm9jZXNzU2xvdENvbnRlbnQoZWwpIHtcclxuICAgIHZhciBzbG90U2NvcGU7XHJcbiAgICBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnKSB7XHJcbiAgICAgICAgc2xvdFNjb3BlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Njb3BlJyk7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgc2xvdFNjb3BlKSB7XHJcbiAgICAgICAgICAgIHdhcm4oXCJ0aGUgXFxcInNjb3BlXFxcIiBhdHRyaWJ1dGUgZm9yIHNjb3BlZCBzbG90cyBoYXZlIGJlZW4gZGVwcmVjYXRlZCBhbmQgXCIgK1xyXG4gICAgICAgICAgICAgICAgXCJyZXBsYWNlZCBieSBcXFwic2xvdC1zY29wZVxcXCIgc2luY2UgMi41LiBUaGUgbmV3IFxcXCJzbG90LXNjb3BlXFxcIiBhdHRyaWJ1dGUgXCIgK1xyXG4gICAgICAgICAgICAgICAgXCJjYW4gYWxzbyBiZSB1c2VkIG9uIHBsYWluIGVsZW1lbnRzIGluIGFkZGl0aW9uIHRvIDx0ZW1wbGF0ZT4gdG8gXCIgK1xyXG4gICAgICAgICAgICAgICAgXCJkZW5vdGUgc2NvcGVkIHNsb3RzLlwiLCBlbC5yYXdBdHRyc01hcFsnc2NvcGUnXSwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsLnNsb3RTY29wZSA9IHNsb3RTY29wZSB8fCBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc2xvdC1zY29wZScpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoKHNsb3RTY29wZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzbG90LXNjb3BlJykpKSB7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZWwuYXR0cnNNYXBbJ3YtZm9yJ10pIHtcclxuICAgICAgICAgICAgd2FybihcIkFtYmlndW91cyBjb21iaW5lZCB1c2FnZSBvZiBzbG90LXNjb3BlIGFuZCB2LWZvciBvbiA8XCIuY29uY2F0KGVsLnRhZywgXCI+IFwiKSArXHJcbiAgICAgICAgICAgICAgICBcIih2LWZvciB0YWtlcyBoaWdoZXIgcHJpb3JpdHkpLiBVc2UgYSB3cmFwcGVyIDx0ZW1wbGF0ZT4gZm9yIHRoZSBcIiArXHJcbiAgICAgICAgICAgICAgICBcInNjb3BlZCBzbG90IHRvIG1ha2UgaXQgY2xlYXJlci5cIiwgZWwucmF3QXR0cnNNYXBbJ3Nsb3Qtc2NvcGUnXSwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsLnNsb3RTY29wZSA9IHNsb3RTY29wZTtcclxuICAgIH1cclxuICAgIC8vIHNsb3Q9XCJ4eHhcIlxyXG4gICAgdmFyIHNsb3RUYXJnZXQgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3Nsb3QnKTtcclxuICAgIGlmIChzbG90VGFyZ2V0KSB7XHJcbiAgICAgICAgZWwuc2xvdFRhcmdldCA9IHNsb3RUYXJnZXQgPT09ICdcIlwiJyA/ICdcImRlZmF1bHRcIicgOiBzbG90VGFyZ2V0O1xyXG4gICAgICAgIGVsLnNsb3RUYXJnZXREeW5hbWljID0gISEoZWwuYXR0cnNNYXBbJzpzbG90J10gfHwgZWwuYXR0cnNNYXBbJ3YtYmluZDpzbG90J10pO1xyXG4gICAgICAgIC8vIHByZXNlcnZlIHNsb3QgYXMgYW4gYXR0cmlidXRlIGZvciBuYXRpdmUgc2hhZG93IERPTSBjb21wYXRcclxuICAgICAgICAvLyBvbmx5IGZvciBub24tc2NvcGVkIHNsb3RzLlxyXG4gICAgICAgIGlmIChlbC50YWcgIT09ICd0ZW1wbGF0ZScgJiYgIWVsLnNsb3RTY29wZSkge1xyXG4gICAgICAgICAgICBhZGRBdHRyKGVsLCAnc2xvdCcsIHNsb3RUYXJnZXQsIGdldFJhd0JpbmRpbmdBdHRyKGVsLCAnc2xvdCcpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyAyLjYgdi1zbG90IHN5bnRheFxyXG4gICAge1xyXG4gICAgICAgIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcclxuICAgICAgICAgICAgLy8gdi1zbG90IG9uIDx0ZW1wbGF0ZT5cclxuICAgICAgICAgICAgdmFyIHNsb3RCaW5kaW5nID0gZ2V0QW5kUmVtb3ZlQXR0ckJ5UmVnZXgoZWwsIHNsb3RSRSk7XHJcbiAgICAgICAgICAgIGlmIChzbG90QmluZGluZykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZWwuc2xvdFRhcmdldCB8fCBlbC5zbG90U2NvcGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybihcIlVuZXhwZWN0ZWQgbWl4ZWQgdXNhZ2Ugb2YgZGlmZmVyZW50IHNsb3Qgc3ludGF4ZXMuXCIsIGVsKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsLnBhcmVudCAmJiAhbWF5YmVDb21wb25lbnQoZWwucGFyZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuKFwiPHRlbXBsYXRlIHYtc2xvdD4gY2FuIG9ubHkgYXBwZWFyIGF0IHRoZSByb290IGxldmVsIGluc2lkZSBcIiArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInRoZSByZWNlaXZpbmcgY29tcG9uZW50XCIsIGVsKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBnZXRTbG90TmFtZShzbG90QmluZGluZyksIG5hbWVfMiA9IF9hLm5hbWUsIGR5bmFtaWMgPSBfYS5keW5hbWljO1xyXG4gICAgICAgICAgICAgICAgZWwuc2xvdFRhcmdldCA9IG5hbWVfMjtcclxuICAgICAgICAgICAgICAgIGVsLnNsb3RUYXJnZXREeW5hbWljID0gZHluYW1pYztcclxuICAgICAgICAgICAgICAgIGVsLnNsb3RTY29wZSA9IHNsb3RCaW5kaW5nLnZhbHVlIHx8IGVtcHR5U2xvdFNjb3BlVG9rZW47IC8vIGZvcmNlIGl0IGludG8gYSBzY29wZWQgc2xvdCBmb3IgcGVyZlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyB2LXNsb3Qgb24gY29tcG9uZW50LCBkZW5vdGVzIGRlZmF1bHQgc2xvdFxyXG4gICAgICAgICAgICB2YXIgc2xvdEJpbmRpbmcgPSBnZXRBbmRSZW1vdmVBdHRyQnlSZWdleChlbCwgc2xvdFJFKTtcclxuICAgICAgICAgICAgaWYgKHNsb3RCaW5kaW5nKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbWF5YmVDb21wb25lbnQoZWwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oXCJ2LXNsb3QgY2FuIG9ubHkgYmUgdXNlZCBvbiBjb21wb25lbnRzIG9yIDx0ZW1wbGF0ZT4uXCIsIHNsb3RCaW5kaW5nKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsLnNsb3RTY29wZSB8fCBlbC5zbG90VGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oXCJVbmV4cGVjdGVkIG1peGVkIHVzYWdlIG9mIGRpZmZlcmVudCBzbG90IHN5bnRheGVzLlwiLCBlbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbC5zY29wZWRTbG90cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuKFwiVG8gYXZvaWQgc2NvcGUgYW1iaWd1aXR5LCB0aGUgZGVmYXVsdCBzbG90IHNob3VsZCBhbHNvIHVzZSBcIiArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIjx0ZW1wbGF0ZT4gc3ludGF4IHdoZW4gdGhlcmUgYXJlIG90aGVyIG5hbWVkIHNsb3RzLlwiLCBzbG90QmluZGluZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gYWRkIHRoZSBjb21wb25lbnQncyBjaGlsZHJlbiB0byBpdHMgZGVmYXVsdCBzbG90XHJcbiAgICAgICAgICAgICAgICB2YXIgc2xvdHMgPSBlbC5zY29wZWRTbG90cyB8fCAoZWwuc2NvcGVkU2xvdHMgPSB7fSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2IgPSBnZXRTbG90TmFtZShzbG90QmluZGluZyksIG5hbWVfMyA9IF9iLm5hbWUsIGR5bmFtaWMgPSBfYi5keW5hbWljO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNsb3RDb250YWluZXJfMSA9IChzbG90c1tuYW1lXzNdID0gY3JlYXRlQVNURWxlbWVudCgndGVtcGxhdGUnLCBbXSwgZWwpKTtcclxuICAgICAgICAgICAgICAgIHNsb3RDb250YWluZXJfMS5zbG90VGFyZ2V0ID0gbmFtZV8zO1xyXG4gICAgICAgICAgICAgICAgc2xvdENvbnRhaW5lcl8xLnNsb3RUYXJnZXREeW5hbWljID0gZHluYW1pYztcclxuICAgICAgICAgICAgICAgIHNsb3RDb250YWluZXJfMS5jaGlsZHJlbiA9IGVsLmNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoYykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghYy5zbG90U2NvcGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYy5wYXJlbnQgPSBzbG90Q29udGFpbmVyXzE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgc2xvdENvbnRhaW5lcl8xLnNsb3RTY29wZSA9IHNsb3RCaW5kaW5nLnZhbHVlIHx8IGVtcHR5U2xvdFNjb3BlVG9rZW47XHJcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgY2hpbGRyZW4gYXMgdGhleSBhcmUgcmV0dXJuZWQgZnJvbSBzY29wZWRTbG90cyBub3dcclxuICAgICAgICAgICAgICAgIGVsLmNoaWxkcmVuID0gW107XHJcbiAgICAgICAgICAgICAgICAvLyBtYXJrIGVsIG5vbi1wbGFpbiBzbyBkYXRhIGdldHMgZ2VuZXJhdGVkXHJcbiAgICAgICAgICAgICAgICBlbC5wbGFpbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldFNsb3ROYW1lKGJpbmRpbmcpIHtcclxuICAgIHZhciBuYW1lID0gYmluZGluZy5uYW1lLnJlcGxhY2Uoc2xvdFJFLCAnJyk7XHJcbiAgICBpZiAoIW5hbWUpIHtcclxuICAgICAgICBpZiAoYmluZGluZy5uYW1lWzBdICE9PSAnIycpIHtcclxuICAgICAgICAgICAgbmFtZSA9ICdkZWZhdWx0JztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgICB3YXJuKFwidi1zbG90IHNob3J0aGFuZCBzeW50YXggcmVxdWlyZXMgYSBzbG90IG5hbWUuXCIsIGJpbmRpbmcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBkeW5hbWljQXJnUkUudGVzdChuYW1lKVxyXG4gICAgICAgID8gLy8gZHluYW1pYyBbbmFtZV1cclxuICAgICAgICAgICAgeyBuYW1lOiBuYW1lLnNsaWNlKDEsIC0xKSwgZHluYW1pYzogdHJ1ZSB9XHJcbiAgICAgICAgOiAvLyBzdGF0aWMgbmFtZVxyXG4gICAgICAgICAgICB7IG5hbWU6IFwiXFxcIlwiLmNvbmNhdChuYW1lLCBcIlxcXCJcIiksIGR5bmFtaWM6IGZhbHNlIH07XHJcbn1cclxuLy8gaGFuZGxlIDxzbG90Lz4gb3V0bGV0c1xyXG5mdW5jdGlvbiBwcm9jZXNzU2xvdE91dGxldChlbCkge1xyXG4gICAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XHJcbiAgICAgICAgZWwuc2xvdE5hbWUgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ25hbWUnKTtcclxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBlbC5rZXkpIHtcclxuICAgICAgICAgICAgd2FybihcImBrZXlgIGRvZXMgbm90IHdvcmsgb24gPHNsb3Q+IGJlY2F1c2Ugc2xvdHMgYXJlIGFic3RyYWN0IG91dGxldHMgXCIgK1xyXG4gICAgICAgICAgICAgICAgXCJhbmQgY2FuIHBvc3NpYmx5IGV4cGFuZCBpbnRvIG11bHRpcGxlIGVsZW1lbnRzLiBcIiArXHJcbiAgICAgICAgICAgICAgICBcIlVzZSB0aGUga2V5IG9uIGEgd3JhcHBpbmcgZWxlbWVudCBpbnN0ZWFkLlwiLCBnZXRSYXdCaW5kaW5nQXR0cihlbCwgJ2tleScpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcHJvY2Vzc0NvbXBvbmVudChlbCkge1xyXG4gICAgdmFyIGJpbmRpbmc7XHJcbiAgICBpZiAoKGJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2lzJykpKSB7XHJcbiAgICAgICAgZWwuY29tcG9uZW50ID0gYmluZGluZztcclxuICAgIH1cclxuICAgIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAnaW5saW5lLXRlbXBsYXRlJykgIT0gbnVsbCkge1xyXG4gICAgICAgIGVsLmlubGluZVRlbXBsYXRlID0gdHJ1ZTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBwcm9jZXNzQXR0cnMoZWwpIHtcclxuICAgIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xyXG4gICAgdmFyIGksIGwsIG5hbWUsIHJhd05hbWUsIHZhbHVlLCBtb2RpZmllcnMsIHN5bmNHZW4sIGlzRHluYW1pYztcclxuICAgIGZvciAoaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIG5hbWUgPSByYXdOYW1lID0gbGlzdFtpXS5uYW1lO1xyXG4gICAgICAgIHZhbHVlID0gbGlzdFtpXS52YWx1ZTtcclxuICAgICAgICBpZiAoZGlyUkUudGVzdChuYW1lKSkge1xyXG4gICAgICAgICAgICAvLyBtYXJrIGVsZW1lbnQgYXMgZHluYW1pY1xyXG4gICAgICAgICAgICBlbC5oYXNCaW5kaW5ncyA9IHRydWU7XHJcbiAgICAgICAgICAgIC8vIG1vZGlmaWVyc1xyXG4gICAgICAgICAgICBtb2RpZmllcnMgPSBwYXJzZU1vZGlmaWVycyhuYW1lLnJlcGxhY2UoZGlyUkUsICcnKSk7XHJcbiAgICAgICAgICAgIC8vIHN1cHBvcnQgLmZvbyBzaG9ydGhhbmQgc3ludGF4IGZvciB0aGUgLnByb3AgbW9kaWZpZXJcclxuICAgICAgICAgICAgaWYgKG1vZGlmaWVycykge1xyXG4gICAgICAgICAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShtb2RpZmllclJFLCAnJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGJpbmRSRS50ZXN0KG5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB2LWJpbmRcclxuICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoYmluZFJFLCAnJyk7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlRmlsdGVycyh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBpc0R5bmFtaWMgPSBkeW5hbWljQXJnUkUudGVzdChuYW1lKTtcclxuICAgICAgICAgICAgICAgIGlmIChpc0R5bmFtaWMpIHtcclxuICAgICAgICAgICAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZSgxLCAtMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB2YWx1ZS50cmltKCkubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybihcIlRoZSB2YWx1ZSBmb3IgYSB2LWJpbmQgZXhwcmVzc2lvbiBjYW5ub3QgYmUgZW1wdHkuIEZvdW5kIGluIFxcXCJ2LWJpbmQ6XCIuY29uY2F0KG5hbWUsIFwiXFxcIlwiKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobW9kaWZpZXJzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGlmaWVycy5wcm9wICYmICFpc0R5bmFtaWMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IGNhbWVsaXplKG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2lubmVySHRtbCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gJ2lubmVySFRNTCc7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RpZmllcnMuY2FtZWwgJiYgIWlzRHluYW1pYykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gY2FtZWxpemUobmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RpZmllcnMuc3luYykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzeW5jR2VuID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIFwiJGV2ZW50XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzRHluYW1pYykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkSGFuZGxlcihlbCwgXCJ1cGRhdGU6XCIuY29uY2F0KGNhbWVsaXplKG5hbWUpKSwgc3luY0dlbiwgbnVsbCwgZmFsc2UsIHdhcm4sIGxpc3RbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGh5cGhlbmF0ZShuYW1lKSAhPT0gY2FtZWxpemUobmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRIYW5kbGVyKGVsLCBcInVwZGF0ZTpcIi5jb25jYXQoaHlwaGVuYXRlKG5hbWUpKSwgc3luY0dlbiwgbnVsbCwgZmFsc2UsIHdhcm4sIGxpc3RbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGFuZGxlciB3LyBkeW5hbWljIGV2ZW50IG5hbWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZEhhbmRsZXIoZWwsIFwiXFxcInVwZGF0ZTpcXFwiKyhcIi5jb25jYXQobmFtZSwgXCIpXCIpLCBzeW5jR2VuLCBudWxsLCBmYWxzZSwgd2FybiwgbGlzdFtpXSwgdHJ1ZSAvLyBkeW5hbWljXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKChtb2RpZmllcnMgJiYgbW9kaWZpZXJzLnByb3ApIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKCFlbC5jb21wb25lbnQgJiYgcGxhdGZvcm1NdXN0VXNlUHJvcChlbC50YWcsIGVsLmF0dHJzTWFwLnR5cGUsIG5hbWUpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZFByb3AoZWwsIG5hbWUsIHZhbHVlLCBsaXN0W2ldLCBpc0R5bmFtaWMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkQXR0cihlbCwgbmFtZSwgdmFsdWUsIGxpc3RbaV0sIGlzRHluYW1pYyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAob25SRS50ZXN0KG5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB2LW9uXHJcbiAgICAgICAgICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG9uUkUsICcnKTtcclxuICAgICAgICAgICAgICAgIGlzRHluYW1pYyA9IGR5bmFtaWNBcmdSRS50ZXN0KG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzRHluYW1pYykge1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDEsIC0xKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGFkZEhhbmRsZXIoZWwsIG5hbWUsIHZhbHVlLCBtb2RpZmllcnMsIGZhbHNlLCB3YXJuLCBsaXN0W2ldLCBpc0R5bmFtaWMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gbm9ybWFsIGRpcmVjdGl2ZXNcclxuICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoZGlyUkUsICcnKTtcclxuICAgICAgICAgICAgICAgIC8vIHBhcnNlIGFyZ1xyXG4gICAgICAgICAgICAgICAgdmFyIGFyZ01hdGNoID0gbmFtZS5tYXRjaChhcmdSRSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXJnID0gYXJnTWF0Y2ggJiYgYXJnTWF0Y2hbMV07XHJcbiAgICAgICAgICAgICAgICBpc0R5bmFtaWMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGlmIChhcmcpIHtcclxuICAgICAgICAgICAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZSgwLCAtKGFyZy5sZW5ndGggKyAxKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGR5bmFtaWNBcmdSRS50ZXN0KGFyZykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnID0gYXJnLnNsaWNlKDEsIC0xKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNEeW5hbWljID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBhZGREaXJlY3RpdmUoZWwsIG5hbWUsIHJhd05hbWUsIHZhbHVlLCBhcmcsIGlzRHluYW1pYywgbW9kaWZpZXJzLCBsaXN0W2ldKTtcclxuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG5hbWUgPT09ICdtb2RlbCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBjaGVja0ZvckFsaWFzTW9kZWwoZWwsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gbGl0ZXJhbCBhdHRyaWJ1dGVcclxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZXMgPSBwYXJzZVRleHQodmFsdWUsIGRlbGltaXRlcnMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oXCJcIi5jb25jYXQobmFtZSwgXCI9XFxcIlwiKS5jb25jYXQodmFsdWUsIFwiXFxcIjogXCIpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IGlkPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6aWQ9XCJ2YWxcIj4uJywgbGlzdFtpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYWRkQXR0cihlbCwgbmFtZSwgSlNPTi5zdHJpbmdpZnkodmFsdWUpLCBsaXN0W2ldKTtcclxuICAgICAgICAgICAgLy8gIzY4ODcgZmlyZWZveCBkb2Vzbid0IHVwZGF0ZSBtdXRlZCBzdGF0ZSBpZiBzZXQgdmlhIGF0dHJpYnV0ZVxyXG4gICAgICAgICAgICAvLyBldmVuIGltbWVkaWF0ZWx5IGFmdGVyIGVsZW1lbnQgY3JlYXRpb25cclxuICAgICAgICAgICAgaWYgKCFlbC5jb21wb25lbnQgJiZcclxuICAgICAgICAgICAgICAgIG5hbWUgPT09ICdtdXRlZCcgJiZcclxuICAgICAgICAgICAgICAgIHBsYXRmb3JtTXVzdFVzZVByb3AoZWwudGFnLCBlbC5hdHRyc01hcC50eXBlLCBuYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgYWRkUHJvcChlbCwgbmFtZSwgJ3RydWUnLCBsaXN0W2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjaGVja0luRm9yKGVsKSB7XHJcbiAgICB2YXIgcGFyZW50ID0gZWw7XHJcbiAgICB3aGlsZSAocGFyZW50KSB7XHJcbiAgICAgICAgaWYgKHBhcmVudC5mb3IgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBwYXJzZU1vZGlmaWVycyhuYW1lKSB7XHJcbiAgICB2YXIgbWF0Y2ggPSBuYW1lLm1hdGNoKG1vZGlmaWVyUkUpO1xyXG4gICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgICAgdmFyIHJldF8xID0ge307XHJcbiAgICAgICAgbWF0Y2guZm9yRWFjaChmdW5jdGlvbiAobSkge1xyXG4gICAgICAgICAgICByZXRfMVttLnNsaWNlKDEpXSA9IHRydWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJldF8xO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIG1ha2VBdHRyc01hcChhdHRycykge1xyXG4gICAgdmFyIG1hcCA9IHt9O1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdHRycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBtYXBbYXR0cnNbaV0ubmFtZV0gJiYgIWlzSUUgJiYgIWlzRWRnZSkge1xyXG4gICAgICAgICAgICB3YXJuKCdkdXBsaWNhdGUgYXR0cmlidXRlOiAnICsgYXR0cnNbaV0ubmFtZSwgYXR0cnNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtYXBbYXR0cnNbaV0ubmFtZV0gPSBhdHRyc1tpXS52YWx1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBtYXA7XHJcbn1cclxuLy8gZm9yIHNjcmlwdCAoZS5nLiB0eXBlPVwieC90ZW1wbGF0ZVwiKSBvciBzdHlsZSwgZG8gbm90IGRlY29kZSBjb250ZW50XHJcbmZ1bmN0aW9uIGlzVGV4dFRhZyhlbCkge1xyXG4gICAgcmV0dXJuIGVsLnRhZyA9PT0gJ3NjcmlwdCcgfHwgZWwudGFnID09PSAnc3R5bGUnO1xyXG59XHJcbmZ1bmN0aW9uIGlzRm9yYmlkZGVuVGFnKGVsKSB7XHJcbiAgICByZXR1cm4gKGVsLnRhZyA9PT0gJ3N0eWxlJyB8fFxyXG4gICAgICAgIChlbC50YWcgPT09ICdzY3JpcHQnICYmXHJcbiAgICAgICAgICAgICghZWwuYXR0cnNNYXAudHlwZSB8fCBlbC5hdHRyc01hcC50eXBlID09PSAndGV4dC9qYXZhc2NyaXB0JykpKTtcclxufVxyXG52YXIgaWVOU0J1ZyA9IC9eeG1sbnM6TlNcXGQrLztcclxudmFyIGllTlNQcmVmaXggPSAvXk5TXFxkKzovO1xyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5mdW5jdGlvbiBndWFyZElFU1ZHQnVnKGF0dHJzKSB7XHJcbiAgICB2YXIgcmVzID0gW107XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIGF0dHIgPSBhdHRyc1tpXTtcclxuICAgICAgICBpZiAoIWllTlNCdWcudGVzdChhdHRyLm5hbWUpKSB7XHJcbiAgICAgICAgICAgIGF0dHIubmFtZSA9IGF0dHIubmFtZS5yZXBsYWNlKGllTlNQcmVmaXgsICcnKTtcclxuICAgICAgICAgICAgcmVzLnB1c2goYXR0cik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxufVxyXG5mdW5jdGlvbiBjaGVja0ZvckFsaWFzTW9kZWwoZWwsIHZhbHVlKSB7XHJcbiAgICB2YXIgX2VsID0gZWw7XHJcbiAgICB3aGlsZSAoX2VsKSB7XHJcbiAgICAgICAgaWYgKF9lbC5mb3IgJiYgX2VsLmFsaWFzID09PSB2YWx1ZSkge1xyXG4gICAgICAgICAgICB3YXJuKFwiPFwiLmNvbmNhdChlbC50YWcsIFwiIHYtbW9kZWw9XFxcIlwiKS5jb25jYXQodmFsdWUsIFwiXFxcIj46IFwiKSArXHJcbiAgICAgICAgICAgICAgICBcIllvdSBhcmUgYmluZGluZyB2LW1vZGVsIGRpcmVjdGx5IHRvIGEgdi1mb3IgaXRlcmF0aW9uIGFsaWFzLiBcIiArXHJcbiAgICAgICAgICAgICAgICBcIlRoaXMgd2lsbCBub3QgYmUgYWJsZSB0byBtb2RpZnkgdGhlIHYtZm9yIHNvdXJjZSBhcnJheSBiZWNhdXNlIFwiICtcclxuICAgICAgICAgICAgICAgIFwid3JpdGluZyB0byB0aGUgYWxpYXMgaXMgbGlrZSBtb2RpZnlpbmcgYSBmdW5jdGlvbiBsb2NhbCB2YXJpYWJsZS4gXCIgK1xyXG4gICAgICAgICAgICAgICAgXCJDb25zaWRlciB1c2luZyBhbiBhcnJheSBvZiBvYmplY3RzIGFuZCB1c2Ugdi1tb2RlbCBvbiBhbiBvYmplY3QgcHJvcGVydHkgaW5zdGVhZC5cIiwgZWwucmF3QXR0cnNNYXBbJ3YtbW9kZWwnXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9lbCA9IF9lbC5wYXJlbnQ7XHJcbiAgICB9XHJcbn1cblxuLyoqXHJcbiAqIEV4cGFuZCBpbnB1dFt2LW1vZGVsXSB3aXRoIGR5bmFtaWMgdHlwZSBiaW5kaW5ncyBpbnRvIHYtaWYtZWxzZSBjaGFpbnNcclxuICogVHVybiB0aGlzOlxyXG4gKiAgIDxpbnB1dCB2LW1vZGVsPVwiZGF0YVt0eXBlXVwiIDp0eXBlPVwidHlwZVwiPlxyXG4gKiBpbnRvIHRoaXM6XHJcbiAqICAgPGlucHV0IHYtaWY9XCJ0eXBlID09PSAnY2hlY2tib3gnXCIgdHlwZT1cImNoZWNrYm94XCIgdi1tb2RlbD1cImRhdGFbdHlwZV1cIj5cclxuICogICA8aW5wdXQgdi1lbHNlLWlmPVwidHlwZSA9PT0gJ3JhZGlvJ1wiIHR5cGU9XCJyYWRpb1wiIHYtbW9kZWw9XCJkYXRhW3R5cGVdXCI+XHJcbiAqICAgPGlucHV0IHYtZWxzZSA6dHlwZT1cInR5cGVcIiB2LW1vZGVsPVwiZGF0YVt0eXBlXVwiPlxyXG4gKi9cclxuZnVuY3Rpb24gcHJlVHJhbnNmb3JtTm9kZShlbCwgb3B0aW9ucykge1xyXG4gICAgaWYgKGVsLnRhZyA9PT0gJ2lucHV0Jykge1xyXG4gICAgICAgIHZhciBtYXAgPSBlbC5hdHRyc01hcDtcclxuICAgICAgICBpZiAoIW1hcFsndi1tb2RlbCddKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHR5cGVCaW5kaW5nID0gdm9pZCAwO1xyXG4gICAgICAgIGlmIChtYXBbJzp0eXBlJ10gfHwgbWFwWyd2LWJpbmQ6dHlwZSddKSB7XHJcbiAgICAgICAgICAgIHR5cGVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd0eXBlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbWFwLnR5cGUgJiYgIXR5cGVCaW5kaW5nICYmIG1hcFsndi1iaW5kJ10pIHtcclxuICAgICAgICAgICAgdHlwZUJpbmRpbmcgPSBcIihcIi5jb25jYXQobWFwWyd2LWJpbmQnXSwgXCIpLnR5cGVcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlQmluZGluZykge1xyXG4gICAgICAgICAgICB2YXIgaWZDb25kaXRpb24gPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1pZicsIHRydWUpO1xyXG4gICAgICAgICAgICB2YXIgaWZDb25kaXRpb25FeHRyYSA9IGlmQ29uZGl0aW9uID8gXCImJihcIi5jb25jYXQoaWZDb25kaXRpb24sIFwiKVwiKSA6IFwiXCI7XHJcbiAgICAgICAgICAgIHZhciBoYXNFbHNlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZScsIHRydWUpICE9IG51bGw7XHJcbiAgICAgICAgICAgIHZhciBlbHNlSWZDb25kaXRpb24gPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlLWlmJywgdHJ1ZSk7XHJcbiAgICAgICAgICAgIC8vIDEuIGNoZWNrYm94XHJcbiAgICAgICAgICAgIHZhciBicmFuY2gwID0gY2xvbmVBU1RFbGVtZW50KGVsKTtcclxuICAgICAgICAgICAgLy8gcHJvY2VzcyBmb3Igb24gdGhlIG1haW4gbm9kZVxyXG4gICAgICAgICAgICBwcm9jZXNzRm9yKGJyYW5jaDApO1xyXG4gICAgICAgICAgICBhZGRSYXdBdHRyKGJyYW5jaDAsICd0eXBlJywgJ2NoZWNrYm94Jyk7XHJcbiAgICAgICAgICAgIHByb2Nlc3NFbGVtZW50KGJyYW5jaDAsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICBicmFuY2gwLnByb2Nlc3NlZCA9IHRydWU7IC8vIHByZXZlbnQgaXQgZnJvbSBkb3VibGUtcHJvY2Vzc2VkXHJcbiAgICAgICAgICAgIGJyYW5jaDAuaWYgPSBcIihcIi5jb25jYXQodHlwZUJpbmRpbmcsIFwiKT09PSdjaGVja2JveCdcIikgKyBpZkNvbmRpdGlvbkV4dHJhO1xyXG4gICAgICAgICAgICBhZGRJZkNvbmRpdGlvbihicmFuY2gwLCB7XHJcbiAgICAgICAgICAgICAgICBleHA6IGJyYW5jaDAuaWYsXHJcbiAgICAgICAgICAgICAgICBibG9jazogYnJhbmNoMFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgLy8gMi4gYWRkIHJhZGlvIGVsc2UtaWYgY29uZGl0aW9uXHJcbiAgICAgICAgICAgIHZhciBicmFuY2gxID0gY2xvbmVBU1RFbGVtZW50KGVsKTtcclxuICAgICAgICAgICAgZ2V0QW5kUmVtb3ZlQXR0cihicmFuY2gxLCAndi1mb3InLCB0cnVlKTtcclxuICAgICAgICAgICAgYWRkUmF3QXR0cihicmFuY2gxLCAndHlwZScsICdyYWRpbycpO1xyXG4gICAgICAgICAgICBwcm9jZXNzRWxlbWVudChicmFuY2gxLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgYWRkSWZDb25kaXRpb24oYnJhbmNoMCwge1xyXG4gICAgICAgICAgICAgICAgZXhwOiBcIihcIi5jb25jYXQodHlwZUJpbmRpbmcsIFwiKT09PSdyYWRpbydcIikgKyBpZkNvbmRpdGlvbkV4dHJhLFxyXG4gICAgICAgICAgICAgICAgYmxvY2s6IGJyYW5jaDFcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8vIDMuIG90aGVyXHJcbiAgICAgICAgICAgIHZhciBicmFuY2gyID0gY2xvbmVBU1RFbGVtZW50KGVsKTtcclxuICAgICAgICAgICAgZ2V0QW5kUmVtb3ZlQXR0cihicmFuY2gyLCAndi1mb3InLCB0cnVlKTtcclxuICAgICAgICAgICAgYWRkUmF3QXR0cihicmFuY2gyLCAnOnR5cGUnLCB0eXBlQmluZGluZyk7XHJcbiAgICAgICAgICAgIHByb2Nlc3NFbGVtZW50KGJyYW5jaDIsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICBhZGRJZkNvbmRpdGlvbihicmFuY2gwLCB7XHJcbiAgICAgICAgICAgICAgICBleHA6IGlmQ29uZGl0aW9uLFxyXG4gICAgICAgICAgICAgICAgYmxvY2s6IGJyYW5jaDJcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChoYXNFbHNlKSB7XHJcbiAgICAgICAgICAgICAgICBicmFuY2gwLmVsc2UgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGVsc2VJZkNvbmRpdGlvbikge1xyXG4gICAgICAgICAgICAgICAgYnJhbmNoMC5lbHNlaWYgPSBlbHNlSWZDb25kaXRpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGJyYW5jaDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNsb25lQVNURWxlbWVudChlbCkge1xyXG4gICAgcmV0dXJuIGNyZWF0ZUFTVEVsZW1lbnQoZWwudGFnLCBlbC5hdHRyc0xpc3Quc2xpY2UoKSwgZWwucGFyZW50KTtcclxufVxyXG52YXIgbW9kZWwgPSB7XHJcbiAgICBwcmVUcmFuc2Zvcm1Ob2RlOiBwcmVUcmFuc2Zvcm1Ob2RlXHJcbn07XG5cbnZhciBtb2R1bGVzID0gW2tsYXNzLCBzdHlsZSwgbW9kZWxdO1xuXG5mdW5jdGlvbiB0ZXh0KGVsLCBkaXIpIHtcclxuICAgIGlmIChkaXIudmFsdWUpIHtcclxuICAgICAgICBhZGRQcm9wKGVsLCAndGV4dENvbnRlbnQnLCBcIl9zKFwiLmNvbmNhdChkaXIudmFsdWUsIFwiKVwiKSwgZGlyKTtcclxuICAgIH1cclxufVxuXG5mdW5jdGlvbiBodG1sKGVsLCBkaXIpIHtcclxuICAgIGlmIChkaXIudmFsdWUpIHtcclxuICAgICAgICBhZGRQcm9wKGVsLCAnaW5uZXJIVE1MJywgXCJfcyhcIi5jb25jYXQoZGlyLnZhbHVlLCBcIilcIiksIGRpcik7XHJcbiAgICB9XHJcbn1cblxudmFyIGRpcmVjdGl2ZXMgPSB7XHJcbiAgICBtb2RlbDogbW9kZWwkMSxcclxuICAgIHRleHQ6IHRleHQsXHJcbiAgICBodG1sOiBodG1sXHJcbn07XG5cbnZhciBiYXNlT3B0aW9ucyA9IHtcclxuICAgIGV4cGVjdEhUTUw6IHRydWUsXHJcbiAgICBtb2R1bGVzOiBtb2R1bGVzLFxyXG4gICAgZGlyZWN0aXZlczogZGlyZWN0aXZlcyxcclxuICAgIGlzUHJlVGFnOiBpc1ByZVRhZyxcclxuICAgIGlzVW5hcnlUYWc6IGlzVW5hcnlUYWcsXHJcbiAgICBtdXN0VXNlUHJvcDogbXVzdFVzZVByb3AsXHJcbiAgICBjYW5CZUxlZnRPcGVuVGFnOiBjYW5CZUxlZnRPcGVuVGFnLFxyXG4gICAgaXNSZXNlcnZlZFRhZzogaXNSZXNlcnZlZFRhZyxcclxuICAgIGdldFRhZ05hbWVzcGFjZTogZ2V0VGFnTmFtZXNwYWNlLFxyXG4gICAgc3RhdGljS2V5czogZ2VuU3RhdGljS2V5cyQxKG1vZHVsZXMpXHJcbn07XG5cbnZhciBpc1N0YXRpY0tleTtcclxudmFyIGlzUGxhdGZvcm1SZXNlcnZlZFRhZztcclxudmFyIGdlblN0YXRpY0tleXNDYWNoZWQgPSBjYWNoZWQoZ2VuU3RhdGljS2V5cyk7XHJcbi8qKlxyXG4gKiBHb2FsIG9mIHRoZSBvcHRpbWl6ZXI6IHdhbGsgdGhlIGdlbmVyYXRlZCB0ZW1wbGF0ZSBBU1QgdHJlZVxyXG4gKiBhbmQgZGV0ZWN0IHN1Yi10cmVlcyB0aGF0IGFyZSBwdXJlbHkgc3RhdGljLCBpLmUuIHBhcnRzIG9mXHJcbiAqIHRoZSBET00gdGhhdCBuZXZlciBuZWVkcyB0byBjaGFuZ2UuXHJcbiAqXHJcbiAqIE9uY2Ugd2UgZGV0ZWN0IHRoZXNlIHN1Yi10cmVlcywgd2UgY2FuOlxyXG4gKlxyXG4gKiAxLiBIb2lzdCB0aGVtIGludG8gY29uc3RhbnRzLCBzbyB0aGF0IHdlIG5vIGxvbmdlciBuZWVkIHRvXHJcbiAqICAgIGNyZWF0ZSBmcmVzaCBub2RlcyBmb3IgdGhlbSBvbiBlYWNoIHJlLXJlbmRlcjtcclxuICogMi4gQ29tcGxldGVseSBza2lwIHRoZW0gaW4gdGhlIHBhdGNoaW5nIHByb2Nlc3MuXHJcbiAqL1xyXG5mdW5jdGlvbiBvcHRpbWl6ZShyb290LCBvcHRpb25zKSB7XHJcbiAgICBpZiAoIXJvb3QpXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgaXNTdGF0aWNLZXkgPSBnZW5TdGF0aWNLZXlzQ2FjaGVkKG9wdGlvbnMuc3RhdGljS2V5cyB8fCAnJyk7XHJcbiAgICBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcgPSBvcHRpb25zLmlzUmVzZXJ2ZWRUYWcgfHwgbm87XHJcbiAgICAvLyBmaXJzdCBwYXNzOiBtYXJrIGFsbCBub24tc3RhdGljIG5vZGVzLlxyXG4gICAgbWFya1N0YXRpYyhyb290KTtcclxuICAgIC8vIHNlY29uZCBwYXNzOiBtYXJrIHN0YXRpYyByb290cy5cclxuICAgIG1hcmtTdGF0aWNSb290cyhyb290LCBmYWxzZSk7XHJcbn1cclxuZnVuY3Rpb24gZ2VuU3RhdGljS2V5cyhrZXlzKSB7XHJcbiAgICByZXR1cm4gbWFrZU1hcCgndHlwZSx0YWcsYXR0cnNMaXN0LGF0dHJzTWFwLHBsYWluLHBhcmVudCxjaGlsZHJlbixhdHRycyxzdGFydCxlbmQscmF3QXR0cnNNYXAnICtcclxuICAgICAgICAoa2V5cyA/ICcsJyArIGtleXMgOiAnJykpO1xyXG59XHJcbmZ1bmN0aW9uIG1hcmtTdGF0aWMobm9kZSkge1xyXG4gICAgbm9kZS5zdGF0aWMgPSBpc1N0YXRpYyhub2RlKTtcclxuICAgIGlmIChub2RlLnR5cGUgPT09IDEpIHtcclxuICAgICAgICAvLyBkbyBub3QgbWFrZSBjb21wb25lbnQgc2xvdCBjb250ZW50IHN0YXRpYy4gdGhpcyBhdm9pZHNcclxuICAgICAgICAvLyAxLiBjb21wb25lbnRzIG5vdCBhYmxlIHRvIG11dGF0ZSBzbG90IG5vZGVzXHJcbiAgICAgICAgLy8gMi4gc3RhdGljIHNsb3QgY29udGVudCBmYWlscyBmb3IgaG90LXJlbG9hZGluZ1xyXG4gICAgICAgIGlmICghaXNQbGF0Zm9ybVJlc2VydmVkVGFnKG5vZGUudGFnKSAmJlxyXG4gICAgICAgICAgICBub2RlLnRhZyAhPT0gJ3Nsb3QnICYmXHJcbiAgICAgICAgICAgIG5vZGUuYXR0cnNNYXBbJ2lubGluZS10ZW1wbGF0ZSddID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgIG1hcmtTdGF0aWMoY2hpbGQpO1xyXG4gICAgICAgICAgICBpZiAoIWNoaWxkLnN0YXRpYykge1xyXG4gICAgICAgICAgICAgICAgbm9kZS5zdGF0aWMgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobm9kZS5pZkNvbmRpdGlvbnMpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDEsIGwgPSBub2RlLmlmQ29uZGl0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBibG9jayA9IG5vZGUuaWZDb25kaXRpb25zW2ldLmJsb2NrO1xyXG4gICAgICAgICAgICAgICAgbWFya1N0YXRpYyhibG9jayk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWJsb2NrLnN0YXRpYykge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuc3RhdGljID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gbWFya1N0YXRpY1Jvb3RzKG5vZGUsIGlzSW5Gb3IpIHtcclxuICAgIGlmIChub2RlLnR5cGUgPT09IDEpIHtcclxuICAgICAgICBpZiAobm9kZS5zdGF0aWMgfHwgbm9kZS5vbmNlKSB7XHJcbiAgICAgICAgICAgIG5vZGUuc3RhdGljSW5Gb3IgPSBpc0luRm9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBGb3IgYSBub2RlIHRvIHF1YWxpZnkgYXMgYSBzdGF0aWMgcm9vdCwgaXQgc2hvdWxkIGhhdmUgY2hpbGRyZW4gdGhhdFxyXG4gICAgICAgIC8vIGFyZSBub3QganVzdCBzdGF0aWMgdGV4dC4gT3RoZXJ3aXNlIHRoZSBjb3N0IG9mIGhvaXN0aW5nIG91dCB3aWxsXHJcbiAgICAgICAgLy8gb3V0d2VpZ2ggdGhlIGJlbmVmaXRzIGFuZCBpdCdzIGJldHRlciBvZmYgdG8ganVzdCBhbHdheXMgcmVuZGVyIGl0IGZyZXNoLlxyXG4gICAgICAgIGlmIChub2RlLnN0YXRpYyAmJlxyXG4gICAgICAgICAgICBub2RlLmNoaWxkcmVuLmxlbmd0aCAmJlxyXG4gICAgICAgICAgICAhKG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIG5vZGUuY2hpbGRyZW5bMF0udHlwZSA9PT0gMykpIHtcclxuICAgICAgICAgICAgbm9kZS5zdGF0aWNSb290ID0gdHJ1ZTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbm9kZS5zdGF0aWNSb290ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIG1hcmtTdGF0aWNSb290cyhub2RlLmNoaWxkcmVuW2ldLCBpc0luRm9yIHx8ICEhbm9kZS5mb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChub2RlLmlmQ29uZGl0aW9ucykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMSwgbCA9IG5vZGUuaWZDb25kaXRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbWFya1N0YXRpY1Jvb3RzKG5vZGUuaWZDb25kaXRpb25zW2ldLmJsb2NrLCBpc0luRm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpc1N0YXRpYyhub2RlKSB7XHJcbiAgICBpZiAobm9kZS50eXBlID09PSAyKSB7XHJcbiAgICAgICAgLy8gZXhwcmVzc2lvblxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmIChub2RlLnR5cGUgPT09IDMpIHtcclxuICAgICAgICAvLyB0ZXh0XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gISEobm9kZS5wcmUgfHxcclxuICAgICAgICAoIW5vZGUuaGFzQmluZGluZ3MgJiYgLy8gbm8gZHluYW1pYyBiaW5kaW5nc1xyXG4gICAgICAgICAgICAhbm9kZS5pZiAmJlxyXG4gICAgICAgICAgICAhbm9kZS5mb3IgJiYgLy8gbm90IHYtaWYgb3Igdi1mb3Igb3Igdi1lbHNlXHJcbiAgICAgICAgICAgICFpc0J1aWx0SW5UYWcobm9kZS50YWcpICYmIC8vIG5vdCBhIGJ1aWx0LWluXHJcbiAgICAgICAgICAgIGlzUGxhdGZvcm1SZXNlcnZlZFRhZyhub2RlLnRhZykgJiYgLy8gbm90IGEgY29tcG9uZW50XHJcbiAgICAgICAgICAgICFpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvcihub2RlKSAmJlxyXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhub2RlKS5ldmVyeShpc1N0YXRpY0tleSkpKTtcclxufVxyXG5mdW5jdGlvbiBpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvcihub2RlKSB7XHJcbiAgICB3aGlsZSAobm9kZS5wYXJlbnQpIHtcclxuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnQ7XHJcbiAgICAgICAgaWYgKG5vZGUudGFnICE9PSAndGVtcGxhdGUnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5vZGUuZm9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxuXG52YXIgZm5FeHBSRSA9IC9eKFtcXHckX10rfFxcKFteKV0qP1xcKSlcXHMqPT58XmZ1bmN0aW9uKD86XFxzK1tcXHckXSspP1xccypcXCgvO1xyXG52YXIgZm5JbnZva2VSRSA9IC9cXChbXildKj9cXCk7KiQvO1xyXG52YXIgc2ltcGxlUGF0aFJFID0gL15bQS1aYS16XyRdW1xcdyRdKig/OlxcLltBLVphLXpfJF1bXFx3JF0qfFxcWydbXiddKj8nXXxcXFtcIlteXCJdKj9cIl18XFxbXFxkK118XFxbW0EtWmEtel8kXVtcXHckXSpdKSokLztcclxuLy8gS2V5Ym9hcmRFdmVudC5rZXlDb2RlIGFsaWFzZXNcclxudmFyIGtleUNvZGVzID0ge1xyXG4gICAgZXNjOiAyNyxcclxuICAgIHRhYjogOSxcclxuICAgIGVudGVyOiAxMyxcclxuICAgIHNwYWNlOiAzMixcclxuICAgIHVwOiAzOCxcclxuICAgIGxlZnQ6IDM3LFxyXG4gICAgcmlnaHQ6IDM5LFxyXG4gICAgZG93bjogNDAsXHJcbiAgICBkZWxldGU6IFs4LCA0Nl1cclxufTtcclxuLy8gS2V5Ym9hcmRFdmVudC5rZXkgYWxpYXNlc1xyXG52YXIga2V5TmFtZXMgPSB7XHJcbiAgICAvLyAjNzg4MDogSUUxMSBhbmQgRWRnZSB1c2UgYEVzY2AgZm9yIEVzY2FwZSBrZXkgbmFtZS5cclxuICAgIGVzYzogWydFc2MnLCAnRXNjYXBlJ10sXHJcbiAgICB0YWI6ICdUYWInLFxyXG4gICAgZW50ZXI6ICdFbnRlcicsXHJcbiAgICAvLyAjOTExMjogSUUxMSB1c2VzIGBTcGFjZWJhcmAgZm9yIFNwYWNlIGtleSBuYW1lLlxyXG4gICAgc3BhY2U6IFsnICcsICdTcGFjZWJhciddLFxyXG4gICAgLy8gIzc4MDY6IElFMTEgdXNlcyBrZXkgbmFtZXMgd2l0aG91dCBgQXJyb3dgIHByZWZpeCBmb3IgYXJyb3cga2V5cy5cclxuICAgIHVwOiBbJ1VwJywgJ0Fycm93VXAnXSxcclxuICAgIGxlZnQ6IFsnTGVmdCcsICdBcnJvd0xlZnQnXSxcclxuICAgIHJpZ2h0OiBbJ1JpZ2h0JywgJ0Fycm93UmlnaHQnXSxcclxuICAgIGRvd246IFsnRG93bicsICdBcnJvd0Rvd24nXSxcclxuICAgIC8vICM5MTEyOiBJRTExIHVzZXMgYERlbGAgZm9yIERlbGV0ZSBrZXkgbmFtZS5cclxuICAgIGRlbGV0ZTogWydCYWNrc3BhY2UnLCAnRGVsZXRlJywgJ0RlbCddXHJcbn07XHJcbi8vICM0ODY4OiBtb2RpZmllcnMgdGhhdCBwcmV2ZW50IHRoZSBleGVjdXRpb24gb2YgdGhlIGxpc3RlbmVyXHJcbi8vIG5lZWQgdG8gZXhwbGljaXRseSByZXR1cm4gbnVsbCBzbyB0aGF0IHdlIGNhbiBkZXRlcm1pbmUgd2hldGhlciB0byByZW1vdmVcclxuLy8gdGhlIGxpc3RlbmVyIGZvciAub25jZVxyXG52YXIgZ2VuR3VhcmQgPSBmdW5jdGlvbiAoY29uZGl0aW9uKSB7IHJldHVybiBcImlmKFwiLmNvbmNhdChjb25kaXRpb24sIFwiKXJldHVybiBudWxsO1wiKTsgfTtcclxudmFyIG1vZGlmaWVyQ29kZSA9IHtcclxuICAgIHN0b3A6ICckZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7JyxcclxuICAgIHByZXZlbnQ6ICckZXZlbnQucHJldmVudERlZmF1bHQoKTsnLFxyXG4gICAgc2VsZjogZ2VuR3VhcmQoXCIkZXZlbnQudGFyZ2V0ICE9PSAkZXZlbnQuY3VycmVudFRhcmdldFwiKSxcclxuICAgIGN0cmw6IGdlbkd1YXJkKFwiISRldmVudC5jdHJsS2V5XCIpLFxyXG4gICAgc2hpZnQ6IGdlbkd1YXJkKFwiISRldmVudC5zaGlmdEtleVwiKSxcclxuICAgIGFsdDogZ2VuR3VhcmQoXCIhJGV2ZW50LmFsdEtleVwiKSxcclxuICAgIG1ldGE6IGdlbkd1YXJkKFwiISRldmVudC5tZXRhS2V5XCIpLFxyXG4gICAgbGVmdDogZ2VuR3VhcmQoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMFwiKSxcclxuICAgIG1pZGRsZTogZ2VuR3VhcmQoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMVwiKSxcclxuICAgIHJpZ2h0OiBnZW5HdWFyZChcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAyXCIpXHJcbn07XHJcbmZ1bmN0aW9uIGdlbkhhbmRsZXJzKGV2ZW50cywgaXNOYXRpdmUpIHtcclxuICAgIHZhciBwcmVmaXggPSBpc05hdGl2ZSA/ICduYXRpdmVPbjonIDogJ29uOic7XHJcbiAgICB2YXIgc3RhdGljSGFuZGxlcnMgPSBcIlwiO1xyXG4gICAgdmFyIGR5bmFtaWNIYW5kbGVycyA9IFwiXCI7XHJcbiAgICBmb3IgKHZhciBuYW1lXzEgaW4gZXZlbnRzKSB7XHJcbiAgICAgICAgdmFyIGhhbmRsZXJDb2RlID0gZ2VuSGFuZGxlcihldmVudHNbbmFtZV8xXSk7XHJcbiAgICAgICAgLy9AdHMtZXhwZWN0LWVycm9yXHJcbiAgICAgICAgaWYgKGV2ZW50c1tuYW1lXzFdICYmIGV2ZW50c1tuYW1lXzFdLmR5bmFtaWMpIHtcclxuICAgICAgICAgICAgZHluYW1pY0hhbmRsZXJzICs9IFwiXCIuY29uY2F0KG5hbWVfMSwgXCIsXCIpLmNvbmNhdChoYW5kbGVyQ29kZSwgXCIsXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc3RhdGljSGFuZGxlcnMgKz0gXCJcXFwiXCIuY29uY2F0KG5hbWVfMSwgXCJcXFwiOlwiKS5jb25jYXQoaGFuZGxlckNvZGUsIFwiLFwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWNIYW5kbGVycyA9IFwie1wiLmNvbmNhdChzdGF0aWNIYW5kbGVycy5zbGljZSgwLCAtMSksIFwifVwiKTtcclxuICAgIGlmIChkeW5hbWljSGFuZGxlcnMpIHtcclxuICAgICAgICByZXR1cm4gcHJlZml4ICsgXCJfZChcIi5jb25jYXQoc3RhdGljSGFuZGxlcnMsIFwiLFtcIikuY29uY2F0KGR5bmFtaWNIYW5kbGVycy5zbGljZSgwLCAtMSksIFwiXSlcIik7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gcHJlZml4ICsgc3RhdGljSGFuZGxlcnM7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2VuSGFuZGxlcihoYW5kbGVyKSB7XHJcbiAgICBpZiAoIWhhbmRsZXIpIHtcclxuICAgICAgICByZXR1cm4gJ2Z1bmN0aW9uKCl7fSc7XHJcbiAgICB9XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVyKSkge1xyXG4gICAgICAgIHJldHVybiBcIltcIi5jb25jYXQoaGFuZGxlci5tYXAoZnVuY3Rpb24gKGhhbmRsZXIpIHsgcmV0dXJuIGdlbkhhbmRsZXIoaGFuZGxlcik7IH0pLmpvaW4oJywnKSwgXCJdXCIpO1xyXG4gICAgfVxyXG4gICAgdmFyIGlzTWV0aG9kUGF0aCA9IHNpbXBsZVBhdGhSRS50ZXN0KGhhbmRsZXIudmFsdWUpO1xyXG4gICAgdmFyIGlzRnVuY3Rpb25FeHByZXNzaW9uID0gZm5FeHBSRS50ZXN0KGhhbmRsZXIudmFsdWUpO1xyXG4gICAgdmFyIGlzRnVuY3Rpb25JbnZvY2F0aW9uID0gc2ltcGxlUGF0aFJFLnRlc3QoaGFuZGxlci52YWx1ZS5yZXBsYWNlKGZuSW52b2tlUkUsICcnKSk7XHJcbiAgICBpZiAoIWhhbmRsZXIubW9kaWZpZXJzKSB7XHJcbiAgICAgICAgaWYgKGlzTWV0aG9kUGF0aCB8fCBpc0Z1bmN0aW9uRXhwcmVzc2lvbikge1xyXG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlci52YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFwiZnVuY3Rpb24oJGV2ZW50KXtcIi5jb25jYXQoaXNGdW5jdGlvbkludm9jYXRpb24gPyBcInJldHVybiBcIi5jb25jYXQoaGFuZGxlci52YWx1ZSkgOiBoYW5kbGVyLnZhbHVlLCBcIn1cIik7IC8vIGlubGluZSBzdGF0ZW1lbnRcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhciBjb2RlID0gJyc7XHJcbiAgICAgICAgdmFyIGdlbk1vZGlmaWVyQ29kZSA9ICcnO1xyXG4gICAgICAgIHZhciBrZXlzID0gW107XHJcbiAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIGlmIChtb2RpZmllckNvZGVba2V5XSkge1xyXG4gICAgICAgICAgICAgICAgZ2VuTW9kaWZpZXJDb2RlICs9IG1vZGlmaWVyQ29kZVtrZXldO1xyXG4gICAgICAgICAgICAgICAgLy8gbGVmdC9yaWdodFxyXG4gICAgICAgICAgICAgICAgaWYgKGtleUNvZGVzW2tleV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgPT09ICdleGFjdCcpIHtcclxuICAgICAgICAgICAgICAgIHZhciBtb2RpZmllcnNfMSA9IGhhbmRsZXIubW9kaWZpZXJzO1xyXG4gICAgICAgICAgICAgICAgZ2VuTW9kaWZpZXJDb2RlICs9IGdlbkd1YXJkKFsnY3RybCcsICdzaGlmdCcsICdhbHQnLCAnbWV0YSddXHJcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoa2V5TW9kaWZpZXIpIHsgcmV0dXJuICFtb2RpZmllcnNfMVtrZXlNb2RpZmllcl07IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoa2V5TW9kaWZpZXIpIHsgcmV0dXJuIFwiJGV2ZW50LlwiLmNvbmNhdChrZXlNb2RpZmllciwgXCJLZXlcIik7IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmpvaW4oJ3x8JykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBoYW5kbGVyLm1vZGlmaWVycykge1xyXG4gICAgICAgICAgICBfbG9vcF8xKGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChrZXlzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBjb2RlICs9IGdlbktleUZpbHRlcihrZXlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTWFrZSBzdXJlIG1vZGlmaWVycyBsaWtlIHByZXZlbnQgYW5kIHN0b3AgZ2V0IGV4ZWN1dGVkIGFmdGVyIGtleSBmaWx0ZXJpbmdcclxuICAgICAgICBpZiAoZ2VuTW9kaWZpZXJDb2RlKSB7XHJcbiAgICAgICAgICAgIGNvZGUgKz0gZ2VuTW9kaWZpZXJDb2RlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaGFuZGxlckNvZGUgPSBpc01ldGhvZFBhdGhcclxuICAgICAgICAgICAgPyBcInJldHVybiBcIi5jb25jYXQoaGFuZGxlci52YWx1ZSwgXCIuYXBwbHkobnVsbCwgYXJndW1lbnRzKVwiKVxyXG4gICAgICAgICAgICA6IGlzRnVuY3Rpb25FeHByZXNzaW9uXHJcbiAgICAgICAgICAgICAgICA/IFwicmV0dXJuIChcIi5jb25jYXQoaGFuZGxlci52YWx1ZSwgXCIpLmFwcGx5KG51bGwsIGFyZ3VtZW50cylcIilcclxuICAgICAgICAgICAgICAgIDogaXNGdW5jdGlvbkludm9jYXRpb25cclxuICAgICAgICAgICAgICAgICAgICA/IFwicmV0dXJuIFwiLmNvbmNhdChoYW5kbGVyLnZhbHVlKVxyXG4gICAgICAgICAgICAgICAgICAgIDogaGFuZGxlci52YWx1ZTtcclxuICAgICAgICByZXR1cm4gXCJmdW5jdGlvbigkZXZlbnQpe1wiLmNvbmNhdChjb2RlKS5jb25jYXQoaGFuZGxlckNvZGUsIFwifVwiKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZW5LZXlGaWx0ZXIoa2V5cykge1xyXG4gICAgcmV0dXJuIChcclxuICAgIC8vIG1ha2Ugc3VyZSB0aGUga2V5IGZpbHRlcnMgb25seSBhcHBseSB0byBLZXlib2FyZEV2ZW50c1xyXG4gICAgLy8gIzk0NDE6IGNhbid0IHVzZSAna2V5Q29kZScgaW4gJGV2ZW50IGJlY2F1c2UgQ2hyb21lIGF1dG9maWxsIGZpcmVzIGZha2VcclxuICAgIC8vIGtleSBldmVudHMgdGhhdCBkbyBub3QgaGF2ZSBrZXlDb2RlIHByb3BlcnR5Li4uXHJcbiAgICBcImlmKCEkZXZlbnQudHlwZS5pbmRleE9mKCdrZXknKSYmXCIgK1xyXG4gICAgICAgIFwiXCIuY29uY2F0KGtleXMubWFwKGdlbkZpbHRlckNvZGUpLmpvaW4oJyYmJyksIFwiKXJldHVybiBudWxsO1wiKSk7XHJcbn1cclxuZnVuY3Rpb24gZ2VuRmlsdGVyQ29kZShrZXkpIHtcclxuICAgIHZhciBrZXlWYWwgPSBwYXJzZUludChrZXksIDEwKTtcclxuICAgIGlmIChrZXlWYWwpIHtcclxuICAgICAgICByZXR1cm4gXCIkZXZlbnQua2V5Q29kZSE9PVwiLmNvbmNhdChrZXlWYWwpO1xyXG4gICAgfVxyXG4gICAgdmFyIGtleUNvZGUgPSBrZXlDb2Rlc1trZXldO1xyXG4gICAgdmFyIGtleU5hbWUgPSBrZXlOYW1lc1trZXldO1xyXG4gICAgcmV0dXJuIChcIl9rKCRldmVudC5rZXlDb2RlLFwiICtcclxuICAgICAgICBcIlwiLmNvbmNhdChKU09OLnN0cmluZ2lmeShrZXkpLCBcIixcIikgK1xyXG4gICAgICAgIFwiXCIuY29uY2F0KEpTT04uc3RyaW5naWZ5KGtleUNvZGUpLCBcIixcIikgK1xyXG4gICAgICAgIFwiJGV2ZW50LmtleSxcIiArXHJcbiAgICAgICAgXCJcIi5jb25jYXQoSlNPTi5zdHJpbmdpZnkoa2V5TmFtZSkpICtcclxuICAgICAgICBcIilcIik7XHJcbn1cblxuZnVuY3Rpb24gb24oZWwsIGRpcikge1xyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZGlyLm1vZGlmaWVycykge1xyXG4gICAgICAgIHdhcm4kMihcInYtb24gd2l0aG91dCBhcmd1bWVudCBkb2VzIG5vdCBzdXBwb3J0IG1vZGlmaWVycy5cIik7XHJcbiAgICB9XHJcbiAgICBlbC53cmFwTGlzdGVuZXJzID0gZnVuY3Rpb24gKGNvZGUpIHsgcmV0dXJuIFwiX2coXCIuY29uY2F0KGNvZGUsIFwiLFwiKS5jb25jYXQoZGlyLnZhbHVlLCBcIilcIik7IH07XHJcbn1cblxuZnVuY3Rpb24gYmluZChlbCwgZGlyKSB7XHJcbiAgICBlbC53cmFwRGF0YSA9IGZ1bmN0aW9uIChjb2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiX2IoXCIuY29uY2F0KGNvZGUsIFwiLCdcIikuY29uY2F0KGVsLnRhZywgXCInLFwiKS5jb25jYXQoZGlyLnZhbHVlLCBcIixcIikuY29uY2F0KGRpci5tb2RpZmllcnMgJiYgZGlyLm1vZGlmaWVycy5wcm9wID8gJ3RydWUnIDogJ2ZhbHNlJykuY29uY2F0KGRpci5tb2RpZmllcnMgJiYgZGlyLm1vZGlmaWVycy5zeW5jID8gJyx0cnVlJyA6ICcnLCBcIilcIik7XHJcbiAgICB9O1xyXG59XG5cbnZhciBiYXNlRGlyZWN0aXZlcyA9IHtcclxuICAgIG9uOiBvbixcclxuICAgIGJpbmQ6IGJpbmQsXHJcbiAgICBjbG9hazogbm9vcFxyXG59O1xuXG52YXIgQ29kZWdlblN0YXRlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ29kZWdlblN0YXRlKG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xyXG4gICAgICAgIHRoaXMud2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3RyYW5zZm9ybUNvZGUnKTtcclxuICAgICAgICB0aGlzLmRhdGFHZW5GbnMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ2dlbkRhdGEnKTtcclxuICAgICAgICB0aGlzLmRpcmVjdGl2ZXMgPSBleHRlbmQoZXh0ZW5kKHt9LCBiYXNlRGlyZWN0aXZlcyksIG9wdGlvbnMuZGlyZWN0aXZlcyk7XHJcbiAgICAgICAgdmFyIGlzUmVzZXJ2ZWRUYWcgPSBvcHRpb25zLmlzUmVzZXJ2ZWRUYWcgfHwgbm87XHJcbiAgICAgICAgdGhpcy5tYXliZUNvbXBvbmVudCA9IGZ1bmN0aW9uIChlbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gISFlbC5jb21wb25lbnQgfHwgIWlzUmVzZXJ2ZWRUYWcoZWwudGFnKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMub25jZUlkID0gMDtcclxuICAgICAgICB0aGlzLnN0YXRpY1JlbmRlckZucyA9IFtdO1xyXG4gICAgICAgIHRoaXMucHJlID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gQ29kZWdlblN0YXRlO1xyXG59KCkpO1xyXG5mdW5jdGlvbiBnZW5lcmF0ZShhc3QsIG9wdGlvbnMpIHtcclxuICAgIHZhciBzdGF0ZSA9IG5ldyBDb2RlZ2VuU3RhdGUob3B0aW9ucyk7XHJcbiAgICAvLyBmaXggIzExNDgzLCBSb290IGxldmVsIDxzY3JpcHQ+IHRhZ3Mgc2hvdWxkIG5vdCBiZSByZW5kZXJlZC5cclxuICAgIHZhciBjb2RlID0gYXN0XHJcbiAgICAgICAgPyBhc3QudGFnID09PSAnc2NyaXB0J1xyXG4gICAgICAgICAgICA/ICdudWxsJ1xyXG4gICAgICAgICAgICA6IGdlbkVsZW1lbnQoYXN0LCBzdGF0ZSlcclxuICAgICAgICA6ICdfYyhcImRpdlwiKSc7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlbmRlcjogXCJ3aXRoKHRoaXMpe3JldHVybiBcIi5jb25jYXQoY29kZSwgXCJ9XCIpLFxyXG4gICAgICAgIHN0YXRpY1JlbmRlckZuczogc3RhdGUuc3RhdGljUmVuZGVyRm5zXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGdlbkVsZW1lbnQoZWwsIHN0YXRlKSB7XHJcbiAgICBpZiAoZWwucGFyZW50KSB7XHJcbiAgICAgICAgZWwucHJlID0gZWwucHJlIHx8IGVsLnBhcmVudC5wcmU7XHJcbiAgICB9XHJcbiAgICBpZiAoZWwuc3RhdGljUm9vdCAmJiAhZWwuc3RhdGljUHJvY2Vzc2VkKSB7XHJcbiAgICAgICAgcmV0dXJuIGdlblN0YXRpYyhlbCwgc3RhdGUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZWwub25jZSAmJiAhZWwub25jZVByb2Nlc3NlZCkge1xyXG4gICAgICAgIHJldHVybiBnZW5PbmNlKGVsLCBzdGF0ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChlbC5mb3IgJiYgIWVsLmZvclByb2Nlc3NlZCkge1xyXG4gICAgICAgIHJldHVybiBnZW5Gb3IoZWwsIHN0YXRlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCkge1xyXG4gICAgICAgIHJldHVybiBnZW5JZihlbCwgc3RhdGUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnICYmICFlbC5zbG90VGFyZ2V0ICYmICFzdGF0ZS5wcmUpIHtcclxuICAgICAgICByZXR1cm4gZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKSB8fCAndm9pZCAwJztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XHJcbiAgICAgICAgcmV0dXJuIGdlblNsb3QoZWwsIHN0YXRlKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIGNvbXBvbmVudCBvciBlbGVtZW50XHJcbiAgICAgICAgdmFyIGNvZGUgPSB2b2lkIDA7XHJcbiAgICAgICAgaWYgKGVsLmNvbXBvbmVudCkge1xyXG4gICAgICAgICAgICBjb2RlID0gZ2VuQ29tcG9uZW50KGVsLmNvbXBvbmVudCwgZWwsIHN0YXRlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gdm9pZCAwO1xyXG4gICAgICAgICAgICB2YXIgbWF5YmVDb21wb25lbnQgPSBzdGF0ZS5tYXliZUNvbXBvbmVudChlbCk7XHJcbiAgICAgICAgICAgIGlmICghZWwucGxhaW4gfHwgKGVsLnByZSAmJiBtYXliZUNvbXBvbmVudCkpIHtcclxuICAgICAgICAgICAgICAgIGRhdGEgPSBnZW5EYXRhKGVsLCBzdGF0ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHRhZyBcclxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBhIGNvbXBvbmVudCBpbiA8c2NyaXB0IHNldHVwPlxyXG4gICAgICAgICAgICA9IHZvaWQgMDtcclxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBhIGNvbXBvbmVudCBpbiA8c2NyaXB0IHNldHVwPlxyXG4gICAgICAgICAgICB2YXIgYmluZGluZ3MgPSBzdGF0ZS5vcHRpb25zLmJpbmRpbmdzO1xyXG4gICAgICAgICAgICBpZiAobWF5YmVDb21wb25lbnQgJiYgYmluZGluZ3MgJiYgYmluZGluZ3MuX19pc1NjcmlwdFNldHVwICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgdGFnID0gY2hlY2tCaW5kaW5nVHlwZShiaW5kaW5ncywgZWwudGFnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXRhZylcclxuICAgICAgICAgICAgICAgIHRhZyA9IFwiJ1wiLmNvbmNhdChlbC50YWcsIFwiJ1wiKTtcclxuICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gZWwuaW5saW5lVGVtcGxhdGUgPyBudWxsIDogZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlLCB0cnVlKTtcclxuICAgICAgICAgICAgY29kZSA9IFwiX2MoXCIuY29uY2F0KHRhZykuY29uY2F0KGRhdGEgPyBcIixcIi5jb25jYXQoZGF0YSkgOiAnJyAvLyBkYXRhXHJcbiAgICAgICAgICAgICkuY29uY2F0KGNoaWxkcmVuID8gXCIsXCIuY29uY2F0KGNoaWxkcmVuKSA6ICcnIC8vIGNoaWxkcmVuXHJcbiAgICAgICAgICAgICwgXCIpXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBtb2R1bGUgdHJhbnNmb3Jtc1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGUudHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb2RlID0gc3RhdGUudHJhbnNmb3Jtc1tpXShlbCwgY29kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb2RlO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNoZWNrQmluZGluZ1R5cGUoYmluZGluZ3MsIGtleSkge1xyXG4gICAgdmFyIGNhbWVsTmFtZSA9IGNhbWVsaXplKGtleSk7XHJcbiAgICB2YXIgUGFzY2FsTmFtZSA9IGNhcGl0YWxpemUoY2FtZWxOYW1lKTtcclxuICAgIHZhciBjaGVja1R5cGUgPSBmdW5jdGlvbiAodHlwZSkge1xyXG4gICAgICAgIGlmIChiaW5kaW5nc1trZXldID09PSB0eXBlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBrZXk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChiaW5kaW5nc1tjYW1lbE5hbWVdID09PSB0eXBlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjYW1lbE5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChiaW5kaW5nc1tQYXNjYWxOYW1lXSA9PT0gdHlwZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gUGFzY2FsTmFtZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdmFyIGZyb21Db25zdCA9IGNoZWNrVHlwZShcInNldHVwLWNvbnN0XCIgLyogQmluZGluZ1R5cGVzLlNFVFVQX0NPTlNUICovKSB8fFxyXG4gICAgICAgIGNoZWNrVHlwZShcInNldHVwLXJlYWN0aXZlLWNvbnN0XCIgLyogQmluZGluZ1R5cGVzLlNFVFVQX1JFQUNUSVZFX0NPTlNUICovKTtcclxuICAgIGlmIChmcm9tQ29uc3QpIHtcclxuICAgICAgICByZXR1cm4gZnJvbUNvbnN0O1xyXG4gICAgfVxyXG4gICAgdmFyIGZyb21NYXliZVJlZiA9IGNoZWNrVHlwZShcInNldHVwLWxldFwiIC8qIEJpbmRpbmdUeXBlcy5TRVRVUF9MRVQgKi8pIHx8XHJcbiAgICAgICAgY2hlY2tUeXBlKFwic2V0dXAtcmVmXCIgLyogQmluZGluZ1R5cGVzLlNFVFVQX1JFRiAqLykgfHxcclxuICAgICAgICBjaGVja1R5cGUoXCJzZXR1cC1tYXliZS1yZWZcIiAvKiBCaW5kaW5nVHlwZXMuU0VUVVBfTUFZQkVfUkVGICovKTtcclxuICAgIGlmIChmcm9tTWF5YmVSZWYpIHtcclxuICAgICAgICByZXR1cm4gZnJvbU1heWJlUmVmO1xyXG4gICAgfVxyXG59XHJcbi8vIGhvaXN0IHN0YXRpYyBzdWItdHJlZXMgb3V0XHJcbmZ1bmN0aW9uIGdlblN0YXRpYyhlbCwgc3RhdGUpIHtcclxuICAgIGVsLnN0YXRpY1Byb2Nlc3NlZCA9IHRydWU7XHJcbiAgICAvLyBTb21lIGVsZW1lbnRzICh0ZW1wbGF0ZXMpIG5lZWQgdG8gYmVoYXZlIGRpZmZlcmVudGx5IGluc2lkZSBvZiBhIHYtcHJlXHJcbiAgICAvLyBub2RlLiAgQWxsIHByZSBub2RlcyBhcmUgc3RhdGljIHJvb3RzLCBzbyB3ZSBjYW4gdXNlIHRoaXMgYXMgYSBsb2NhdGlvbiB0b1xyXG4gICAgLy8gd3JhcCBhIHN0YXRlIGNoYW5nZSBhbmQgcmVzZXQgaXQgdXBvbiBleGl0aW5nIHRoZSBwcmUgbm9kZS5cclxuICAgIHZhciBvcmlnaW5hbFByZVN0YXRlID0gc3RhdGUucHJlO1xyXG4gICAgaWYgKGVsLnByZSkge1xyXG4gICAgICAgIHN0YXRlLnByZSA9IGVsLnByZTtcclxuICAgIH1cclxuICAgIHN0YXRlLnN0YXRpY1JlbmRlckZucy5wdXNoKFwid2l0aCh0aGlzKXtyZXR1cm4gXCIuY29uY2F0KGdlbkVsZW1lbnQoZWwsIHN0YXRlKSwgXCJ9XCIpKTtcclxuICAgIHN0YXRlLnByZSA9IG9yaWdpbmFsUHJlU3RhdGU7XHJcbiAgICByZXR1cm4gXCJfbShcIi5jb25jYXQoc3RhdGUuc3RhdGljUmVuZGVyRm5zLmxlbmd0aCAtIDEpLmNvbmNhdChlbC5zdGF0aWNJbkZvciA/ICcsdHJ1ZScgOiAnJywgXCIpXCIpO1xyXG59XHJcbi8vIHYtb25jZVxyXG5mdW5jdGlvbiBnZW5PbmNlKGVsLCBzdGF0ZSkge1xyXG4gICAgZWwub25jZVByb2Nlc3NlZCA9IHRydWU7XHJcbiAgICBpZiAoZWwuaWYgJiYgIWVsLmlmUHJvY2Vzc2VkKSB7XHJcbiAgICAgICAgcmV0dXJuIGdlbklmKGVsLCBzdGF0ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChlbC5zdGF0aWNJbkZvcikge1xyXG4gICAgICAgIHZhciBrZXkgPSAnJztcclxuICAgICAgICB2YXIgcGFyZW50XzEgPSBlbC5wYXJlbnQ7XHJcbiAgICAgICAgd2hpbGUgKHBhcmVudF8xKSB7XHJcbiAgICAgICAgICAgIGlmIChwYXJlbnRfMS5mb3IpIHtcclxuICAgICAgICAgICAgICAgIGtleSA9IHBhcmVudF8xLmtleTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHBhcmVudF8xID0gcGFyZW50XzEucGFyZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWtleSkge1xyXG4gICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXHJcbiAgICAgICAgICAgICAgICBzdGF0ZS53YXJuKFwidi1vbmNlIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIHYtZm9yIHRoYXQgaXMga2V5ZWQuIFwiLCBlbC5yYXdBdHRyc01hcFsndi1vbmNlJ10pO1xyXG4gICAgICAgICAgICByZXR1cm4gZ2VuRWxlbWVudChlbCwgc3RhdGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gXCJfbyhcIi5jb25jYXQoZ2VuRWxlbWVudChlbCwgc3RhdGUpLCBcIixcIikuY29uY2F0KHN0YXRlLm9uY2VJZCsrLCBcIixcIikuY29uY2F0KGtleSwgXCIpXCIpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGdlblN0YXRpYyhlbCwgc3RhdGUpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdlbklmKGVsLCBzdGF0ZSwgYWx0R2VuLCBhbHRFbXB0eSkge1xyXG4gICAgZWwuaWZQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cclxuICAgIHJldHVybiBnZW5JZkNvbmRpdGlvbnMoZWwuaWZDb25kaXRpb25zLnNsaWNlKCksIHN0YXRlLCBhbHRHZW4sIGFsdEVtcHR5KTtcclxufVxyXG5mdW5jdGlvbiBnZW5JZkNvbmRpdGlvbnMoY29uZGl0aW9ucywgc3RhdGUsIGFsdEdlbiwgYWx0RW1wdHkpIHtcclxuICAgIGlmICghY29uZGl0aW9ucy5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gYWx0RW1wdHkgfHwgJ19lKCknO1xyXG4gICAgfVxyXG4gICAgdmFyIGNvbmRpdGlvbiA9IGNvbmRpdGlvbnMuc2hpZnQoKTtcclxuICAgIGlmIChjb25kaXRpb24uZXhwKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiKFwiLmNvbmNhdChjb25kaXRpb24uZXhwLCBcIik/XCIpLmNvbmNhdChnZW5UZXJuYXJ5RXhwKGNvbmRpdGlvbi5ibG9jayksIFwiOlwiKS5jb25jYXQoZ2VuSWZDb25kaXRpb25zKGNvbmRpdGlvbnMsIHN0YXRlLCBhbHRHZW4sIGFsdEVtcHR5KSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQoZ2VuVGVybmFyeUV4cChjb25kaXRpb24uYmxvY2spKTtcclxuICAgIH1cclxuICAgIC8vIHYtaWYgd2l0aCB2LW9uY2Ugc2hvdWxkIGdlbmVyYXRlIGNvZGUgbGlrZSAoYSk/X20oMCk6X20oMSlcclxuICAgIGZ1bmN0aW9uIGdlblRlcm5hcnlFeHAoZWwpIHtcclxuICAgICAgICByZXR1cm4gYWx0R2VuXHJcbiAgICAgICAgICAgID8gYWx0R2VuKGVsLCBzdGF0ZSlcclxuICAgICAgICAgICAgOiBlbC5vbmNlXHJcbiAgICAgICAgICAgICAgICA/IGdlbk9uY2UoZWwsIHN0YXRlKVxyXG4gICAgICAgICAgICAgICAgOiBnZW5FbGVtZW50KGVsLCBzdGF0ZSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2VuRm9yKGVsLCBzdGF0ZSwgYWx0R2VuLCBhbHRIZWxwZXIpIHtcclxuICAgIHZhciBleHAgPSBlbC5mb3I7XHJcbiAgICB2YXIgYWxpYXMgPSBlbC5hbGlhcztcclxuICAgIHZhciBpdGVyYXRvcjEgPSBlbC5pdGVyYXRvcjEgPyBcIixcIi5jb25jYXQoZWwuaXRlcmF0b3IxKSA6ICcnO1xyXG4gICAgdmFyIGl0ZXJhdG9yMiA9IGVsLml0ZXJhdG9yMiA/IFwiLFwiLmNvbmNhdChlbC5pdGVyYXRvcjIpIDogJyc7XHJcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxyXG4gICAgICAgIHN0YXRlLm1heWJlQ29tcG9uZW50KGVsKSAmJlxyXG4gICAgICAgIGVsLnRhZyAhPT0gJ3Nsb3QnICYmXHJcbiAgICAgICAgZWwudGFnICE9PSAndGVtcGxhdGUnICYmXHJcbiAgICAgICAgIWVsLmtleSkge1xyXG4gICAgICAgIHN0YXRlLndhcm4oXCI8XCIuY29uY2F0KGVsLnRhZywgXCIgdi1mb3I9XFxcIlwiKS5jb25jYXQoYWxpYXMsIFwiIGluIFwiKS5jb25jYXQoZXhwLCBcIlxcXCI+OiBjb21wb25lbnQgbGlzdHMgcmVuZGVyZWQgd2l0aCBcIikgK1xyXG4gICAgICAgICAgICBcInYtZm9yIHNob3VsZCBoYXZlIGV4cGxpY2l0IGtleXMuIFwiICtcclxuICAgICAgICAgICAgXCJTZWUgaHR0cHM6Ly92dWVqcy5vcmcvZ3VpZGUvbGlzdC5odG1sI2tleSBmb3IgbW9yZSBpbmZvLlwiLCBlbC5yYXdBdHRyc01hcFsndi1mb3InXSwgdHJ1ZSAvKiB0aXAgKi8pO1xyXG4gICAgfVxyXG4gICAgZWwuZm9yUHJvY2Vzc2VkID0gdHJ1ZTsgLy8gYXZvaWQgcmVjdXJzaW9uXHJcbiAgICByZXR1cm4gKFwiXCIuY29uY2F0KGFsdEhlbHBlciB8fCAnX2wnLCBcIigoXCIpLmNvbmNhdChleHAsIFwiKSxcIikgK1xyXG4gICAgICAgIFwiZnVuY3Rpb24oXCIuY29uY2F0KGFsaWFzKS5jb25jYXQoaXRlcmF0b3IxKS5jb25jYXQoaXRlcmF0b3IyLCBcIil7XCIpICtcclxuICAgICAgICBcInJldHVybiBcIi5jb25jYXQoKGFsdEdlbiB8fCBnZW5FbGVtZW50KShlbCwgc3RhdGUpKSArXHJcbiAgICAgICAgJ30pJyk7XHJcbn1cclxuZnVuY3Rpb24gZ2VuRGF0YShlbCwgc3RhdGUpIHtcclxuICAgIHZhciBkYXRhID0gJ3snO1xyXG4gICAgLy8gZGlyZWN0aXZlcyBmaXJzdC5cclxuICAgIC8vIGRpcmVjdGl2ZXMgbWF5IG11dGF0ZSB0aGUgZWwncyBvdGhlciBwcm9wZXJ0aWVzIGJlZm9yZSB0aGV5IGFyZSBnZW5lcmF0ZWQuXHJcbiAgICB2YXIgZGlycyA9IGdlbkRpcmVjdGl2ZXMoZWwsIHN0YXRlKTtcclxuICAgIGlmIChkaXJzKVxyXG4gICAgICAgIGRhdGEgKz0gZGlycyArICcsJztcclxuICAgIC8vIGtleVxyXG4gICAgaWYgKGVsLmtleSkge1xyXG4gICAgICAgIGRhdGEgKz0gXCJrZXk6XCIuY29uY2F0KGVsLmtleSwgXCIsXCIpO1xyXG4gICAgfVxyXG4gICAgLy8gcmVmXHJcbiAgICBpZiAoZWwucmVmKSB7XHJcbiAgICAgICAgZGF0YSArPSBcInJlZjpcIi5jb25jYXQoZWwucmVmLCBcIixcIik7XHJcbiAgICB9XHJcbiAgICBpZiAoZWwucmVmSW5Gb3IpIHtcclxuICAgICAgICBkYXRhICs9IFwicmVmSW5Gb3I6dHJ1ZSxcIjtcclxuICAgIH1cclxuICAgIC8vIHByZVxyXG4gICAgaWYgKGVsLnByZSkge1xyXG4gICAgICAgIGRhdGEgKz0gXCJwcmU6dHJ1ZSxcIjtcclxuICAgIH1cclxuICAgIC8vIHJlY29yZCBvcmlnaW5hbCB0YWcgbmFtZSBmb3IgY29tcG9uZW50cyB1c2luZyBcImlzXCIgYXR0cmlidXRlXHJcbiAgICBpZiAoZWwuY29tcG9uZW50KSB7XHJcbiAgICAgICAgZGF0YSArPSBcInRhZzpcXFwiXCIuY29uY2F0KGVsLnRhZywgXCJcXFwiLFwiKTtcclxuICAgIH1cclxuICAgIC8vIG1vZHVsZSBkYXRhIGdlbmVyYXRpb24gZnVuY3Rpb25zXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlLmRhdGFHZW5GbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBkYXRhICs9IHN0YXRlLmRhdGFHZW5GbnNbaV0oZWwpO1xyXG4gICAgfVxyXG4gICAgLy8gYXR0cmlidXRlc1xyXG4gICAgaWYgKGVsLmF0dHJzKSB7XHJcbiAgICAgICAgZGF0YSArPSBcImF0dHJzOlwiLmNvbmNhdChnZW5Qcm9wcyhlbC5hdHRycyksIFwiLFwiKTtcclxuICAgIH1cclxuICAgIC8vIERPTSBwcm9wc1xyXG4gICAgaWYgKGVsLnByb3BzKSB7XHJcbiAgICAgICAgZGF0YSArPSBcImRvbVByb3BzOlwiLmNvbmNhdChnZW5Qcm9wcyhlbC5wcm9wcyksIFwiLFwiKTtcclxuICAgIH1cclxuICAgIC8vIGV2ZW50IGhhbmRsZXJzXHJcbiAgICBpZiAoZWwuZXZlbnRzKSB7XHJcbiAgICAgICAgZGF0YSArPSBcIlwiLmNvbmNhdChnZW5IYW5kbGVycyhlbC5ldmVudHMsIGZhbHNlKSwgXCIsXCIpO1xyXG4gICAgfVxyXG4gICAgaWYgKGVsLm5hdGl2ZUV2ZW50cykge1xyXG4gICAgICAgIGRhdGEgKz0gXCJcIi5jb25jYXQoZ2VuSGFuZGxlcnMoZWwubmF0aXZlRXZlbnRzLCB0cnVlKSwgXCIsXCIpO1xyXG4gICAgfVxyXG4gICAgLy8gc2xvdCB0YXJnZXRcclxuICAgIC8vIG9ubHkgZm9yIG5vbi1zY29wZWQgc2xvdHNcclxuICAgIGlmIChlbC5zbG90VGFyZ2V0ICYmICFlbC5zbG90U2NvcGUpIHtcclxuICAgICAgICBkYXRhICs9IFwic2xvdDpcIi5jb25jYXQoZWwuc2xvdFRhcmdldCwgXCIsXCIpO1xyXG4gICAgfVxyXG4gICAgLy8gc2NvcGVkIHNsb3RzXHJcbiAgICBpZiAoZWwuc2NvcGVkU2xvdHMpIHtcclxuICAgICAgICBkYXRhICs9IFwiXCIuY29uY2F0KGdlblNjb3BlZFNsb3RzKGVsLCBlbC5zY29wZWRTbG90cywgc3RhdGUpLCBcIixcIik7XHJcbiAgICB9XHJcbiAgICAvLyBjb21wb25lbnQgdi1tb2RlbFxyXG4gICAgaWYgKGVsLm1vZGVsKSB7XHJcbiAgICAgICAgZGF0YSArPSBcIm1vZGVsOnt2YWx1ZTpcIi5jb25jYXQoZWwubW9kZWwudmFsdWUsIFwiLGNhbGxiYWNrOlwiKS5jb25jYXQoZWwubW9kZWwuY2FsbGJhY2ssIFwiLGV4cHJlc3Npb246XCIpLmNvbmNhdChlbC5tb2RlbC5leHByZXNzaW9uLCBcIn0sXCIpO1xyXG4gICAgfVxyXG4gICAgLy8gaW5saW5lLXRlbXBsYXRlXHJcbiAgICBpZiAoZWwuaW5saW5lVGVtcGxhdGUpIHtcclxuICAgICAgICB2YXIgaW5saW5lVGVtcGxhdGUgPSBnZW5JbmxpbmVUZW1wbGF0ZShlbCwgc3RhdGUpO1xyXG4gICAgICAgIGlmIChpbmxpbmVUZW1wbGF0ZSkge1xyXG4gICAgICAgICAgICBkYXRhICs9IFwiXCIuY29uY2F0KGlubGluZVRlbXBsYXRlLCBcIixcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZGF0YSA9IGRhdGEucmVwbGFjZSgvLCQvLCAnJykgKyAnfSc7XHJcbiAgICAvLyB2LWJpbmQgZHluYW1pYyBhcmd1bWVudCB3cmFwXHJcbiAgICAvLyB2LWJpbmQgd2l0aCBkeW5hbWljIGFyZ3VtZW50cyBtdXN0IGJlIGFwcGxpZWQgdXNpbmcgdGhlIHNhbWUgdi1iaW5kIG9iamVjdFxyXG4gICAgLy8gbWVyZ2UgaGVscGVyIHNvIHRoYXQgY2xhc3Mvc3R5bGUvbXVzdFVzZVByb3AgYXR0cnMgYXJlIGhhbmRsZWQgY29ycmVjdGx5LlxyXG4gICAgaWYgKGVsLmR5bmFtaWNBdHRycykge1xyXG4gICAgICAgIGRhdGEgPSBcIl9iKFwiLmNvbmNhdChkYXRhLCBcIixcXFwiXCIpLmNvbmNhdChlbC50YWcsIFwiXFxcIixcIikuY29uY2F0KGdlblByb3BzKGVsLmR5bmFtaWNBdHRycyksIFwiKVwiKTtcclxuICAgIH1cclxuICAgIC8vIHYtYmluZCBkYXRhIHdyYXBcclxuICAgIGlmIChlbC53cmFwRGF0YSkge1xyXG4gICAgICAgIGRhdGEgPSBlbC53cmFwRGF0YShkYXRhKTtcclxuICAgIH1cclxuICAgIC8vIHYtb24gZGF0YSB3cmFwXHJcbiAgICBpZiAoZWwud3JhcExpc3RlbmVycykge1xyXG4gICAgICAgIGRhdGEgPSBlbC53cmFwTGlzdGVuZXJzKGRhdGEpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRhdGE7XHJcbn1cclxuZnVuY3Rpb24gZ2VuRGlyZWN0aXZlcyhlbCwgc3RhdGUpIHtcclxuICAgIHZhciBkaXJzID0gZWwuZGlyZWN0aXZlcztcclxuICAgIGlmICghZGlycylcclxuICAgICAgICByZXR1cm47XHJcbiAgICB2YXIgcmVzID0gJ2RpcmVjdGl2ZXM6Wyc7XHJcbiAgICB2YXIgaGFzUnVudGltZSA9IGZhbHNlO1xyXG4gICAgdmFyIGksIGwsIGRpciwgbmVlZFJ1bnRpbWU7XHJcbiAgICBmb3IgKGkgPSAwLCBsID0gZGlycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICBkaXIgPSBkaXJzW2ldO1xyXG4gICAgICAgIG5lZWRSdW50aW1lID0gdHJ1ZTtcclxuICAgICAgICB2YXIgZ2VuID0gc3RhdGUuZGlyZWN0aXZlc1tkaXIubmFtZV07XHJcbiAgICAgICAgaWYgKGdlbikge1xyXG4gICAgICAgICAgICAvLyBjb21waWxlLXRpbWUgZGlyZWN0aXZlIHRoYXQgbWFuaXB1bGF0ZXMgQVNULlxyXG4gICAgICAgICAgICAvLyByZXR1cm5zIHRydWUgaWYgaXQgYWxzbyBuZWVkcyBhIHJ1bnRpbWUgY291bnRlcnBhcnQuXHJcbiAgICAgICAgICAgIG5lZWRSdW50aW1lID0gISFnZW4oZWwsIGRpciwgc3RhdGUud2Fybik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuZWVkUnVudGltZSkge1xyXG4gICAgICAgICAgICBoYXNSdW50aW1lID0gdHJ1ZTtcclxuICAgICAgICAgICAgcmVzICs9IFwie25hbWU6XFxcIlwiLmNvbmNhdChkaXIubmFtZSwgXCJcXFwiLHJhd05hbWU6XFxcIlwiKS5jb25jYXQoZGlyLnJhd05hbWUsIFwiXFxcIlwiKS5jb25jYXQoZGlyLnZhbHVlXHJcbiAgICAgICAgICAgICAgICA/IFwiLHZhbHVlOihcIi5jb25jYXQoZGlyLnZhbHVlLCBcIiksZXhwcmVzc2lvbjpcIikuY29uY2F0KEpTT04uc3RyaW5naWZ5KGRpci52YWx1ZSkpXHJcbiAgICAgICAgICAgICAgICA6ICcnKS5jb25jYXQoZGlyLmFyZyA/IFwiLGFyZzpcIi5jb25jYXQoZGlyLmlzRHluYW1pY0FyZyA/IGRpci5hcmcgOiBcIlxcXCJcIi5jb25jYXQoZGlyLmFyZywgXCJcXFwiXCIpKSA6ICcnKS5jb25jYXQoZGlyLm1vZGlmaWVycyA/IFwiLG1vZGlmaWVyczpcIi5jb25jYXQoSlNPTi5zdHJpbmdpZnkoZGlyLm1vZGlmaWVycykpIDogJycsIFwifSxcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGhhc1J1bnRpbWUpIHtcclxuICAgICAgICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKSArICddJztcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZW5JbmxpbmVUZW1wbGF0ZShlbCwgc3RhdGUpIHtcclxuICAgIHZhciBhc3QgPSBlbC5jaGlsZHJlblswXTtcclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIChlbC5jaGlsZHJlbi5sZW5ndGggIT09IDEgfHwgYXN0LnR5cGUgIT09IDEpKSB7XHJcbiAgICAgICAgc3RhdGUud2FybignSW5saW5lLXRlbXBsYXRlIGNvbXBvbmVudHMgbXVzdCBoYXZlIGV4YWN0bHkgb25lIGNoaWxkIGVsZW1lbnQuJywgeyBzdGFydDogZWwuc3RhcnQgfSk7XHJcbiAgICB9XHJcbiAgICBpZiAoYXN0ICYmIGFzdC50eXBlID09PSAxKSB7XHJcbiAgICAgICAgdmFyIGlubGluZVJlbmRlckZucyA9IGdlbmVyYXRlKGFzdCwgc3RhdGUub3B0aW9ucyk7XHJcbiAgICAgICAgcmV0dXJuIFwiaW5saW5lVGVtcGxhdGU6e3JlbmRlcjpmdW5jdGlvbigpe1wiLmNvbmNhdChpbmxpbmVSZW5kZXJGbnMucmVuZGVyLCBcIn0sc3RhdGljUmVuZGVyRm5zOltcIikuY29uY2F0KGlubGluZVJlbmRlckZucy5zdGF0aWNSZW5kZXJGbnNcclxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoY29kZSkgeyByZXR1cm4gXCJmdW5jdGlvbigpe1wiLmNvbmNhdChjb2RlLCBcIn1cIik7IH0pXHJcbiAgICAgICAgICAgIC5qb2luKCcsJyksIFwiXX1cIik7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2VuU2NvcGVkU2xvdHMoZWwsIHNsb3RzLCBzdGF0ZSkge1xyXG4gICAgLy8gYnkgZGVmYXVsdCBzY29wZWQgc2xvdHMgYXJlIGNvbnNpZGVyZWQgXCJzdGFibGVcIiwgdGhpcyBhbGxvd3MgY2hpbGRcclxuICAgIC8vIGNvbXBvbmVudHMgd2l0aCBvbmx5IHNjb3BlZCBzbG90cyB0byBza2lwIGZvcmNlZCB1cGRhdGVzIGZyb20gcGFyZW50LlxyXG4gICAgLy8gYnV0IGluIHNvbWUgY2FzZXMgd2UgaGF2ZSB0byBiYWlsLW91dCBvZiB0aGlzIG9wdGltaXphdGlvblxyXG4gICAgLy8gZm9yIGV4YW1wbGUgaWYgdGhlIHNsb3QgY29udGFpbnMgZHluYW1pYyBuYW1lcywgaGFzIHYtaWYgb3Igdi1mb3Igb24gdGhlbS4uLlxyXG4gICAgdmFyIG5lZWRzRm9yY2VVcGRhdGUgPSBlbC5mb3IgfHxcclxuICAgICAgICBPYmplY3Qua2V5cyhzbG90cykuc29tZShmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIHZhciBzbG90ID0gc2xvdHNba2V5XTtcclxuICAgICAgICAgICAgcmV0dXJuIChzbG90LnNsb3RUYXJnZXREeW5hbWljIHx8IHNsb3QuaWYgfHwgc2xvdC5mb3IgfHwgY29udGFpbnNTbG90Q2hpbGQoc2xvdCkgLy8gaXMgcGFzc2luZyBkb3duIHNsb3QgZnJvbSBwYXJlbnQgd2hpY2ggbWF5IGJlIGR5bmFtaWNcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9KTtcclxuICAgIC8vICM5NTM0OiBpZiBhIGNvbXBvbmVudCB3aXRoIHNjb3BlZCBzbG90cyBpcyBpbnNpZGUgYSBjb25kaXRpb25hbCBicmFuY2gsXHJcbiAgICAvLyBpdCdzIHBvc3NpYmxlIGZvciB0aGUgc2FtZSBjb21wb25lbnQgdG8gYmUgcmV1c2VkIGJ1dCB3aXRoIGRpZmZlcmVudFxyXG4gICAgLy8gY29tcGlsZWQgc2xvdCBjb250ZW50LiBUbyBhdm9pZCB0aGF0LCB3ZSBnZW5lcmF0ZSBhIHVuaXF1ZSBrZXkgYmFzZWQgb25cclxuICAgIC8vIHRoZSBnZW5lcmF0ZWQgY29kZSBvZiBhbGwgdGhlIHNsb3QgY29udGVudHMuXHJcbiAgICB2YXIgbmVlZHNLZXkgPSAhIWVsLmlmO1xyXG4gICAgLy8gT1Igd2hlbiBpdCBpcyBpbnNpZGUgYW5vdGhlciBzY29wZWQgc2xvdCBvciB2LWZvciAodGhlIHJlYWN0aXZpdHkgbWF5IGJlXHJcbiAgICAvLyBkaXNjb25uZWN0ZWQgZHVlIHRvIHRoZSBpbnRlcm1lZGlhdGUgc2NvcGUgdmFyaWFibGUpXHJcbiAgICAvLyAjOTQzOCwgIzk1MDZcclxuICAgIC8vIFRPRE86IHRoaXMgY2FuIGJlIGZ1cnRoZXIgb3B0aW1pemVkIGJ5IHByb3Blcmx5IGFuYWx5emluZyBpbi1zY29wZSBiaW5kaW5nc1xyXG4gICAgLy8gYW5kIHNraXAgZm9yY2UgdXBkYXRpbmcgb25lcyB0aGF0IGRvIG5vdCBhY3R1YWxseSB1c2Ugc2NvcGUgdmFyaWFibGVzLlxyXG4gICAgaWYgKCFuZWVkc0ZvcmNlVXBkYXRlKSB7XHJcbiAgICAgICAgdmFyIHBhcmVudF8yID0gZWwucGFyZW50O1xyXG4gICAgICAgIHdoaWxlIChwYXJlbnRfMikge1xyXG4gICAgICAgICAgICBpZiAoKHBhcmVudF8yLnNsb3RTY29wZSAmJiBwYXJlbnRfMi5zbG90U2NvcGUgIT09IGVtcHR5U2xvdFNjb3BlVG9rZW4pIHx8XHJcbiAgICAgICAgICAgICAgICBwYXJlbnRfMi5mb3IpIHtcclxuICAgICAgICAgICAgICAgIG5lZWRzRm9yY2VVcGRhdGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHBhcmVudF8yLmlmKSB7XHJcbiAgICAgICAgICAgICAgICBuZWVkc0tleSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcGFyZW50XzIgPSBwYXJlbnRfMi5wYXJlbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdmFyIGdlbmVyYXRlZFNsb3RzID0gT2JqZWN0LmtleXMoc2xvdHMpXHJcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBnZW5TY29wZWRTbG90KHNsb3RzW2tleV0sIHN0YXRlKTsgfSlcclxuICAgICAgICAuam9pbignLCcpO1xyXG4gICAgcmV0dXJuIFwic2NvcGVkU2xvdHM6X3UoW1wiLmNvbmNhdChnZW5lcmF0ZWRTbG90cywgXCJdXCIpLmNvbmNhdChuZWVkc0ZvcmNlVXBkYXRlID8gXCIsbnVsbCx0cnVlXCIgOiBcIlwiKS5jb25jYXQoIW5lZWRzRm9yY2VVcGRhdGUgJiYgbmVlZHNLZXkgPyBcIixudWxsLGZhbHNlLFwiLmNvbmNhdChoYXNoKGdlbmVyYXRlZFNsb3RzKSkgOiBcIlwiLCBcIilcIik7XHJcbn1cclxuZnVuY3Rpb24gaGFzaChzdHIpIHtcclxuICAgIHZhciBoYXNoID0gNTM4MTtcclxuICAgIHZhciBpID0gc3RyLmxlbmd0aDtcclxuICAgIHdoaWxlIChpKSB7XHJcbiAgICAgICAgaGFzaCA9IChoYXNoICogMzMpIF4gc3RyLmNoYXJDb2RlQXQoLS1pKTtcclxuICAgIH1cclxuICAgIHJldHVybiBoYXNoID4+PiAwO1xyXG59XHJcbmZ1bmN0aW9uIGNvbnRhaW5zU2xvdENoaWxkKGVsKSB7XHJcbiAgICBpZiAoZWwudHlwZSA9PT0gMSkge1xyXG4gICAgICAgIGlmIChlbC50YWcgPT09ICdzbG90Jykge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGVsLmNoaWxkcmVuLnNvbWUoY29udGFpbnNTbG90Q2hpbGQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIGdlblNjb3BlZFNsb3QoZWwsIHN0YXRlKSB7XHJcbiAgICB2YXIgaXNMZWdhY3lTeW50YXggPSBlbC5hdHRyc01hcFsnc2xvdC1zY29wZSddO1xyXG4gICAgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCAmJiAhaXNMZWdhY3lTeW50YXgpIHtcclxuICAgICAgICByZXR1cm4gZ2VuSWYoZWwsIHN0YXRlLCBnZW5TY29wZWRTbG90LCBcIm51bGxcIik7XHJcbiAgICB9XHJcbiAgICBpZiAoZWwuZm9yICYmICFlbC5mb3JQcm9jZXNzZWQpIHtcclxuICAgICAgICByZXR1cm4gZ2VuRm9yKGVsLCBzdGF0ZSwgZ2VuU2NvcGVkU2xvdCk7XHJcbiAgICB9XHJcbiAgICB2YXIgc2xvdFNjb3BlID0gZWwuc2xvdFNjb3BlID09PSBlbXB0eVNsb3RTY29wZVRva2VuID8gXCJcIiA6IFN0cmluZyhlbC5zbG90U2NvcGUpO1xyXG4gICAgdmFyIGZuID0gXCJmdW5jdGlvbihcIi5jb25jYXQoc2xvdFNjb3BlLCBcIil7XCIpICtcclxuICAgICAgICBcInJldHVybiBcIi5jb25jYXQoZWwudGFnID09PSAndGVtcGxhdGUnXHJcbiAgICAgICAgICAgID8gZWwuaWYgJiYgaXNMZWdhY3lTeW50YXhcclxuICAgICAgICAgICAgICAgID8gXCIoXCIuY29uY2F0KGVsLmlmLCBcIik/XCIpLmNvbmNhdChnZW5DaGlsZHJlbihlbCwgc3RhdGUpIHx8ICd1bmRlZmluZWQnLCBcIjp1bmRlZmluZWRcIilcclxuICAgICAgICAgICAgICAgIDogZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKSB8fCAndW5kZWZpbmVkJ1xyXG4gICAgICAgICAgICA6IGdlbkVsZW1lbnQoZWwsIHN0YXRlKSwgXCJ9XCIpO1xyXG4gICAgLy8gcmV2ZXJzZSBwcm94eSB2LXNsb3Qgd2l0aG91dCBzY29wZSBvbiB0aGlzLiRzbG90c1xyXG4gICAgdmFyIHJldmVyc2VQcm94eSA9IHNsb3RTY29wZSA/IFwiXCIgOiBcIixwcm94eTp0cnVlXCI7XHJcbiAgICByZXR1cm4gXCJ7a2V5OlwiLmNvbmNhdChlbC5zbG90VGFyZ2V0IHx8IFwiXFxcImRlZmF1bHRcXFwiXCIsIFwiLGZuOlwiKS5jb25jYXQoZm4pLmNvbmNhdChyZXZlcnNlUHJveHksIFwifVwiKTtcclxufVxyXG5mdW5jdGlvbiBnZW5DaGlsZHJlbihlbCwgc3RhdGUsIGNoZWNrU2tpcCwgYWx0R2VuRWxlbWVudCwgYWx0R2VuTm9kZSkge1xyXG4gICAgdmFyIGNoaWxkcmVuID0gZWwuY2hpbGRyZW47XHJcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XHJcbiAgICAgICAgdmFyIGVsXzEgPSBjaGlsZHJlblswXTtcclxuICAgICAgICAvLyBvcHRpbWl6ZSBzaW5nbGUgdi1mb3JcclxuICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmXHJcbiAgICAgICAgICAgIGVsXzEuZm9yICYmXHJcbiAgICAgICAgICAgIGVsXzEudGFnICE9PSAndGVtcGxhdGUnICYmXHJcbiAgICAgICAgICAgIGVsXzEudGFnICE9PSAnc2xvdCcpIHtcclxuICAgICAgICAgICAgdmFyIG5vcm1hbGl6YXRpb25UeXBlXzEgPSBjaGVja1NraXBcclxuICAgICAgICAgICAgICAgID8gc3RhdGUubWF5YmVDb21wb25lbnQoZWxfMSlcclxuICAgICAgICAgICAgICAgICAgICA/IFwiLDFcIlxyXG4gICAgICAgICAgICAgICAgICAgIDogXCIsMFwiXHJcbiAgICAgICAgICAgICAgICA6IFwiXCI7XHJcbiAgICAgICAgICAgIHJldHVybiBcIlwiLmNvbmNhdCgoYWx0R2VuRWxlbWVudCB8fCBnZW5FbGVtZW50KShlbF8xLCBzdGF0ZSkpLmNvbmNhdChub3JtYWxpemF0aW9uVHlwZV8xKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG5vcm1hbGl6YXRpb25UeXBlID0gY2hlY2tTa2lwXHJcbiAgICAgICAgICAgID8gZ2V0Tm9ybWFsaXphdGlvblR5cGUoY2hpbGRyZW4sIHN0YXRlLm1heWJlQ29tcG9uZW50KVxyXG4gICAgICAgICAgICA6IDA7XHJcbiAgICAgICAgdmFyIGdlbl8xID0gYWx0R2VuTm9kZSB8fCBnZW5Ob2RlO1xyXG4gICAgICAgIHJldHVybiBcIltcIi5jb25jYXQoY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBnZW5fMShjLCBzdGF0ZSk7IH0pLmpvaW4oJywnKSwgXCJdXCIpLmNvbmNhdChub3JtYWxpemF0aW9uVHlwZSA/IFwiLFwiLmNvbmNhdChub3JtYWxpemF0aW9uVHlwZSkgOiAnJyk7XHJcbiAgICB9XHJcbn1cclxuLy8gZGV0ZXJtaW5lIHRoZSBub3JtYWxpemF0aW9uIG5lZWRlZCBmb3IgdGhlIGNoaWxkcmVuIGFycmF5LlxyXG4vLyAwOiBubyBub3JtYWxpemF0aW9uIG5lZWRlZFxyXG4vLyAxOiBzaW1wbGUgbm9ybWFsaXphdGlvbiBuZWVkZWQgKHBvc3NpYmxlIDEtbGV2ZWwgZGVlcCBuZXN0ZWQgYXJyYXkpXHJcbi8vIDI6IGZ1bGwgbm9ybWFsaXphdGlvbiBuZWVkZWRcclxuZnVuY3Rpb24gZ2V0Tm9ybWFsaXphdGlvblR5cGUoY2hpbGRyZW4sIG1heWJlQ29tcG9uZW50KSB7XHJcbiAgICB2YXIgcmVzID0gMDtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgZWwgPSBjaGlsZHJlbltpXTtcclxuICAgICAgICBpZiAoZWwudHlwZSAhPT0gMSkge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5lZWRzTm9ybWFsaXphdGlvbihlbCkgfHxcclxuICAgICAgICAgICAgKGVsLmlmQ29uZGl0aW9ucyAmJlxyXG4gICAgICAgICAgICAgICAgZWwuaWZDb25kaXRpb25zLnNvbWUoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIG5lZWRzTm9ybWFsaXphdGlvbihjLmJsb2NrKTsgfSkpKSB7XHJcbiAgICAgICAgICAgIHJlcyA9IDI7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWF5YmVDb21wb25lbnQoZWwpIHx8XHJcbiAgICAgICAgICAgIChlbC5pZkNvbmRpdGlvbnMgJiYgZWwuaWZDb25kaXRpb25zLnNvbWUoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIG1heWJlQ29tcG9uZW50KGMuYmxvY2spOyB9KSkpIHtcclxuICAgICAgICAgICAgcmVzID0gMTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcbmZ1bmN0aW9uIG5lZWRzTm9ybWFsaXphdGlvbihlbCkge1xyXG4gICAgcmV0dXJuIGVsLmZvciAhPT0gdW5kZWZpbmVkIHx8IGVsLnRhZyA9PT0gJ3RlbXBsYXRlJyB8fCBlbC50YWcgPT09ICdzbG90JztcclxufVxyXG5mdW5jdGlvbiBnZW5Ob2RlKG5vZGUsIHN0YXRlKSB7XHJcbiAgICBpZiAobm9kZS50eXBlID09PSAxKSB7XHJcbiAgICAgICAgcmV0dXJuIGdlbkVsZW1lbnQobm9kZSwgc3RhdGUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobm9kZS50eXBlID09PSAzICYmIG5vZGUuaXNDb21tZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIGdlbkNvbW1lbnQobm9kZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gZ2VuVGV4dChub2RlKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZW5UZXh0KHRleHQpIHtcclxuICAgIHJldHVybiBcIl92KFwiLmNvbmNhdCh0ZXh0LnR5cGUgPT09IDJcclxuICAgICAgICA/IHRleHQuZXhwcmVzc2lvbiAvLyBubyBuZWVkIGZvciAoKSBiZWNhdXNlIGFscmVhZHkgd3JhcHBlZCBpbiBfcygpXHJcbiAgICAgICAgOiB0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMoSlNPTi5zdHJpbmdpZnkodGV4dC50ZXh0KSksIFwiKVwiKTtcclxufVxyXG5mdW5jdGlvbiBnZW5Db21tZW50KGNvbW1lbnQpIHtcclxuICAgIHJldHVybiBcIl9lKFwiLmNvbmNhdChKU09OLnN0cmluZ2lmeShjb21tZW50LnRleHQpLCBcIilcIik7XHJcbn1cclxuZnVuY3Rpb24gZ2VuU2xvdChlbCwgc3RhdGUpIHtcclxuICAgIHZhciBzbG90TmFtZSA9IGVsLnNsb3ROYW1lIHx8ICdcImRlZmF1bHRcIic7XHJcbiAgICB2YXIgY2hpbGRyZW4gPSBnZW5DaGlsZHJlbihlbCwgc3RhdGUpO1xyXG4gICAgdmFyIHJlcyA9IFwiX3QoXCIuY29uY2F0KHNsb3ROYW1lKS5jb25jYXQoY2hpbGRyZW4gPyBcIixmdW5jdGlvbigpe3JldHVybiBcIi5jb25jYXQoY2hpbGRyZW4sIFwifVwiKSA6ICcnKTtcclxuICAgIHZhciBhdHRycyA9IGVsLmF0dHJzIHx8IGVsLmR5bmFtaWNBdHRyc1xyXG4gICAgICAgID8gZ2VuUHJvcHMoKGVsLmF0dHJzIHx8IFtdKS5jb25jYXQoZWwuZHluYW1pY0F0dHJzIHx8IFtdKS5tYXAoZnVuY3Rpb24gKGF0dHIpIHsgcmV0dXJuICh7XHJcbiAgICAgICAgICAgIC8vIHNsb3QgcHJvcHMgYXJlIGNhbWVsaXplZFxyXG4gICAgICAgICAgICBuYW1lOiBjYW1lbGl6ZShhdHRyLm5hbWUpLFxyXG4gICAgICAgICAgICB2YWx1ZTogYXR0ci52YWx1ZSxcclxuICAgICAgICAgICAgZHluYW1pYzogYXR0ci5keW5hbWljXHJcbiAgICAgICAgfSk7IH0pKVxyXG4gICAgICAgIDogbnVsbDtcclxuICAgIHZhciBiaW5kID0gZWwuYXR0cnNNYXBbJ3YtYmluZCddO1xyXG4gICAgaWYgKChhdHRycyB8fCBiaW5kKSAmJiAhY2hpbGRyZW4pIHtcclxuICAgICAgICByZXMgKz0gXCIsbnVsbFwiO1xyXG4gICAgfVxyXG4gICAgaWYgKGF0dHJzKSB7XHJcbiAgICAgICAgcmVzICs9IFwiLFwiLmNvbmNhdChhdHRycyk7XHJcbiAgICB9XHJcbiAgICBpZiAoYmluZCkge1xyXG4gICAgICAgIHJlcyArPSBcIlwiLmNvbmNhdChhdHRycyA/ICcnIDogJyxudWxsJywgXCIsXCIpLmNvbmNhdChiaW5kKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXMgKyAnKSc7XHJcbn1cclxuLy8gY29tcG9uZW50TmFtZSBpcyBlbC5jb21wb25lbnQsIHRha2UgaXQgYXMgYXJndW1lbnQgdG8gc2h1biBmbG93J3MgcGVzc2ltaXN0aWMgcmVmaW5lbWVudFxyXG5mdW5jdGlvbiBnZW5Db21wb25lbnQoY29tcG9uZW50TmFtZSwgZWwsIHN0YXRlKSB7XHJcbiAgICB2YXIgY2hpbGRyZW4gPSBlbC5pbmxpbmVUZW1wbGF0ZSA/IG51bGwgOiBnZW5DaGlsZHJlbihlbCwgc3RhdGUsIHRydWUpO1xyXG4gICAgcmV0dXJuIFwiX2MoXCIuY29uY2F0KGNvbXBvbmVudE5hbWUsIFwiLFwiKS5jb25jYXQoZ2VuRGF0YShlbCwgc3RhdGUpKS5jb25jYXQoY2hpbGRyZW4gPyBcIixcIi5jb25jYXQoY2hpbGRyZW4pIDogJycsIFwiKVwiKTtcclxufVxyXG5mdW5jdGlvbiBnZW5Qcm9wcyhwcm9wcykge1xyXG4gICAgdmFyIHN0YXRpY1Byb3BzID0gXCJcIjtcclxuICAgIHZhciBkeW5hbWljUHJvcHMgPSBcIlwiO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciBwcm9wID0gcHJvcHNbaV07XHJcbiAgICAgICAgdmFyIHZhbHVlID0gdHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzKHByb3AudmFsdWUpO1xyXG4gICAgICAgIGlmIChwcm9wLmR5bmFtaWMpIHtcclxuICAgICAgICAgICAgZHluYW1pY1Byb3BzICs9IFwiXCIuY29uY2F0KHByb3AubmFtZSwgXCIsXCIpLmNvbmNhdCh2YWx1ZSwgXCIsXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc3RhdGljUHJvcHMgKz0gXCJcXFwiXCIuY29uY2F0KHByb3AubmFtZSwgXCJcXFwiOlwiKS5jb25jYXQodmFsdWUsIFwiLFwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWNQcm9wcyA9IFwie1wiLmNvbmNhdChzdGF0aWNQcm9wcy5zbGljZSgwLCAtMSksIFwifVwiKTtcclxuICAgIGlmIChkeW5hbWljUHJvcHMpIHtcclxuICAgICAgICByZXR1cm4gXCJfZChcIi5jb25jYXQoc3RhdGljUHJvcHMsIFwiLFtcIikuY29uY2F0KGR5bmFtaWNQcm9wcy5zbGljZSgwLCAtMSksIFwiXSlcIik7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gc3RhdGljUHJvcHM7XHJcbiAgICB9XHJcbn1cclxuLy8gIzM4OTUsICM0MjY4XHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyh0ZXh0KSB7XHJcbiAgICByZXR1cm4gdGV4dC5yZXBsYWNlKC9cXHUyMDI4L2csICdcXFxcdTIwMjgnKS5yZXBsYWNlKC9cXHUyMDI5L2csICdcXFxcdTIwMjknKTtcclxufVxuXG4vLyB0aGVzZSBrZXl3b3JkcyBzaG91bGQgbm90IGFwcGVhciBpbnNpZGUgZXhwcmVzc2lvbnMsIGJ1dCBvcGVyYXRvcnMgbGlrZVxyXG4vLyB0eXBlb2YsIGluc3RhbmNlb2YgYW5kIGluIGFyZSBhbGxvd2VkXHJcbnZhciBwcm9oaWJpdGVkS2V5d29yZFJFID0gbmV3IFJlZ0V4cCgnXFxcXGInICtcclxuICAgICgnZG8saWYsZm9yLGxldCxuZXcsdHJ5LHZhcixjYXNlLGVsc2Usd2l0aCxhd2FpdCxicmVhayxjYXRjaCxjbGFzcyxjb25zdCwnICtcclxuICAgICAgICAnc3VwZXIsdGhyb3csd2hpbGUseWllbGQsZGVsZXRlLGV4cG9ydCxpbXBvcnQscmV0dXJuLHN3aXRjaCxkZWZhdWx0LCcgK1xyXG4gICAgICAgICdleHRlbmRzLGZpbmFsbHksY29udGludWUsZGVidWdnZXIsZnVuY3Rpb24sYXJndW1lbnRzJylcclxuICAgICAgICAuc3BsaXQoJywnKVxyXG4gICAgICAgIC5qb2luKCdcXFxcYnxcXFxcYicpICtcclxuICAgICdcXFxcYicpO1xyXG4vLyB0aGVzZSB1bmFyeSBvcGVyYXRvcnMgc2hvdWxkIG5vdCBiZSB1c2VkIGFzIHByb3BlcnR5L21ldGhvZCBuYW1lc1xyXG52YXIgdW5hcnlPcGVyYXRvcnNSRSA9IG5ldyBSZWdFeHAoJ1xcXFxiJyArXHJcbiAgICAnZGVsZXRlLHR5cGVvZix2b2lkJy5zcGxpdCgnLCcpLmpvaW4oJ1xcXFxzKlxcXFwoW15cXFxcKV0qXFxcXCl8XFxcXGInKSArXHJcbiAgICAnXFxcXHMqXFxcXChbXlxcXFwpXSpcXFxcKScpO1xyXG4vLyBzdHJpcCBzdHJpbmdzIGluIGV4cHJlc3Npb25zXHJcbnZhciBzdHJpcFN0cmluZ1JFID0gLycoPzpbXidcXFxcXXxcXFxcLikqJ3xcIig/OlteXCJcXFxcXXxcXFxcLikqXCJ8YCg/OlteYFxcXFxdfFxcXFwuKSpcXCRcXHt8XFx9KD86W15gXFxcXF18XFxcXC4pKmB8YCg/OlteYFxcXFxdfFxcXFwuKSpgL2c7XHJcbi8vIGRldGVjdCBwcm9ibGVtYXRpYyBleHByZXNzaW9ucyBpbiBhIHRlbXBsYXRlXHJcbmZ1bmN0aW9uIGRldGVjdEVycm9ycyhhc3QsIHdhcm4pIHtcclxuICAgIGlmIChhc3QpIHtcclxuICAgICAgICBjaGVja05vZGUoYXN0LCB3YXJuKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjaGVja05vZGUobm9kZSwgd2Fybikge1xyXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xyXG4gICAgICAgIGZvciAodmFyIG5hbWVfMSBpbiBub2RlLmF0dHJzTWFwKSB7XHJcbiAgICAgICAgICAgIGlmIChkaXJSRS50ZXN0KG5hbWVfMSkpIHtcclxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IG5vZGUuYXR0cnNNYXBbbmFtZV8xXTtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IG5vZGUucmF3QXR0cnNNYXBbbmFtZV8xXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobmFtZV8xID09PSAndi1mb3InKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrRm9yKG5vZGUsIFwidi1mb3I9XFxcIlwiLmNvbmNhdCh2YWx1ZSwgXCJcXFwiXCIpLCB3YXJuLCByYW5nZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5hbWVfMSA9PT0gJ3Ytc2xvdCcgfHwgbmFtZV8xWzBdID09PSAnIycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tGdW5jdGlvblBhcmFtZXRlckV4cHJlc3Npb24odmFsdWUsIFwiXCIuY29uY2F0KG5hbWVfMSwgXCI9XFxcIlwiKS5jb25jYXQodmFsdWUsIFwiXFxcIlwiKSwgd2FybiwgcmFuZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChvblJFLnRlc3QobmFtZV8xKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja0V2ZW50KHZhbHVlLCBcIlwiLmNvbmNhdChuYW1lXzEsIFwiPVxcXCJcIikuY29uY2F0KHZhbHVlLCBcIlxcXCJcIiksIHdhcm4sIHJhbmdlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrRXhwcmVzc2lvbih2YWx1ZSwgXCJcIi5jb25jYXQobmFtZV8xLCBcIj1cXFwiXCIpLmNvbmNhdCh2YWx1ZSwgXCJcXFwiXCIpLCB3YXJuLCByYW5nZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY2hlY2tOb2RlKG5vZGUuY2hpbGRyZW5baV0sIHdhcm4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobm9kZS50eXBlID09PSAyKSB7XHJcbiAgICAgICAgY2hlY2tFeHByZXNzaW9uKG5vZGUuZXhwcmVzc2lvbiwgbm9kZS50ZXh0LCB3YXJuLCBub2RlKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjaGVja0V2ZW50KGV4cCwgdGV4dCwgd2FybiwgcmFuZ2UpIHtcclxuICAgIHZhciBzdHJpcHBlZCA9IGV4cC5yZXBsYWNlKHN0cmlwU3RyaW5nUkUsICcnKTtcclxuICAgIHZhciBrZXl3b3JkTWF0Y2ggPSBzdHJpcHBlZC5tYXRjaCh1bmFyeU9wZXJhdG9yc1JFKTtcclxuICAgIGlmIChrZXl3b3JkTWF0Y2ggJiYgc3RyaXBwZWQuY2hhckF0KGtleXdvcmRNYXRjaC5pbmRleCAtIDEpICE9PSAnJCcpIHtcclxuICAgICAgICB3YXJuKFwiYXZvaWQgdXNpbmcgSmF2YVNjcmlwdCB1bmFyeSBvcGVyYXRvciBhcyBwcm9wZXJ0eSBuYW1lOiBcIiArXHJcbiAgICAgICAgICAgIFwiXFxcIlwiLmNvbmNhdChrZXl3b3JkTWF0Y2hbMF0sIFwiXFxcIiBpbiBleHByZXNzaW9uIFwiKS5jb25jYXQodGV4dC50cmltKCkpLCByYW5nZSk7XHJcbiAgICB9XHJcbiAgICBjaGVja0V4cHJlc3Npb24oZXhwLCB0ZXh0LCB3YXJuLCByYW5nZSk7XHJcbn1cclxuZnVuY3Rpb24gY2hlY2tGb3Iobm9kZSwgdGV4dCwgd2FybiwgcmFuZ2UpIHtcclxuICAgIGNoZWNrRXhwcmVzc2lvbihub2RlLmZvciB8fCAnJywgdGV4dCwgd2FybiwgcmFuZ2UpO1xyXG4gICAgY2hlY2tJZGVudGlmaWVyKG5vZGUuYWxpYXMsICd2LWZvciBhbGlhcycsIHRleHQsIHdhcm4sIHJhbmdlKTtcclxuICAgIGNoZWNrSWRlbnRpZmllcihub2RlLml0ZXJhdG9yMSwgJ3YtZm9yIGl0ZXJhdG9yJywgdGV4dCwgd2FybiwgcmFuZ2UpO1xyXG4gICAgY2hlY2tJZGVudGlmaWVyKG5vZGUuaXRlcmF0b3IyLCAndi1mb3IgaXRlcmF0b3InLCB0ZXh0LCB3YXJuLCByYW5nZSk7XHJcbn1cclxuZnVuY3Rpb24gY2hlY2tJZGVudGlmaWVyKGlkZW50LCB0eXBlLCB0ZXh0LCB3YXJuLCByYW5nZSkge1xyXG4gICAgaWYgKHR5cGVvZiBpZGVudCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBuZXcgRnVuY3Rpb24oXCJ2YXIgXCIuY29uY2F0KGlkZW50LCBcIj1fXCIpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgd2FybihcImludmFsaWQgXCIuY29uY2F0KHR5cGUsIFwiIFxcXCJcIikuY29uY2F0KGlkZW50LCBcIlxcXCIgaW4gZXhwcmVzc2lvbjogXCIpLmNvbmNhdCh0ZXh0LnRyaW0oKSksIHJhbmdlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY2hlY2tFeHByZXNzaW9uKGV4cCwgdGV4dCwgd2FybiwgcmFuZ2UpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgbmV3IEZ1bmN0aW9uKFwicmV0dXJuIFwiLmNvbmNhdChleHApKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgdmFyIGtleXdvcmRNYXRjaCA9IGV4cFxyXG4gICAgICAgICAgICAucmVwbGFjZShzdHJpcFN0cmluZ1JFLCAnJylcclxuICAgICAgICAgICAgLm1hdGNoKHByb2hpYml0ZWRLZXl3b3JkUkUpO1xyXG4gICAgICAgIGlmIChrZXl3b3JkTWF0Y2gpIHtcclxuICAgICAgICAgICAgd2FybihcImF2b2lkIHVzaW5nIEphdmFTY3JpcHQga2V5d29yZCBhcyBwcm9wZXJ0eSBuYW1lOiBcIiArXHJcbiAgICAgICAgICAgICAgICBcIlxcXCJcIi5jb25jYXQoa2V5d29yZE1hdGNoWzBdLCBcIlxcXCJcXG4gIFJhdyBleHByZXNzaW9uOiBcIikuY29uY2F0KHRleHQudHJpbSgpKSwgcmFuZ2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgd2FybihcImludmFsaWQgZXhwcmVzc2lvbjogXCIuY29uY2F0KGUubWVzc2FnZSwgXCIgaW5cXG5cXG5cIikgK1xyXG4gICAgICAgICAgICAgICAgXCIgICAgXCIuY29uY2F0KGV4cCwgXCJcXG5cXG5cIikgK1xyXG4gICAgICAgICAgICAgICAgXCIgIFJhdyBleHByZXNzaW9uOiBcIi5jb25jYXQodGV4dC50cmltKCksIFwiXFxuXCIpLCByYW5nZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNoZWNrRnVuY3Rpb25QYXJhbWV0ZXJFeHByZXNzaW9uKGV4cCwgdGV4dCwgd2FybiwgcmFuZ2UpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgbmV3IEZ1bmN0aW9uKGV4cCwgJycpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICB3YXJuKFwiaW52YWxpZCBmdW5jdGlvbiBwYXJhbWV0ZXIgZXhwcmVzc2lvbjogXCIuY29uY2F0KGUubWVzc2FnZSwgXCIgaW5cXG5cXG5cIikgK1xyXG4gICAgICAgICAgICBcIiAgICBcIi5jb25jYXQoZXhwLCBcIlxcblxcblwiKSArXHJcbiAgICAgICAgICAgIFwiICBSYXcgZXhwcmVzc2lvbjogXCIuY29uY2F0KHRleHQudHJpbSgpLCBcIlxcblwiKSwgcmFuZ2UpO1xyXG4gICAgfVxyXG59XG5cbnZhciByYW5nZSA9IDI7XHJcbmZ1bmN0aW9uIGdlbmVyYXRlQ29kZUZyYW1lKHNvdXJjZSwgc3RhcnQsIGVuZCkge1xyXG4gICAgaWYgKHN0YXJ0ID09PSB2b2lkIDApIHsgc3RhcnQgPSAwOyB9XHJcbiAgICBpZiAoZW5kID09PSB2b2lkIDApIHsgZW5kID0gc291cmNlLmxlbmd0aDsgfVxyXG4gICAgdmFyIGxpbmVzID0gc291cmNlLnNwbGl0KC9cXHI/XFxuLyk7XHJcbiAgICB2YXIgY291bnQgPSAwO1xyXG4gICAgdmFyIHJlcyA9IFtdO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvdW50ICs9IGxpbmVzW2ldLmxlbmd0aCArIDE7XHJcbiAgICAgICAgaWYgKGNvdW50ID49IHN0YXJ0KSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSBpIC0gcmFuZ2U7IGogPD0gaSArIHJhbmdlIHx8IGVuZCA+IGNvdW50OyBqKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChqIDwgMCB8fCBqID49IGxpbmVzLmxlbmd0aClcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIHJlcy5wdXNoKFwiXCIuY29uY2F0KGogKyAxKS5jb25jYXQocmVwZWF0KFwiIFwiLCAzIC0gU3RyaW5nKGogKyAxKS5sZW5ndGgpLCBcInwgIFwiKS5jb25jYXQobGluZXNbal0pKTtcclxuICAgICAgICAgICAgICAgIHZhciBsaW5lTGVuZ3RoID0gbGluZXNbal0ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgaWYgKGogPT09IGkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBwdXNoIHVuZGVybGluZVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYWQgPSBzdGFydCAtIChjb3VudCAtIGxpbmVMZW5ndGgpICsgMTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoXzEgPSBlbmQgPiBjb3VudCA/IGxpbmVMZW5ndGggLSBwYWQgOiBlbmQgLSBzdGFydDtcclxuICAgICAgICAgICAgICAgICAgICByZXMucHVzaChcIiAgIHwgIFwiICsgcmVwZWF0KFwiIFwiLCBwYWQpICsgcmVwZWF0KFwiXlwiLCBsZW5ndGhfMSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaiA+IGkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kID4gY291bnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbmd0aF8yID0gTWF0aC5taW4oZW5kIC0gY291bnQsIGxpbmVMZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXMucHVzaChcIiAgIHwgIFwiICsgcmVwZWF0KFwiXlwiLCBsZW5ndGhfMikpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb3VudCArPSBsaW5lTGVuZ3RoICsgMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzLmpvaW4oJ1xcbicpO1xyXG59XHJcbmZ1bmN0aW9uIHJlcGVhdChzdHIsIG4pIHtcclxuICAgIHZhciByZXN1bHQgPSAnJztcclxuICAgIGlmIChuID4gMCkge1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cclxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXHJcbiAgICAgICAgICAgIGlmIChuICYgMSlcclxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBzdHI7XHJcbiAgICAgICAgICAgIG4gPj4+PSAxO1xyXG4gICAgICAgICAgICBpZiAobiA8PSAwKVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIHN0ciArPSBzdHI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxuXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbihjb2RlLCBlcnJvcnMpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbihjb2RlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnIpIHtcclxuICAgICAgICBlcnJvcnMucHVzaCh7IGVycjogZXJyLCBjb2RlOiBjb2RlIH0pO1xyXG4gICAgICAgIHJldHVybiBub29wO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVUb0Z1bmN0aW9uRm4oY29tcGlsZSkge1xyXG4gICAgdmFyIGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgIHJldHVybiBmdW5jdGlvbiBjb21waWxlVG9GdW5jdGlvbnModGVtcGxhdGUsIG9wdGlvbnMsIHZtKSB7XHJcbiAgICAgICAgb3B0aW9ucyA9IGV4dGVuZCh7fSwgb3B0aW9ucyk7XHJcbiAgICAgICAgdmFyIHdhcm4gPSBvcHRpb25zLndhcm4gfHwgd2FybiQyO1xyXG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLndhcm47XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgICAgLy8gZGV0ZWN0IHBvc3NpYmxlIENTUCByZXN0cmljdGlvblxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gMScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZS50b1N0cmluZygpLm1hdGNoKC91bnNhZmUtZXZhbHxDU1AvKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oJ0l0IHNlZW1zIHlvdSBhcmUgdXNpbmcgdGhlIHN0YW5kYWxvbmUgYnVpbGQgb2YgVnVlLmpzIGluIGFuICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnZW52aXJvbm1lbnQgd2l0aCBDb250ZW50IFNlY3VyaXR5IFBvbGljeSB0aGF0IHByb2hpYml0cyB1bnNhZmUtZXZhbC4gJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdUaGUgdGVtcGxhdGUgY29tcGlsZXIgY2Fubm90IHdvcmsgaW4gdGhpcyBlbnZpcm9ubWVudC4gQ29uc2lkZXIgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdyZWxheGluZyB0aGUgcG9saWN5IHRvIGFsbG93IHVuc2FmZS1ldmFsIG9yIHByZS1jb21waWxpbmcgeW91ciAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RlbXBsYXRlcyBpbnRvIHJlbmRlciBmdW5jdGlvbnMuJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY2hlY2sgY2FjaGVcclxuICAgICAgICB2YXIga2V5ID0gb3B0aW9ucy5kZWxpbWl0ZXJzXHJcbiAgICAgICAgICAgID8gU3RyaW5nKG9wdGlvbnMuZGVsaW1pdGVycykgKyB0ZW1wbGF0ZVxyXG4gICAgICAgICAgICA6IHRlbXBsYXRlO1xyXG4gICAgICAgIGlmIChjYWNoZVtrZXldKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjYWNoZVtrZXldO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjb21waWxlXHJcbiAgICAgICAgdmFyIGNvbXBpbGVkID0gY29tcGlsZSh0ZW1wbGF0ZSwgb3B0aW9ucyk7XHJcbiAgICAgICAgLy8gY2hlY2sgY29tcGlsYXRpb24gZXJyb3JzL3RpcHNcclxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgICBpZiAoY29tcGlsZWQuZXJyb3JzICYmIGNvbXBpbGVkLmVycm9ycy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29tcGlsZWQuZXJyb3JzLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybihcIkVycm9yIGNvbXBpbGluZyB0ZW1wbGF0ZTpcXG5cXG5cIi5jb25jYXQoZS5tc2csIFwiXFxuXFxuXCIpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlQ29kZUZyYW1lKHRlbXBsYXRlLCBlLnN0YXJ0LCBlLmVuZCksIHZtKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhcm4oXCJFcnJvciBjb21waWxpbmcgdGVtcGxhdGU6XFxuXFxuXCIuY29uY2F0KHRlbXBsYXRlLCBcIlxcblxcblwiKSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBpbGVkLmVycm9ycy5tYXAoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIFwiLSBcIi5jb25jYXQoZSk7IH0pLmpvaW4oJ1xcbicpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ1xcbicsIHZtKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY29tcGlsZWQudGlwcyAmJiBjb21waWxlZC50aXBzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb21waWxlZC50aXBzLmZvckVhY2goZnVuY3Rpb24gKGUpIHsgcmV0dXJuIHRpcChlLm1zZywgdm0pOyB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBpbGVkLnRpcHMuZm9yRWFjaChmdW5jdGlvbiAobXNnKSB7IHJldHVybiB0aXAobXNnLCB2bSk7IH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHR1cm4gY29kZSBpbnRvIGZ1bmN0aW9uc1xyXG4gICAgICAgIHZhciByZXMgPSB7fTtcclxuICAgICAgICB2YXIgZm5HZW5FcnJvcnMgPSBbXTtcclxuICAgICAgICByZXMucmVuZGVyID0gY3JlYXRlRnVuY3Rpb24oY29tcGlsZWQucmVuZGVyLCBmbkdlbkVycm9ycyk7XHJcbiAgICAgICAgcmVzLnN0YXRpY1JlbmRlckZucyA9IGNvbXBpbGVkLnN0YXRpY1JlbmRlckZucy5tYXAoZnVuY3Rpb24gKGNvZGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUZ1bmN0aW9uKGNvZGUsIGZuR2VuRXJyb3JzKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBjaGVjayBmdW5jdGlvbiBnZW5lcmF0aW9uIGVycm9ycy5cclxuICAgICAgICAvLyB0aGlzIHNob3VsZCBvbmx5IGhhcHBlbiBpZiB0aGVyZSBpcyBhIGJ1ZyBpbiB0aGUgY29tcGlsZXIgaXRzZWxmLlxyXG4gICAgICAgIC8vIG1vc3RseSBmb3IgY29kZWdlbiBkZXZlbG9wbWVudCB1c2VcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgICAgICBpZiAoKCFjb21waWxlZC5lcnJvcnMgfHwgIWNvbXBpbGVkLmVycm9ycy5sZW5ndGgpICYmIGZuR2VuRXJyb3JzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgd2FybihcIkZhaWxlZCB0byBnZW5lcmF0ZSByZW5kZXIgZnVuY3Rpb246XFxuXFxuXCIgK1xyXG4gICAgICAgICAgICAgICAgICAgIGZuR2VuRXJyb3JzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnIgPSBfYS5lcnIsIGNvZGUgPSBfYS5jb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQoZXJyLnRvU3RyaW5nKCksIFwiIGluXFxuXFxuXCIpLmNvbmNhdChjb2RlLCBcIlxcblwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuam9pbignXFxuJyksIHZtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKGNhY2hlW2tleV0gPSByZXMpO1xyXG4gICAgfTtcclxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21waWxlckNyZWF0b3IoYmFzZUNvbXBpbGUpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiBjcmVhdGVDb21waWxlcihiYXNlT3B0aW9ucykge1xyXG4gICAgICAgIGZ1bmN0aW9uIGNvbXBpbGUodGVtcGxhdGUsIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgdmFyIGZpbmFsT3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoYmFzZU9wdGlvbnMpO1xyXG4gICAgICAgICAgICB2YXIgZXJyb3JzID0gW107XHJcbiAgICAgICAgICAgIHZhciB0aXBzID0gW107XHJcbiAgICAgICAgICAgIHZhciB3YXJuID0gZnVuY3Rpb24gKG1zZywgcmFuZ2UsIHRpcCkge1xyXG4gICAgICAgICAgICAgICAgKHRpcCA/IHRpcHMgOiBlcnJvcnMpLnB1c2gobXNnKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbGVhZGluZ1NwYWNlTGVuZ3RoXzEgPSB0ZW1wbGF0ZS5tYXRjaCgvXlxccyovKVswXS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybiA9IGZ1bmN0aW9uIChtc2csIHJhbmdlLCB0aXApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB0eXBlb2YgbXNnID09PSAnc3RyaW5nJyA/IHsgbXNnOiBtc2cgfSA6IG1zZztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2Uuc3RhcnQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuc3RhcnQgPSByYW5nZS5zdGFydCArIGxlYWRpbmdTcGFjZUxlbmd0aF8xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlLmVuZCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5lbmQgPSByYW5nZS5lbmQgKyBsZWFkaW5nU3BhY2VMZW5ndGhfMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAodGlwID8gdGlwcyA6IGVycm9ycykucHVzaChkYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gbWVyZ2UgY3VzdG9tIG1vZHVsZXNcclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm1vZHVsZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBmaW5hbE9wdGlvbnMubW9kdWxlcyA9IChiYXNlT3B0aW9ucy5tb2R1bGVzIHx8IFtdKS5jb25jYXQob3B0aW9ucy5tb2R1bGVzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIG1lcmdlIGN1c3RvbSBkaXJlY3RpdmVzXHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5kaXJlY3RpdmVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmluYWxPcHRpb25zLmRpcmVjdGl2ZXMgPSBleHRlbmQoT2JqZWN0LmNyZWF0ZShiYXNlT3B0aW9ucy5kaXJlY3RpdmVzIHx8IG51bGwpLCBvcHRpb25zLmRpcmVjdGl2ZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gY29weSBvdGhlciBvcHRpb25zXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgIT09ICdtb2R1bGVzJyAmJiBrZXkgIT09ICdkaXJlY3RpdmVzJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbE9wdGlvbnNba2V5XSA9IG9wdGlvbnNba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmluYWxPcHRpb25zLndhcm4gPSB3YXJuO1xyXG4gICAgICAgICAgICB2YXIgY29tcGlsZWQgPSBiYXNlQ29tcGlsZSh0ZW1wbGF0ZS50cmltKCksIGZpbmFsT3B0aW9ucyk7XHJcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICBkZXRlY3RFcnJvcnMoY29tcGlsZWQuYXN0LCB3YXJuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb21waWxlZC5lcnJvcnMgPSBlcnJvcnM7XHJcbiAgICAgICAgICAgIGNvbXBpbGVkLnRpcHMgPSB0aXBzO1xyXG4gICAgICAgICAgICByZXR1cm4gY29tcGlsZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGNvbXBpbGU6IGNvbXBpbGUsXHJcbiAgICAgICAgICAgIGNvbXBpbGVUb0Z1bmN0aW9uczogY3JlYXRlQ29tcGlsZVRvRnVuY3Rpb25Gbihjb21waWxlKVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG59XG5cbi8vIGBjcmVhdGVDb21waWxlckNyZWF0b3JgIGFsbG93cyBjcmVhdGluZyBjb21waWxlcnMgdGhhdCB1c2UgYWx0ZXJuYXRpdmVcclxuLy8gcGFyc2VyL29wdGltaXplci9jb2RlZ2VuLCBlLmcgdGhlIFNTUiBvcHRpbWl6aW5nIGNvbXBpbGVyLlxyXG4vLyBIZXJlIHdlIGp1c3QgZXhwb3J0IGEgZGVmYXVsdCBjb21waWxlciB1c2luZyB0aGUgZGVmYXVsdCBwYXJ0cy5cclxudmFyIGNyZWF0ZUNvbXBpbGVyID0gY3JlYXRlQ29tcGlsZXJDcmVhdG9yKGZ1bmN0aW9uIGJhc2VDb21waWxlKHRlbXBsYXRlLCBvcHRpb25zKSB7XHJcbiAgICB2YXIgYXN0ID0gcGFyc2UodGVtcGxhdGUudHJpbSgpLCBvcHRpb25zKTtcclxuICAgIGlmIChvcHRpb25zLm9wdGltaXplICE9PSBmYWxzZSkge1xyXG4gICAgICAgIG9wdGltaXplKGFzdCwgb3B0aW9ucyk7XHJcbiAgICB9XHJcbiAgICB2YXIgY29kZSA9IGdlbmVyYXRlKGFzdCwgb3B0aW9ucyk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGFzdDogYXN0LFxyXG4gICAgICAgIHJlbmRlcjogY29kZS5yZW5kZXIsXHJcbiAgICAgICAgc3RhdGljUmVuZGVyRm5zOiBjb2RlLnN0YXRpY1JlbmRlckZuc1xyXG4gICAgfTtcclxufSk7XG5cbnZhciBfYSA9IGNyZWF0ZUNvbXBpbGVyKGJhc2VPcHRpb25zKSwgY29tcGlsZVRvRnVuY3Rpb25zID0gX2EuY29tcGlsZVRvRnVuY3Rpb25zO1xuXG4vLyBjaGVjayB3aGV0aGVyIGN1cnJlbnQgYnJvd3NlciBlbmNvZGVzIGEgY2hhciBpbnNpZGUgYXR0cmlidXRlIHZhbHVlc1xyXG52YXIgZGl2O1xyXG5mdW5jdGlvbiBnZXRTaG91bGREZWNvZGUoaHJlZikge1xyXG4gICAgZGl2ID0gZGl2IHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgZGl2LmlubmVySFRNTCA9IGhyZWYgPyBcIjxhIGhyZWY9XFxcIlxcblxcXCIvPlwiIDogXCI8ZGl2IGE9XFxcIlxcblxcXCIvPlwiO1xyXG4gICAgcmV0dXJuIGRpdi5pbm5lckhUTUwuaW5kZXhPZignJiMxMDsnKSA+IDA7XHJcbn1cclxuLy8gIzM2NjM6IElFIGVuY29kZXMgbmV3bGluZXMgaW5zaWRlIGF0dHJpYnV0ZSB2YWx1ZXMgd2hpbGUgb3RoZXIgYnJvd3NlcnMgZG9uJ3RcclxudmFyIHNob3VsZERlY29kZU5ld2xpbmVzID0gaW5Ccm93c2VyID8gZ2V0U2hvdWxkRGVjb2RlKGZhbHNlKSA6IGZhbHNlO1xyXG4vLyAjNjgyODogY2hyb21lIGVuY29kZXMgY29udGVudCBpbiBhW2hyZWZdXHJcbnZhciBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWYgPSBpbkJyb3dzZXJcclxuICAgID8gZ2V0U2hvdWxkRGVjb2RlKHRydWUpXHJcbiAgICA6IGZhbHNlO1xuXG52YXIgaWRUb1RlbXBsYXRlID0gY2FjaGVkKGZ1bmN0aW9uIChpZCkge1xyXG4gICAgdmFyIGVsID0gcXVlcnkoaWQpO1xyXG4gICAgcmV0dXJuIGVsICYmIGVsLmlubmVySFRNTDtcclxufSk7XHJcbnZhciBtb3VudCA9IFZ1ZS5wcm90b3R5cGUuJG1vdW50O1xyXG5WdWUucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChlbCwgaHlkcmF0aW5nKSB7XHJcbiAgICBlbCA9IGVsICYmIHF1ZXJ5KGVsKTtcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKGVsID09PSBkb2N1bWVudC5ib2R5IHx8IGVsID09PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcclxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXHJcbiAgICAgICAgICAgIHdhcm4kMihcIkRvIG5vdCBtb3VudCBWdWUgdG8gPGh0bWw+IG9yIDxib2R5PiAtIG1vdW50IHRvIG5vcm1hbCBlbGVtZW50cyBpbnN0ZWFkLlwiKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIHZhciBvcHRpb25zID0gdGhpcy4kb3B0aW9ucztcclxuICAgIC8vIHJlc29sdmUgdGVtcGxhdGUvZWwgYW5kIGNvbnZlcnQgdG8gcmVuZGVyIGZ1bmN0aW9uXHJcbiAgICBpZiAoIW9wdGlvbnMucmVuZGVyKSB7XHJcbiAgICAgICAgdmFyIHRlbXBsYXRlID0gb3B0aW9ucy50ZW1wbGF0ZTtcclxuICAgICAgICBpZiAodGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0ZW1wbGF0ZS5jaGFyQXQoMCkgPT09ICcjJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlID0gaWRUb1RlbXBsYXRlKHRlbXBsYXRlKTtcclxuICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhdGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybiQyKFwiVGVtcGxhdGUgZWxlbWVudCBub3QgZm91bmQgb3IgaXMgZW1wdHk6IFwiLmNvbmNhdChvcHRpb25zLnRlbXBsYXRlKSwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRlbXBsYXRlLm5vZGVUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLmlubmVySFRNTDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybiQyKCdpbnZhbGlkIHRlbXBsYXRlIG9wdGlvbjonICsgdGVtcGxhdGUsIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZWwpIHtcclxuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxyXG4gICAgICAgICAgICB0ZW1wbGF0ZSA9IGdldE91dGVySFRNTChlbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0ZW1wbGF0ZSkge1xyXG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcclxuICAgICAgICAgICAgICAgIG1hcmsoJ2NvbXBpbGUnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgX2EgPSBjb21waWxlVG9GdW5jdGlvbnModGVtcGxhdGUsIHtcclxuICAgICAgICAgICAgICAgIG91dHB1dFNvdXJjZVJhbmdlOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLFxyXG4gICAgICAgICAgICAgICAgc2hvdWxkRGVjb2RlTmV3bGluZXM6IHNob3VsZERlY29kZU5ld2xpbmVzLFxyXG4gICAgICAgICAgICAgICAgc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmOiBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWYsXHJcbiAgICAgICAgICAgICAgICBkZWxpbWl0ZXJzOiBvcHRpb25zLmRlbGltaXRlcnMsXHJcbiAgICAgICAgICAgICAgICBjb21tZW50czogb3B0aW9ucy5jb21tZW50c1xyXG4gICAgICAgICAgICB9LCB0aGlzKSwgcmVuZGVyID0gX2EucmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgPSBfYS5zdGF0aWNSZW5kZXJGbnM7XHJcbiAgICAgICAgICAgIG9wdGlvbnMucmVuZGVyID0gcmVuZGVyO1xyXG4gICAgICAgICAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IHN0YXRpY1JlbmRlckZucztcclxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XHJcbiAgICAgICAgICAgICAgICBtYXJrKCdjb21waWxlIGVuZCcpO1xyXG4gICAgICAgICAgICAgICAgbWVhc3VyZShcInZ1ZSBcIi5jb25jYXQodGhpcy5fbmFtZSwgXCIgY29tcGlsZVwiKSwgJ2NvbXBpbGUnLCAnY29tcGlsZSBlbmQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBtb3VudC5jYWxsKHRoaXMsIGVsLCBoeWRyYXRpbmcpO1xyXG59O1xyXG4vKipcclxuICogR2V0IG91dGVySFRNTCBvZiBlbGVtZW50cywgdGFraW5nIGNhcmVcclxuICogb2YgU1ZHIGVsZW1lbnRzIGluIElFIGFzIHdlbGwuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRPdXRlckhUTUwoZWwpIHtcclxuICAgIGlmIChlbC5vdXRlckhUTUwpIHtcclxuICAgICAgICByZXR1cm4gZWwub3V0ZXJIVE1MO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbC5jbG9uZU5vZGUodHJ1ZSkpO1xyXG4gICAgICAgIHJldHVybiBjb250YWluZXIuaW5uZXJIVE1MO1xyXG4gICAgfVxyXG59XHJcblZ1ZS5jb21waWxlID0gY29tcGlsZVRvRnVuY3Rpb25zO1xuXG5leHBvcnQgeyBFZmZlY3RTY29wZSwgY29tcHV0ZWQsIGN1c3RvbVJlZiwgVnVlIGFzIGRlZmF1bHQsIGRlZmluZUFzeW5jQ29tcG9uZW50LCBkZWZpbmVDb21wb25lbnQsIGRlbCwgZWZmZWN0U2NvcGUsIGdldEN1cnJlbnRJbnN0YW5jZSwgZ2V0Q3VycmVudFNjb3BlLCBoLCBpbmplY3QsIGlzUHJveHksIGlzUmVhY3RpdmUsIGlzUmVhZG9ubHksIGlzUmVmLCBpc1NoYWxsb3csIG1hcmtSYXcsIG1lcmdlRGVmYXVsdHMsIG5leHRUaWNrLCBvbkFjdGl2YXRlZCwgb25CZWZvcmVNb3VudCwgb25CZWZvcmVVbm1vdW50LCBvbkJlZm9yZVVwZGF0ZSwgb25EZWFjdGl2YXRlZCwgb25FcnJvckNhcHR1cmVkLCBvbk1vdW50ZWQsIG9uUmVuZGVyVHJhY2tlZCwgb25SZW5kZXJUcmlnZ2VyZWQsIG9uU2NvcGVEaXNwb3NlLCBvblNlcnZlclByZWZldGNoLCBvblVubW91bnRlZCwgb25VcGRhdGVkLCBwcm92aWRlLCBwcm94eVJlZnMsIHJlYWN0aXZlLCByZWFkb25seSwgcmVmJDEgYXMgcmVmLCBzZXQsIHNoYWxsb3dSZWFjdGl2ZSwgc2hhbGxvd1JlYWRvbmx5LCBzaGFsbG93UmVmLCB0b1JhdywgdG9SZWYsIHRvUmVmcywgdHJpZ2dlclJlZiwgdW5yZWYsIHVzZUF0dHJzLCB1c2VDc3NNb2R1bGUsIHVzZUNzc1ZhcnMsIHVzZUxpc3RlbmVycywgdXNlU2xvdHMsIHZlcnNpb24sIHdhdGNoLCB3YXRjaEVmZmVjdCwgd2F0Y2hQb3N0RWZmZWN0LCB3YXRjaFN5bmNFZmZlY3QgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/vue/dist/vue.esm.js\n");

/***/ }),

/***/ "./resources/js/layouts sync .*\\.vue$":
/*!**********************************************************!*\
  !*** ./resources/js/layouts/ sync nonrecursive .*\.vue$ ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var map = {
	"./default.vue": "./resources/js/layouts/default.vue"
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = "./resources/js/layouts sync .*\\.vue$";

/***/ }),

/***/ "./resources/js/middleware sync .*\\.js$":
/*!************************************************************!*\
  !*** ./resources/js/middleware/ sync nonrecursive .*\.js$ ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var map = {
	"./example.js": "./resources/js/middleware/example.js"
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = "./resources/js/middleware sync .*\\.js$";

/***/ }),

/***/ "./resources/js/pages lazy recursive ^\\.\\/.*$":
/*!************************************************************!*\
  !*** ./resources/js/pages/ lazy ^\.\/.*$ namespace object ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var map = {
	"./welcome": [
		"./resources/js/pages/welcome.vue",
		"resources_js_pages_welcome_vue"
	],
	"./welcome.vue": [
		"./resources/js/pages/welcome.vue",
		"resources_js_pages_welcome_vue"
	]
};
function webpackAsyncContext(req) {
	if(!__webpack_require__.o(map, req)) {
		return Promise.resolve().then(() => {
			var e = new Error("Cannot find module '" + req + "'");
			e.code = 'MODULE_NOT_FOUND';
			throw e;
		});
	}

	var ids = map[req], id = ids[0];
	return __webpack_require__.e(ids[1]).then(() => {
		return __webpack_require__(id);
	});
}
webpackAsyncContext.keys = () => (Object.keys(map));
webpackAsyncContext.id = "./resources/js/pages lazy recursive ^\\.\\/.*$";
module.exports = webpackAsyncContext;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "dist/js/" + "17a204db5c411807" + ".js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get mini-css chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference all chunks
/******/ 		__webpack_require__.miniCssF = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".css";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	(() => {
/******/ 		var inProgress = {};
/******/ 		// data-webpack is not used as build has no uniqueName
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = (url, done, key, chunkId) => {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 		
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = (prev, event) => {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach((fn) => (fn(event)));
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			;
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		__webpack_require__.p = "/";
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"/dist/js/app": 0,
/******/ 			"dist/css/app": 0
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.f.j = (chunkId, promises) => {
/******/ 				// JSONP chunk loading for javascript
/******/ 				var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 				if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 		
/******/ 					// a Promise means "currently loading".
/******/ 					if(installedChunkData) {
/******/ 						promises.push(installedChunkData[2]);
/******/ 					} else {
/******/ 						if("dist/css/app" != chunkId) {
/******/ 							// setup Promise in chunk cache
/******/ 							var promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));
/******/ 							promises.push(installedChunkData[2] = promise);
/******/ 		
/******/ 							// start chunk loading
/******/ 							var url = __webpack_require__.p + __webpack_require__.u(chunkId);
/******/ 							// create error before stack unwound to get useful stacktrace later
/******/ 							var error = new Error();
/******/ 							var loadingEnded = (event) => {
/******/ 								if(__webpack_require__.o(installedChunks, chunkId)) {
/******/ 									installedChunkData = installedChunks[chunkId];
/******/ 									if(installedChunkData !== 0) installedChunks[chunkId] = undefined;
/******/ 									if(installedChunkData) {
/******/ 										var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 										var realSrc = event && event.target && event.target.src;
/******/ 										error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 										error.name = 'ChunkLoadError';
/******/ 										error.type = errorType;
/******/ 										error.request = realSrc;
/******/ 										installedChunkData[1](error);
/******/ 									}
/******/ 								}
/******/ 							};
/******/ 							__webpack_require__.l(url, loadingEnded, "chunk-" + chunkId, chunkId);
/******/ 						} else installedChunks[chunkId] = 0;
/******/ 					}
/******/ 				}
/******/ 		};
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 			return __webpack_require__.O(result);
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunk"] = self["webpackChunk"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module depends on other loaded chunks and execution need to be delayed
/******/ 	__webpack_require__.O(undefined, ["dist/css/app"], () => (__webpack_require__("./resources/js/app.js")))
/******/ 	var __webpack_exports__ = __webpack_require__.O(undefined, ["dist/css/app"], () => (__webpack_require__("./resources/sass/app.scss")))
/******/ 	__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 	
/******/ })()
;